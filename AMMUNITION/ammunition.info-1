This is ammunition.info, produced by makeinfo version 4.0b from
/tmp/sgml-tools-dir-5903/sgmltmp.ammunition5903.info.2.

   \input texinfo


File: ammunition.info,  Node: Top,  Next: Introduction,  Up: (dir)

Ammunition (Reusable packages) - C interface
********************************************

     Vladimir Makarov, `vmakarov@users.sourceforge.net'
     Apr 5, 2001

   This document describes ammunition (reusable packages written in
C/C++).

* Menu:

* Introduction::
* Package for allocating memory with fixing some allocation errors::
* Package for work with variable length objects::
* Package for work with stacks of objects::
* Package for work with hash tables::
* Package for work with source code positions::
* Package for output of compiler messages::
* Package for work with command line::
* Package for work with bit strings::
* Package for machine-independent arbitrary precision integer arithmetic::
* Package for machine-independent IEEE floating point arithmetic::
* Ticker package::
* Earley parser::


File: ammunition.info,  Node: Introduction,  Next: Package for allocating memory with fixing some allocation errors,  Prev: Top,  Up: Top

Introduction
************

   This document describes ammunition (reusable packages written in
C/C++).  The packages are oriented towards creation of compiler and
cross-compiler.  Currently there are the following packages (their
names and tasks):

`allocate'
     allocating and freeing memory with fixing some allocation errors

`vlobject'
     work with variable length objects

`objstack'
     work with stacks of objects

`hashtab'
     work with hash tables

`position'
     work with source code positions

`errors'
     output of compiler messages

`commline'
     work with command line

`bits'
     work with bit strings

`arithm'
     implementing host machine-independently arbitrary precision
     integer numbers arithmetic

`IEEE'
     implementing host machine-independently IEEE floating point
     arithmetic

`ticker'
     timer

`earley'
     Earley parser


File: ammunition.info,  Node: Package for allocating memory with fixing some allocation errors,  Next: Package for work with variable length objects,  Prev: Introduction,  Up: Top

Package for allocating memory with fixing some allocation errors
****************************************************************

   Developing modern compilers it is necessary to avoid arbitrary limits
on the length or number of any data structure by allocating all data
structures dynamically.  Here the package `allocate' which implements
allocation and freeing memory with automatic fixing allocation errors
is suggested.

   The package automatically calls action on situation `no memory'.  The
action never returns control back because after calling function which
processes allocation error the function `abort' is always called.
Therefore the function which processes allocation error should not
return control back.

   The interface part of the package is file `allocate.h'.  Defining
macro `NDEBUG' (e.g. by option `-D' in C compiler command line) before
the package macros usage disables fixing some internal errors and
errors of usage of the package.  The implementation part is file
`allocate.c'.  The interface contains the following external
definitions and macros:

`Function `change_allocation_error_function''
                  `void change_allocation_error_function
                        (void (*error_function) (void))) (void)'

     is used for changing up action on the situation `no memory'.  The
     function also returns former function which was early action on
     the situation `no memory'.

`Function `default_allocation_error_function''
                  `void default_allocation_error_function (void)'

     is default action of the package on the situation `no memory'.
     This action consists of output message `*** no memory ***' to
     standard error stream and calling function `exit' with code equals
     to 1.

`Macro `MALLOC''
                  `MALLOC(ptr, size)'

     is analogous to ANSI C library function `malloc'.  But the macro
     has two parameters.  The first is pointer variable which is set up
     by address of allocated memory.  The second is size of needed
     memory.

`Macro `CALLOC''
                  `CALLOC(ptr, nel, size)'

     is analogous to ANSI C library function `calloc'.  But the macro
     has three parameters.  The first is pointer variable which is set
     up by address of allocated memory.  The last two parameters have
     the same sense as in standard function `calloc'.

`Macro `FREE''
                  `FREE(ptr)'

     is analogous to ANSI C library function `free' but can accept nil
     pointer value.  In this case macro does nothing.

`Macro `REALLOC''
                  `REALLOC(new, old, size)'

     is analogous to ANSI C library function `realloc' but has three
     parameters.  The first parameter is variable which is set up by
     new address of reallocated memory.  The second is old address of
     reallocated memory.  And third is new size of reallocated memory.


File: ammunition.info,  Node: Package for work with variable length objects,  Next: Package for work with stacks of objects,  Prev: Package for allocating memory with fixing some allocation errors,  Up: Top

Package for work with variable length objects
*********************************************

   The package `vlobject' implements work with variable length object
(VLO) and uses package `allocate'.  Any number of bytes may be added to
and removed from the end of VLO.  If it is needed the memory allocated
for storing variable length object may be expanded possibly with
changing the object place.  But between any additions of the bytes (or
tailoring) the object place is not changed.  To decrease number of
changes of the object place the memory being allocated for the object
is longer than the current object length.

   Because arguments of all macros which return a result
(`VLO_LENGTH', `VLO_BEGIN', `VLO_BOUND', and
`VLO_END') may be evaluated many times no side-effects should be
in the arguments.

   The package uses package `allocate'.  The interface part of the
package is file `vlobject.h'.  Defining macro `NDEBUG' (e.g. by option
`-D' in C compiler command line) before the package macros usage
disables fixing some internal errors and errors of usage of the
package.  The implementation part is file `vlobject.c'.  The interface
contains the following definitions and macros:

`Type `vlo_t''
     describes a descriptor of variable length object.  All work with
     variable length object is executed by the following macros through
     the descriptors.  Structure (implementation) of this type is not
     needed for using variable length object.  But it should remember
     that work with the object through several descriptors is not safe.

`Macro `VLO_DEFAULT_LENGTH''
     has value which is default initial size of memory is allocated for
     VLO when the object is created (with zero initial size).  Original
     value of the macros is equal to 512.  This macro can be redefined
     in C compiler command line or with the aid of directive `[num
     ]undef' before any using the package macros.

`Macro `VLO_CREATE''
                    `VLO_CREATE(vlo, initial_length)'

     is used for creation of VLO with initial zero length.  Initial
     memory allocated for VLO whose descriptor is given as the first
     macro parameter is given as the second parameter.  If the second
     parameter is equal to zero then the initial allocated memory
     length is equal to `VLO_DEFAULT_LENGTH'.

``VLO_DELETE''
                    `VLO_DELETE(vlo)'

     is used for freeing memory used by VLO whose descriptor is given
     as the macro parameter.

`Macro `VLO_NULLIFY''
                    `VLO_NULLIFY(vlo)'

     makes that length of VLO whose descriptor is given as the macro
     parameter will be equal to zero (but memory for VLO is not freed
     and not reallocated).

`Macro `VLO_TAILOR''
                    `VLO_TAILOR(vlo)'

     makes that length of memory allocated for VLO whose descriptor is
     given as the macro parameter becomes equal to VLO length.

`Macro `VLO_LENGTH''
                    `VLO_LENGTH(vlo)'

     returns current length of VLO whose descriptor is given as the
     macro parameter.

`Macros `VLO_BEGIN', `VLO_END', `VLO_BOUND''
                    `VLO_BEGIN(vlo)', `VLO_END(vlo)', `VLO_BOUND(vlo)'

     return pointer (of type `void *') to correspondingly the first,
     the last byte of VLO whose descriptor is given as the macros
     parameter, and pointer to the last byte plus one.  Remember that
     the object may change own place after any addition.

`Macro `VLO_SHORTEN''
                    `VLO_SHORTEN(vlo, n)'

     removes n bytes from the end of VLO whose descriptor is given as
     the first parameter.  VLO is nullified if its length is less than
     n.

`Macro `VLO_EXPAND''
                    `VLO_EXPAND(vlo, length)'

     increases length of VLO whose descriptor is given as the first
     parameter on number of bytes given as the second parameter.  The
     values of bytes added to the end of VLO will be not defined.

`Macro `VLO_ADD_BYTE''
                    `VLO_ADD_BYTE(vlo, b)'

     adds byte given as the second parameter to the end of VLO whose
     descriptor is given as the first parameter.

`Macro `VLO_ADD_MEMORY''
                    `VLO_ADD_MEMORY(vlo, str, length)'

     adds memory starting with address given as the second macro
     parameter and with length given as the third parameter to the end
     of VLO whose descriptor is given as the first parameter.

`Macro `VLO_ADD_STRING''
                    `VLO_ADD_STRING(vlo, str)'

     adds C string (with end marker 0) given as the second macro
     parameter to the end of VLO whose descriptor is given as the first
     parameter.  Before the addition the macro deletes last character
     of the VLO.  The last character is suggested to be C string end
     marker 0.


File: ammunition.info,  Node: Package for work with stacks of objects,  Next: Package for work with hash tables,  Prev: Package for work with variable length objects,  Up: Top

Package for work with stacks of objects
***************************************

   The package `objstack' is based on package `allocate' and implements
efficient work with stacks of objects (OS).  Work with the object on
the stack top is analogous to one with a variable length object.  One
motivation for the package is the problem of growing char strings in
symbol tables.  Memory for OS is allocated by segments.  A segment may
contain more one objects.  The most recently allocated segment contains
object on the top of OS.  If there is not sufficient free memory for
the top object than new segment is created and the top object is
transferred into the new segment, i.e. there is not any memory
reallocation.  Therefore the top object may change its address.  But
other objects never change address.

   Because arguments of all macros which return a result
(`OS_TOP_LENGTH', `OS_TOP_BEGIN',
`OS_TOP_BOUND', and `OS_TOP_END') may be
evaluated many times no side-effects should be in the arguments.

   The package uses package `allocate'.  The interface part of the
package is file `objstack.h'.  Defining macro `NDEBUG' (e.g.  by option
`-D' in C compiler command line) before the package macros usage
disables fixing some internal errors and errors of usage of the
package.  The implementation part is file `objstack.c'.  The interface
contains the following definitions and macros:

`Type `os_t''
     describes a descriptor of stack of objects.  All work with stack
     of objects is executed by the following macros through the
     descriptors.  Structure (implementation) of this type is not
     needed for using stack of objects.  But it should remember that
     work with the stack through several descriptors is not safe.

`Macro `OS_DEFAULT_SEGMENT_LENGTH''
     has value which is default size of memory segments which will be
     allocated for OS when the stack is created (with zero initial
     segment size).  This is also minimal size of all segments.
     Original value of the macros is equal to 512.  This macro can be
     redefined in C compiler command line or with the aid of directive
     `[num   ]undef' before any using the package macros.

`Macro `OS_CREATE''
                  `OS_CREATE(os, initial_segment_length)'

     creates OS which contains the single zero length object.  OS
     descriptor is given as the first macro parameter.  Minimum size of
     memory segments which will be allocated for OS is given as the
     second parameter.  If the second parameter is equal to zero the
     allocated memory segments length is equal to
     `OS_DEFAULT_SEGMENT_LENGTH'.  But in any case
     the segment length is always not less than maximum alignment.

`Macro `OS_DELETE''
                  `OS_DELETE(os)'

     is used for freeing all memory used by OS whose descriptor is
     given as the macro parameter.

`Macro `OS_EMPTY''
                  `OS_EMPTY(os)'

     is used for removing all objects and freeing all memory allocated
     for OS except for the first segment.

`Macro `OS_TOP_FINISH''
                  `OS_TOP_FINISH(os)'

     creates new variable length object with initial zero length on the
     top of OS whose descriptor is given as the macro parameter.  The
     work (analogous to one with variable length object) with object
     which was on the top of OS is finished, i.e. the object will never
     more change address.

`Macro `OS_TOP_NULLIFY''
                  `OS_TOP_NULLIFY(os)'

     makes that length of variable length object on the top of OS whose
     descriptor is given as the macro parameter will be equal to zero.

`Macro `OS_TOP_LENGTH''
                  `OS_TOP_LENGTH(os)'

     returns current length of variable length object on the top of OS
     whose descriptor is given as the macro parameter.

`Macros `OS_TOP_BEGIN', `OS_TOP_END', `OS_TOP_BOUND''
                  `OS_TOP_BEGIN(os)', `OS_TOP_END(os)', `OS_TOP_BOUND(os)'

     return pointer to correspondingly the first and the last byte of
     variable length object on the top of OS whose descriptor is given
     as the macros parameter, and pointer to the last byte plus one.
     Remember that the top object may change own place after any
     addition.

`Macro `OS_TOP_SHORTEN''
                  `OS_TOP_SHORTEN(os, n)'

     removes n bytes from the end of variable length object on the top
     of OS whose descriptor is given as the first parameter.  The top
     variable length object is nullified if its length is less than n.

`Macro `OS_TOP_EXPAND''
                  `OS_TOP_EXPAND(os, length)'

     increases length of variable length object on the top of OS whose
     descriptor is given as the first parameter on number of bytes
     given as the second parameter.  The values of bytes added to the
     end of variable length object on the top of OS will be not defined.

`Macro `OS_TOP_ADD_BYTE''
                  `OS_TOP_ADD_BYTE(os, b)'

     adds byte given as the second parameter to the end of variable
     length object on the top of OS whose descriptor is given as the
     first parameter.

`Macro `OS_TOP_ADD_MEMORY''
                  `OS_TOP_ADD_MEMORY(os, str, length)'

     adds memory starting with address given as the second macro
     parameter and with length given as the third parameter to the end
     of variable length object on the top of OS whose descriptor is
     given as the first parameter.

`Macro `OS_TOP_ADD_STRING''
                  `OS_TOP_ADD_STRING(os, str)'

     adds C string (with end marker 0) given as the second macro
     parameter to the end of variable length string on the top of OS
     whose descriptor is given as the first parameter.  Before the
     addition the macro deletes last character of the top variable
     length object.  The last character is suggested to be C string end
     marker 0.


File: ammunition.info,  Node: Package for work with hash tables,  Next: Package for work with source code positions,  Prev: Package for work with stacks of objects,  Up: Top

Package for work with hash tables
*********************************

   The most compilers use search structures.  Here the package `hashtab'
which implements expandable hash tables is suggested.  This abstract
data implements features analogous to ones of public domain functions
`hsearch', `hcreate' and `hdestroy'.  The goal of the abstract data
creation is to implement additional needed features.  The abstract data
permits to work simultaneously with several expandable hash tables.
Besides insertion and search of elements the elements from the hash
tables can be also removed.  The table element can be only a pointer.
The size of hash tables is not fixed.  The hash table will be expanded
when its occupancy will become big.

   The abstract data implementation is based on generalized Algorithm D
from Knuth's book "The art of computer programming".  Hash table is
expanded by creation of new hash table and transferring elements from
the old table to the new table.

   The package uses package `allocate'.  The interface part of the
abstract data is file `hashtab.h'.  The implementation part is file
`hashtab.c'.  The interface contains the following external definitions:

`Type `hash_table_entry_t''
     is described as `void *' and represents hash table element type.
     Empty entries have value `NULL'.

`Type `hash_table_t''
     describes hash table itself.  All work with hash table should be
     executed only through functions mentioned below.

`Function `create_hash_table''
                  `hash_table_t create_hash_table
                     (size_t size,
                      unsigned (*hash_function) (hash_table_entry_t el_ptr),
                      int (*eq_function) (hash_table_entry_t el1_ptr,
                                          hash_table_entry_t el2_ptr))'

     creates and returns hash table with length slightly longer than
     value of function parameter `size'.  Created hash table is
     initiated as empty (all the hash table entries are NULL).  The
     hash table will use functions `hash_function',
     `eq_function' given as the function parameters to evaluate
     table element hash value and function to test on equality of two
     table elements.

`Function `delete_hash_table''
                  `void delete_hash_table (hash_table_t htab)'

     frees memory allocated for hash table given as parameter `htab'.
     Naturally the hash table must already exist.

`Function `empty_hash_table''
                  `void empty_hash_table  (hash_table_t htab)'

     makes hash table given as parameter `htab' empty.  Naturally the
     hash table must already exist.  If you need to remove all table
     elements, it is better to use this function than several times
     function
     `remove_element_from_hash_table_entry'.
     This function does not change size of the table or clear
     statistics about collisions.

`Function `find_hash_table_entry''
                  `hash_table_entry_t *find_hash_table_entry
                                       (hash_table_t htab,
                                        hash_table_entry_t element,
                                        int reserve)'

     searches for hash table entry which contains element equal to
     value of the function parameter `element' or empty entry in which
     `element' can be placed (if the element does not exist in the
     table).  The function parameter `reserve' is to be nonzero if the
     element is to be placed in the table.  The element should be
     inserted into the table entry before another call of
     `find_hash_table_entry'.  The table is
     expanded if occupancy (taking into account also deleted elements)
     is more than 75%.  The occupancy of the table after the
     expansion will be about 50%.

`Function `remove_element_from_hash_table_entry''
                  `void remove_element_from_hash_table_entry
                        (hash_table_t htab, hash_table_entry_t element)'

     removes element from hash table_entry whose value is given
     as the function parameter.  Hash table entry for given value
     should be not empty (or deleted).  The hash table entry value will
     be marked as deleted after the function call.

`Function `hash_table_size''
                  `size_t hash_table_size (hash_table_t htab)'

     returns current size of given hash table.

`Function `hash_table_elements_number''
                  `size_t hash_table_elements_number (hash_table_t htab)'

     returns current number of elements in given hash table.

`Function `hash_table_collisions''
                  `int hash_table_collisions (hash_table_t htab)'

     returns number of of percents of fixed collisions during all work
     with given hash table.

`Function `all_hash_table_collisions''
                  `int all_hash_table_collisions (void)'

     returns number of of percents of fixed collisions during all work
     with all hash tables.


File: ammunition.info,  Node: Package for work with source code positions,  Next: Package for output of compiler messages,  Prev: Package for work with hash tables,  Up: Top

Package for work with source code positions
*******************************************

   The compilers often use internal representation which stores source
code positions.  Here package `position' which serves to support
information about source positions of compiled files taking into
account all included files is suggested.

   The strategy of the package usage can be follows.  Function
`initiate_positions' is called by the first.  After that function
`start_file_position' is called when a file is opened for
compilation as source or included file.  Members `line_number'
and `column_number' of variable `current_position' are
modified correspondingly during given file compilation.  The value of
`current_position' can be stored into internal representation
for usage for output messages on the following passes.  Function
`finish_file_position' is called when a processed file is
closed.  Function `finish_positions' may be called after all
processing a source file.

   The package uses packages `vlobject' and `objstack' which use package
`allocate'.  The interface part of the package is file `position.h'.
The implementation part is file `position.c'.  The interface contains
the following external definitions:

`Type `position_t''
     is structure which describes a file position.  The structure has
     the following members:

    `Member `file_name''
          is name of file to which given position belongs.

    `Members `line_number', `column_number''
          are source line and column corresponding to given position.

    `Member `path''
          is pointer to another position structure representing
          position of include-clause which caused immediately given
          file compilation.

`Variable `no_position''
     has value of type `position_t' has members with values
     equals to zero or `NULL'.  The value does not correspond to
     concrete file position.

`Variable `current_position''
     has value which is current file position.

`Function `initiate_positions''
                  `void initiate_positions (void)'

     initiates the package.  Value of variable `current_position'
     becomes equal to `no_position'.

`Function `finish_position''
                  `void finish_positions (void)'

     frees all memory allocated during package work.

`Function `position_file_inclusion_level''
                  `int position_file_inclusion_level (position_t position)'

     returns level of inclusion of file of position given as the
     function parameter.  The level numbers are started with zero for
     positions corresponding non-included files and for positions which
     does not correspond to concrete file.

`Function `start_file_position''
                  `void start_file_position (const char *file_name)'

     copys position structure (by dynamic memory allocation) in
     variable `current_position' and sets up new values of
     members of `current_position'.  Values of members
     `file_name', `line_number', `column_number',
     and `path' become equal to the function parameter value, 1, 0, and
     pointer to the copied structure.  Values of
     `current_position' during different calls of the function
     must be different (e.g.  different columns or lines), i.e.
     positions of different include-clauses must be different.

`Function `finish_file_position''
                  `void finish_file_position (void)'

     recovers previous value of variable `current_position', more
     exactly sets up the variable by structure to which the variable
     member `path' refers.

`Function `compare_positions''
                  `int compare_positions (position_t position_1,
                                          position_t position_2)'

     compares two positions given by parameters of type
     `position_t' and returns -1 (if the first position is less
     than the second), 0 (if the first position is equal to the second)
     or 1 (if the first position is greater than the second).  The
     order of positions is lexicographic.


File: ammunition.info,  Node: Package for output of compiler messages,  Next: Package for work with command line,  Prev: Package for work with source code positions,  Up: Top

Package for output of compiler messages
***************************************

   The most of compilers report error messages for incorrect program.
Here the package `errors' which serves to output one-pass or multi-pass
compiler messages of various modes (errors, warnings, fatal, system
errors and appended messages) in Unix style or for traditional listing
is suggested.  The package also permits adequate error reporting for
included files.

   The package uses packages `vlobject', `objstack', `position' which
use package `allocate'.  Therefore package `position' have to be
initiated before any work with this package.  The interface part of the
package is file `errors.h'.  The implementation part is file
`errors.c'.  The maximum length of generated error message is suggested
to be not greater then `MAX_ERROR_MESSAGE_LENGTH'.
The default value (150) of this macro can be redefined with
corresponding C compiler option
`-DMAX_ERROR_MESSAGE_LENGTH=...'  during
compilation of file `errors.c'.  The interface contains the following
external definitions:

`Integer variables `number_of_errors', `number_of_warnings''
     have values which are number of correspondingly errors and
     warnings fixed after the most recent package initiation.

`Integer variable `maximum_number_of_errors''
     has value which is maximum number of errors which will be fixed.
     If an error is fixed with number equals to
     `maximum_number_of_errors' then special fatal
     error `fatal error - too many errors' with position of given error
     is fixed instead of the error.  And all following errors are
     ignored.  Zero value of the variable means that the special fatal
     error will never fixed.

`Integer constant `default_maximum_number_of_errors''
     defines originally value of variable
     `maximum_number_of_errors'.  The constant
     value is `50'.

`Variable `fatal_error_function''
     contains pointer to function without parameters which will be
     called after fixing a fatal error.  The fatal error function is
     suggested to do not return the control back.

`Function `default_fatal_error_function''
                  `void default_fatal_error_function (void)'

     defines originally value of variable
     `fatal_error_function'.  The function only calls
     `exit (1)'.

`Function `initiate_errors''
                  `void initiate_errors (int immediate_output_flag)'

     initiates the package in regime depending on parameter value.  If
     the parameter value is nonzero than all fixed messages are output
     immediately.  Otherwise the compiler messages are stored until
     function `output_errors' are called.

`Function `finish_errors''
                  `void finish_errors (void)'

     frees all memory allocated during package work.

`Function `output_errors''
                  `void output_errors (void)'

     sorts (stable sorting) all fixed messages by their positions,
     outputs ones, and deletes ones.  Appended messages will be output
     after corresponding error or warning.  This function should be
     used only in regime of storing messages.

`Function `error''
                       `void error (int fatal_error_flag, position_t
                                    position, const char *format, ...)'

     fixes error (fatal error if the first parameter value is nonzero)
     at the position given as the second parameter.  If the error is
     fatal than functions `output_errors' and
     `*fatal_error_function' are called.  The diagnostic
     messages are formed analogous to output of function `printf'.  For
     example,
                     error (1, current_position, "fatal error - no memory");

`Function `warning''
                  `void warning (position_t position, const char *format, ...)'

     is analogous to the previous but is used to fix a warning.

`Function `append_message''
                  `void append_message (position_t position,
                                        const char *format, ...)'

     When regime of immediately output of fixed message is on this
     function is analogous to the previous (except for incrementing
     variable `number_of_warnings').  In opposite case
     the appended message will be output with the most recent fixed
     error or warning independently from value of the first parameter.
     Of course the previously fixed error or warning must exist.

     For example, this function may be used for generation of messages
     of type
                        `<file>:<line>:<position-1>: repeated declaration'

     and then
                        `<file>:<line>:<position-1>: previous declaration'.

     Description of function
     `default_output_error_function' contains
     explanation why decremented position is output.

`Function `system_error''
                  `void system_error (int fatal_error_flag,
                                      position_t position,
                                      const char *format, ...)'

     is analogous to function `error' but serves to fix a system error.
     The current system message without head blanks (given by standard
     function `strerror') is placed after the message formed by the
     function parameters.  For example, the following call may be used
     when a file is not opened

                       system_error  (1, current_position,
                                      "fatal error - %s:", new_file_name);

`Variable `output_error_function''
     contains pointer to function which is used to output error
     message.  The function has three parameters - flag of appended
     message, message position and message itself.

`Function `default_output_error_function''
                  `void default_output_error_function
                        (int appended_message_flag, position_t position,
                         const char *message)'

     Originally value of variable `output_error_function'
     is equal to this function.  The function is oriented to output in
     Unix style according to GNU standard.  To output a listing the
     value of variable `output_error_function' should be
     changed.  The function output message in the following formats:
            MESSAGE                              (NULL file name)
            FILE_NAME:1: MESSAGE                 (zero line number)
            FILE_NAME:LINE_NUMBER: MESSAGE       (zero column number)
            FILE_NAME:LINE_NUMBER:COLUMN_NUMBER-1: MESSAGE  (all other cases)

     After that the function outputs newline.  The function also
     outputs additional messages `in file processed from ...'  if given
     message is not appended message and corresponds to file different
     from one of previous output error.  This message reflects path of
     the message position (see package `position'), i.e.  reflects
     positions of corresponding include-clauses.  Decremented column
     number is output in order to be in concordance with editor Emacs
     in which positions start with 0.


File: ammunition.info,  Node: Package for work with command line,  Next: Package for work with bit strings,  Prev: Package for output of compiler messages,  Up: Top

Package for work with command line
**********************************

   To make easy process of command line, here abstract data `commline'
is suggested.  This abstract data implements features analogous to ones
of public domain function `getopt'.  The goal of the abstract data
creation is to use more readable language of command line description
and to use command line description as help output of program.

   POSIX terminology concerning command line is used here.  Command
line is divided into command name and arguments.  The arguments are
subdivided into options, option-arguments and operands.  Option starts
with `-'.  All arguments after first `-' in command line are treated as
operands.

   The description of command line is made up from two parts.  Any part
(or both) may be absent in the description.  First part contains
option-arguments names of options which are in the second part.
option-arguments names are separated by white space.  The second part
starts with percents `%%' and contains any text in which
description of options are placed.  Any description of option starts
with character "' followed by character `-' and finishes by character
`".  White spaces may precede option-argument name.  It means that the
corresponding option has obligatory separate option-argument.  For
example, the following may be a part of description of options of a
pascal compiler command line.

     dir xxx file
     %%
     command line:  pc [options] file ...
                                    Options:
     `-0'      Pascal standard level 0    `-1'      Pascal standard Level 1.
     `-29000'  Am29000 code generation    `-29050'* Am29050 code generation
     `-c'      only object files creation `-el'     output of listing
     `-g'      information for debuggers  `-Idir'   data task units directory
     `-lxxx'   library                    `-Ldir'   libraries directory
     `-o file' output file                `-O'      all optimizations
     `-S'      only ass. code creation    `-v'      loaded processes indication
     `-w'      no warnings generation
                    Star * marks defaults

   In this example options with names `-I', `-l', `-L' and `-o' have
option-arguments but only option with name `-o' has separate
option-argument, i.e. option-argument which is represented by separate
argument after given option in command line.

   The interface part of the abstract data is file `commline.h'.  The
package uses package `vlobject' which use package `allocate'.  The
implementation part is file `commline.c'.  The interface contains the
following external definitions:

`Function'
                    `int start_command_line_processing
                         (int argc, char **argv, const char *description)'

     must be called before any work with abstract data.  The function
     processes command line description given as string parameter and
     command line itself given as two parameter `argc' and `argv'.  The
     function also initiates variables `argument_vector' and
     `argument_count' by parameters `argc' and `argv'.  The
     function returns 0 if error in command line description is fixed,
     otherwise returns 1 (it means success).

`Function `output_command_line_description''
                    `void output_command_line_description (void)'

     outputs the second part (without `%%') of
     description of options to stderr.  This function should be called
     when it is necessary to show the program usage.

`Function `next_operand''
                    `int next_operand (int flag_of_first)'

     returns command line argument number of next operand if the
     function parameter is nonzero.  Otherwise the function returns
     number of the first operand in the command line.  The function
     returns 0 if all operands are already processed.  Returned number
     may be used as index of array `argument_vector' to access
     corresponding operand.

`Function `number_of_operands''
                    `int number_of_operands (void)'

     returns number of operands in the command line.

`Function `next_option''
                    `int next_option (int flag_of_first)'

     returns command line argument number of next option if the
     function parameter is nonzero.  Otherwise the function returns
     number of the first option in the command line.  The function
     returns 0 if all options are already processed.  Returned number
     may be used as index of array `argument_vector' to access
     corresponding option.

`Function `option_characteristics''
                    `char *option_characteristics (int argument_number,
                                                   int *option_has_argument)'

     returns pointer to option name which describes the command line
     argument with number `argument_number' given as the first
     parameter of the function.  The function returns NULL if the
     corresponding option in the command line description is not found
     or an option described as with option-argument has not
     option-argument in the command line.  Remember that option name
     with option-argument differs from option in the command line (e.g.
     `-U' and `-Ufoo').  If the option in the command line description
     is found than the function sets up correspondingly the second
     function parameter `option_has_argument'.  The case
     of returned NULL and `*option_has_argument' equals
     to TRUE means that given option must have option-argument but the
     option has not option-argument in the command line.

`Function `last_option_place''
                    `int last_option_place (const char *option_name)'

     returns number of last option with given option name in the
     command line.  The function returns 0 if the option is absent in
     the command line.

`Function `option_argument''
                    `char *option_argument (const char *option_name)'

     returns pointer to argument of last option in the command line
     with given option name.  The function returns NULL if the option
     is absent in the command line.  The function must be called only
     for options which have argument separated by white spaces.

`Variables `argument_count', `argument_vector''
     have analogous values as parameters `argc' and `argv' of function
     `main'.  See also description of
     `start_command_line_processing'.


File: ammunition.info,  Node: Package for work with bit strings,  Next: Package for machine-independent arbitrary precision integer arithmetic,  Prev: Package for work with command line,  Up: Top

Package for work with bit strings
*********************************

   The package for work with bit strings is used to implement package
`IEEE'.  But of course the package can be used for solving other tasks.

   Here a bit is given by address (start address) of byte from which
counting bits starts and its displacement which is any non negative
number of bit from the start address.  The most significant bit of the
start address byte has number 0.  The bit string is given by its first
bit and its length in bits.

   The interface part of the package is file `bits.h'.  The
implementation part is file `bits.c'.  The interface contains the
following external definitions of macros and functions:

`Macro `BIT''
                    `BIT(start_byte, bit_displacement)'

     returns given bit value as integer value `0' or `1'.  There is
     macro `SET_BIT (start_byte, bit_displacement,
     bit) for changing value of a bit.  Parameter `bit' must have value
     `0' or `1'.

`Function `is_zero_bit_string''
                    `int is_zero_bit_string (const void *start_byte,
                                             int bit_displacement,
                                             int bit_length)'

     returns `1' if given bit string contains only zero value bits, 0
     otherwise.

`Function `bit_string_set''
                    `void bit_string_set (void *start_byte, int
                                          bit_displacement, int bit,
                                          int bit_length)'

     sets up new value of all bits of given bit string.  This function
     is bit string analog of standard C function `memset'.

`Function `bit_string_copy''
                    `void bit_string_copy (void *to, int to_bit_displacement,
                                           const void *from,
                                           int from_bit_displacement,
                                           int bit_length)'

     copys a bit string to another bit string.  The bit strings must be
     nonoverlapped.  This function is bit string analog of standard C
     function `memcpy'.

`Function `bit_string_move''
                    void bit_string_move (void *to, int to_bit_displacement,
                                          const void *from,
                                          int from_bit_displacement,
                                          int bit_length)'

     copys a bit string to another bit string.  The bit strings can be
     overlapped.  This function is bit string analog of standard C
     function `memmove'.

`Function `bit_string_comparison''
                    `int bit_string_comparison
                         (const void *str1, int bit_displacement1,
                          const void *str2, int bit_displacement2,
                          int bit_length)'

     returns 0 if the bit strings are equal, 1 if the first bit string
     is greater than the second, -1 if the first bit string is less
     than the second.  This function is bit string analog of standard C
     function `memcmp'.

