This is ammunition++.info, produced by makeinfo version 4.0 from
/tmp/sgmltmp.ammunition++31892.info.2.

   \input texinfo


File: ammunition++.info,  Node: Package for machine-independent arbitrary precision integer arithmetic,  Next: Package for machine-independent IEEE floating point arithmetic,  Prev: Package for work with bit strings,  Up: Top

Package for machine-independent arbitrary precision integer arithmetic
**********************************************************************

   Abstract data `arithm' may be used for implementation of a
cross-compiler.  This abstract data implements arbitrary precision
integer and unsigned integer number arithmetic by machine independent
way.  The implementation of the package functions are not sufficiently
efficient in order to use for run-time.  The package functions are
oriented to implement constant-folding in compilers.  This package is
necessary because host machine may not support such arithmetic for
target machine.  For example, VAX does not support does not support
more 32-bits integer numbers arithmetic.

   The numbers in packages are represented by bytes in big endian mode,
negative integer numbers are represented in complementary code.  All
sizes are given in bytes and must be positive.  Results of executions
of all functions can coincide with a operand(s).  All functions of
addition, subtraction, multiplication, division, evaluation of
remainder, shift, changing size and transformation of string into
number fix overflow.  The overflow is fixed when result can not be
represented by number of given size.

   The interface part of the abstract data is file `arithm.h'.  The
implementation part is file `arithm.cpp'.  The maximum length of integer
number is suggested to be not greater then
`MAX_INTEGER_OPERAND_SIZE'.  The default value
(128) of this macro can be redefined with corresponding C++ compiler
option `-DMAX_INTEGER_OPERAND_SIZE=...'  during
compilation of file `arithm.cpp'.  But in any case the minimal value of
the macros will be 16.  The interface contains the following external
definitions:

`Class `integer''
     is auxialiary.  It serves to describe common variables and
     functions for work with signed and unsigned integers (classes
     `signed_integer' and `unsigned_integer').  The class
     `integer' has the following members.
    `Public static variable `overflow_bit''
          has only two values 0 or 1.  The value `1' corresponds to
          overflow.  The variable value are modified by all functions of
          addition, subtract, multiplication, division, evaluation of
          remainder, shift, changing size and transformation of string
          into number.

    `Public static variable `const unsigned char *zero_constant''
          represents zero (unsigned) integer of any size.

    `Public static function `default_arithmetic_overflow_reaction''
                          `void default_arithmetic_overflow_reaction (void)'

          Originally reaction on all integer and unsigned integer
          overflow is equal to this function.  The function does
          nothing.  Reaction on overflow for integers or unsigned
          integers is called after setting up variable
          `overflow_bit'.

`Classes `signed_integer' and `unsigned_integer''
     are sub-classes of the class `integer'.  The first class contains
     functions for implementation of signed integer arithmetic.  The
     second one contains functions for implementation of unsigned
     integer arithmetic.  The classes contains the following functions:
    `Static public function `set_overflow_reaction''
                          `void (*set_overflow_reaction
                                  (void (*function) (void))) (void)'

          change reaction on integer overflow and returns previous
          overflow reaction function.

    `Static public functions `maximum''
                          `void maximum   (int  size,  void  *result)'

          create given size (in bytes) maximal integer constant which
          is placed in memory whose address is given by the second
          parameter.

    `Static public functions `add''
                          `void add (int size, const void *op1,
                                     const void *op2,
                                     void *result)'

          make integer addition of integers of given size.  The
          functions fix overflow when result can not be represented by
          number of given size.  There are analogous functions which
          implement other operations:
                          `subtract',
                          `multiply',
                          `divide',
                          `remainder'.

    `Static public functions `shift_left''
                          `void  shift_left (int size,  const void *operand,
                                             int bits, void *result)'

          make left shift of integer of given size on given number of
          bits.  If number of bits is negative the functions make shift
          to right actually.  The functions fix overflow when result
          can not be represented by number of given size, i.e. in other
          words the opposite shift (to right) results in number not
          equal to source operand.  There are analogous functions which
          implement another operation
                          `shift_right'.

    `Static public function `_or_''
                          `void _or_ (int size, const void *op1,
                                      const void *op2,
                                      void *result)'

          make bitwise `or' of integers of given size.  There are
          analogous functions which implement bitwise `and':
                          `_and_'.

          Static public functions
                          `void _not_ (int size, const void *operand,
                                       void *result)'

          make bitwise `not' of integer of given size.

    `Static public functions `eq''
                          `int eq (int size, const void *op1, const void *op2)'

          compare two integers of given size on equality and returns 1
          or 0 depending on result of the comparison.  There are
          analogous functions which implement other integer operations:
                          `ne',
                          `gt',
                          `lt',
                          `ge',
                          and `le'.

    `Static public functions `change_size''
                          `void  change_size (int operand_size,
                                              const  void *operand,
                                              int result_size, void *result)'

          change size of integer.  The functions fix overflow when
          result can not be represented by number of given size.

    `Static public functions `to_string''
                          `char *to_string (int  size, const void *operand,
                                            char *result)'

          transform integer of given size to decimal ascii
          representation.  Sign is present in result string only for
          negative numbers (it is not possible for the function in
          class `unsigned_integer').  The functions return value
          `result'.

    `Static public functions `from_string''
                          `char *from_string (int  size, const char *operand,
                                              void *result)'

          skip all white spaces at the begin of source string and
          transforms the tail of the source string (decimal ascii
          representation with possible sign `+' or `-' only for the
          function in class `signed_integer') to given size
          integer and return pointer to first non digit in the source
          string.  If the string started with invalid integer
          representation the result will be zero.  The functions fix
          overflow when result can not be represented by number of
          given size.

`Classes `sint' and `unsint''
     Classes `signed_integer' and `unsigned_integer'
     containing only static function are simply written in C style.
     Object oriented implementation of integer arithmetic requires C++
     template classes which is not supported all C++ compilers.
     Therefore if you define macro `NO_TEMPLATE' before inclusion
     of interface file, classes `sint' and `unsint' will be absent.
     The classes is parameterized by size of integers (in bytes).  As
     the classes are subclasses of `signed_integer' and
     `unsigned_integer', you can members `overflow_bit',
     `set_overflow_reaction' to work with arithmetic
     overflow.  The classes have the following memebers:
    `Public constructors `sint', `unsint''
                          `sint (int value)', `sint (void)'
                          `unsint (unsigned int value)', `unsint (void)'

          can be used for creation integer with given value or zero
          integer.

    `Static public functions `max', `min''
                          `class sint<size> max (void)'
                          `class sint<size> min (void)'
                          `class unsint<size> max (void)'
                          `class unsint<size> min (void)'

          create integers and unsigned integers of maximal and minimal
          value.

    `Public operators `+''
                          `class sint<size> operator +
                                              (const class sint<size> &op)'
                          `class unsint<size> operator +
                                              (const class unsint<size> &op)'

          make integer addition of integers of given size.  The
          operator fixes overflow when result can not be represented by
          number of given size.  There are analogous operators which
          implement other operations:
                          `-',
                          `*',
                          `/',
                          `%'.

    `Public operators `<<''
                          `class sint<size> operator << (int bits)'
                          `class unsint<size> operator << (int bits)'

          make left shift of integer on given number of bits.  If
          number of bits is negative operator makes shift to right
          actually.  The operators fix overflow when result can not be
          represented by number of given size, i.e. in other words the
          opposite shift (to right) results in number not equal to
          source operand.  There are analogous operators which
          implement another operation (right shift)
                          `>>'.

    `Public operators `[verbar]''
                          `class sint<size> operator |
                                            (const class sint<size> &op)'
                          `class unsint<size> operator |
                                              (const class unsint<size> &op)'

          make bitwise `or' of integers.  There are analogous operators
          which implement bitwise `and':
                          `&'.

          Public operators
                          `class sint<size> operator ~ (void)'
                          `class unsint<size> operator ~ (void)'

          make bitwise `not' of integer of given size.

    `Public operators `==''
                          `int operator == (const class sint<size> &op)'
                          `int operator == (const class unsint<size> &op)'

          compare two integers of given size on equality and returns 1
          or 0 depending on result of the comparison.  There are
          analogous operators which implement other integer operations:
                          `!=',
                          `>',
                          `<',
                          `>=',
                          and `<='.

    `Public functions `to_str''
                          `char *to_str (char *result)'

          transform integer to decimal ascii representation.  Sign is
          present in result string only for negative numbers (it is not
          possible for the function in class `unsint').  The functions
          return value `result'.

    `Public functions `from_str''
                          `char *from_str (const char *operand)'

          skip all white spaces at the begin of source string and
          transforms the tail of the source string (decimal ascii
          representation with possible sign `+' or `-' only for the
          function in class `signed_integer') to given integer
          and return pointer to first non digit in the source string.
          If the string started with invalid integer representation the
          result will be zero.  The functions fixe overflow when result
          can not be represented by number of given size.

`Template functions `new_size''
                  `template <int result_size, int operand_size>
                   inline void new_size (class sint<operand_size> &operand,
                                         class sint<result_size> &result)'
                  `template <int result_size, int operand_size>
                   inline void new_size (class unsint<operand_size> &operand,
                                         class unsint<result_size> &result)'

     change size of integer.  The functions fix overflow when result
     can not be represented by number of given size.


File: ammunition++.info,  Node: Package for machine-independent IEEE floating point arithmetic,  Next: Ticker package,  Prev: Package for machine-independent arbitrary precision integer arithmetic,  Up: Top

Package for machine-independent IEEE floating point arithmetic
**************************************************************

   Abstract data `IEEE' may be used for implementation of a
cross-compiler.  This abstract data implements IEEE floating point
arithmetic by machine independent way with the aid of package `arithm'.
This abstract data is necessary because host machine may not support
such arithmetic for target machine.  For example, VAX does not support
IEEE floating point arithmetic.  The floating point numbers are
represented by bytes in big endian mode.  The implementation of the
package functions are not sufficiently efficient in order to use for
run-time.  The package functions are oriented to implement
constant-folding in compilers.  All integer sizes (see transformation
functions) are given in bytes and must be positive.

   Functions of addition, subtraction, multiplication, division,
conversion of floating point numbers of different formats can fix input
exceptions.  If an operand of such operation is trapping (signal) not a
number then invalid operation and reserved operand exceptions are fixed
and the result is (quiet) NaN, otherwise if an operand is (quiet) NaN
then only reserved operand exception is fixed and the result is (quiet)
NaN.  Operation specific processing the rest of special case values of
operands is placed with description of the operation.  In general case
the function can fix output exceptions and produces results for
exception according to the following table.  The result and status for
a given exceptional operation are determined by the highest priority
exception.  If, for example, an operation produces both overflow and
imprecise result exceptions, the overflow exception, having higher
priority, determines the behavior of the operation.  The behavior of
this operation is therefore described by the Overflow entry of the
table.

         Exception|Condition|                     |Result |Status
       -----------|---------|---------------------|-------|-------------
                  |masked   |         IEEE_RN(_RP)| +Inf  |IEEE_OFL and
                  |overflow | sign +  IEEE_RZ(_RM)| +Max  |IEEE_IMP
                  |exception|---------------------|-------|-------------
         Overflow |         | sign -  IEEE_RN(_RM)| -Inf  |IEEE_OFL and
                  |         |         IEEE_RZ(_RP)| -Max  |IEEE_IMP
                  |---------|---------------------|-------|-------------
                  |unmasked | Precise result      |See    |IEEE_OFL
                  |overflow |---------------------|above  |-------------
                  |exception| Imprecise result    |       |IEEE_OFL and
                  |         |                     |       |IEEE_IMP
       -----------|---------|---------------------|-------|-------------
                  |masked   |                     |Rounded|IEEE_UFL and
                  |underflow| Imprecise result    |result |IEEE_IMP
        Underflow |exception|                     |       |
                  |---------|---------------------|-------|-------------
                  |unmasked | Precise result      |result |IEEE_UFL
                  |underflow|---------------------|-------|-------------
                  |exception| Imprecise result    |Rounded|IEEE_UFL and
                  |         |                     |result |IEEE_IMP
       -----------|-------------------------------|-------|-------------
                  |masked imprecise exception     |Rounded|IEEE_IMP
        Imprecise |                               |result |
                  |-------------------------------|-------|-------------
                  |unmasked imprecise exception   |Rounded|IEEE_IMP
                  |                               |result |

   The package uses package `bits'.  The interface part of the abstract
data is file `IEEE.h'.  The implementation part is file `IEEE.cpp'.  The
interface contains the following external definitions:

`Macros `IEEE_FLOAT_SIZE', `IEEE_DOUBLE_SIZE', `IEEE_QUAD_SIZE''
     have values which are are sizes of IEEE single, double and quad
     precision floating point numbers (`4', `8',  and `16'
     correspondingly).

`Types `IEEE_float_t', `IEEE_double_t', and'
     `IEEE_quad_t' are simply synonyms of classes
     `IEEE_float', `IEEE_double', and `IEEE_quad'
     representing correspondingly IEEE single precision, double, and
     quad precision floating point numbers.

`Constants `IEEE_RN', `IEEE_RM', `IEEE_RP', `IEEE_RZ''
     defines rounding control (round to nearest representable number,
     round toward minus infinity, round toward plus infinity, round
     toward zero).

     Round to nearest means the result produced is the representable
     value nearest to the infinitely-precise result.  There are special
     cases when infinitely precise result falls exactly halfway between
     two representable values.  In this cases the result will be
     whichever of those two representable values has a fractional part
     whose least significant bit is zero.

     Round toward minus infinity means the result produced is the
     representable value closest to but no greater than the infinitely
     precise result.

     Round toward plus infinity means the result produced is the
     representable value closest to but no less than the infinitely
     precise result.

     Round toward zero, i.e.  the result produced is the representable
     value closest to but no greater in magnitude than the infinitely
     precise result.

`Class `IEEE''
     The class has the following functions common for all packages:
    `Static public function `reset''
                          `void reset (void)'

          and to separate bits in mask returned by functions
                          `IEEE_get_sticky_status_bits',
                          `IEEE_get_status_bits', and
                          `IEEE_get_trap_mask'.

    `Function `IEEE_reset''
                          `void IEEE_reset (void)'

          and to separate bits in mask returned by functions
                          `IEEE_get_sticky_status_bits',
                          `IEEE_get_status_bits', and
                          `IEEE_get_trap_mask'.

    `Static public function `get_trap_mask''
                          `int get_trap_mask (void)'

          returns exceptions trap mask.  Static public function
                          `int set_trap_mask (int mask)'

          sets up new exception trap mask and returns the previous.

          If the mask bit corresponding given exception is set, a
          floating point exception trap does not occur for given
          exception.  Such exception is said to be masked exception.
          Initial exception trap mask is zero.  Remember that more one
          exception may be occurred simultaneously.

    `Static public function `set_sticky_status_bits''
                          `int set_sticky_status_bits (int mask)'

          changes sticky status bits and returns the previous bits.

          Static public function
                          `int get_sticky_status_bits (void)'

          returns mask of current sticky status bits.  Only sticky
          status bits corresponding to masked exceptions are updated
          regardless whether a floating point exception trap is taken or
          not.  Initial values of sticky status bits are zero.

    `Static public function `get_status_bits''
                          `int get_status_bits (void)'

          returns mask of status bits.  It is supposed that the function
          will be used in trap on an floating point exception.  Status
          bits are updated regardless of the current exception trap mask
          only when a floating point exception trap is taken.  Initial
          values of status bits are zero.

    `Static public functions `set_round', `get_round''
                          `int set_round (int round_mode)'

          which sets up current rounding mode and returns previous mode
          and
                          `int IEEE_get_round (void)'

          which returns current mode.  Initial rounding mode is round
          to nearest.

    `Static public function `default_floating_point_exception_trap''
                          `void default_floating_point_exception_trap (void)'

          Originally reaction on occurred trap on an unmasked floating
          point exception is equal to this function.  The function does
          nothing. All occurred exceptions can be found in the trap with
          the aid of status bits.

    `Static public function `set_floating_point_exception_trap''
                          `void (*set_floating_point_exception_trap
                                  (void (*function) (void))) (void)'

          sets up trap on an unmasked exception.  Function given as
          parameter simulates floating point exception trap.

`Classes `IEEE_float', `IEEE_double', and `IEEE_quad''
     The classes implements IEEE floating point numbers in
     object-oriented style.  The following functions are described for
     class `IEEE_float'.  The classes `IEEE_double' and
     `IEEE_quad' have analogous functions (if details are absent)
     with the same names but for IEEE double and quad numbers.
    `Public constructors `IEEE_float', `IEEE_double', `IEEE_quad''
                          `IEEE_float (void)'
                          `IEEE_float (float f)'
                          `IEEE_double (void)'
                          `IEEE_double (float f)'
                          `IEEE_quad (void)'
                          `IEEE_quad (float f)'

          creates IEEE single, IEEE double, or IEEE quad precision
          numbers with pozitive zero values or with given value.

    `Public function `positive_zero''
                          `void positive_zero (void)'

          Given float becomes positive single precision zero constant.
          There are analogous functions which return other special case
          values:
                          `negative_zero',
                          `NaN',
                          `trapping_NaN',
                          `positive_infinity',
                          `negative_infinity',

          According to the IEEE standard NaN (and trapping NaN) can be
          represented by more one bit string.  But all functions of the
          package generate and use only one its representation created
          by function `NaN' (and `trapping_NaN').  A (quiet) NaN
          does not cause an Invalid Operation exception and can be
          reported as an operation result.  A trapping NaN causes an
          Invalid Operation exception if used as in input operand to
          floating point operation.  Trapping NaN can not be reported
          as an operation result.

    `Public function `is_positive_zero''
                          `int is_positive_zero (void)'

          returns 1 if given number is positive single precision zero
          constant.  There are analogous functions for other special
          case values:
                          `is_negative_zero',
                          `is_NaN',
                          `is_trapping_NaN',
                          `is_positive_infinity',
                          `is_negative_infinity',
                          `is_positive_maximum' (positive max value),
                          `is_negative_maximum',
                          `is_positive_minimum' (positive min value),
                          `is_negative_minimum',

          In spite of that all functions of the package generate and
          use only one its representation created by function `NaN' (or
          `trapping_NaN').  The function `is_NaN' (and
          `trapping_NaN') determines any representation of NaN.

    `Public function `is_normalized''
                          `int is_normalized (void)'

          returns TRUE if given number is normalized (special case
          values are not normalized).  There is analogous function
                          `is_denormalized'

          for determination of denormalized number.

    `Public operator `+''
                          `class IEEE_float operator + (class IEEE_float &op)'

          makes single precision addition of floating point numbers.
          There are analogous operators which implement other floating
          point operations:
                          `-',
                          `*',
                          `/',

          Results and input exceptions for operands of special cases
          values (except for NaNs) are described for addition by the
          following table
                              first  |         second operand
                              operand|---------------------------------------
                                     |    +Inf      |    -Inf     |   Others
                              -------|--------------|-------------|----------
                              +Inf   |    +Inf      |     NaN     |   +Inf
                                     |    none      |IEEE_INV(_RO)|   none
                              -------|--------------|-------------|----------
                              -Inf   |    NaN       |    -Inf     |   -Inf
                                     |IEEE_INV(_RO) |    none     |   none
                              -------|--------------|-------------|----------
                              Others |    +Inf      |    -Inf     |
                                     |    none      |    none     |

          Results and input exceptions for operands of special cases
          values (except for NaNs) are described for subtraction by the
          following table
                              first  |         second operand
                              operand|---------------------------------------
                                     |    +Inf     |    -Inf      |   Others
                              -------|-------------|--------------|----------
                              +Inf   |     NaN     |    +Inf      |   +Inf
                                     |IEEE_INV(_RO)|    none      |   none
                              -------|-------------|--------------|----------
                              -Inf   |    -Inf     |    NaN       |   -Inf
                                     |    none     |IEEE_INV(_RO) |   none
                              -------|-------------|--------------|----------
                              Others |    -Inf     |    +Inf      |
                                     |    none     |    none      |

          Results and input exceptions for operands of special cases
          values (except for NaNs) are described for multiplication by
          the following table
                          first  |         second operand
                          operand|--------------------------------------------
                                 |  +Inf    |   -Inf    |    0       |  Others
                          -------|----------|-----------|------------|--------
                          +Inf   |  +Inf    |   -Inf    |    NaN     | (+-)Inf
                                 |  none    |   none    |  IEEE_INV  |  none
                                 |          |           |    (_RO)   |
                          -------|----------|-----------|------------|--------
                          -Inf   |  -Inf    |   +Inf    |    NaN     | (+-)Inf
                                 |  none    |   none    |  IEEE_INV  |  none
                                 |          |           |   (_RO)    |
                          -------|----------|-----------|------------|--------
                          0      |   NaN    |   NaN     |   (+-)0    | (+-)0
                                 | IEEE_INV | IEEE_INV  |   none     | none
                                 |  (_RO)   |   (_RO)   |            |
                          -------|----------|-----------|------------|--------
                          Others | (+-)Inf  |  (+-)Inf  |   (+-)0    |
                                 |  none    |   none    |   none     |

          Results and input exceptions for operands of special cases
          values (except for NaNs) are described for division by the
          following table
                          first  |         second operand
                          operand|--------------------------------------------
                                 |   +Inf    |   -Inf    |   0       |  Others
                          -------|-----------|-----------|-----------|--------
                          +Inf   |    NaN    |    NaN    |  (+-)Inf  | (+-)Inf
                                 |  IEEE_INV |  IEEE_INV |  none     |  none
                                 |   (_RO)   |   (_RO)   |           |
                          -------|-----------|-----------|-----------|--------
                          -Inf   |    NaN    |    NaN    |  (+-)Inf  | (+-)Inf
                                 |  IEEE_INV |  IEEE_INV |  none     |  none
                                 |   (_RO)   |   (_RO)   |           |
                          -------|-----------|-----------|-----------|--------
                          0      |  (+-)0    |  (+-)0    |    NaN    | (+-)0
                                 |  none     |  none     |  IEEE_INV | none
                                 |           |           |   (_RO)   |
                          -------|-----------|-----------|-----------|--------
                          Others |  (+-)0    |  (+-)0    |  (+-)Inf  |
                                 |  none     |   none    |  IEEE_DZ  |

    `Public operator `==''
                          `int operator == (class IEEE_float &op)'

          compares two floating point numbers on equality and returns 1
          or 0 depending on result of the comparison.  There are
          analogous operators which implement other integer operations:
                          `!=',
                          `>',
                          `>=',
                          `<',
                          `<='.

          Results and input exceptions for operands of special cases
          values are described for equality and inequality by the
          following table

                          first  |         second operand
                          operand|---------------------------------------
                                 |    SNaN     |    QNaN      |   Others
                          -------|-------------|--------------|----------
                          SNaN   |   FALSE     |   FALSE      |  FALSE
                                 |  IEEE_INV   |  IEEE_INV    | IEEE_INV
                          -------|-------------|--------------|----------
                          QNaN   |   FALSE     |   FALSE      |  FALSE
                                 |  IEEE_INV   |    none      |   none
                          -------|-------------|--------------|----------
                          Others |   FALSE     |   FALSE      |
                                 |  IEEE_INV   |    none      |

          Results and input exceptions for operands of special cases
          values are described for other comparison operation by the
          following table

                          first  |         second operand
                          operand|---------------------------------------
                                 |    SNaN     |    QNaN      |   Others
                          -------|-------------|--------------|----------
                          SNaN   |   FALSE     |   FALSE      |  FALSE
                                 |  IEEE_INV   |  IEEE_INV    | IEEE_INV
                          -------|-------------|--------------|----------
                          QNaN   |   FALSE     |   FALSE      |  FALSE
                                 |  IEEE_INV   |  IEEE_INV    | IEEE_INV
                          -------|-------------|--------------|----------
                          Others |   FALSE     |   FALSE      |
                                 |  IEEE_INV   |  IEEE_INV    |

    `Public functions `to_string''
                          `char *to_string (char *result)'

          transforms single precision to decimal ascii representation
          with obligatory integer part (1 digit), fractional part (of
          constant length), and optional exponent.  Signs minus are
          present if it is needed.  The special cases IEEE floating
          point values are represented by strings `SNaN', `QNaN',
          `+Inf', `-Inf', `+0', and `-0'.  The function returns value
          `result'.  Current round mode does not affect the resultant
          ascii representation.  The function outputs 9 decimal fraction
          digits for single precision number, 17 decimal fraction
          digits for double precision number, and 36 decimal fraction
          digits for quad precision number

    `Public function `from_string''
                          `char *from_string (const char *operand)'

          skips all white spaces at the begin of source string and
          transforms tail of the source string to single precision
          floating point number.  The number must correspond the
          following syntax
                             ['+' | '-'] [<decimal digits>]
                                         [ '.' [<decimal digits>] ]
                                  [ ('e' | 'E') ['+' | '-'] <decimal digits>]

          or must be the following strings `SNaN', `QNaN', `+Inf',
          `-Inf', `+0', or `-0'.  The function returns pointer to first
          character in the source string after read floating point
          number.  If the string does not correspond floating point
          number syntax the result will be zero and function returns the
          source string.

          The function can fix output exceptions as described above.
          Current round mode may affect resultant floating point
          number.  It is guaranteed that transformation `IEEE floating
          point number -> string -> IEEE floating point number' results
          in the same IEEE floating point number if round to nearest
          mode is used.  But the reverse transformation `string with 9
          (or 17) digits -> IEEE floating point number -> string' may
          results in different digits of the fractions in ascii
          representation because a floating point number may represent
          several such strings with differences in the least
          significant digit.  But the ascii representations are
          identical when the functions for IEEE single, double, and
          quad  precision numbers do not fix imprecise result exception
          or less than 9 (17 or 36) digits of the fractions in the
          ascii representations are compared.

    `Public transformation functions'
          In class `IEEE_float'
                          `class IEEE_double to_double (void)'
                          `class IEEE_quad to_quad (void)'
                          `class IEEE_float &from_signed_integer
                                             (int size, const void *integer)'
                          `class IEEE_float &from_unsigned_integer
                                             (int size,
                                              const void *unsigned_integer)'
                          `void to_signed_integer (int size, void *integer)'
                          `void to_unsigned_integer (int size,
                                                     void *unsigned_integer)'

          In class `IEEE_double'
                          `class IEEE_float to_single (void)'
                          `class IEEE_quad to_quad (void)'
                          `class IEEE_double &from_signed_integer
                                              (int size,
                                               const void *integer)'
                          `class IEEE_double &from_unsigned_integer
                                               (int size,
                                                const void *unsigned_integer)'
                          `void to_signed_integer (int size, void *integer)'
                          `void to_unsigned_integer (int size,
                                                     void *unsigned_integer)'

          In class `IEEE_quad'
                          `class IEEE_float to_single (void)'
                          `class IEEE_double to_double (void)'
                          `class IEEE_quad &from_signed_integer
                                              (int size,
                                               const void *integer)'
                          `class IEEE_quad &from_unsigned_integer
                                               (int size,
                                                const void *unsigned_integer)'
                          `void to_signed_integer (int size, void *integer)'
                          `void to_unsigned_integer (int size,
                                                     void *unsigned_integer)'

          Actually no one output exceptions occur during transformation
          of single precision floating point number to double (or quad)
          precision number and of double precision floating point
          number to quad precision number.  No input exceptions occur
          during transformation of integer numbers to floating point
          numbers.  Results and input exceptions for operand of special
          cases values (and for NaNs) are described for conversion
          floating point number to integer by the following table
                                      Operand     | Result & Exception
                                    --------------|-------------------
                                        SNaN      |     0
                                                  |IEEE_INV(_RO)
                                    --------------|-------------------
                                        QNaN      |     0
                                                  |IEEE_INV(_RO)
                                    --------------|-------------------
                                        +Inf      |    IMax
                                                  |  IEEE_INV
                                    --------------|-------------------
                                        -Inf      |    IMin
                                                  |  IEEE_INV
                                    --------------|-------------------
                                        Others    |
                                                  |

          Results and input exceptions for operand of special cases
          values (and for NaNs) are described for conversion floating
          point number to unsigned integer by the following table
                                      Operand     | Result & Exception
                                    --------------|-------------------
                                        SNaN      |     0
                                                  |IEEE_INV(_RO)
                                    --------------|-------------------
                                        QNaN      |     0
                                                  |IEEE_INV(_RO)
                                    --------------|-------------------
                                        +Inf      |    IMax
                                                  |  IEEE_INV
                                    --------------|-------------------
                                        -Inf or   |    0
                                   negative number|  IEEE_INV
                                    --------------|-------------------
                                        Others    |
                                                  |

          Results and exceptions for NaNs during transformation of
          floating point numbers to (unsigned) integers are differed
          from the ones for operations of addition, multiplication and
          so on.

`Template transformation functions'
     As mentioned above there are template classes `sint' and `unsint'
     of package `arithm'.  Therefore package `IEEE' contains template
     functions for transformation of between IEEE numbers and integer
     numbers.  As in package `arithm' if you define macro
     `NO_TEMPLATE' before inclusion of interface file, these
     template transformation functions will be absent.  There are the
     following functions:
                  `template <int size>
                   class IEEE_float &IEEE_float_from_unsint
                                     (class IEEE_float &single,
                                      class unsint<size> &unsigned_integer)'
          
                  `template <int size>
                   class IEEE_float &IEEE_float_from_sint
                                     (class IEEE_float &single,
                                      class sint<size> &integer)
          
                  `template <int size>
                   void IEEE_float_to_sint (class IEEE_float &single,
                                            class sint<size> &integer)'
                  `template <int size>
                   void IEEE_float_to_unsint
                                (class IEEE_float &single,
                                 class unsint<size> &unsigned_integer)'
                  `template <int size>
                   class IEEE_double &IEEE_double_from_unsint
                                      (class IEEE_double &single,
                                       class unsint<size> &unsigned_integer)'
          
                  `template <int size>
                   class IEEE_double &IEEE_double_from_sint
                                      (class IEEE_double &single,
                                       class sint<size> &integer)
          
                  `template <int size>
                   void IEEE_double_to_sint (class IEEE_double &single,
                                             class sint<size> &integer)'
                  `template <int size>
                   void IEEE_double_to_unsint
                        (class IEEE_double &single,
                         class unsint<size> &unsigned_integer)'
                  `template <int size>
                   class IEEE_quad &IEEE_quad_from_unsint
                                      (class IEEE_quad &single,
                                       class unsint<size> &unsigned_integer)'
          
                  `template <int size>
                   class IEEE_quad &IEEE_quad_from_sint
                                      (class IEEE_quad &single,
                                       class sint<size> &integer)
          
                  `template <int size>
                   void IEEE_quad_to_sint (class IEEE_quad &single,
                                           class sint<size> &integer)'
                  `template <int size>
                   void IEEE_quad_to_unsint
                        (class IEEE_quad &single,
                         class unsint<size> &unsigned_integer)'

     Exceptions for these functions are the same as described above for
     functions `from_signed_integer',
     `to_signed_integer' and so on.

   Important note: All items (they contains word quad or QUAD in their
names) relative to IEEE 128 bits floating point numbers are defined
only when macro `IEEE_QUAD' is defined.  By default
`IEEE_QUAD' is not defined.  It is made because supporting IEEE
18-bits numbers requires more 100Kb memory.


File: ammunition++.info,  Node: Ticker package,  Next: Earley parser,  Prev: Package for machine-independent IEEE floating point arithmetic,  Up: Top

Ticker package
**************

   The package `ticker' implements a timer.  Timer can be activated or
can be stopped.  The timer accumulates execution time only when it is
in active state.  The interface part of the package is file `ticker.h'.
The implementation part is file `ticker.cpp'.  The interface contains
the following external definitions and macros:

`Type `ticker_t''
     describes a timer.  This type is simply synonym of `class ticker'.

`Class `ticker''
     Timers are objects of this class.  The class has the following
     members:
    `Public constructor `ticker''
                            `ticker (void)'

          creates new timer.  The state of the timer is active.

    `Public function `ticker_off''
                            `void ticker_off (void)'

          stops given timer.

    `Public function `ticker_on''
                            `void ticker_on (void)'

          activates given timer.

    `Function `active_time''
                            `double active_time (ticker_t ticker)'

          returns time in seconds as double float value in which the
          timer given as the function parameter was active.

    `Function `active_time_string''
                            `const char *active_time_string (ticker_t ticker)'

          returns string representation of time in seconds in which the
          timer given as the function parameter was active.  Remember
          that this function must be the single in a C++ expression
          because the string is stored in a static variable of the
          function.

