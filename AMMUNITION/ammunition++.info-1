This is ammunition++.info, produced by makeinfo version 4.0b from
/tmp/sgml-tools-dir-5988/sgmltmp.ammunition++5988.info.2.

   \input texinfo


File: ammunition++.info,  Node: Top,  Next: Introduction,  Up: (dir)

Ammunition (Reusable packages) - C++ interface
**********************************************

     Vladimir Makarov, `vmakarov@users.sourceforge.net'
     Apr 5, 2001

   This document describes ammunition (reusable packages written in
C/C++).

* Menu:

* Introduction::
* Package for allocating memory with fixing some allocation errors::
* Package for work with variable length objects::
* Package for work with stacks of objects::
* Package for work with hash tables::
* Package for work with source code positions::
* Package for output of compiler messages::
* Package for work with command line::
* Package for work with bit strings::
* Package for machine-independent arbitrary precision integer arithmetic::
* Package for machine-independent IEEE floating point arithmetic::
* Ticker package::
* Earley parser::


File: ammunition++.info,  Node: Introduction,  Next: Package for allocating memory with fixing some allocation errors,  Prev: Top,  Up: Top

Introduction
************

   This document describes ammunition (reusable packages written in
C/C++).  The packages are oriented towards creation of compiler and
cross-compiler.  Currently there are the following packages (their
names and tasks):

`allocate'
     allocating and freeing memory with fixing some allocation errors

`vlobject'
     work with variable length objects

`objstack'
     work with stacks of objects

`hashtab'
     work with hash tables

`position'
     work with source code positions

`errors'
     output of compiler messages

`commline'
     work with command line

`bits'
     work with bit strings

`arithm'
     implementing host machine-independently arbitrary precision
     integer numbers arithmetic

`IEEE'
     implementing host machine-independently IEEE floating point
     arithmetic

`ticker'
     timer

`earley'
     Earley parser


File: ammunition++.info,  Node: Package for allocating memory with fixing some allocation errors,  Next: Package for work with variable length objects,  Prev: Introduction,  Up: Top

Package for allocating memory with fixing some allocation errors
****************************************************************

   Developing modern compilers it is necessary to avoid arbitrary limits
on the length or number of any data structure by allocating all data
structures dynamically.  Here the package `allocate' which implements
allocation and freeing memory with automatic fixing allocation errors
is suggested.

   The package automatically calls action on situation `no memory'.  The
action never returns control back because after calling function which
processes allocation error the function `abort' is always called.
Therefore the function which processes allocation error should not
return control back.

   The interface part of the package is file `allocate.h'.  The
implementation part is file `allocate.cpp'.  The interface contains
class `allocate' without any public constructors/destructors.  The
class has the following functions:

`Static public function `change_error_function''
                  `void change_error_function
                        (void (*error_function) (void))) (void)'

     is used for changing up action on the situation `no memory'.  The
     function also returns former function which was early action on
     the situation `no memory'.

`Static public function `default_error_function''
                  `void default_error_function (void)'

     is default action of the package on the situation `no memory'.
     This action consists of output message `*** no memory ***' to
     standard error stream and calling function `exit' with code equals
     to 1.

`Static public function `malloc''
                  `void *malloc (size_t size)'

     is analogous to ANSI C library function `malloc'.  The parameter
     is size of needed memory.  The function returns address of
     allocated memory.

`Static public function `calloc''
                  `void *calloc (size_t nel, size_t size)'

     is analogous to ANSI C library function `calloc'.  The parameters
     have the same sense as in standard function `calloc'.  The
     function returns address of allocated memory.

`Static public function `free''
                  `void free (void *ptr)'

     is analogous to ANSI C library function `free' but can accept nil
     pointer value.  In this case function does nothing.

`Static public function `realloc''
                  `void *realloc(void *old, size_t size)'

     is analogous to ANSI C library function `realloc'.  The first
     parameter is old address of reallocated memory.  The second
     parameter is new size of reallocated memory.  The function returns
     new address of reallocated memory.


File: ammunition++.info,  Node: Package for work with variable length objects,  Next: Package for work with stacks of objects,  Prev: Package for allocating memory with fixing some allocation errors,  Up: Top

Package for work with variable length objects
*********************************************

   The package `vlobject' implements work with variable length object
(VLO) and uses package `allocate'.  Any number of bytes may be added to
and removed from the end of VLO.  If it is needed the memory allocated
for storing variable length object may be expanded possibly with
changing the object place.  But between any additions of the bytes (or
tailoring) the object place is not changed.  To decrease number of
changes of the object place the memory being allocated for the object
is longer than the current object length.

   The package uses package `allocate'.  The interface part of the
package is file `vlobject.h'.  Defining macro `NDEBUG' (e.g. by option
`-D' in C++ compiler command line) before the inclusion of the
interface file disables fixing some internal errors and errors of usage
of the package.  The implementation part is file `vlobject.cpp'.  The
interface contains the following objects:

`Type `vlo_t''
     describes a descriptor variable length object.  The type is simply
     synonym of `class vlo'.  All work with stack of objects is
     executed through the descriptors.  It should remember that work
     with the object through several descriptors is not safe.

`Macro `VLO_DEFAULT_LENGTH''
     has value which is default initial size of memory is allocated for
     VLO when the object is created (with not given initial size).
     Original value of the macros is equal to 512.  This macro can be
     redefined in C++ compiler command line or with the aid of
     directive `[num   ]undef' before including the interface file.

`Class `vlo''
     The class contains the following functions:
    `Public constructor `vlo''
                            `vlo (size_t initial_length = VLO_DEFAULT_LENGTH)'

          is used for creation of descriptor of VLO with initial zero
          length.  If the parameter value is absent, the value is equal
          to zero then the VLO initial allocated memory length is equal
          to `VLO_DEFAULT_LENGTH'.

    `Public destructor `[nbsp  ]vlo''
                            `~vlo (void)'

          is used for deleting the descritor of VLO and freeing memory
          used by the VLO.

    `Public function `nullify''
                            `void nullify (void)'

          makes that length of VLO of given descriptor will be equal to
          zero (but memory for VLO is not freed and not reallocated).

    `Public function `tailor''
                            `void tailor (void)'

          makes that length of memory allocated for VLO of given
          descriptor becomes equal to VLO length.

    `Public function `length''
                            `size_t length (void)'

          returns current length of VLO of given descriptor.

    `Public functions `begin', `end', `bound''
                            `void *begin(void)', `void *end(void)', `void *bound(void)'

          return pointer (of type `void *') to correspondingly the
          first, the last byte of VLO of given descriptor, and pointer
          to the last byte plus one.  Remember that the object may
          change own place after any addition.

    `Public function `shorten''
                            `void shorten (size_t n)'

          removes n bytes from the end of VLO of given descriptor.  VLO
          is nullified if its length is less than n.

    `Public function `expand''
                            `void expand (size_t length)'

          increases length of VLO of given descriptor on number of
          bytes given as the parameter.  The values of bytes added to
          the end of VLO will be not defined.

    `Public function `add_byte''
                            `void add_byte (int b)'

          adds byte given as the parameter to the end of VLO of given
          descriptor.

    `Public function `add_memory''
                            `void add_memory (void *str, size_t length)'

          adds memory starting with address given as the first macro
          parameter and with length given as the second parameter to
          the end of VLO of given descriptor.

    `Public function `add_string''
                            `void add_string (const char *str)'

          adds C string (with end marker 0) given as the parameter to
          the end of VLO of given descriptor.  Before the addition the
          macro deletes last character of the VLO.  The last character
          is suggested to be C string end marker 0.


File: ammunition++.info,  Node: Package for work with stacks of objects,  Next: Package for work with hash tables,  Prev: Package for work with variable length objects,  Up: Top

Package for work with stacks of objects
***************************************

   The package `objstack' is based on package `allocate' and implements
efficient work with stacks of objects (OS).  Work with the object on
the stack top is analogous to one with a variable length object.  One
motivation for the package is the problem of growing char strings in
symbol tables.  Memory for OS is allocated by segments.  A segment may
contain more one objects.  The most recently allocated segment contains
object on the top of OS.  If there is not sufficient free memory for
the top object than new segment is created and the top object is
transferred into the new segment, i.e. there is not any memory
reallocation.  Therefore the top object may change its address.  But
other objects never change address.

   The package uses package `allocate'.  The interface part of the
package is file `objstack.h'.  Defining macro `NDEBUG' (e.g.  by option
`-D' in C++ compiler command line) before inclusion of the interface
file disables fixing some internal errors and errors of usage of the
package.  The implementation part is file `objstack.cpp'.  The
interface contains the following objects:

`Type `os_t''
     describes a descriptor of stack of objects.  The type is simply
     synonym of `class os'.  All work with stack of objects is executed
     through the descriptors.  It should remember that work with the
     stack through several descriptors is not safe.

`Macro `OS_DEFAULT_SEGMENT_LENGTH''
     has value which is default size of memory segments which will be
     allocated for OS when the stack is created (with not given initial
     segment size).  This is also minimal size of all segments.
     Original value of the macros is equal to 512.  This macro can be
     redefined in C++ compiler command line or with the aid of
     directive `[num   ]undef' before including the interface file.

`Class `os''
     The class contains the following functions:
    `Public constructor `os''
                          `os (size_t initial_segment_length
                                           = OS_DEFAULT_SEGMENT_LENGTH)'

          creates OS which contains the single zero length object.
          Minimum size of memory segments which will be allocated for
          OS is given as the parameter.  If the parameter is absent the
          allocated memory segments length is equal to
          `OS_DEFAULT_SEGMENT_LENGTH'.  But in any
          case the segment length is always not less than maximum
          alignment.

    `Public destructor `[nbsp  ]os''
                          `~os (void)'

          is used for deleting the descritor of OS and freeing memory
          used by the OS.

    `Public function `empty''
                          `void empty (void)'

          is used for removing all objects on OS and freeing all memory
          allocated for OS except for the first segment.

    `Public function `top_finish''
                          `void top_finish (void)'

          creates new variable length object with initial zero length
          on the top of OS of given descriptor.  The work (analogous to
          one with variable length object) with object which was on the
          top of OS is finished, i.e. the object will never more change
          address.

    `Public function `top_nullify''
                          `void top_nullify (void)'

          makes that length of variable length object on the top of OS
          of given descriptor will be equal to zero.

    `Public function `top_length''
                          `size_t top_length (os)'

          returns current length of variable length object on the top of
          OS of given descriptor.

    `Public functions `top_begin', `top_end', `top_bound''
                          `void *top_begin (void)', `void *top_end (void)',
                          `void *top_bound (void)'

          return pointer to correspondingly the first, the last byte of
          variable length object on the top of OS of given descriptor,
          and pointer to the last byte plus one.  Remember that the top
          object may change own place after any addition.

    `Public function `top_shorten''
                          `void top_shorten (size_t n)'

          removes n bytes from the end of variable length object on the
          top of OS of given descriptor.  The top variable length
          object is nullified if its length is less than n.

    `Public function `top_expand''
                          `void top_expand (size_t length)'

          increases length of variable length object on the top of OS
          of given descriptor on number of bytes given as the
          parameter.  The values of bytes added to the end of variable
          length object on the top of OS will be not defined.

    `Public function `top_add_byte''
                          `void top_add_byte (int b)'

          adds byte given as the parameter to the end of variable
          length object on the top of OS of given descriptor.

    `Public function `top_add_memory''
                          `void top_add_memory (void *str, size_t length)'

          adds memory starting with address given as the first
          parameter and with length given as the second parameter to
          the end of variable length object on the top of OS of given
          descriptor.

    `Public function `top_add_string''
                          `void top_add_string (const char *str)'

          adds C++ string (with end marker 0) given as the parameter to
          the end of variable length string on the top of OS of the
          descriptor.  Before the addition the macro deletes last
          character of the top variable length object.  The last
          character is suggested to be C++ string end marker 0.


File: ammunition++.info,  Node: Package for work with hash tables,  Next: Package for work with source code positions,  Prev: Package for work with stacks of objects,  Up: Top

Package for work with hash tables
*********************************

   The most compilers use search structures.  Here the package `hashtab'
which implements expandable hash tables is suggested.  This abstract
data implements features analogous to ones of public domain functions
`hsearch', `hcreate' and `hdestroy'.  The goal of the abstract data
creation is to implement additional needed features.  The abstract data
permits to work simultaneously with several expandable hash tables.
Besides insertion and search of elements the elements from the hash
tables can be also removed.  The table element can be only a pointer.
The size of hash tables is not fixed.  The hash table will be expanded
when its occupancy will become big.

   The abstract data implementation is based on generalized Algorithm D
from Knuth's book "The art of computer programming".  Hash table is
expanded by creation of new hash table and transferring elements from
the old table to the new table.

   The package uses package `allocate'.  The interface part of the
abstract data is file `hashtab.h'.  The implementation part is file
`hashtab.cpp'.  The interface contains the following objects:

`Type `hash_table_entry_t''
     is described as `void *' and represents hash table element type.
     Empty entries have value `NULL'.

`Type `hash_table_t''
     describes hash table itself.  The type is simply synonym of `class
     hash_table *'.

`Class `hash_table''
     The class contains the following functions:
    `Public constructor `hash_table''
                          `hash_table
                             (size_t size,
                              unsigned (*hash_function)
                                                 (hash_table_entry_t el_ptr),
                              int (*eq_function) (hash_table_entry_t el1_ptr,
                                                  hash_table_entry_t el2_ptr))'

          creates hash table with length slightly longer than value of
          function parameter `size'.  Created hash table is initiated
          as empty (all the hash table entries are NULL).  The hash
          table will use functions `hash_function',
          `eq_function' given as the function parameters to
          evaluate table element hash value and function to test on
          equality of two table elements.

    `Public destructor `[nbsp  ]hash_table''
                          `~hash_table (void)'

          deletes given hash table and frees memory allocated for it.

    `Public function `empty''
                          `void empty  (void)'

          makes the hash table empty.  If you need to remove all table
          elements, it is better to use this function than several
          times function
          `remove_element_from_entry'.  This
          function does not change size of the table or clear
          statistics about collisions.

    `Public function `find_entry''
                          `hash_table_entry_t *find_entry
                                               (hash_table_entry_t element,
                                                int reserve)'

          searches for hash table entry which contains element equal to
          value of the function parameter `element' or empty entry in
          which `element' can be placed (if the element does not exist
          in the table).  The function parameter `reserve' is to be
          nonzero if the element is to be placed in the table.  The
          element should be inserted into the table entry before another
          call of `find_hash_table_entry'.  The
          table is expanded if occupancy (taking into account also
          deleted elements) is more than 75%.  The occupancy of
          the table after the expansion will be about 50%.

    `Public function `remove_element_from_entry''
                          `void remove_element_from_entry
                                   (hash_table_entry_t element)'

          removes element from hash table_entry whose value is
          given as the function parameter.  Hash table entry for given
          value should be not empty (or deleted).  The hash table entry
          value will be marked as deleted after the function call.

    `Public function `size''
                          `size_t size (void)'

          returns current size of given hash table.

    `Public function `elements_number''
                          `size_t elements_number (void)'

          returns current number of elements in given hash table.

    `Public function `collisions''
                          `int collisions (void)'

          returns number of of percents of fixed collisions during all
          work with given hash table.

    `Static public function `all_collisions''
                          `int all_collisions (void)'

          returns number of of percents of fixed collisions during all
          work with all hash tables.


File: ammunition++.info,  Node: Package for work with source code positions,  Next: Package for output of compiler messages,  Prev: Package for work with hash tables,  Up: Top

Package for work with source code positions
*******************************************

   The compilers often use internal representation which stores source
code positions.  Here package `position' which serves to support
information about source positions of compiled files taking into
account all included files is suggested.

   The strategy of the package usage can be follows.  Function
`initiate' of class `positions' is called by the first.  After that
function `start_file' of class `positions' is called when a file
is opened for compilation as source or included file.  Members
`line_number' and `column_number' of variable
`current_position' are modified correspondingly during given
file compilation.  The value of `current_position' can be stored
into internal representation for usage for output messages on the
following passes.  Function `finish_file' of class `positions'
is called when a processed file is closed.  Function `finish' of class
`positions' may be called after all processing a source file.

   The package uses packages `vlobject' and `objstack' which use package
`allocate'.  The interface part of the package is file `position.h'.
The implementation part is file `position.cpp'.  The interface contains
the following objects:

`Type `position_t''
     is simply `class position' describes a file position.  The class
     has the following members:

    `Public members `line_number', `column_number''
          are source line and column corresponding to given position.

    `Public function `file_name''
                              `const char *file_name (void)'

          returns name of file to which given position belongs.

    `Public function `path''
                              `class position *path (void)'

          is pointer to another position class object representing
          position of a include-clause which caused immediately given
          file compilation.

    `Public function `path''
                              `int file_inclusion_level (void)'

          returns number of level of position file inclusion.  The
          level numbers are started with zero for positions
          corresponding non-included files and for positions which does
          not correspond to concrete file.

`Class `positions''
     The class has not public constructors/destructors.  The class has
     the following members:
    `Static const member `no_position''
          has value of type `position_t' has values
          `line_number', `column_number' equals to zero
          or `NULL'.  The value does not correspond to concrete file
          position.

    `Static member `current''
          has value which is current file position.

    `Static public function `initiate''
                          `void initiate (void)'

          initiates the package.  Value of variable `current' becomes
          equal to `no_position'.

    `Static public function `finish''
                          `void finish (void)'

          frees all memory allocated during package work.

    `Static public function `start_file''
                          `void start_file (const char *file_name)'

          save position in member variable `current' and sets up new
          values of members of `current'.  Values of members
          `file_name', `line_number',
          `column_number', and `path' become equal to the
          function parameter value, 1, 0, and pointer to the saved
          position.  Values of `current' during different calls of the
          function must be different (e.g.  different columns or
          lines), i.e. positions of different include-clauses must be
          different.

    `Static public function `finish_file''
                          `void finish_file (void)'

          restores previous value of the member `current', more exactly
          sets up the member by position to which the member `path'
          refers.

    `Static public Function `compare''
                          `int compare_positions (position_t position_1,
                                                  position_t position_2)'

          compares two positions given by parameters of type
          `position_t' and returns -1 (if the first position is
          less than the second), 0 (if the first position is equal to
          the second) or 1 (if the first position is greater than the
          second).  The order of positions is lexicographic.


File: ammunition++.info,  Node: Package for output of compiler messages,  Next: Package for work with command line,  Prev: Package for work with source code positions,  Up: Top

Package for output of compiler messages
***************************************

   The most of compilers report error messages for incorrect program.
Here the package `errors' which serves to output one-pass or multi-pass
compiler messages of various modes (errors, warnings, fatal, system
errors and appended messages) in Unix style or for traditional listing
is suggested.  The package also permits adequate error reporting for
included files.

   The package uses packages `vlobject', `objstack', `position' which
use package `allocate'.  Therefore package `position' have to be
initiated before any work with this package.  The interface part of the
package is file `errors.h'.  The implementation part is file
`errors.cpp'.  The maximum length of generated error message is
suggested to be not greater then
`MAX_ERROR_MESSAGE_LENGTH'.  The default value
(150) of this macro can be redefined with corresponding C++ compiler
option `-DMAX_ERROR_MESSAGE_LENGTH=...'  during
compilation of file `errors.cpp'.  The interface contains only one
class `errors'.  The class has the following members:

`Public functions `number_of_errors', `number_of_warnings''
                  `unsigned int number_of_errors (void)'
                  `unsigned int number_of_warnings (void)'

     return values which are number of correspondingly errors and
     warnings fixed after given class object creation.

`Integer variable `maximum_number_of_errors''
     has value which is maximum number of errors which will be fixed.
     If an error is fixed with number equals to
     `maximum_number_of_errors' then special fatal
     error `fatal error - too many errors' with position of given error
     is fixed instead of the error.  And all following errors are
     ignored.  Zero value of the variable means that the special fatal
     error will never fixed.

`Public virtual function `fatal_error_function''
                  `void fatal_error_function (void)'

     without parameters which will be called after fixing a fatal
     error.  The fatal error function is suggested to do not return the
     control back.  The default fatal error function only calls `exit
     (1)'.

`Public constructor `errors''
                  `errors (int immediate_output_flag)'

     creates the class `errors' object working in regime depending on
     parameter value.  If the parameter value is nonzero than all fixed
     messages are output immediately.  Otherwise the compiler messages
     are stored until function `output' are called.

`Public destructor `[nbsp  ]errors''
                  `~errors (void)'

     frees all memory allocated during the class `errors' object work.

`Public function `output''
                  `void output (void)'

     sorts (stable sorting) all fixed messages by their positions,
     outputs ones, and deletes ones.  Appended messages will be output
     after corresponding error or warning.  This function should be
     used only in regime of storing messages.

`Public function `error''
                       `void error (int fatal_error_flag, position_t
                                    position, const char *format, ...)'

     fixes error (fatal error if the first parameter value is nonzero)
     at the position given as the second parameter.  If the error is
     fatal than functions `output' and
     `*fatal_error_function' are called.  The diagnostic
     messages are formed analogous to output of function `printf'.  For
     example,
                     error (1, current_position, "fatal error - no memory");

`Public function `warning''
                  `void warning (position_t position, const char *format, ...)'

     is analogous to the previous but is used to fix a warning.

`Public function `append_message''
                  `void append_message (position_t position,
                                        const char *format, ...)'

     When regime of immediately output of fixed message is on this
     function is analogous to the previous (except for incrementing
     `number_of_warnings').  In opposite case the
     appended message will be output with the most recent fixed error
     or warning independently from value of the first parameter.  Of
     course the previously fixed error or warning must exist.

     For example, this function may be used for generation of messages
     of type
                        `<file>:<line>:<position-1>: repeated declaration'

     and then
                        `<file>:<line>:<position-1>: previous declaration'.

     Description of function `output_error_function'
     contains explanation why decremented position is output.

`Public function `system_error''
                  `void system_error (int fatal_error_flag,
                                      position_t position,
                                      const char *format, ...)'

     is analogous to function `error' but serves to fix a system error.
     The current system message without head blanks (given by standard
     function `strerror') is placed after the message formed by the
     function parameters.  For example, the following call may be used
     when a file is not opened
                       system_error  (1, current_position,
                                      "fatal error - %s:", new_file_name);

`Public virtual function `output_error_function''
                  `void default_output_error_function
                        (int appended_message_flag, position_t position,
                         const char *message)'

     is used to output error message.  The function has three
     parameters - flag of appended message, message position and
     message itself.

     By default the function is oriented to output in Unix style
     according to GNU standard.  To output a listing the function
     `output_error_function' should be changed.  The
     default function output message in the following formats:
            MESSAGE                              (NULL file name)
            FILE_NAME:1: MESSAGE                 (zero line number)
            FILE_NAME:LINE_NUMBER: MESSAGE       (zero column number)
            FILE_NAME:LINE_NUMBER:COLUMN_NUMBER-1: MESSAGE  (all other cases)

     After that the function outputs newline.  The function also
     outputs additional messages `in file processed from ...'  if given
     message is not appended message and corresponds to file different
     from one of previous output error.  This message reflects path of
     the message position (see package `position'), i.e.  reflects
     positions of corresponding include-clauses.  Decremented column
     number is output in order to be in concordance with editor Emacs
     in which positions start with 0.


File: ammunition++.info,  Node: Package for work with command line,  Next: Package for work with bit strings,  Prev: Package for output of compiler messages,  Up: Top

Package for work with command line
**********************************

   To make easy process of command line, here abstract data `commline'
is suggested.  This abstract data implements features analogous to ones
of public domain function `getopt'.  The goal of the abstract data
creation is to use more readable language of command line description
and to use command line description as help output of program.

   POSIX terminology concerning command line is used here.  Command
line is divided into command name and arguments.  The arguments are
subdivided into options, option-arguments and operands.  Option starts
with `-'.  All arguments after first `-' in command line are treated as
operands.

   The description of command line is made up from two parts.  Any part
(or both) may be absent in the description.  First part contains
option-arguments names of options which are in the second part.
option-arguments names are separated by white space.  The second part
starts with percents `%%' and contains any text in which
description of options are placed.  Any description of option starts
with character "' followed by character `-' and finishes by character
`".  White spaces may precede option-argument name.  It means that the
corresponding option has obligatory separate option-argument.  For
example, the following may be a part of description of options of a
pascal compiler command line.

     dir xxx file
     %%
     command line:  pc [options] file ...
                                    Options:
     `-0'      Pascal standard level 0    `-1'      Pascal standard Level 1.
     `-29000'  Am29000 code generation    `-29050'* Am29050 code generation
     `-c'      only object files creation `-el'     output of listing
     `-g'      information for debuggers  `-Idir'   data task units directory
     `-lxxx'   library                    `-Ldir'   libraries directory
     `-o file' output file                `-O'      all optimizations
     `-S'      only ass. code creation    `-v'      loaded processes indication
     `-w'      no warnings generation
                    Star * marks defaults

   In this example options with names `-I', `-l', `-L' and `-o' have
option-arguments but only option with name `-o' has separate
option-argument, i.e. option-argument which is represented by separate
argument after given option in command line.

   The interface part of the abstract data is file `commline.h'.  The
package uses package `vlobject' which use package `allocate'.  The
implementation part is file `commline.cpp'.  The interface contains
only one class `command_line'.  The class has the following
members:

`Public constructor `command_line''
                    `command_line (int argc, char **argv,
                                   const char *description,
                                   int &correct_description_flag)'

     The constructor processes command line description given as string
     parameter and command line itself given as two parameter `argc'
     and `argv'.  The function returns 0 through parameter
     `correct_description_flag' if error in command line
     description is fixed, otherwise returns 1 (it means success).

`Public destructor `command_line''
                    `~command_line (void)'

     finishes work with the command line.

`Public function `output_description''
                    `void output_description (void)'

     outputs the second part (without `%%') of
     description of options to stderr.  This function should be called
     when it is necessary to show the program usage.

`Public function `next_operand''
                    `int next_operand (int flag_of_first)'

     returns command line argument number of next operand if the
     function parameter is nonzero.  Otherwise the function returns
     number of the first operand in the command line.  The function
     returns 0 if all operands are already processed.  Returned number
     may be used as index of array returned by function
     `argument_vector' to access corresponding operand.

`Public function `number_of_operands''
                    `int number_of_operands (void)'

     returns number of operands in the command line.

`Public function `next_option''
                    `int next_option (int flag_of_first)'

     returns command line argument number of next option if the
     function parameter is nonzero.  Otherwise the function returns
     number of the first option in the command line.  The function
     returns 0 if all options are already processed.  Returned number
     may be used as index of array returned by function
     `argument_vector' to access corresponding option.

`Function `option_characteristics''
                    `char *option_characteristics (int argument_number,
                                                   int *option_has_argument)'

     returns pointer to option name which describes the command line
     argument with number `argument_number' given as the first
     parameter of the function.  The function returns NULL if the
     corresponding option in the command line description is not found
     or an option described as with option-argument has not
     option-argument in the command line.  Remember that option name
     with option-argument differs from option in the command line (e.g.
     `-U' and `-Ufoo').  If the option in the command line description
     is found than the function sets up correspondingly the second
     function parameter `option_has_argument'.  The case
     of returned NULL and `*option_has_argument' equals
     to TRUE means that given option must have option-argument but the
     option has not option-argument in the command line.

`Public function `last_option_place''
                    `int last_option_place (const char *option_name)'

     returns number of last option with given option name in the
     command line.  The function returns 0 if the option is absent in
     the command line.

`Public function `option_argument''
                    `char *option_argument (const char *option_name)'

     returns pointer to argument of last option in the command line
     with given option name.  The function returns NULL if the option
     is absent in the command line.  The function must be called only
     for options which have argument separated by white spaces.

`Public functions `argument_count', `argument_vector''
                    `int argument_count (void)'
                    `char **argument_vector (void)'

     return `argc' and `argv' of function `main'.  See also description
     of the class constructor.


File: ammunition++.info,  Node: Package for work with bit strings,  Next: Package for machine-independent arbitrary precision integer arithmetic,  Prev: Package for work with command line,  Up: Top

Package for work with bit strings
*********************************

   The package for work with bit strings is used to implement package
`IEEE'.  But of course the package can be used for solving other tasks.

   Here a bit is given by address (start address) of byte from which
counting bits starts and its displacement which is any non negative
number of bit from the start address.  The most significant bit of the
start address byte has number 0.  The bit string is given by its first
bit and its length in bits.

   The interface part of the package is file `bits.h'.  The
implementation part is file `bits.cpp'.  The interface contains only
class `bits' without public constructors and destructors.  The class
contains the following members:

`Static public function `bit''
                    `int bit (const void *start_byte, int bit_displacement)'

     returns given bit value as integer value `0' or `1'.  There is
     static public function `set_bit'
                    `void set_bit (void *start_byte, int bit_displacement,
                                   int bit)

     for changing value of a bit.  Parameter `bit' must have value `0'
     or `1'.

`Static public function `is_zero_bit_string''
                    `int is_zero_bit_string (const void *start_byte,
                                             int bit_displacement,
                                             int bit_length)'

     returns `1' if given bit string contains only zero value bits, 0
     otherwise.

`Static public function `bit_string_set''
                    `void bit_string_set (void *start_byte, int
                                          bit_displacement, int bit,
                                          int bit_length)'

     sets up new value of all bits of given bit string.  This function
     is bit string analog of standard C++ function `memset'.

`Static public function `bit_string_copy''
                    `void bit_string_copy (void *to, int to_bit_displacement,
                                           const void *from,
                                           int from_bit_displacement,
                                           int bit_length)'

     copys a bit string to another bit string.  The bit strings must be
     nonoverlapped.  This function is bit string analog of standard C++
     function `memcpy'.

`Static public function `bit_string_move''
                    void bit_string_move (void *to, int to_bit_displacement,
                                          const void *from,
                                          int from_bit_displacement,
                                          int bit_length)'

     copys a bit string to another bit string.  The bit strings can be
     overlapped.  This function is bit string analog of standard C++
     function `memmove'.

`Static public function `bit_string_comparison''
                    `int bit_string_comparison
                         (const void *str1, int bit_displacement1,
                          const void *str2, int bit_displacement2,
                          int bit_length)'

     returns 0 if the bit strings are equal, 1 if the first bit string
     is greater than the second, -1 if the first bit string is less
     than the second.  This function is bit string analog of standard
     C++ function `memcmp'.

