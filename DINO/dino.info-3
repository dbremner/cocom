This is dino.info, produced by makeinfo version 4.0 from
/tmp/sgmltmp.dino5641.info.2.

   \input texinfo


File: dino.info,  Node: Token-,  Next: Anode-,  Prev: Parser-,  Up: Earley parser classes

Token-
......

   Dino has predeclared class `token'.  Objects of this class should be
input of the earley parser (see function `parse' in class `parser').
The result abstract tree representing translation will have input
tokens as leaves.  Class `token' has one public variable `code' whose
value should be code of terminal described in the grammar.  You could
extend the class description e.g. by adding variables whose values
could be attributes of the token (e.g. source line number, name of an
identifier, or value for a number).


File: dino.info,  Node: Anode-,  Next: Example of Earley parser usage-,  Prev: Token-,  Up: Earley parser classes

Anode-
......

   Dino has predeclared class `anode' whose objects are nodes of
abtract tree representing the translation (see function `parse' of
class `parser').  Objects of this class are generated by earley parser.
The class has two public variables `name' whose value is string
representing name of the abstract node as it given in the grammar and
`transl' whose value is array with abstract node fields as the array
elements.  There are a few node types which have special meaning:

   * Terminal node which has reserved name `$term'.  Value of public
     variable `transl' for this node is object of class `token'
     representing the corresponding input token which was an element of
     array passed as parameter of function `parse' of function `parser'.

   * Error node which has reserved name `$error'.  This node exists in
     one exemplar and represents translation of grammar reserved symbol
     `error'.  The value is public variable will be `nil' in this case.

   * Empty node which has reserved name `$nil'.  This node exists also
     in one exemplar and represents translation of grammar symbol for
     which we did not describe a translation.  For example, in a
     grammar rule an abstract node refers for translation of
     nonterminal for which we do not produce a translation.  The value
     is public variable of such class object will be `nil' in this case.

   * Alternative node which has reserved name `$alt'.  It represents
     all possible alternatives in translation of grammar nonterminal.
     The value of public variable `transl' will be array with elements
     whose value are objects of class `anode' which represent the all
     possible translations.  Such nodes can be generated by the parser
     only if the grammar is ambiguous and we did not asked it to
     produce only one translation.


File: dino.info,  Node: Example of Earley parser usage-,  Prev: Anode-,  Up: Earley parser classes

Example of Earley parser usage-
...............................

   Let us write program which transforms expression into postfix polish
form.  Please, read the program comments to understand what the code
do.  The program should output string `"abcda*+*+"' which is postfix
polish form of input string `"a+b*(c+d*a)"'.
               // The following is expression grammar:
               var grammar = "E : E '+' T   # plus (0 2)\n\
                                | T         # 0\n\
                                | error     # 0\n\
                              T : T '*' F   # mult (0 2)\n\
                                | F         # 0\n\
                              F : 'a'       # 0\n\
                                | 'b'       # 0\n\
                                | 'c'       # 0\n\
                                | 'd'       # 0\n\
                                | '(' E ')' # 1";
               // Create parser and set up grammar.
               var p = parser ();
               p.set_grammar (grammar, 1);
     
               // Add attribute repr to token:
               ext token { var repr; }
               // The following code forms input tokens from string:
               var str = "a+b*(c+d*a)";
               var i, inp = [#str : nil];
               for (i = 0; i < #str; i++) {
                 inp [i] = token (str[i] + 0);
                 inp [i].repr = str[i];
               }
               // The following function output messages about syntax errors
               // syntax error recovery:
               func error (err_start, err_tok,
                           start_ignored_num, start_ignored_tok_attr,
                           start_recovered_num, start_recovered_tok) {
                 put ("syntax error on token #", err_start,
                      " (" @ err_tok.code @ ")");
                 putln (" -- ignore ", start_recovered_num - start_ignored_num,
                        " tokens starting with token #", start_ignored_num);
               }
     
               var root = p.parse (inp, error); // parse
     
               // Output translation in polish inverse form
               func pr (r) {
                 var i, n = r.name;
     
                 if (n == "$term")
                   put (r.transl.repr);
                 else if (n == "mult" || n == "plus") {
                   for (i = 0; i < #r.transl; i++)
                     pr (r.transl [i]);
                   put (n == "mult" ? "*" : "+");
                 }
                 else if (n != "$error") {
                   putln ("internal error");
                   exit (1);
                 }
               }
     
               pr (root);
               putln ();


File: dino.info,  Node: Predeclared functions,  Prev: Predeclared classes,  Up: Predeclared identifiers

Predeclared functions
=====================

   The predeclared functions expect given number actual parameters (may
be variable number parameters).  If the actual parameter number is
unexpected one, exception `partype' is generated.  The predeclared
functions believe that the actual parameters (may be after implicit
conversions) are of required type.  If it is not true, exception
`partype' is generated.  To show how many parameters the function
requires, we will write names of the parameters and to use brackets `['
and `]' for the optional parameters in description of the functions.

   Examples:  The following description
               strtime ([format [, time]])

   describes that the function can accept zero, one, or two parameters.
If only one parameter is given, then this is parameter `format'.

   If something special is not said about the returned result, the
function returns default value `nil'.

* Menu:

* Mathematical functions::
* Pattern matching functions::
* File functions::
* Time functions::
* Functions for access to process information::
* Miscellaneous functions::


File: dino.info,  Node: Mathematical functions,  Next: Pattern matching functions,  Up: Predeclared functions

Mathematical functions
----------------------

   The following functions make implicit arithmetic conversion of the
parameters.  After the conversions the parameters are expected to be of
integer or floating point type.  The result is always a floating point
number.
   * `sqrt (x)'.  The function returns the square root of `x'.  The
     function generates exception `edom' if `x' is negative.

   * `exp (x)'.  The function returns `e' (the base of natural
     logarithms) raised to the power of `x'.

   * `log (x)'.  The function returns the natural logarithm of `x'.
     The function generates exception `edom' if `x' is negative or may
     generate `erange' if the value is zero.

   * `log10 (x)'.  The function returns the decimal logarithm of `x'.
     The function generate exception `edom' if `x' is negative or may
     generate `erange' if the value is zero.

   * `pow (x, y)'.  The function returns `x' raised to the power of
     `y'.  The function generates exception `edom' if x is negative and
     y is not integral value.

   * `sin (x)'.  The function returns the sine of `x'.

   * `cos (x)'.  The function returns the cosine of `x'.

   * `atan2 (x, y)'.  The function returns the arc tangent of the two
     variables `x' and `y'.  It is similar to calculating the arc
     tangent of `y / x', except that the signs of both arguments are
     used to determine the quadrant of the result.


File: dino.info,  Node: Pattern matching functions,  Next: File functions,  Prev: Mathematical functions,  Up: Predeclared functions

Pattern matching functions
--------------------------

   Dino has predeclared functions which are used for `pattern
matching'.  The pattern is described by `regular expressions'
(`regex').  The pattern has syntax of `extended' POSIX (1003.2) regular
expression, i.e. the pattern has the following syntax:
               Regex = Branch {"|" Branch}

   A regex matches anything that matches one of the `branches'.
               Branch = {Piece}

   A branch matches a match for the first `piece', followed by a match
for the second piece, etc.  If the pieces are omitted, the branch
matches the null string.
               Piece = Atom ("*" | "+" | "?" | Bound)
     
               Bound = "{" Min ["," [Max]] "}"
     
               Min = <unsigned integer between 0 and 255 inclusive>
     
               Max = <unsigned integer between 0 and 255 inclusive>

   An `atom' followed by `*' matches a sequence of 0 or more matches of
the atom.  An atom followed by `+' matches a sequence of 1 or more
matches of the atom.  An atom followed by `?' matches a sequence of 0
or 1 matches of the atom.

   There is more general construction (a `bound') for describing
repetitions of atom.  An atom followed by a bound containing only one
integer `min' matches a sequence of exactly `min' matches of the atom.
An atom followed by a bound containing one integer `min' and a comma
matches a sequence of `min' or more matches of the atom.  An atom
followed by a bound containing two integers `min' and `max' matches a
sequence of `min' through `max' (inclusive) matches of the atom.
               Atom = "(" Regex ")"
                    | "(" ")"
                    | "."
                    | "^"
                    | "$"
                    | BracketedList
                    | "\^"
                    | "\["
                    | "\$"
                    | "\("
                    | "\)"
                    | "\*"
                    | "\+"
                    | "\?"
                    | "\{"
                    | <any pair the first character is \ and the second is any
                       except for ^.[$()|*+? >
                    | <any character except for ^.[$()|*+? >

   Regular expression enclosed in `()' can be an atom.  In this case it
matches a match for the regular expression in the parentheses), an atom
`()' matches the null string.  Atom `.' matches any single character.
Atoms `[circ  ]' and `$' match correspondingly the null string at the
beginning of a line and the null string at the end of a line.

   Atom which is `\' followed by one of the characters `[circ
].[$()[verbar]*+?{\' matches that character taken as an ordinary
character.  Atom which is `\' followed by any other character matches
the second character taken as an ordinary character, as if the `\' had
not been present.  So you should use `\\' for matching with single `\'.
An atom which is any other single character matches that character.
It is illegal to end an regular expression with `\'.  There is an
exception which is not described by the atom syntax.  A `{'
followed by a character other than a digit is an ordinary character not
the beginning of a bound and matches character `{'.
               BracketedList = "[" List "]"
     
               List = FirstChar ["-" Char] {Char ["-" Char]}
     
               Char = <any character except for ^ - and ]>
                    | CollatingElement
     
               Char = FirstChar
                    | "^"
     
               CollatingElement = "[:" Class ":]"
     
               Class = "alnum"
                     | "alpha"
                     | "blank"
                     | "ctrl"
                     | "digit"
                     | "graph"
                     | "lower"
                     | "print"
                     | "punct"
                     | "space"
                     | "upper"
                     | "xdigit"

   An atom can be a bracket expression which is a `list' of characters
enclosed in `[]'.  Usually it is used to match practically any single
character from the list.  If the list begins with `[circ  ]', it
matches any single character (but see below) not from the rest of the
list.  If two characters in the list are separated by `-', this is
shorthand for the full `range' of characters between those two
(inclusive) in the collating sequence of ASCII codes, e.g. `[0-9]'
matches any decimal digit.  It is illegal for two ranges to share an
`endpoint', e.g. `a-c-e'.

   There are exceptions which are not described by the atom syntax which
is used to include a literal `]' in the list: make it the first
character (following a possible `[circ  ]').  To include a literal `-',
make it the first or the last character, or the second endpoint of a
range.  As you can see from the syntax, all special characters (except
for `[') described in atom lose their special significance within a
bracket expression.

   Collating element is a name of a character class enclosed in `[:'
and `:]'.  It denotes the list of all characters belonging to that
class.  Standard character class names are:
            alnum       digit       punct
            alpha       graph       space
            blank       lower       upper
            cntrl       print       xdigit

   These names stand for the character classes defined in ANSI C include
file `ctype.h'.  There is an exception not described by the syntax: a
character class can not be used as an endpoint of a range.

   There is an extension in regular expressions used by DINO and in ones
defined in Posix 1003.2: no particular limit is imposed on the length
of the regular expression.

   There are the following Dino pattern matching functions:
   * `match (regex, string)'.  The function searches for matching
     regular expression `regex' in `string'.  The both parameters
     should be strings after their implicit string conversion.  The
     matching is made according to standard POSIX 1003.2: The regular
     expression matches the substring starting earliest in the string.
     If the regular expression could match more than one substring
     starting at that point, it matches the longest.  Subexpressions
     also match the longest possible substrings, subject to the
     constraint that the whole match be as long as possible, with
     subexpressions starting earlier in the regular expression taking
     priority over ones starting later.  In other words higher-level
     subexpressions take priority over their lower-level component
     subexpressions.  Match lengths are measured in characters, not
     collating elements.  A null string is considered longer than no
     match at all.  If there is no matching, the function returns value
     `nil'.  Otherwise, the function returns new mutable vector of
     integers.  The length of the vector is `2 * (N + 1)' where `N' is
     number of atoms which are regular expressions in parentheses.  The
     first two elements are index of the first character of substring
     corresponding to all regular expression and index of the last
     character plus one.  The subsequent two elements are index of the
     first character of substring corresponding to the first atom in
     the regular expression (the atoms are ordered by their open
     parentheses) and index of the last character plus one.  And so on.
     Example: The program
                    println (match ("()(a)((a)(a))", "baaab"));

     outputs
                    [1, 4, 1, 1, 1, 2, 2, 4, 2, 3, 3, 4]

   * `rcount (regex, string[, flag])'.  The function searches number of
     different occurrences of regular expression `regex' in `string'.
     The both parameters should be strings after their implicit string
     conversion.  The third parameter is optional.  If it is present,
     it should be integer after implicit integer conversion.  If its
     value is nonzero, the substrings matched by regexp can be
     overlapped.  Otherwise, the substrings are never overlapped.  If
     the parameter is absent, the function behaves as its value were
     zero.  Example: The program
                    println (rcount ("aa", "aaaaa"));
                    println (rcount ("aa", "aaaaa", 1));

     outputs
                    2
                    4

   * `sub (regex, string, subst)'.  The function searches for matching
     regular expression `regex' in `string'.  The all parameters should
     be string after their implicit string conversion.  If there is no
     matching, the function returns value `nil'.  Otherwise, the
     function returns new mutable vector of characters in which the
     matched substring has been changed by string `subst'.  Within the
     replacement string `subst', the sequence `\n', where `n' is a
     digit from 1 to 9, may be used to indicate just the text that
     matched the `n"th atom of the regex in parentheses.  The sequence
     `\0' represents the entire matched text, as does the character
     `&'.

   * `gsub (regex, string, subst)'.  The function is analogous to
     function `sub' except for the function searches for all
     non-overlapped substrings matched with the regular expression and
     returns new mutable vector of characters in which all matched
     substrings have been changed by string `subst'.

   * `split (string [, regex])'.  The function splits `string' onto
     non-overlapped substrings separated by strings matched with the
     regular expression.  The all parameters should be strings after
     their implicit string conversion.  If the second parameter is
     omitted the value of predeclared variable `split_regex' is
     used instead of the second parameter value.  In this case the
     function may generate exception `invenvar' (corrupted value of a
     predeclared variable).  The function returns new mutable vector
     with elements which are the separated substrings.  If the regular
     expression is null string, the function returns new mutable vector
     with elements which are strings each containing one character of
     the string parameter.   Examples: The program
                    println (split ("aaa bbb ccc  ddd"));

     outputs
                    ["aaa", "bbb", "ccc", "ddd"]

     The program
                    println (split ("abcdef", ""));

     outputs
                    ["a", "b", "c", "d", "e", "f"]


   If the regular expression is incorrect, the functions generates one
of the following predeclared exceptions (see predeclared classes):
   * `ebrack'.  Regular expression has unmatched bracket.

   * `erange'.  Invalid use of range in regular expression.

   * `ectype'.  Unknown character class name in regular expression.

   * `eparen'.  Regular expression has unmatched parenthesis.

   * `esubreg'.  Invalid back reference to a subexpression in regular
     expression.

   * `eend'.  Non specific error in regular expression.

   * `eescape'.  Invalid escape sequence in regex.

   * `ebadpat'.  Invalid use of pattern operators in regular expression.

   * `esize'.  Compiled regular expression is too big.

   * `espace'.  No memory for regular expression function work.


File: dino.info,  Node: File functions,  Next: Time functions,  Prev: Pattern matching functions,  Up: Predeclared functions

File functions
--------------

   Dino has some predeclared functions working on files and directories.

* Menu:

* Functions for access to file/directory information::
* Functions for work with directories::
* Functions for work with files-::
* File output functions::
* File input functions::


File: dino.info,  Node: Functions for access to file/directory information,  Next: Functions for work with directories,  Up: File functions

Functions for access to file/directory information
..................................................

   The following predeclared functions can be used for reading file or
directory information.  The functions may generate an exception
declared in class syserror (e.g. `eaccess', `enametoolong', `enfile'
and so on) besides standard `partype', `parnumber'.  The functions
expect one parameter which should be a file instance (see predeclared
class `file') or path name of a file represented by a string (the
functions makes implicit string conversion of the parameter).  The
single exception is `isatty' which expect only a file instance.
   * `ftype (fileinstance_or_filename)'.  The function
     returns one the following characters:
        * `'f".  A regular file.

        * `'d".  A directory.

        * `'L".  A symbolic link.

        * `'c".  A character device.

        * `'b".  A block device.

        * `'p".  A fifo.

        * `'S".  A socket.

     Under some OSes the function never returns some of the characters
     (e.g. 'c' or 'b').

   * `fun (fileinstance_or_filename)'.  The function
     returns new string representing name of owner of the file
     (directory).  Under some OSes the function may return new string
     `"Unknown"' if there is no notion "owner" in the OS file system.

   * `fgn (fileinstance_or_filename)'.  Analogous to the
     previous function except for it returns new string representing
     name of group of the file (directory).  Under some OSes the
     function may return new string `"Unknown"' if there is no notion
     "group" in the OS file system.

   * `fsize (fileinstance_or_filename)'.  The function
     returns integer value which is the length in bytes of the file.

   * `fatime (fileinstance_or_filename)'.  The function
     returns integer value which is time of the last access to the file
     (directory).  The time is measured in seconds since the fixed time
     (usually since January 1, 1970).  See also `time functions'.

   * `fmtime (fileinstance_or_filename)'.  Analogous to
     the previous functions but returns time of the last modification.

   * `fctime (fileinstance_or_filename)'.  Analogous to
     the previous functions but returns time of the last change.  Here
     the change means usually changing file attributes (owner, modes
     and so on), the modification means usually changing the file
     itself.

   * `fumode (fileinstance_or_filename)'.  The function
     returns new string representing rights of owner of the file
     (directory).  The string may contain the following characters (in
     the same order if the string contains more one character):
        * `'s".  Sticky bit of the file (directory).

        * `'r".  Right to read.

        * `'w".  Right to write.

        * `'x".  Right to execute.

   * `fgmode (fileinstance_or_filename)'.  Analogous to
     the previous function except for that it returns information about
     the file (directory) group users rights and that the function
     never returns a string containing character `'s".

   * `fomode (fileinstance_or_filename)'.  Analogous to
     the previous function except for that it returns information about
     rights of all other users.

   * `isatty (fileinstance)'.  The function returns 1 if a file
     instance given as parameter is an open file connected to a
     terminal and 0 else.

   The following function can be used to change rights of the file
(directory) for different users.  The function expects two strings
(after implicit string conversions).  The first one is path name of a
file (directory).  The second one is rights.  If the string contains a
character 'r', this is right to read (see characters used to denote
different rights in description of function `fumod').  The functions
always return value `nil'.
   * `chumod (path, mode)'.  The function sets up rights for the file
     (directory) owner according to given mode.

   * `chgmod (path, mode)'.  Analogous to the previous function except
     for that it sets up rights for the file (directory) group users
     and that the function ignores character `'s".

   * `chomod (path, mode)'.  Analogous to the previous function except
     for that it sets up rights for all other users.


File: dino.info,  Node: Functions for work with directories,  Next: Functions for work with files-,  Prev: Functions for access to file/directory information,  Up: File functions

Functions for work with directories
...................................

   The following functions work with directories.  The functions may
generate an exception declared in class syserror (e.g. `eaccess',
`enametoolong', `enotdir' and so on) besides standard `partype',
`parnumber'.
   * `readdir (dirpath)'.  The function makes implicit string
     conversion of the parameter value which should be a string
     (directory path).  The function returns new mutable vector with
     elements which are strings representing names of all files and
     sub-directories (including `"."' and `".."' for the current and
     parent directory respectively) in given directory.

   * `mkdir (dirpath)'.  The function creates directory with given name
     represented by a string (the parameter value after implicit string
     conversion).  The directory has read/write/execute rights for all.
     You can change it with the aid of functions `ch*mod'.

   * `rmdir (dirpath)'.  The function returns the directory given by a
     string which is parameter value after implicit string conversion.

   * `getcwd ()'.  The function returns new string representing full
     path of the current directory.

   * `chdir (dirpath)'.  The function makes the directory given by a
     string (which is parameter value after implicit string conversion)
     the current directory.


File: dino.info,  Node: Functions for work with files-,  Next: File output functions,  Prev: Functions for work with directories,  Up: File functions

Functions for work with files-
..............................

   The following functions (besides input/output functions) work with OS
files.  The functions may generate an exception declared in class
syserror (e.g. `eaccess', `enametoolong', `eisdir' and so on) besides
standard `partype', `parnumber'.  The function `rename' can be used for
renaming a directory besides files.
   * `rename (old_path, new_path)'.  The function renames
     file (directory) given by its path name.  The old and new names
     are given by parameter values which should be strings after
     implicit string conversions.

   * `remove (file_path)'.  The function removes OS file given
     by its path name.  The file path name should be a string after
     implicit string conversion.

   * `open (file_path, mode)'.  The function opens the file for
     work in given `mode', creates new class `file' instance,
     associates the opened file to the instance, and returns the
     instance.  The parameter values should be strings after implicit
     string conversions.  The first parameter value is string
     representing the file path.  The second parameter value is string
     representing mode for work with the file (see all possible modes
     in ANSI C function `fopen' documentation).  All work with an
     opened file is made through the file instance.

   * `close (fileinstance)'.  The function closes file opened by
     function `open'.  The file is given by class `file' instance.  The
     function also removes association of the instance with the file.

   * `flush (fileinstance)'.  The function flushes any output that has
     been buffered for the opened file given by class `file' instance.

   * `popen (command, mode)'.  The function starts shell command line
     given by the first parameter value (which should be a string after
     implicit string conversion), creates a pipe, creates new class
     `file' instance, associates the pipe with the instance, and return
     the instance.  Writing to such pipe (through the class file
     instance) writes to the standard input of the command.
     Conversely, reading from the pipe reads the command's standard
     output.  After implicit string conversion the second parameter
     value should be string "r" (for reading from the pipe) or "w" (for
     writing to the pipe).  The pipe should be closed by function
     `pclose'.

   * `pclose (fileinstance)'.  The function waits for the command
     connected to a pipe to terminate.  The pipe is given by class
     `file' instance returned by function `popen'.  The function also
     removes association of the instance with the pipe.

   * `tell (fileinstance)'.  The function returns the current value of
     the file position indicator for the file (opened by function
     `open') given by class `file' instance.

   * `seek (fileinstance, offset, whence)'.  The function sets up the
     current file position indicator for the file (opened by function
     `open') given by class `file' instance.  The position is given by
     `offset' which should be an integer after implicit arithmetic
     conversion and `whence' which should be a string after implicit
     string conversion.  The first character of the string should be
     `'s", `'c", or `'e" (these characters mean that the offset is
     relative to the start of the file, the current position indicator,
     or end-of-file, respectively).


File: dino.info,  Node: File output functions,  Next: File input functions,  Prev: Functions for work with files-,  Up: File functions

File output functions
.....................

   The following functions are used to output something into opened
files.  All the functions return always value `nil'.  The functions may
generate an exception declared in class syserror (e.g. `eio', `enospc'
and so on) besides standard `partype', `parnumber'.
   * `put (...)'.  All parameters should be strings after implicit
     string conversions.  The function outputs all strings into
     standard output stream.

   * `putln (...)'.  The function is analogous to function `put' except
     for that it additionally outputs new line character after output
     of all the strings.

   * `fput (fileinstance, ...)'.  The function is analogous to function
     `put' except for that it outputs the string into opened file
     associated with class `file' instance which is the first parameter
     value.

   * `fputln (fileinstance, ...)'.  The function is analogous to
     function `fput' except for that it additionally outputs new line
     character after output of all the strings.

   * `print (...)'.  The function outputs all parameter values into
     standard output stream.  The function never makes implicit
     conversions of the parameter values.  The parameter values are
     output as they could be represented in Dino itself (e.g. character
     `'c" is output as `'c", vector `['a', 'b', 'c']' is output as
     `"abc"', vector `[10, 20]' as `[10, 20]' and so on).  As you know
     some values (functions, classes, block instances, class instances,
     threads) are not represented fully in DINO.  Such values are
     represented schematically.  For example, output `func f [lcub
     ]}.g(unique_number)' means function `f' in call of
     function (or class) `g' with given unique number and function g is
     in instance of the implicit block covering all program.  For the
     function `g', output would look like simply `func g' because there
     is only one instance of the implicit block covering all program.
     Output for instance of class `c' in function `f' looks like
     `instance {[rcub
     ].f(unique_number).c(unique_number)'.  Output for
     block instance of function `f' looks like `stack {[rcub
     ].f(unique_number)'.  Output for thread whose
     thread-function `t' is declared in function `f' looks like `thread
     unique_number {[rcub
     ].f(unique_number).t(unique_number)'.

   * `println (...)'.  The function is analogous to function `print'
     except for that it additionally outputs new line character after
     output of all parameters.

   * `fprint (fileinstance, ...)'.  The function is analogous to
     function `print' except for that it outputs the parameters into
     opened file associated with class `file' instance which is the
     first parameter value.

   * `fprintln (fileinstance, ...)'.  The function is analogous to
     function `fprint' except for that it additionally outputs new line
     character after output of all the output parameters.


File: dino.info,  Node: File input functions,  Prev: File output functions,  Up: File functions

File input functions
....................

   The following functions are used to input something from opened
files.  All the functions return always value `nil'.  The functions may
generate an exception declared in class syserror (e.g. `eio', `enospc'
and so on) and `eof' besides standard `partype', `parnumber'.
   * `get ()'.  The function reads one character from standard input
     stream and returns it.  The functions generates exception `eof' if
     the function tries to read the end of file.

   * `getln ()'.  The function reads one line from standard input
     stream and returns it as new string.  The end of line is character
     newline or end of file.  The returned string does not contain the
     newline character.  The function generates exception `eof' only
     when the file position indicator before the function call stands
     exactly on the end of file.

   * `fget (fileinstance)'.  The function is analogous to function
     `get' except for that it reads from opened file associated with
     class `file' instance which is the parameter value.

   * `fgetln (fileinstance)'.  The function is analogous to function
     `getln' except for that it reads from opened file associated with
     class `file' instance which is the parameter value.

   * `scan ()'.  The functions reads character, integer, floating point
     number, string, vector, or table and returns it as the result.
     The input values should be represented in the file as ones in Dino
     language (except for that there should be no identifiers in the
     input values and there should be no operators in the values.
     Although sign `+' and `-' is possible in integer or floating point
     represenation).  The table or vector should contains only values
     of types mentioned above.  The values in the file can be separated
     by white characters.  If there is error (e.g. unbalanced brackets
     in a vector value) in read value representation the function
     generates exception `invinput'.  The functions generates exception
     `eof' if only white characters are unread in the file.

   * `scanln ()'.  The function is analogous to function `scan' except
     for that it skips all characters until end of line or end of file
     after reading the value.  Skipping is made even if the exception
     `invinput' is generated.

   * `fscan (fileinstance)'.  The function is analogous to function
     `scan' except for that it reads from opened file associated with
     class `file' instance which is the parameter value.

   * `fscanln (fileinstance)'.  The function is analogous to function
     `scanln' except for that it reads from opened file associated with
     class `file' instance which is the parameter value.


File: dino.info,  Node: Time functions,  Next: Functions for access to process information,  Prev: File functions,  Up: Predeclared functions

Time functions
--------------

   The following functions can be used to get information about real
time.
   * `time ()'.  The function returns time in seconds since the fixed
     time (usually since January 1, 1970).

   * `strtime ([format [, time]])'.  The function returns string
     representing `time' (integer representing time in seconds since
     the fixed time) according to `format' (string).  If the format is
     not given, the value of variable `time_format' is used.  In
     this case if `time_format' value is corrupted, the function
     generates exception `invenvar'.  If the time is not given, the
     current time is used.  The format is the same as in C library
     function `strftime'.  Here the extraction from the function
     documentation.  The following format specifier can be used in the
     format.
        * `%a' - the abbreviated weekday name according to the
          current locale.

        * `%A' - the full weekday name according to the current
          locale.

        * `%%b' - the abbreviated month name according to
          the current locale.

        * `%%B' - the full month name according to the
          current locale.

        * `%%c' - the preferred date and time
          representation for the current locale.

        * `%%d' - the day of the month as a decimal number
          (range 01 to 31).

        * `%%H' - the hour as a decimal number using a
          24-hour clock (range 00 to 23).

        * `%%I' - the hour as a decimal number using a
          12-hour clock (range 01 to 12).

        * `%%j' - the day of the year as a decimal number
          (range 001 to 366).

        * `%%m' - the month as a decimal number (range 01
          to 12).

        * `%%M' - the minute as a decimal number.

        * `%%p' - either `am' or `pm' according to the
          given time value, or the corresponding strings for the
          current locale.

        * `%%S' - the second as a decimal number.

        * `%%U' - the week number of the current year as a
          decimal number, starting with the first Sunday as the first
          day of the first week.

        * `%%W' - the week number of the current year as a
          decimal number, starting with the first Monday as the first
          day of the first week.

        * `%%w' - the day of the week as a decimal, Sunday
          being 0.

        * `%%x' - the preferred date representation for
          the current locale without the time.

        * `%%X' - the preferred time representation for
          the current locale without the date.

        * `%%y' - the year as a decimal number without a
          century (range 00 to 99).

        * `%%Y' - the year as a decimal number including
          the century.

        * `%%Z' - the time zone or name or abbreviation.

        * `%%%' - a literal `%' character.


File: dino.info,  Node: Functions for access to process information,  Next: Miscellaneous functions,  Prev: Time functions,  Up: Predeclared functions

Functions for access to process information
-------------------------------------------

   There are Dino predeclared functions which are used to get
information about the current OS process (Dino interpreter which
executes the program).  Each OS processor has unique identifier and
usually OS processes are called by a concrete user and group and are
executed on behalf of the concrete user and group (so called effective
identifiers).  The following functions return such information.  On
some OSes the function may return string "Unknown" as a name if there
are notion of user and group identifiers.
   * `getpid ()'.  The function returns integer value which is process
     ID of the current OS process.

   * `getun ()'.  The function returns new string which is user name
     for the current OS process.

   * `geteun ()'.  The function returns new string which is effective
     user name for the current OS process.

   * `getgn ()'.  The function returns new string which is group name
     for the current OS process.

   * `getegn ()'.  The function returns new string which is effective
     group name for the current OS process.

   * `getgroups ()'.  The function returns new vector of strings
     (possibly empty vector) representing supplementary group names for
     the current OS process.


File: dino.info,  Node: Miscellaneous functions,  Prev: Functions for access to process information,  Up: Predeclared functions

Miscellaneous functions
-----------------------

   There are the following miscellaneous functions.
   * `max (v1, v2, ...)'.  The function searches for and returns
     maximal value between all parameters.  The parameters should be of
     integer or floating point type after implicit arithmetic
     conversions.  So the function can return integer or floating point
     number depending from the type of maximal value after the
     conversion.

   * `min (v1, v2, ...)'.  The function is analogous to the previous
     function but searches for and returns the minimal value.

   * `tolower (str)'.  The function expects that parameter `str' (after
     implicit string conversion) is a string.  The function returns new
     string `str' in which upper case letters changed by the
     corresponding lower case letters.

   * `toupper (str)'.  The function expects that parameter `str' (after
     implicit string conversion) is a string.  The function returns new
     string `str' in which lower case letters changed by the
     corresponding upper case letters.

   * `eltype (vect)'.  The function expects that the parameter value is
     a vector.  The function returns `nil' if the vector is
     heterogenous, otherwise the function returns type of the vector
     elements (type of `nil' if the vector is empty).

   * `keys (tab)'.  The function expects that the parameter value is a
     table.  The function returns new mutable vector containing all
     keys of the table.  The order of keys in the vector is undefined.

   * `context (par)'. The function returns context (see section
     `Declarations and Scope Rules') represented by a block instance or
     an object for given parameter value which should be a function, a
     class, a thread, a block instance, or an object.

   * `inside (par1, par2[, flag])'.  The function usage goal is to
     check that something declared inside something other.  If the
     third parameter value after implicit integer conversion is given
     and nonzero, it is checked with taking contexts into account.  The
     second parameter value should be a function or a class.  The first
     parameter value should be a function, a class, an object, or a
     block instance.  In the last three cases, they defines
     corresponding function, class, block.  If the function, class,
     block defined by the first parameter is declared inside function
     or class given by the second parameter, the function `inside'
     returns 1.  The function `inside' returns 1 also if function or
     class defined by the first parameter is the same as the function or
     class given by the second parameter.  Otherwise the function
     `inside' returns 0.  The following example illustrates the
     difference between checking with taking contexts into account and
     without it.
                    class c () {
                      class subc () {
                      }
                    }
                    inside (c ().subc (), c ().subc);
                    inside (c ().subc (), c ().subc, 1);

     The first call of `inside' returns 1, the second one returns 0.

   * `subv (vect, index[, length])'.  The function is used to extract a
     slice of vector elements.  The first parameter value should be a
     vector after implicit string conversion.  The second and the third
     parameter values should be integers after implicit integer
     conversion. The function extracts only element or part of the
     slice existing in the vector (so you can use any values of the
     index and the length).  If index is negative, it is considered to
     be equal to zero.  If the length is negative, the slice will
     finish on the vector end.  The function returns new vector which
     is the slice.  The result vector is immutable only when the
     original vector is immutable.

   * `del (vect, index[, length]) or del (tab, key)'.  The first form
     of the function is used to remove the vector element or the slice
     of vector elements from the mutable vector.  The second and the
     third parameter values should be integers after implicit integer
     conversion. The function removes only element or part of the slice
     existing in the vector (so you can use any values of the index and
     the length).  If index is negative, it is considered to be equal
     to zero.  If the length is negative, the slice will finish on the
     vector end.  The second form of the function is used to remove the
     element (if any) with given key from the mutable table.  The
     function generates exception `immutable' if we are trying to
     remove from an immutable vector or table.

   * `ins (vect, el[, index])'.  The function inserts element given by
     the second parameter into the vector given by the first parameter
     on the place given by the third parameter.  If the third parameter
     is not given it is believed to be zero.  The third parameter
     should be an integer after implicit integer conversion.  If the
     third parameter is negative or equal or greater than the vector
     length, the element is inserted at the end of the vector.  The
     function generates exception `immutable' if we are trying to
     insert into an immutable vector.

   * `insv (vect, vect[, index])'.  The function is analogous to the
     function `ins' but it is used for insertion of all vector elements
     into the vector given as the first parameter.  So the second
     parameter value should be a vector.

   * `cmpv (vect, vect)'.  The function makes implicit string
     conversion of the parameter values.  After that, the parameter
     values should be vectors whose the first corresponding equal
     elements should have the same type (character, integer, or
     floating point type).  The first corresponding unequal elements
     should have the same type too (the remaining elements can have
     different type).  As usually if this is not true, exception
     `partype' is generated.  The function returns 1 if the first
     unequal element value of the first vector is greater than the
     corresponding element in the second vector, -1 if less, and 0 if
     the all vector elements are equal.  If the first vector is a
     prefix of the second vector, the function returns -1.  If the
     second vector is a prefix of the first vector, the function
     returns 1.  So it is generalized lexicographical order.

   * `sort (vect[, compare_function])'.  The function returns
     new sorted vector.  The original vector given as the first
     parameter value should be a homogeneous vector whose elements are
     of character, integer, or floating point type.  If the second
     parameter is not given, standard arithmetic order (see comparison
     operators) is used.  To use special ordering, use the second
     parameter which should be a function which compares two elements
     of the vector and returns negative integer if the first parameter
     value (element) is less than the second one, positive integer if
     the first parameter value is greater than the second one, and zero
     if they are equal.

   * `exit (code)'.  The function finishes work of the interpreter with
     given code which should be integer value after implicit integer
     conversion.

   * `gc ()'.  The function forces garbage collection with heap
     compaction.  Usually Dino interpreter itself calls garbage
     collection when there are no more free memory.

   * `system (command)'.  The function executes command given by a
     string (the parameter value) in OS command interpreter.  Besides
     standard exceptions `parnumber' and `partype' the function may
     generate exceptions `noshell' and `systemfail'.

   * `srand ([seed])'.  The function sets the parameter value (after
     implicit integer conversion) as the seed for a new sequence of
     pseudo-random integers to be returned by `rand'.  These sequences
     are repeatable by calling `srand' with the same seed value.  If
     the parameter is not given, the seed will be the result of calling
     function `time'.

   * `rand ()'.  The function returns a pseudo-random integer value.
     If the function `srand' is not called before, 1 will be used as
     the seed value.

