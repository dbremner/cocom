This is dino.info, produced by makeinfo version 4.0 from
/tmp/sgmltmp.dino16841.info.2.

   \input texinfo


File: dino.info,  Node: Logical operators,  Next: Bit operators,  Up: Operators

Logical operators
-----------------

   Logical operators produce the integer result 1 which means `true' or
0 which means `false'.  Logical `or' `[verbar][verbar]' and logical
`and' `&&' are `short circuit' operators.  That means
that the second operand is evaluated depending on the result of the
first operand.  When the operands of the operators are evaluated, the
arithmetic conversion is made.

   If the first operand of logical `or' is nonzero (integer or floating
point), the result will be 1.  Otherwise, the second operand is
evaluated.  If the second operand is nonzero, the result will be 1.
Otherwise, the result will be 0.

   If the first operand of logical `and' is zero (integer or floating
point), the result will be 0.  Otherwise, the second operand is
evaluated.  If the second operand is nonzero, the result will be 1.
Otherwise, the result will be 0.

   Logical negation `!' makes impilict integer conversion of the
operand.  If the operand is zero (integer or floating point), the
result will be 1.  Otherwise, the result will be 0.

   Operator `in' checks that there is an element with the given key
(the first operand) in the given table (the second operand).  If the
element is in the table, the result will be 1.  Otherwise the result
will be 0.  If the second operand is not a table, exception `keyop' is
generated.
               Expr = Expr "||"  Expr
                    | Expr "&&"  Expr
                    | Expr in  Expr
                    | "!"  Expr

   Examples:
               !(type (i) == int && type (a) == table && i >= 0 && i < #a)
               k in t && t {k} == 0
               0.0  || another_try
               0  || another_try


File: dino.info,  Node: Bit operators,  Next: Comparison operators,  Prev: Logical operators,  Up: Operators

Bit operators
-------------

   The following operators work on integers (implicit integer conversion
is made) and return an integer result.  Operators `[verbar] [circ  ]
& [tilde ]' denote correspondingly bitwise or, bitwise exclusive
or, bitwise and, and bitwise negation of 32-bit integers.

   Operators `<< >>> >>' denote correspondingly logical left bit shift,
logical right bit shift, and arithmetic (with sign extension) right bit
shift of given number (the first operand) by given number of bits (the
second operand).  The value of the second operand must be non-negative,
otherwise the result is undefined.
               Expr = Expr "|"  Expr
                    | Expr "^"  Expr
                    | Expr "&"  Expr
                    | Expr "<<"  Expr
                    | Expr ">>"  Expr
                    | Expr ">>>"  Expr
                    | "~"  Expr

   Examples:
               (i >> shift) & mask
               i & ~mask | (value << shift) & mask
               i >>> 2
               i << 2


File: dino.info,  Node: Comparison operators,  Next: Arithmetic operators,  Prev: Bit operators,  Up: Operators

Comparison operators
--------------------

   All comparison operators return a logical value (integer 0 which
means false or integer 1 which means true).

   Operators equality `==' and inequality `!=' may make some conversion
of the operands.  If one of the two operands is string, then the string
conversion is applied to the other operand before the comparison.
Otherwise, standard arithmetic conversion is applied to the operands.
The operators do not generate exceptions (but the conversions may).
The operands are equal if they have the same type and equal values (see
section `Types and Values').

   Operator identity `===' or unidentity `!==' returns 1 if the
operands have (or not) the same value or 0 otherwise.  The operators
never generate exceptions.

   By default the arithmetic conversion is applied to the operands of
operators `< > <= >='.  There is no exception if the operands after the
conversion are of integer or floating point type.  So the operands
should be characters, integers, floating point numbers, or strings
representing integers or floating point numbers.
               Expr = Expr "=="  Expr
                    | Expr "!="  Expr
                    | Expr "==="  Expr
                    | Expr "!=="  Expr
                    | Expr "<"  Expr
                    | Expr ">"  Expr
                    | Expr "<="  Expr
                    | Expr ">="  Expr

   Examples:
               10 == 10
               10 === 10
               10 == 10.0
               10 !== 10.0
               10 <= 'c'
               p != nil
               'c' == "c"
               10 < "20.0"
               [10, 20] == [10, 20]
               [10, 20] !== [10, 20]


File: dino.info,  Node: Arithmetic operators,  Next: Miscellaneous operators,  Prev: Comparison operators,  Up: Operators

Arithmetic operators
--------------------

   The following operators return integer or floating point numbers.
Before operator execution, implicit arithmetic conversion is made on
the operands.  The binary operators `+ - * / %' denote
correspondingly integer or floating point addition, subtraction,
multiplication, division, and evaluation of remainder.  Unary operator
`-' denotes arithmetic negation.  The unary operator `+' is given for
symmetry and it returns simply the operand after the conversion.  It
can be used for conversion of a string into an integer or floating
point number.
               Expr = Expr "+"  Expr
                    | Expr "-"  Expr
                    | Expr "*"  Expr
                    | Expr "/"  Expr
                    | Expr "%"  Expr
                    | "+"  Expr
                    | "-"  Expr

   Examples:
               +"0"
               +"10."
               +"1e1"
               -i
               (value + m - 1) / m * m
               index % bound


File: dino.info,  Node: Miscellaneous operators,  Prev: Arithmetic operators,  Up: Operators

Miscellaneous operators
-----------------------

   The Dino conditional expression is analogous to the C language one.
Implicit arithmetic conversion is made for the first expression
followed by `?'.  If the value of the expression is non zero (integer
or floating point), the second expression with following `:' is
evaluated and it will be the result of the condition expression.
Otherwise, the third expression is evaluated and it becomes the result.

   The operator `[num   ]' can be applied to a vector or a table.  It
returns the length of the vector or the number of elements in the table.

   The operator `@' denotes concatenation of two vectors into a new
vector.  Before the concatenation implicit string conversion of the
operands is made.

   The remaining operators look like function calls.  Operator `type'
returns the expression type.  Never is exception generation possible
during the operator evaluation.

   The operator `char' is used to conversion of a value into a
character.  First, implicit integer conversion is applied to the
operand.  The operand should be an integer after the conversion.
Otherwise, exception `optype' will be generated.  The integer is
transformed into the character with the corresponding code.  If the
code is too big to be a character or is negative, exception `erange' is
generated.

   The operator `int' is used to conversion of a value into an integer.
Implicit integer conversion is applied to the operand.  The operand
should be an integer after the conversion.  Otherwise, exception
`optype' will be generated.  If the code is too big to be an integer,
exception `erange' is generated.

   The operator `float' is used to conversion of a value into
floating-point number.  The first, implicit arithmetic conversion is
applied to the operand.  The operand should be an integer or a
floating-point number after the conversion.  Otherwise, exception
`optype' will be generated.  If the result integer is transformed into
the corresponding floating-point number.  If the code is too big or too
small to be a floating-point number, exception `erange' is generated.

   The operator `vector' is used for conversion of a value into a
vector.  First, implicit string conversion is applied to the operand.
The optional second expression defines the format used only for the
string conversion of a character, an integer, a floating point number,
or a string.  The second parameter value should be a string after
implicit string conversion.  The format should not be given for a
table.  The first operand should be a table or a vector after
conversion.  The table is transformed into a new vector which consists
of pairs (one pair for each element in the table).  The first element
of the pair is a key of the corresponding element, and the second one
is the element itself.  The order of pairs in the result vector is
undefined.

   The operator `table' is used to conversion of a value into table.
First, string conversion is applied to the operand.  The operand should
be a vector or a table after the conversion.  The vector is transformed
into a new table whose elements are equal to the vector elements that
have integer keys equal to the corresponding vector indexes.

   If the operand of the operator `func' is a block instance of the
body of a function, it returns the corresponding function.  Otherwise,
it returns the value `nil'.  The operator never generates exceptions.

   If the operand of the operator `thread' is a thread, it returns the
corresponding thread-function.  Otherwise, it returns the value `nil'.
The operator never generates exceptions.

   If the operand of the operator `class' is an object, it returns the
object's class.  Otherwise, it returns the value `nil'.  The operator
never generates exceptions.
               Expr = Expr "?"  Expr ":" Expr
                    | "#"  Expr
                    | Expr "@"  Expr
                    | type "(" Expr ")"
                    | char "(" Expr ")"
                    | int "(" Expr ")"
                    | float "(" Expr ")"
                    | vector "(" Expr ["," Expr] ")"
                    | table "(" Expr ")"
                    | func "(" Expr ")"
                    | thread "(" Expr ")"
                    | class "(" Expr ")"

   Examples:
               i < 10 ? i : 10
               #{"a", 'b'}
               #["a", 'b']
               "concat this " @ "and this"
               type (type)
               type (10)
               char (12)
               vector  (10)
               vector  (10, "%x")
               vector ({"1":1, "2":2})
               table ([1, 2, 3, 4])
               func (context (obj))
               thread (curr_thread)
               class (c ())


File: dino.info,  Node: Executive statements,  Next: Program,  Prev: Expressions,  Up: Top

Executive statements
********************

   Statements denote actions.  There are `simple' and `compound'
statements.  Simple statements do not consist of any parts that are
statements themselves.  They are the assignment, procedure call,
return, break, continue, throw, and the wait statements.  Analogous to
the C language the last symbol of a Dino simple statement is semicolon
`;'.  Compound statements consists of parts that are statements
themselves.  They are used to express sequencing, exception handling,
conditional, and repetitive execution.

* Menu:

* Empty statement::
* Block-statement::
* Assignment statements::
* Call-statement::
* If-statement::
* For-statement::
* Foreach-statement::
* Break- and continue-statement::
* Return-statement::
* Throw-statement::
* Try-block::
* Wait-statement::


File: dino.info,  Node: Empty statement,  Next: Block-statement,  Up: Executive statements

Empty statement
===============

   There is also the empty statement in Dino.  It denotes no action.
The empty statement is included in Dino for convenience.
               ExecutiveStmt = ";"

   Example: Usage of an empty statement in a for-statement:
               for (i = 0; a[i] == 0; i++)
                 ;


File: dino.info,  Node: Block-statement,  Next: Assignment statements,  Prev: Empty statement,  Up: Executive statements

Block-statement
===============

   A block-statement is simply a block and can used to group statements
into one statement and/or describe local declarations.  For details on
how the block is executed see section `Declaration and Scope Rules'.
               ExecutiveStmt = BlockStmt
     
               BlockStmt = Block

   Example: Usage of a block-statement in a for-statement:
               sum = 0;
               for (i = 0; i < #a; i++)
                 {
                   var value = a[i];
                   if (value > 0)
                     sum += value;
                 }


File: dino.info,  Node: Assignment statements,  Next: Call-statement,  Prev: Block-statement,  Up: Executive statements

Assignment statements
=====================

   Assignment-statements are used to change variable values or element
values of a structured value which are referred through a designator
(see sub-section `Designator' in section `Expressions'.  The designator
can not denote a final variable (see section `Variable Declaration').
You can not change the element value of an immutable value (see section
`Types and Values').  In this case exception `immutable' is generated.

   A simple assignment statement looks like `Designator = Expr;'.  That
means that the expression value is assigned to variable or element of
structured type value denoted by the designator.  For the convenience
of C programmers there are also the Dino assignments `Designator op=
Expr;', `Designator++;', `++Designator;', `Designator-;', and
`-Designator;'.  They are analogous correspondingly to `Designator =
Designator op Expr;', `Designator = Designator + 1;', and `Designator =
Designator - 1;'.  The only difference is in the fact that the
designator is evaluated only once, not twice as in the analogous form.
It is important to know if you have `side effects' in the statement.
               ExecutiveStmt = Designator Assign  Expr ";"
                             | Designator ("++" | "--")  ";"
                             | ("++" | "--")  Designator ";"
               Assign = "="
                      | "*="
                      | "/="
                      | "%="
                      | "+="
                      | "-="
                      | "@="
                      | "<<="
                      | ">>="
                      | ">>>="
                      | "&="
                      | "^="
                      | "|="

   Examples:
               v = [10, 20];
               i = 1;
               i++;
               --i;
               i *= 20


File: dino.info,  Node: Call-statement,  Next: If-statement,  Prev: Assignment statements,  Up: Executive statements

Call-statement
==============

   A call-statement is used to call a function, a thread-function, or a
class.  It works analogous to the call in an expression (see
sub-section `Calls' in section `Types and Values').  The single
difference is in that a call-statement throws away the call's result.
               ExecutiveStmt = Designator ActualParameters  ";"

   Examples:
               putln ("percent=" @ percent @ "%");
               newthread ();


File: dino.info,  Node: If-statement,  Next: For-statement,  Prev: Call-statement,  Up: Executive statements

If-statement
============

   The Dino if-statement is analogous to the C language one.  First, the
expression after `if' is evaluated and arithmetic conversion is done to
it.  The value should be an integer or a floating-point number,
otherwise the exception `optype' is generated.  If the value is nonzero
the first statement is executed, otherwise the statement after `else'
is executed (if any).  The problem with `dangling else' is resolved
analogous to the C language - `else' is associated with the closest
`if'.
               ExecutiveStmt = if  "(" Expr ")" Stmt [ else Stmt ]

   Examples:
               if (i < 0) i = 0;
               if (i < j) return -1; else if (i > 0) return 1; else return 0;


File: dino.info,  Node: For-statement,  Next: Foreach-statement,  Prev: If-statement,  Up: Executive statements

For-statement
=============

   The Dino for-statement is analogous to the C language one.  The
statement is executed in the following way.
  1. Execution of the first statement in the parentheses.

  2. The expression (`for-guard') is evaluated and implicit arithmetic
     conversion is made.  The value should be an integer or a floating
     point number.  If this is not true, exception `optype' is
     generated.

  3. If the value of for-guard is nonzero, the body of the loop (the
     last statement) is executed.  Otherwise, the for-statement
     execution finishes.

  4. When the body has been executed, the second statement in the
     parentheses is executed and steps 2,3,4 (one iteration) are
     repeated.

   If the second statement is a simple statement, the statement
semicolon can be omitted.  The for-statement also can be finished by
execution of the statement `break' in the body.  The body can be
finished by execution of statement `continue'.  In this case, the
for-statement execution continues with the step 4.
               ExecutiveStmt = for  "("  Stmt ForGuardExpr ";"  Stmt ")" Stmt
     
               ForGuardExpr = [Expr]

   Examples:
               for (i = 0; i < 10; i++;) sum += v [i];
               for (i = 0; i < 10; i++) sum += v [i];
               for ({sum = 0; i = 0;} i < 10; i++) sum += v [i];


File: dino.info,  Node: Foreach-statement,  Next: Break- and continue-statement,  Prev: For-statement,  Up: Executive statements

Foreach-statement
=================

   This statement is used to execution of the foreach-statement body
(the statement) for all keys of table which is value of the expression.
The expression value should be a table.  If this is not true, exception
`keyop' is generated.  The current key value on each iteration is
assigned to the designator.  The order in which the key values are
assigned on each iteration is undefined.  One iteration can be finished
with the aid of the statement `continue' and a foreach-statement can be
finished by execution of statement `break'.
               ExecutiveStmt = for  "("  Designator in Expr ")" Stmt

   Examples:
               putln ("The table is");
               for (k in t) {
                 put ("key=");
                 print (k);
                 put (", element=");
                 println (t{k});
               }


File: dino.info,  Node: Break- and continue-statement,  Next: Return-statement,  Prev: Foreach-statement,  Up: Executive statements

Break- and continue-statement
=============================

   Statements `break' and `continue' are used correspondingly to finish
execution of the closest-containing for- or foreach-statement covering
the statement and to finish one iteration of the body of the for- or
foreach-statement.  These statement can be used only inside a for- or
foreach-statement.
               ExecutiveStmt = break ";"
                             | continue ";"

   Examples:
               for (i = 0; i < 10; i++) {
                  if (ind [i] < 0)
                    continue;
                  val = v [ind[i]];
               }
               for (i in t)
                 if (t{i} == elval)
                   break;


File: dino.info,  Node: Return-statement,  Next: Throw-statement,  Prev: Break- and continue-statement,  Up: Executive statements

Return-statement
================

   Return-statement is used to finish execution of a function, a thread,
or class block.  The statement corresponds to the closest-containing
function, thread-function, or class covering the statement, so the
return-statement can be placed only in a function, a function-thread,
or a class.  The expression in a return-statement can be given only for
functions.  In this case, the expression value will be the value of the
function call (instead of the default result value `nil').
               ExecutiveStmt = return  [ Expr ] ";"

   Examples:
               return;
               return [10, 2:0]


File: dino.info,  Node: Throw-statement,  Next: Try-block,  Prev: Return-statement,  Up: Executive statements

Throw-statement
===============

   This statement generates an exception which is given by value of the
expression.  The expression should evaluate to an object of predeclared
class `except' or an object of a class declared somewhere in
predeclared class `except'.  If this is not true, exception `optype' is
generated.  How exceptions are processed is described in the following
section.
               ExecutiveStmt = throw  Expr ";"

   Examples:
               ext except {
                 ext error {
                   class myexcept (msg) {}
                 }
               }
               throw errors.myexcept ("this is an user defined exception");


File: dino.info,  Node: Try-block,  Next: Wait-statement,  Prev: Throw-statement,  Up: Executive statements

Try-block
=========

   Exceptions can be generated by the Dino interpreter when some
conditions are not satisfied, by predeclared Dino functions, by other
OS processes, by user interruptions, or by the user with the aid of a
throw-statement.  Actually, the exceptions are represented by an object
of the predeclared class `except' or by an object of a class declared
inside the predeclared class `except'.  All predeclared exceptions are
described in the section `Predeclared Identifiers'.  To detect and
process exceptions, a try-block can be used.

   When an exception is generated, the closest-containing try-block
which is covering the statement generating the exception or currently
being executed (when this is is generated by an OS process or by an user
interruption) is searched for.  Then, expressions in the catch list
elements are processed.  The expression value in the catch list element
being currently processed should be the predeclared class `except' or a
class declared inside the predeclared class `except'.  If the
expression being processed is a class and the exception is an object of
the class or an object of a class declared inside the class, the block
corresponding to the given catch list element is executed.  If there is
no such catch expression, the closest-containing try-block covering the
current try-block is searched for and processing the exception is
repeated.  If there are no more try-blocks, the program finishes with a
diagnostic message which is dependent on the generated exception.

   Blocks corresponding to catch list elements have a predeclared
variable `e'.  When block execution starts, the variable contains the
object representing the exception.
               ExecutiveStmt = TryBlockStmt
     
               TryBlockStmt = try Block { Catch }
     
               Catch = catch  "(" ExceptClassList ")" Block
     
               ExceptClassList = Expr { "," Expr }

   Examples:
               try {
                 var ln;
                 for (;;)
                   ln = getln ();
               } catch (invcalls.eof) {
               }
               try {
                 var v = [];
                 v {1} = 0;
               } catch (except) {
                 put ("catching and propagating exception"); println (class (e));
                 throw e;
               }


File: dino.info,  Node: Wait-statement,  Prev: Try-block,  Up: Executive statements

Wait-statement
==============

   This statement is used for the synchronization of different threads
in a Dino program.  The expression can not contain a function, class, or
a thread-function call.  The thread in which the statement has been
executed waits until the expression value becomes nonzero.  The
expression value (after implicit arithmetic conversion) should be an
integer or a floating point number.  Otherwise the exception `optype'
is generated.  The important thing to know how to make synchronization
is that an assignment statement without any calls is always executed as
one transaction.
               ExecutiveStmt = wait  Expr ";"

   Examples:
               wait !empty;


File: dino.info,  Node: Program,  Next: Predeclared identifiers,  Prev: Executive statements,  Up: Top

Program
*******

   A Dino program is simply a sequence of statements.  There is a
special declaration useful for writing programs consisting of several
files or for making Dino packages.  This is the include-declaration.
Before execution of any statements all include-declarations are
replaced by files whose base names are given by the strings.  It is made
recursively, i.e.  the files themselves can contain other
include-declarations.  There should be no infinite recursion in this.
If `+' is present in the include-declaration, the file is inserted in
any case.  Without `+' the file is inserted only if it has been yet not
inserted into the block of the declaration.
               Program = StmtList
     
               IncludeDeclaration = include ["+"] STRING ";"

   Examples:

   The following program outputs the first 24 Fibonachi numbers:
               // Recursive function to compute Fibonacci numbers
               func fibonacci (n)
                 {
                    if (n <= 1) return 1;
                    return (fibonacci(n-1) + fibonacci(n-2));
                 }
     
               var i, fibnum;
     
               fibnum = 0;
               for (i = 0; i <= 24; i++)
                 {
                   fibnum = fibonacci(i);
                   putln (i @ " " @ fibnum);
                 }

   The following program outputs the number of prime numbers less than
8190:
               var i, prime, k, count, flags;
               var final SieveSize = 8190;
     
               flags = [SieveSize + 1 : 0];
               count = 0;
               for (i = 0; i <= SieveSize; i++)
                 flags[i] = 1;
               for (i = 0; i <= SieveSize; i++)
                 if (flags[i])
                   {
                     prime = i + i + 3;
                     k = i + prime;
                     for (;1;;)
                       {
                           if (k > SieveSize)
                           break;
                         flags[k] = 0;
                         k += prime;
                       }
                     count++;
                   }
               println (count);

   The following program outputs the number of occurrences of different
numbers and identifiers in stdin:
               var i, key, voc = {};
               for (;;)
                 try {
                   var ln, a;
     
                   ln = getln ();
                   if (ln == "")
                     continue;
                   a = split (ln, "[^[:alnum:]]");
                   for (i = 0; i < #a; i++)
                     voc {a[i]} = (a[i] in voc ? voc {a[i]} + 1 : 1);
                 } catch (invcalls.eof) {
                   break;
                 }
               func comp (el1, el2) {
                 return cmpv (tolower (el1), tolower (el2));
               }
               key = sort (keys (voc), comp);
               for (i = 0; i < #key; i++)
                 putln (key[i], " : ", voc{key[i]});

   The following program uses the Dino package `mpi':
               include "mpi";
               var mpi1, mpi2;
               mpi1 = mpis.from_string(50, "1000000000000000000000000000000000000");
               mpi2 = mpis.from_string(50, "5000000000000000000000000000000000000");
               putln (mpis.to_string (mpis.add (mpi1, mpi2)));


File: dino.info,  Node: Predeclared identifiers,  Next: Appendix A- Syntax of Dino,  Prev: Program,  Up: Top

Predeclared identifiers
***********************

   Dino has quite a lot of predeclared identifiers.  The section
`Declarations and Scope Rules' contains them in alphanumeric order.
Here they are described according to the declaration category which
they belongs to.

* Menu:

* Predeclared variables::
* Predeclared classes::
* Predeclared functions::


File: dino.info,  Node: Predeclared variables,  Next: Predeclared classes,  Up: Predeclared identifiers

Predeclared variables
=====================

   Dino has some predeclared variables which contain useful information
or can be used to control the behaviour of the Dino interpreter.

* Menu:

* Arguments and environment::
* Version::
* Threads::
* Exceptions::
* Files::
* Miscellaneous variables::


File: dino.info,  Node: Arguments and environment,  Next: Version,  Up: Predeclared variables

Arguments and environment
-------------------------

   To access arguments to the program and the environment, the following
variables can be used:
   * `argv'.  The variable value is an immutable vector whose elements
     are strings (immutable vectors of characters) representing
     arguments to the program (see implementation).

   * `env'.  The variable value is immutable table whose elements are
     strings (immutable vectors of characters) representing values of
     environment variables whose names are the keys of the table.


File: dino.info,  Node: Version,  Next: Threads,  Prev: Arguments and environment,  Up: Predeclared variables

Version
-------

   As Dino is a live programming language, it and its interpreter are in
the process of permanent development.  To access the Dino interpreter's
version number and consequently the language version, the final variable
`version' can be used.  The variable value is the Dino version as a
floating point number.  For example, if the current Dino version is
0.54, the variable value will be 0.54.


File: dino.info,  Node: Threads,  Next: Exceptions,  Prev: Version,  Up: Predeclared variables

Threads
-------

   To access some information about threads in Dino program, the
following variables can be used.
   * `main_thread'.  The variable value is the main thread.
     When the program starts, there is only one thread which is called
     `the main thread'.

   * `curr_thread'.  The variable value is the thread in which
     you reference the variable.

   All these variables are final, so you can not change their values.


File: dino.info,  Node: Exceptions,  Next: Files,  Prev: Threads,  Up: Predeclared variables

Exceptions
----------

   When it is necessary to create an exception which is a object of a
class declared inside class `except' or when it is necessary to refer
to a class inside class `except', the following variables can be used.
Instead of typing `catch (except().signal().sigint)', you could type
`catch (signals.sigint)'.
   * `excepts'.  The variable value is an object of the class `except'.

   * `errors'.  The variable value is an object of the class
     `excepts.error'.

   * `signals'.  The variable value is an object of the class
     `errors.signal'.

   * `invops'.  The variable value is an object of the class
     `errors.invop'.

   * `invindexes'.  The variable value is an object of the class
     `errors.invindex'.

   * `invkeys'.  The variable value is an object of the class
     `errors.invkey'.

   * `invcalls'.  The variable value is an object of the class
     `errors.invcall'.

   * `syserrors'.  The variable value is an object of the class
     `invcalls.syserror'.

   * `systemcalls'.  The variable value is an object of the class
     `invcalls.systemcall'.

   * `invparsers'.  The variable value is an object of the class
     `invcalls.invparser'.

   * `invregexps'.  The variable value is an object of the class
     `invcalls.invregexp'.

   * `invexterns'.  The variable value is an object of the class
     `invcalls.invextern'.

   * `invaccesses'.  The variable value is an object of the class
     `errors.invaccess'.

   All these variables are final, so you can not change their values.


File: dino.info,  Node: Files,  Next: Miscellaneous variables,  Prev: Exceptions,  Up: Predeclared variables

Files
-----

   To output something into standard streams or to input something from
the standard input stream, the following variables can be used:
   * `stdin'.  The variable value is an object of the class `file'
     which corresponds to the standard input stream.

   * `stdout'.  The variable value is an object of the class `file'
     which corresponds to the standard output stream.

   * `stderr'.  The variable value is an object of the class `file'
     which corresponds to the standard error stream.

   All these variables are final, so you can not change their values.


File: dino.info,  Node: Miscellaneous variables,  Prev: Files,  Up: Predeclared variables

Miscellaneous variables
-----------------------

   Values of the following variables are used by some predeclared
functions:
   * `split_regex'.  The variable value is a string which
     represents regular expression which is used by the predeclared
     function `split' when the second parameter is not given.  The
     initial value of the variable is string `"[ \t]+"'.

   * `time_format'.  The variable value is a string which is the
     output format of time used by the function `strtime' when it is
     called without parameters.  The initial value of the variable is
     the string `"%a %b %d
     %H:%M:%S %Z %Y"'.


File: dino.info,  Node: Predeclared classes,  Next: Predeclared functions,  Prev: Predeclared variables,  Up: Predeclared identifiers

Predeclared classes
===================

   The most of the predeclared classes describe exceptions which may be
generated in Dino program.

* Menu:

* File::
* Exception classes::
* Earley parser classes::


File: dino.info,  Node: File,  Next: Exception classes,  Up: Predeclared classes

File
----

   Dino has predeclared final class `file'.  Work with files in Dino
program are made through objects of the class.  All declarations inside
of class are private.  The objects of the class can be created only by
predeclared functions `open' or `popen'.  If you create an object of
the class by calling the class, exception `callop' will be generated.


File: dino.info,  Node: Exception classes,  Next: Earley parser classes,  Prev: File,  Up: Predeclared classes

Exception classes
-----------------

   All Dino exceptions are represented by objects of the predeclared
class `except' or of a class in the class `except'.  The class `except'
has no parameters, therefore all arguments in calling the class will be
ignored.  There is one predeclared class `error' inside class `except'.
All classes corresponding to user-defined exceptions are suggested to
be declared in class `except' not in the class `error' because all
other exceptions (e.g. generated by the Dino interpreter itself or by
predeclared functions) are objects of the class `error' or predeclared
classes inside the class `error'. The class `error' and all classes
inside the class has one parameter `msg' which contains a readable
message about the exception.  The following classes are declared in the
class `error':
   * `signal'.  Classes inside this class describe exceptions from
     receiving a signal from other OS processes.  They are
        * `sigint'.  This class describes the exception generated by
          the user's interrupt from the keyboard.

        * `sigill'.  This class describes the exception generated by
          illegal execution of an instruction .

        * `sigabrt'.  This class describes the exception generated by
          the signal abort.

        * `sigfpe'.  This class describes floating point exception.

        * `sigterm'.  This class describes the exception generated by
          the termination signal.

        * `sigsegv'.  This class describes the exception generated by
          an invalid memory reference.

   * `invenv'.  This class describes corruption of the Dino program
     environment (see predeclared variable `env').

   * `invop'.  Classes inside this class describe exceptions when
     operands of operations have an incorrect type or value.
        * `optype'.  This class describes that the operand of an
          operation is not of the required type (possibly after
          implicit conversions).

        * `opvalue'.  This class is reserved for the error of that an
          operand of an operation has invalid value.  Now this
          exception is not generated.

   * `invindex'.  Classes inside this class describe exceptions in
     referring for a vector element.
        * `indextype'.  This class describes that the index is not of
          integer type (possibly after implicit integer conversion).

        * `indexvalue'.  This class describes that the index is
          negative or equal to or more than the vector length.

        * `indexop'.  This class describes that the first operand in
          referring to a vector element is not a vector.

   * `invkey'.  Classes inside this class describe exceptions in
     referring to a table element.
        * `keyvalue'.  This class describes that there is no such
          element in the table with the given key when we need the
          value of the element.  The exception does not occur when a
          table element reference stands in the left hand side of an
          assignment-statement.

        * `keyop'.  This class describes that the first operand in
          referring to a table element is not a table.

   * `invcall'.  Classes inside this class describe exceptions in
     calling functions (mainly predeclared ones).
        * `callop'.  This class describes that we try to call something
          which is not a function, class, or thread-function.  The
          exception is also generated when you try to create a class
          `file' instance by calling the class.

        * `partype'.  This class describes that a parameter value of a
          predeclared function is not of required type.

        * `invresult'.  This class describes that the result value of
          function call is not of required type, e.g. comparison
          function used in a call to function `sort' returns a non
          integer value.

        * `invinput'.  This class describes that the file input is not
          of required format.  Usually the exception is generated by
          function `scan' etc.

        * `eof'.  This class describes that end of file is encountered.
          Usually the exception is generated by functions reading
          files (`get', `scan' etc).

        * `parnumber'.  This class describes that the number of actual
          parameters is not valid when we call a predeclared function.

        * `syserror'.  Classes inside this class describe exceptions in
          predeclared functions which call OS system functions.  Some
          exceptions are never generated but may be generated in the
          future on some OSes.
             * `eaccess'.  This describes the system error "Permission
               denied".

             * `eagain'.  This describes the system error "Resource
               temporarily unavailable".

             * `ebadf'.  This describes the system error "Bad file
               descriptor".

             * `ebusy'.  This describes the system error "Resource
               busy".

             * `echild'.  This describes the system error "No child
               processes".

             * `edeadlk'.  This describes the system error "Resource
               deadlock avoided".

             * `edom'.  This describes the system error "Domain error".

             * `eexist'.  This describes the system error "File exists".

             * `efault'.  This describes the system error "Bad address".

             * `efbig'.  This describes the system error "File too
               large".

             * `eintr'.  This describes the system error "Interrupted
               function call".

             * `einval'.  This describes the system error "Invalid
               argument".

             * `eio'.  This describes the system error "Input/output
               error".

             * `eisdir'.  This describes the system error "Is a
               directory".

             * `emfile'.  This describes the system error "Too many
               open files".

             * `emlink'.  This describes the system error "Too many
               links".

             * `enametoolong'.  This describes the system error
               "Filename too long".

             * `enfile'.  This describes the system error "Too many
               open files in system".

             * `enodev'.  This describes the system error "No such
               device".

             * `enoent'.  This describes the system error "No such file
               or directory".

             * `enoexec'.  This describes the system error "Exec format
               error".

             * `enolck'.  This describes the system error "No locks
               available".

             * `enomem'.  This describes the system error "Not enough
               space".

             * `enospc'.  This describes the system error "No space
               left on device".

             * `enosys'.  This describes the system error "Function not
               implemented".

             * `enotdir'.  This describes the system error "Not a
               directory".

             * `enotempty'.  This describes the system error "Directory
               not empty".

             * `enotty'.  This describes the system error
               "Inappropriate I/O control operation".

             * `enxio'.  This describes the system error "No such
               device or address".

             * `eperm'.  This describes the system error "Operation not
               permitted".

             * `epipe'.  This describes the system error "Broken pipe".

             * `erange'.  This describes the system error "Result too
               large".

             * `erofs'.  This describes the system error "Read-only
               file system".

             * `espipe'.  This describes the system error "Invalid
               seek".

             * `esrch'.  This describes the system error "No such
               process".

             * `exdev'.  This describes the system error "Improper
               link".

        * `systemcall'.  Classes inside this class describe exceptions
          in calling the predeclared function `system'.
             * `noshell'.  This class describes the exception that the
               function `system' can not find the OS command
               interpreter (the shell).

             * `systemfail'.  This class describes all remaining
               exceptions in calling the OS function `system'.

        * `invparser'.  Classes inside this class describe exceptions
          specific for calling functions of the predeclared class
          `parser' implementing the Earley parser.
             * `invgrammar'.  This class describes the exception that
               the Earley parser got a bad grammar, e.g. without rules,
               with loops in rules, with nonterminals unachievable from
               the axiom, with nonterminals not deriving any terminal
               string etc.

             * `invtoken'.  This class describes the exception that the
               parser got an input token with unknown (undeclared) code.

             * `pmemory'.  This class describes the exception that
               there is not enough memory for internal parser data.

        * `invregexp'.  Classes inside this class describe exceptions
          specific for calling predeclared functions implementing
          regular expression pattern matching.
             * `ebrack'.  This class describes the exception that a
               regular expression has an unmatched bracket.

             * `erange'.  This class describes the exception that there
               is an invalid use of range in regular expression.

             * `ectype'.  This class describes the exception that there
               is an unknown character class name in regular expression.

             * `eparen'.  This class describes the exception that a
               regular expression has an unmatched parenthesis.

             * `esubreg'.  This class describes the exception that
               there is an invalid back reference to a subexpression in
               a regular expression.

             * `eend'.  This class describes the exception that there
               is a non specific error in regular expression.

             * `eescape'.  This class describes the exception that
               there is a trailing backslash.

             * `badpat'.  This class describes the exception that there
               is invalid use of pattern operators in a regular
               expression.

             * `esize'.  This class describes exception that the
               compiled regular expression is too big.

             * `espace'.  This class describes the exception that there
               is no memory for a regular expression function to work.

        * `invextern'.  Classes inside this class describe exceptions
          in calling external functions or in accessing an external
          variable.
             * `noextern'.  This class describes the exception that the
               given external can not be find.

             * `libclose'.  This class describes the exception that
               there is an error in closing a shared library.

             * `noexternsupp'.  This class describes an exception in
               the usage of externals when they are not implemented
               under this OS.

        * `invenvar'.  This class describes corruption in the type of
          variables `split_regex' and `time_format' (e.g.
          their values are not strings).

        * `internal'.  This class describes all other (nonspecified)
          exceptions in calling predeclared functions.


File: dino.info,  Node: Earley parser classes,  Prev: Exception classes,  Up: Predeclared classes

Earley parser classes
---------------------

   Dino has the three following classes which are used by the Earley
parser embedded into the Dino interpreter.

* Menu:

* Parser-::
* Token-::
* Anode-::
* Nil_anode and error_anode-::
* Example of Earley parser usage-::

