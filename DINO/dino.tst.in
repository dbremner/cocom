#!/bin/sh

#
# Script to test of DINO.
#
# Copyright (C) 1997-2013 Vladimir Makarov.
# 
# Written by Vladimir Makarov <vmakarov@users.sourceforge.net>
# 
# This file is part of interpreter of DINO.
# 
# This is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
# 
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with GNU CC; see the file COPYING.  If not, write to the Free
# Software Foundation, 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.
#
#
# Usage: dino.tst [start_test_number [build by MSVC]] 
#
# The script outputs self-explanatory messages and returns zero exit code if 
# it is all ok.
#

DINO=./dino
script_file=$0
test_file=test.d
test_file_1=test1.d
stderr=_stderr.out
stdout=_stdout.out
ftemp=_temp.out
ftemp2=_temp2.out
tempdir=__tempdir
result=ok

if uname | fgrep CYGWIN; then
   CMP="eval sh -c 'tr -d \\\\r <\$0 >__tmp && mv __tmp \$0 && tr -d \\\\r <\$1 >__tmp && mv __tmp \$1 && cmp \$0 \$1'"
   SCMP="eval sh -c 'tr -d \\\\r <\$0 >__tmp && mv __tmp \$0 && cmp \$0 \$1'"
else
   CMP=cmp
   SCMP=cmp
fi

if test x$1 = x
then
    start_test_number=1
else
    if expr $1 + 0 >/dev/null
    then
        start_test_number=`expr $1 + 0`
    else
        echo $script_file:invalid argument $1 2>&1
        exit 1
    fi
fi

if test x$2 = x
then
    msvc=
else
    msvc=yes
fi

# Test 1.
if test $result = ok -a $start_test_number -le 1; then
	echo test 1
        cat >$test_file <<'TEST1'
var i;
i = 0;
i++;
TEST1
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        else
                result=fail
        fi
fi


# Test 2.
if test $result = ok -a $start_test_number -le 2; then
	echo test 2
        cat >$test_file <<'TEST2'
var i;
for (i = 0; i < 100000; i++);
TEST2
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        else
                result=fail
        fi
fi

# Test 3.
if test $result = ok -a $start_test_number -le 3; then
	echo test 3
        cat >$test_file <<'TEST3'
func f {}
var i;
for (i = 0; i < 100000;i++)
 f ();
TEST3
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        else
                result=fail
        fi
fi

# Test 4.
if test $result = ok -a $start_test_number -le 4; then
	echo test 4
        cat >$test_file <<'TEST4'
func f {
  {
    return 10;
  }
}

var i;
i = f ();
println (i);
TEST4
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT4' && $CMP $stdout $ftemp2; then
10
OUTPUT4
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 5.
if test $result = ok -a $start_test_number -le 5; then
	echo test 5
        cat >$test_file <<'TEST5'
func f {}
class c {}

putln ("0:", "abc" === "abc");
putln ("1:", 'c' === 'c');
putln ("1:", 10 === 10);
putln ("1:", 10.5 === 10.5);
	   
putln ("1:", f === f);
putln ("0:", f === c);
putln ("1:", c === c);
putln ("0:", c() === c());
	   
putln ("0:", 10 === "10");
putln ("0:", 10.5 === "10.5");
putln ("0:", 'c' === "c");

var op;
op = "abc";
putln ("0:", op === "abc");
op = 'c';
putln ("1:", op === 'c');
op = 10;
putln ("1:", op === 10);
op = 10.5;
putln ("1:", op === 10.5);

op = f;
putln ("1:", op === f);
putln ("0:", f === c);
op = c();
putln ("0:", op === c());
putln ("1:", op === op);

op = 10;
putln ("0:", op === "10");
op = 10.5;
putln ("0:", op === "10.5");
op = 'c';
putln ("0:", op === "c");
op = "abc";
putln ("0:", op === "abc");
TEST5
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT5' && $CMP $stdout $ftemp2; then
0:0
1:1
1:1
1:1
1:1
0:0
1:1
0:0
0:0
0:0
0:0
0:0
1:1
1:1
1:1
1:1
0:0
0:0
1:1
0:0
0:0
0:0
0:0
OUTPUT5
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 6.
if test $result = ok -a $start_test_number -le 6; then
	echo test 6
        cat >$test_file <<'TEST6'
func f {}
putln ("0:", f === 10);
TEST6
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT6' && $CMP $stdout $ftemp2; then
0:0
OUTPUT6
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 7.
if test $result = ok -a $start_test_number -le 7; then
	echo test 7
        cat >$test_file <<'TEST7'
class c {}
putln ("0:", c === 10);
TEST7
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT7' && $CMP $stdout $ftemp2; then
0:0
OUTPUT7
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 8.
if test $result = ok -a $start_test_number -le 8; then
	echo test 8
        cat >$test_file <<'TEST8'
class c {}
putln ("0:", c () === 10);
TEST8
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT8' && $CMP $stdout $ftemp2; then
0:0
OUTPUT8
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 9.
if test $result = ok -a $start_test_number -le 9; then
	echo test 9
        cat >$test_file <<'TEST9'
var i = nil;
putln ("1:", i == nil);
putln ("0:", i != nil);
putln ("1:", i === nil);
putln ("0:", i !== nil);
func f {}
try {putln ("1:", f () == nil);}
catch (invops.optype) {putln ("1:1");}
func g {return;}
try {putln ("1:", f () == nil);}
catch (invops.optype) {putln ("1:1");}
var t;
t = {"e"};
putln ("1:", t{"e"} == nil);
TEST9
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT9' && $CMP $stdout $ftemp2; then
1:1
0:0
1:1
0:0
1:1
1:1
1:1
OUTPUT9
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 10.
if test $result = ok -a $start_test_number -le 10; then
	echo test 10
        cat >$test_file <<'TEST10'
var i;
i = 10 + "aaa";
i = 10 @ "aaa";
i = 10 == "aaa";
TEST10
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST10-1'; then
test.d:2:8: system error - invalid argument: `string-to-float conversion'
TEST10-1
                result=ok
        else
                result=fail
        fi
fi

# Test 11.
if test $result = ok -a $start_test_number -le 11; then
	echo test 11
        cat >$test_file <<'TEST11'
func f {putln ("eval false");return 0;}
func t {putln ("eval true");return 1;}

var i;
putln ("++test false and true");
i = f() && t ();
putln ("++test true and true");
i = t() && t ();
putln ("++test true or true");
i = t() || t ();
putln ("++test false or true");
i = f() || t ();
putln ("++conditional: f ? t : f");
i = f() ? t () : f ();
putln ("++conditional: t ? t : f");
i = t() ? t () : f ();
TEST11
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT11' && $CMP $stdout $ftemp2; then
++test false and true
eval false
++test true and true
eval true
eval true
++test true or true
eval true
++test false or true
eval false
eval true
++conditional: f ? t : f
eval false
eval false
++conditional: t ? t : f
eval true
eval true
OUTPUT11
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 12.
if test $result = ok -a $start_test_number -le 12; then
	echo test 12
        cat >$test_file <<'TEST12'
func fact (x)
{
  if (x <= 1)
    return 1;
  return x * fact (x-1);
}

var i, x;

for (i = 0; i < 1000; i++)
  x = fact (12);

putln (x);
TEST12
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT12' && $CMP $stdout $ftemp2; then
479001600
OUTPUT12
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 13.
if test $result = ok -a $start_test_number -le 13; then
	echo test 13
        cat >$test_file <<'TEST13'
putln ("length of abcd - ", #"abcd");
TEST13
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT13' && $CMP $stdout $ftemp2; then
length of abcd - 4
OUTPUT13
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 14.
if test $result = ok -a $start_test_number -le 14; then
	echo test 14
        cat >$test_file <<'TEST14'
var s, ns, t;
s = "aaaa";
ns = new s;
ns[1] = "b";
println (s,ns);

s = {"a"};
ns = new s;
ns{"a"} = "b";
println (s,ns);

s = ['a'];
t = {s:"a"};
ns = new s;
ns[0] = 'b';
println (s, ns);

class c()
{
  var i = nil;
}
var o, no;
o = final c ();
no = new o;
no.i = 10;
println (o.i, no.i);

s = "10" @ new "10";
s[0] = 'c';
TEST14
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT14' && $CMP $stdout $ftemp2; then
"aaaa"['a', "b", 'a', 'a']
{"a":nil}{"a":"b"}
"a""b"
nil10
OUTPUT14
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 15.
if test $result = ok -a $start_test_number -le 15; then
	echo test 15
        cat >$test_file <<'TEST15'
var i;
for (i = 0.0; i < 100000.0; i = i + 1.0);
TEST15
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT15' && $CMP $stdout $ftemp2; then
OUTPUT15
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 16.
if test $result = ok -a $start_test_number -le 16; then
	echo test 16
        cat >$test_file <<'TEST16'
func tak (x, y, z)
  {
    if (y >= x)
        return z;
    else
        return tak (tak (x-1, y, z), tak (y-1, z, x), tak (z-1, x, y));
  }
putln (tak(18, 12, 6));
TEST16
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT16' && $CMP $stdout $ftemp2; then
7
OUTPUT16
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 17.
if test $result = ok -a $start_test_number -le 17; then
	echo test 17
        cat >$test_file <<'TEST17'
var i, t;
t = {"e":10, 10:11};
putln (t{"e"});
putln (t{10});
putln ("e in t - 1:", "e" in t);
putln ("10 in t - 1:", 10 in t);
putln ("11 in t - 0:", 11 in t);
t = {"e":10, "f":11, "g":12, "h":13};
for (i in t) putln (i);
t = {"e", "f", "g", "h"};
for (i in t) putln (i);
TEST17
        echo '      ' $DINO $test_file "2>$stderr" ">$ftemp2" '&&' sort $ftemp2 ">$stdout"
        if $DINO $test_file 2>$stderr >$ftemp2 && sort $ftemp2 >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT17' && $CMP $stdout $ftemp2; then
10
10 in t - 1:1
11
11 in t - 0:0
e
e
e in t - 1:1
f
f
g
g
h
h
OUTPUT17
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 18.
if test $result = ok -a $start_test_number -le 18; then
	echo test 18
        cat >$test_file <<'TEST18'
var t;
t = {};
t{"e"} = 10;
t{10} = 11;
putln (t{"e"});
putln (t{10});
TEST18
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT18' && $CMP $stdout $ftemp2; then
10
11
OUTPUT18
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 19.
if test $result = ok -a $start_test_number -le 19; then
	echo test 19
        cat >$test_file <<'TEST19'
var i, v, pv;

v = [100:0, 100:'c'];
for (i = 0; i < 1000;i++)
{
  v = [100:10.0];
  v[50] = 'c';
  v[50] = 10.0;
  pv = v;
}
TEST19
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT19' && $CMP $stdout $ftemp2; then
OUTPUT19
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 20.
if test $result = ok -a $start_test_number -le 20; then
	echo test 20
        cat >$test_file <<'TEST20'
class c(p) {
  var i;
  i = 1;
  func f {putln ("i=", i);}
  func g {putln ("p=", p);}
  func f1 (i) {putln ("i=", i);}
  func g1 (p) {putln ("p=", p);}
}
var i;
i = c(10);
i.f();
i.g();
i.f1(100);
i.g1(1000);
TEST20
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT20' && $CMP $stdout $ftemp2; then
i=1
p=10
i=100
p=1000
OUTPUT20
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 21.
if test $result = ok -a $start_test_number -le 21; then
	echo test 21
        cat >$test_file <<'TEST21'
class c(p) {
  var i;
  class cc(p) {
    func f {putln (p);}
  }
  i = 10;
}
var j,k;
j = c(10);
k = j.cc(100);
k.f();


TEST21
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT21' && $CMP $stdout $ftemp2; then
100
OUTPUT21
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 22.
if test $result = ok -a $start_test_number -le 22; then
	echo test 22
        cat >$test_file <<'TEST22'
var a, i;
for (i = 0; i < 10; i++)
  a = [5:2];
TEST22
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT22' && $CMP $stdout $ftemp2; then
OUTPUT22
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 23.
if test $result = ok -a $start_test_number -le 23; then
	echo test 23
        cat >$test_file <<'TEST23'
var v;
var i;
i = 3;
v = [5 : 7, i:8];
for (i = 0; i< #v; i = i + 1)
  putln (v[i]);
TEST23
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT23' && $CMP $stdout $ftemp2; then
7
7
7
7
7
8
8
8
OUTPUT23
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 24.
if test $result = ok -a $start_test_number -le 24; then
	echo test 24
        cat >$test_file <<'TEST24'
putln ("0:", '\n' === 10.0);
putln ("0:", 10 === 10.0);
putln ("0:", "10" === 10.0);
putln ("0:", "10.0" === 10.0);
putln ("0:", "aaaaa" === [5:'a', '\0']);
TEST24
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT24' && $CMP $stdout $ftemp2; then
0:0
0:0
0:0
0:0
0:0
OUTPUT24
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 25.
if test $result = ok -a $start_test_number -le 25; then
	echo test 25
        cat >$test_file <<'TEST25'
func f (args)
{
}

func g (a)
{
  var args;
}

func t (a, ...)
{
  var i;

  putln ("****");
  if (a !== nil)
    putln ("a = ", a);
  for (i = 0; i<#args;i++)
    putln ("args[", i, "]=", args[i]);
}

t (10);
t (10, 1);
t (10, 1, 2);
t (10, 1, 2, 3);
TEST25
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT25' && $CMP $stdout $ftemp2; then
****
a = 10
****
a = 10
args[0]=1
****
a = 10
args[0]=1
args[1]=2
****
a = 10
args[0]=1
args[1]=2
args[2]=3
OUTPUT25
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 26.
if test $result = ok -a $start_test_number -le 26; then
	echo test 26
        cat >$test_file <<'TEST26'
func f {}
class c {}

putln ("1:", "10" == "10");
putln ("1:", 10 == 10);
putln ("1:", 10.5 == 10.5);
putln ("1:", 'c' == 'c');
	  
putln ("1:", 10 == 10.0);
putln ("1:", 99 == 'c');
putln ("1:", 99.0 == 'c');
	  
putln ("1:", 10 == "10");
putln ("1:", 10.5 == "10.5");
putln ("1:", 'c' == "c");
	  
putln ("1:", f == f);
putln ("1:", c == c);
putln ("1:", c() == c());

var op;
op = 10;
putln ("1:", op == "10");
op = 10.5;
putln ("1:", op == "10.5");
op = 'c';
putln ("1:", op == "c");
TEST26
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT26' && $CMP $stdout $ftemp2; then
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
OUTPUT26
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 27.
if test $result = ok -a $start_test_number -le 27; then
	echo test 27
        cat >$test_file <<'TEST27'
func f {}
var r;
r = f == 10;
putln ("0:", r);
TEST27
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT27' && $CMP $stdout $ftemp2; then
0:0
OUTPUT27
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 28.
if test $result = ok -a $start_test_number -le 28; then
	echo test 28
        cat >$test_file <<'TEST28'
class c {}
var r;
r = c == 10;
putln ("0:", r);
TEST28
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT28' && $CMP $stdout $ftemp2; then
0:0
OUTPUT28
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 29.
if test $result = ok -a $start_test_number -le 29; then
	echo test 29
        cat >$test_file <<'TEST29'
class c {}
var r;
r = c () == 10;
putln ("0:", r);
TEST29
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT29' && $CMP $stdout $ftemp2; then
0:0
OUTPUT29
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 30.
if test $result = ok -a $start_test_number -le 30; then
	echo test 30
        cat >$test_file <<'TEST30'
class c (p) {
  putln ("p = ", p);
};

c(10);
TEST30
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT30' && $CMP $stdout $ftemp2; then
p = 10
OUTPUT30
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 31.
if test $result = ok -a $start_test_number -le 31; then
	echo test 31
        cat >$test_file <<'TEST31'
class c (p, ...)
{
  var i;
  putln ("p = ", p);
  for (i = 0; i < #args; i++)
    putln (args[i]);
}

c (10, 11, 12, 13);
TEST31
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT31' && $CMP $stdout $ftemp2; then
p = 10
11
12
13
OUTPUT31
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 32.
if test $result = ok -a $start_test_number -le 32; then
	echo test 32
        cat >$test_file_1 <<'TEST32'
var i;
i = 8;
TEST32
        cat >$test_file <<'TEST32-1'
include "test1";
putln (i);
TEST32-1
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT32' && $CMP $stdout $ftemp2; then
8
OUTPUT32
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 33.
if test $result = ok -a $start_test_number -le 33; then
	echo test 33
        cat >$test_file <<'TEST33'
// vector
var v;
// pack
v = [1, 2, 3, 5, 6]; ins (v, 4, 3); println (v);
v = [2, 3, 4, 5, 6]; ins (v, 1); println (v);
v = [1, 2, 3, 4, 5]; ins (v, 6, -1); println (v);
v = [2, 3, 4, 5, 6]; ins (v, 1, 0); println (v);
// unpack
v = [1.0, 2, 3, 5, 6]; ins (v, 4, 3); println (v);
v = [2.0, 3, 4, 5, 6]; ins (v, 1); println (v);
v = [1.0, 2, 3, 4, 5]; ins (v, 6, -1); println (v);
v = [2.0, 3, 4, 5, 6]; ins (v, 1, 0); println (v);
// empty
v = []; ins (v, nil); println (v);
v = []; ins (v, nil, -1); println (v);
v = []; ins (v, nil, 0); println (v);
v = []; ins (v, nil, 10); println (v);
// string
v = new "123456"; ins (v, 2); println (v);
v = new "123456"; ins (v, "+++"); println (v);
v = new "123456"; ins (v, "+++", -1); println (v);
v = new "123456"; ins (v, "+++", 100); println (v);
//
var i, iter;
for (iter = 0; iter < 10000; iter++)
  { 
    v = [];
    for (i = 0; i < 100; i++)
      ins (v, 1);
    for (i = 0; i < 100; i++)
      del (v, 0);
  }
println (v);
TEST33
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT33' && $CMP $stdout $ftemp2; then
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[nil]
[nil]
[nil]
[nil]
[2, '1', '2', '3', '4', '5', '6']
["+++", '1', '2', '3', '4', '5', '6']
['1', '2', '3', '4', '5', '6', "+++"]
['1', '2', '3', '4', '5', '6', "+++"]
[]
OUTPUT33
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 34.
if test $result = ok -a $start_test_number -le 34; then
	echo test 34
        cat >$test_file <<'TEST34'
// vector
var v;
// pack & pack
v = [1, 2, 3, 5, 6]; insv (v, [4], 3); println (v);
v = [2, 3, 4, 5, 6]; insv (v, [1]); println (v);
v = [1, 2, 3, 4, 5]; insv (v, [6], -1); println (v);
v = [2, 3, 4, 5, 6]; insv (v, [1], 0); println (v);
// unpack & pack
v = [1.0, 2, 3, 5, 6]; insv (v, [4], 3); println (v);
v = [2.0, 3, 4, 5, 6]; insv (v, [1]); println (v);
v = [1.0, 2, 3, 4, 5]; insv (v, [6], -1); println (v);
v = [2.0, 3, 4, 5, 6]; insv (v, [1], 0); println (v);
// unpack & unpack
v = [1.0, 2, 3, 6]; insv (v, [4, 5.0], 3); println (v);
v = [3.0, 4, 5, 6]; insv (v, [1.0, 2]); println (v);
v = [1.0, 2, 3, 4, 5]; insv (v, [6, 7.0], -1); println (v);
v = [3, 4, 5, 6]; insv (v, [1, 2.0], 0); println (v);
// empty
v = []; insv (v, [10]); println (v);
v = []; insv (v, [10], -1); println (v);
v = []; insv (v, [10], 0); println (v);
v = []; insv (v, [10], 10); println (v);
v = [10]; insv (v, []); println (v);
v = [10]; insv (v, [], -1); println (v);
v = [10]; insv (v, [], 0); println (v);
v = [10]; insv (v, [], 10); println (v);
// string
v = new "123456"; insv (v, "+++"); putln (v);
v = new "123456"; insv (v, "+++", -1); putln (v);
v = new "123456"; insv (v, "+++", 100); putln (v);
//
var i, iter;
for (iter = 0; iter < 10000; iter++)
  { 
    v = [];
    for (i = 0; i < 100; i++)
      insv (v, [1]);
    for (i = 0; i < 100; i++)
      del (v, 0);
  }
println (v);
TEST34
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT34' && $CMP $stdout $ftemp2; then
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6, 7]
[1, 2, 3, 4, 5, 6]
[10]
[10]
[10]
[10]
[10]
[10]
[10]
[10]
+++123456
123456+++
123456+++
[]
OUTPUT34
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 35.
if test $result = ok -a $start_test_number -le 35; then
	echo test 35
        cat >$test_file <<'TEST35'
print (nil);put (" ");
print (10);put (" ");
print (10.2e10);put (" ");
print ('c');put (" ");
println ("ssss");
println (["aaa", "bbb", "ccc"]);
println (["v1", {"key":"val", {"key1":"val1"}}]);
func f {}
println (f);
class c {}
println (c);
println (c ());
var stop;
stop = 0;
thread t {wait (stop);}
println (t());
wait (1) stop = 1;

TEST35
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT35' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+11 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", {"key":"val", {"key1":"val1"}:nil}]
func f
class c
instance c()
thread 1 t()
OUTPUT35
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT35-1' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+011 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", {"key":"val", {"key1":"val1"}:nil}]
func f
class c
instance c()
thread 1 t()
OUTPUT35-1
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT35-2' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+11 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", {{"key1":"val1"}:nil, "key":"val"}]
func f
class c
instance c()
thread 1 t()
OUTPUT35-2
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT35-3' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+011 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", {{"key1":"val1"}:nil, "key":"val"}]
func f
class c
instance c()
thread 1 t()
OUTPUT35-3
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 36.
if test $result = ok -a $start_test_number -le 36; then
	echo test 36
        cat >$test_file <<'TEST36'
var s, t;
s = new "aaaa";
s[1] = "b";
TEST36
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT36' && $CMP $stdout $ftemp2; then
OUTPUT36
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 37.
if test $result = ok -a $start_test_number -le 37; then
	echo test 37
        cat >$test_file <<'TEST37'
thread t1 {
  var i;
  for (i = 0; i < 1000; i++)
     if (i % 100 == 0)
       putln ("thread 1 ", i);
}

thread t2 {
  var i;
  for (i = 0; i < 1000; i++)
     if (i % 100 == 0)
       putln ("thread 2 ", i);
}

t1 ();
putln ("after t1()");
t2 ();
putln ("after t2()");
TEST37
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT37' && $CMP $stdout $ftemp2; then
after t1()
after t2()
thread 1 0
thread 1 100
thread 1 200
thread 1 300
thread 2 0
thread 2 100
thread 2 200
thread 2 300
thread 1 400
thread 1 500
thread 1 600
thread 2 400
thread 2 500
thread 2 600
thread 1 700
thread 1 800
thread 1 900
thread 2 700
thread 2 800
thread 2 900
OUTPUT37
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 38.
if test $result = ok -a $start_test_number -le 38; then
	echo test 38
        cat >$test_file <<'TEST38'
class c(){
thread f (start, iter) {var i;
  for (; iter >= 0; iter--){
    println (start);
    start++;
  }
}
}
var o;
o = c();
o.f (0, 5);
o.f (10, 5);
TEST38
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT38' && $CMP $stdout $ftemp2; then
0
1
2
3
4
5
10
11
12
13
14
15
OUTPUT38
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 39.
if test $result = ok -a $start_test_number -le 39; then
	echo test 39
        cat >$test_file <<'TEST39'
wait (1);
TEST39
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT39' && $CMP $stdout $ftemp2; then
OUTPUT39
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 40.
if test $result = ok -a $start_test_number -le 40; then
	echo test 40
        cat >$test_file <<'TEST40'
var i;
for (i = 0; i < #argv; i++)
  putln (argv[i]);
TEST40
        echo '      ' $DINO $test_file "2>$stderr -- aaaa bbbb"
        if $DINO $test_file 2>$stderr >$stdout -- aaaa bbbb; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT40' && $CMP $stdout $ftemp2; then
aaaa
bbbb
OUTPUT40
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 41.
if test $result = ok -a $start_test_number -le 41; then
	echo test 41
        cat >$test_file <<'TEST41'
// vector
var v;
// pack
v = [1, 2, 3, 4, 5, 6]; del (v, 2); println (v);
v = [1, 2, 3, 4, 5, 6]; del (v, -2, 2); println (v);
v = [1, 2, 3, 4, 5, 6]; del (v, 2, 2); println (v);
v = [1, 2, 3, 4, 5, 6]; del (v, 2, -1); println (v);
v = [1, 2, 3, 4, 5, 6]; del (v, 2, 0); println (v);
// unpack
v = [1, 2.0, 3.0, 4, 5, 6]; del (v, 2); println (v);
v = [1.0, 2, 3, 4, 5, 6]; del (v, -2, 2); println (v);
v = [1.0, 2, 3, 4, 5, 6]; del (v, 2, 2); println (v);
v = [1.0, 2, 3, 4, 5, 6]; del (v, 2, -1); println (v);
v = [1.0, 2, 3, 4, 5, 6]; del (v, 2, 0); println (v);
// empty
v = []; del (v, 0); println (v);
v = []; del (v, -2, 1); println (v);
v = []; del (v, 0, 1); println (v);
v = []; del (v, 1, 0); println (v);
v = []; del (v, 0, -1); println (v);
// string
v = new "123456"; del (v, 2, 2); putln (v);
v = new "123456"; del (v, -2, 2); putln (v);
// table
var t;
t = {1:1, 2:2, 3:3, 4:4, 5:5, 6:6}; del (t, 2); println (t);
//
var i, iter;
for (iter = 0; iter < 1000; iter++)
  { 
    v = [1000:1];
    for (i = 0; i < 1000; i++)
      del (v, 0);
  }
println (v);
TEST41
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT41' && $CMP $stdout $ftemp2; then
[1, 2, 4, 5, 6]
[3, 4, 5, 6]
[1, 2, 5, 6]
[1, 2]
[1, 2, 3, 4, 5, 6]
[1, 2, 4, 5, 6]
[3, 4, 5, 6]
[1, 2, 5, 6]
[1, 2]
[1, 2, 3, 4, 5, 6]
[]
[]
[]
[]
[]
1256
3456
{1:1, 3:3, 4:4, 5:5, 6:6}
[]
OUTPUT41
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 42.
if test $result = ok -a $start_test_number -le 42; then
	echo test 42
        cat >$test_file <<'TEST42'
println (system ("echo test"));
TEST42
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT42' && $CMP $stdout $ftemp2; then
test
0
OUTPUT42
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 43.
if test $result = ok -a $start_test_number -le 43; then
	echo test 43
        cat >$test_file <<'TEST43'
var i,j;
j = 0;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
TEST43
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT43' && $CMP $stdout $ftemp2; then
OUTPUT43
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 44.
if test $result = ok -a $start_test_number -le 44; then
	echo test 44
        cat >$test_file <<'TEST44'
println (cos (3.14));
println (cos ("3.14"));
println (cos (3));
println (cos ('\3'));
TEST44
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT44' && $CMP $stdout $ftemp2; then
-0.999999
-0.999999
-0.989992
-0.989992
OUTPUT44
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 45.
if test $result = ok -a $start_test_number -le 45; then
	echo test 45
        cat >$test_file <<'TEST45'
println (sin (3.14));
println (sin ("3.14"));
println (sin (3));
println (sin ('\3'));
TEST45
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT45' && $CMP $stdout $ftemp2; then
0.00159265
0.00159265
0.14112
0.14112
OUTPUT45
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 46.
if test $result = ok -a $start_test_number -le 46; then
	echo test 46
        cat >$test_file <<'TEST46'
println (atan2 (3.14, 0));
println (atan2 ("3.14", 0));
println (atan2 (3, 0));
println (atan2 ('\3', 0));
//
println (atan2 (1.0, 0));
println (atan2 ("1.0", 0));
println (atan2 (1, 0));
println (atan2 ('\1', 0));
TEST46
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT46' && $CMP $stdout $ftemp2; then
1.5708
1.5708
1.5708
1.5708
1.5708
1.5708
1.5708
1.5708
OUTPUT46
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 47.
if test $result = ok -a $start_test_number -le 47; then
	echo test 47
        cat >$test_file <<'TEST47'
var SieveSize, i, prime, k, count, iter, flags;
SieveSize = 8190;

for (iter = 0; iter < 10; iter++;)
  {
    flags = [SieveSize + 1 : 0];
    count = 0;
    for (i = 0; i <= SieveSize; i++)
      flags[i] = 1;
    for (i = 0; i <= SieveSize; i++;)
      if (flags[i])
        {
          prime = i + i + 3;
          k = i + prime;
          for (;1;;)
            {
	      if (k > SieveSize)
                break;
              flags[k] = 0;
              k += prime;
            }
          count++;
        }
  }
println (count);
TEST47
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT47' && $CMP $stdout $ftemp2; then
1899
OUTPUT47
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 48.
if test $result = ok -a $start_test_number -le 48; then
	echo test 48
        cat >$test_file <<'TEST48'
var SieveSize, i, prime, k, count, iter, flags;
SieveSize = 8190;

for (iter = 0; iter < 10; iter++;)
  {
    flags = {};
    count = 0;
    for (i = 0; i <= SieveSize; i++)
      flags{i} = 1;
    for (i = 0; i <= SieveSize; i++;)
      if (flags{i})
        {
          prime = i + i + 3;
          k = i + prime;
          for (;1;;)
            {
	      if (k > SieveSize)
                break;
              flags{k} = 0;
              k += prime;
            }
          count++;
        }
  }
println (count);
TEST48
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT48' && $CMP $stdout $ftemp2; then
1899
OUTPUT48
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 49.
if test $result = ok -a $start_test_number -le 49; then
	echo test 49
        cat >$test_file <<'TEST49'
var m1, m2;

func mmult (m1, m2)
{
  var i, j, k, m1rows, m1cols, m2rows, m2cols, result;

  m1rows = #m1; m2rows = #m2;
  m1cols = #m1[0]; m2cols = #m2[0];
  if (m2cols != m2rows)
    {
       println ("matrices don't match");
       return;
    }
  result = [m1rows:[m2cols:0]];
  for (i=0; i < m1rows; i++)
    for (j=0; j < m2cols; j++)
      for (k=0; k < m1cols; k++)
        result[i][j] += m1[i][k]*m2[k][j];
  return result;
}

m1 = [100:[100:1]];
m2 = [100:[100:1]];
mmult (m1, m2);
TEST49
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT49' && $CMP $stdout $ftemp2; then
OUTPUT49
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 50.
if test $result = ok -a $start_test_number -le 50; then
	echo test 50
        cat >$test_file <<'TEST50'
var m1, m2;

func mmult (m1, m2)
{
  var i, j, k, m1rows, m1cols, m2rows, m2cols, result;

  m1rows = #m1; m2rows = #m2;
  m1cols = #m1{0}; m2cols = #m2{0};
  if (m2cols != m2rows)
    {
       println ("matrices don't match");
       return;
    }
  result = {};
  for (i=0; i < m1rows; i++) {
    result{i} = {};
    for (j=0; j < m2cols; j++) {
      result{i}{j} = 0;
      for (k=0; k < m1cols; k++)
        result{i}{j} += m1{i}{k}*m2{k}{j};
    }
  }
  return result;
}

var i, j;

m1 = {};
for (i = 0;i < 100; i++) {
  m1{i} = {};
  for (j = 0;j < 100; j++)
    m1{i}{j} = 2;
}
m2 = m1;
mmult (m1, m2);
TEST50
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT50' && $CMP $stdout $ftemp2; then
OUTPUT50
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 51.
if test $result = ok -a $start_test_number -le 51; then
	echo test 51
        cat >$test_file <<'TEST51'
var i;
i = 0;
func f
{
   var i;

   func g {i = 20; return i;}
   i = 10;
   return g;
}
println (f ()());
TEST51
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT51' && $CMP $stdout $ftemp2; then
20
OUTPUT51
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 52.
if test $result = ok -a $start_test_number -le 52; then
	echo test 52
        cat >$test_file <<'TEST52'
var i;
i = 0;
class c ()
{
   var i;

   class sc ()
   {
     class scc ()
     {
       println (i);
     }
     i = 30;
   }
   i = 10;
}
var ssc, ssci;
ssc = c().sc().scc;
ssci = ssc ();
TEST52
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT52' && $CMP $stdout $ftemp2; then
30
OUTPUT52
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 53.
if test $result = ok -a $start_test_number -le 53; then
	echo test 53
        cat >$test_file <<'TEST53'
class c {
  class sc {
     class ssc {
     }
  }
}
func f {
  class sc {
    func g {}
  }
  return sc ();
}
println (c().sc().ssc);
println (f().g);
TEST53
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT53' && $CMP $ftemp $ftemp2; then
class c().sc().ssc
func f().sc().g
OUTPUT53
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 54.
if test $result = ok -a $start_test_number -le 54; then
	echo test 54
        cat >$test_file <<'TEST54'
// Recursive function to compute Fibonacci numbers
func fibonacci (n)
  {
     if (n <= 1) return 1;
     return (fibonacci(n-1) + fibonacci(n-2));
  }

var i, fibnum;

fibnum = 0;
for (i = 0; i <= 24; i++) 
  {
    fibnum = fibonacci(i);
    putln (i @ " " @ fibnum); 
  }
TEST54
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT54' && $CMP $stdout $ftemp2; then
0 1
1 1
2 2
3 3
4 5
5 8
6 13
7 21
8 34
9 55
10 89
11 144
12 233
13 377
14 610
15 987
16 1597
17 2584
18 4181
19 6765
20 10946
21 17711
22 28657
23 46368
24 75025
OUTPUT54
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 55.
if test $result = ok -a $start_test_number -le 55; then
	echo test 55
        cat >$test_file <<'TEST55'
func f {putln ("hello, world # 0");}
ext f {putln ("hello, world # 1");}
ext f {putln ("hello, world # 2");}
ext f {putln ("hello, world # 3");}
f();
TEST55
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT55' && $CMP $stdout $ftemp2; then
hello, world # 0
hello, world # 1
hello, world # 2
hello, world # 3
OUTPUT55
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 56.
if test $result = ok -a $start_test_number -le 56; then
	echo test 56
        cat >$test_file <<'TEST56'
class c (p)
{
  var i;
  i = 10;
}

ext c {
  func f {println (i);println (p);}
}

c (20).f();
TEST56
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT56' && $CMP $stdout $ftemp2; then
10
20
OUTPUT56
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 57.
if test $result = ok -a $start_test_number -le 57; then
	echo test 57
        cat >$test_file <<'TEST57'
class c (p)
{
  var i;
  i = 10;
  func f {}
}

ext c {
  ext f {println (i);println (p);}
}

c (20).f();
TEST57
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT57' && $CMP $stdout $ftemp2; then
10
20
OUTPUT57
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 58.
if test $result = ok -a $start_test_number -le 58; then
	echo test 58
        cat >$test_file <<'TEST58'
class p (p)
{
  var i;
  i = 10;
  func f {}
}

ext p {
  class c (p) {
   func f {println (i);println (p);}
  } 
}

p(20).c(30).f();
TEST58
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT58' && $CMP $stdout $ftemp2; then
10
30
OUTPUT58
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 59.
if test $result = ok -a $start_test_number -le 59; then
	echo test 59
        cat >$test_file <<'TEST59'
var ff;
{
  var i;
  i = 10;
  func f {return i;}
  ff = f;
}
println (ff ());
TEST59
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT59' && $CMP $stdout $ftemp2; then
10
OUTPUT59
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 60.
if test $result = ok -a $start_test_number -le 60; then
	echo test 60
        cat >$test_file <<'TEST60'
println (type (nil));
println (type ('a'));
println (type (10));
println (type (10.0));
println (type ([]));
println (type ({}));
func f ()
{
}
println (type (f));
var flag;
thread t ()
{
  wait (flag != nil);
}
println (type (t));
class c ()
{
}
println (type (c));
var i;
i = c ();
println (type (i));
println (type (t ()));
try {wait (1) flag = 1;}
println (type (context (i)));
println (type (type (1)));
TEST60
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT60' && $CMP $stdout $ftemp2; then
type (nil)
char
int
float
vector
table
func
thread
class
class ()
thread ()
func ()
type
OUTPUT60
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 61.
if test $result = ok -a $start_test_number -le 61; then
	echo test 61
        cat >$test_file <<'TEST61'
class c {
};

var i;
i = c ();
println (class (i));
println (class (10));
TEST61
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT61' && $CMP $stdout $ftemp2; then
class c
nil
OUTPUT61
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 62.
if test $result = ok -a $start_test_number -le 62; then
	echo test 62
        cat >$test_file <<'TEST62'
var f;
thread t {
  wait (f != nil);
}
var p;
p = t ();
println (thread (p));
println (thread (1));
println (thread (main_thread));
try {wait (1) f = 10;}
TEST62
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT62' && $CMP $stdout $ftemp2; then
thread t
nil
nil
OUTPUT62
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 63.
if test $result = ok -a $start_test_number -le 63; then
	echo test 63
        cat >$test_file <<'TEST63'
var i;
func f {
   class c {
   }
   i = c ();
}

f ();
println (func (context (i)));
println (func (10));
TEST63
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT63' && $CMP $stdout $ftemp2; then
func f
nil
OUTPUT63
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 64.
if test $result = ok -a $start_test_number -le 64; then
	echo test 64
        cat >$test_file <<'TEST64'
println (main_thread);
TEST64
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT64' && $CMP $ftemp $ftemp2; then
main thread
OUTPUT64
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 65.
if test $result = ok -a $start_test_number -le 65; then
	echo test 65
        cat >$test_file <<'TEST65'
{
  var i;
  func f {
     class c (){
       class c (){
       }
     }

     i = c ().c();
  }
  f ();
  println (context (i));
  println (context (context (i)));
  println (context (context (context (i))));
  println (context (context (context (context (i)))));
  println (context (context (context (context (context (i))))));
}
TEST65
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT65' && $CMP $ftemp $ftemp2; then
instance {}.f().c()
stack {}.f()
stack {}
stack 
nil
OUTPUT65
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 66.
if test $result = ok -a $start_test_number -le 66; then
	echo test 66
        cat >$test_file <<'TEST66'
var i;

{
  var +l;
  class c {};
  i = c();
  l = 10;
}

println (context (i).l);

func f ()
{
  var +l;
  class c {};
  i = c();
  l = 20;
}

f ();
println (context (i).l);

func fp (+l)
{
  class c {};
  i = c();
}

fp (30);
println (context (i).l);

class c ()
{
  var l;
  class cc {};
  i = cc();
  l = 40;
}

c ();
println (context (i).l);

class cp (l)
{
  class cc {};
  i = cc();
}

cp (50);
println (context (i).l);

{
  var +l;
  func f {};
  i = f;
  l = 60;
}

println (context (i).l);

{
  var +l;
  class c {};
  i = c;
  l = 70;
}

println (context (i).l);

{
  var +l;
  thread t { wait (l);};
  i = t ();
  try {wait (1) l = 0;}
}

println (context (i).l);
context (i).l = 1;
TEST66
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT66' && $CMP $ftemp $ftemp2; then
10
20
30
40
50
60
70
0
OUTPUT66
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 67.
if test $result = ok -a $start_test_number -le 67; then
	echo test 67
        cat >$test_file <<'TEST67'
var ci;
{
  var +i;
  class c {
  }
  ci = c ();
  i = 0;
}

println (context(ci).i);
context(ci).i = 1;
println (context(ci).i);
TEST67
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT67' && $CMP $stdout $ftemp2; then
0
1
OUTPUT67
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 68.
if test $result = ok -a $start_test_number -le 68; then
	echo test 68
        cat >$test_file <<'TEST68'
var i = 10, j = i, k;
i = 0;
k = 5;
putln (i, " ", j, " ", k);
TEST68
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT68' && $CMP $stdout $ftemp2; then
0 10 5
OUTPUT68
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 69.
if test $result = ok -a $start_test_number -le 69; then
	echo test 69
        cat >$test_file <<'TEST69'
func e {putln ("e");return 100;}
func f (i, p = e ()) {
  putln (p, " ", i);
}

var i;
for (i = 0; i < 10; i++) {
  f (20, i);
  f (20);
}
TEST69
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT69' && $CMP $stdout $ftemp2; then
0 20
e
100 20
1 20
e
100 20
2 20
e
100 20
3 20
e
100 20
4 20
e
100 20
5 20
e
100 20
6 20
e
100 20
7 20
e
100 20
8 20
e
100 20
9 20
e
100 20
OUTPUT69
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 70.
if test $result = ok -a $start_test_number -le 70; then
	echo test 70
        cat >$test_file <<'TEST70'
func e {putln ("e");return 100;}
class c (i, p = e ()) {
  putln (p, " ", i);
}

var i;
for (i = 0; i < 10; i++) {
  c (20, i);
  c (20);
}
TEST70
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT70' && $CMP $stdout $ftemp2; then
0 20
e
100 20
1 20
e
100 20
2 20
e
100 20
3 20
e
100 20
4 20
e
100 20
5 20
e
100 20
6 20
e
100 20
7 20
e
100 20
8 20
e
100 20
9 20
e
100 20
OUTPUT70
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 71.
if test $result = ok -a $start_test_number -le 71; then
	echo test 71
        cat >$test_file <<'TEST71'
var fp, c;
{
  class cc {
    class c1 {
    }
    func f {
    }
    {
      func f {}
      fp = f;
    }
  }
  c = cc;
}
println (inside (c(), c, 1));
println (inside (c().c1, c, 1));
println (inside (c().c1(), c, 1));
println (inside (c().f, c, 1));
println (inside (fp, c, 1));
println (inside (context (fp), c, 1));
println (inside (c().c1 (), c().c1, 1));
println (inside (fp, c().c1, 1));
println (inside (c(), c().c1, 1));
println (inside (c().c1, c().c1, 1));
//
putln ();
println (inside (c(), c, "1"));
println (inside (c().c1, c, '1'));
println (inside (c().c1(), c, "1.0"));
println (inside (c().f, c, 1.0));
println (inside (fp, c, "1"));
println (inside (context (fp), c, "1"));
println (inside (c().c1 (), c().c1, "1"));
println (inside (fp, c().c1, "1"));
println (inside (c(), c().c1, "1"));
println (inside (c().c1, c().c1, "1"));
//
putln ();
println (inside (c(), c, 0));
println (inside (c().c1, c, 0));
println (inside (c().c1(), c, 0));
println (inside (c().f, c, 0));
println (inside (fp, c, 0));
println (inside (context (fp), c, 0));
println (inside (c().c1 (), c().c1, 0));
println (inside (fp, c().c1, 0));
println (inside (c(), c().c1, 0));
println (inside (c().c1, c().c1, 0));
//
putln ();
println (inside (c(), c, "0"));
println (inside (c().c1, c, '0'));
println (inside (c().c1(), c, 0.5));
println (inside (c().f, c, "0"));
println (inside (fp, c, "0"));
println (inside (context (fp), c, "0"));
println (inside (c().c1 (), c().c1, "0"));
println (inside (fp, c().c1, "0"));
println (inside (c(), c().c1, "0"));
println (inside (c().c1, c().c1, "0"));
//
putln ();
println (inside (c(), c));
println (inside (c().c1, c));
println (inside (c().c1(), c));
println (inside (c().f, c));
println (inside (fp, c));
println (inside (context (fp), c));
println (inside (c().c1 (), c().c1));
println (inside (fp, c().c1));
println (inside (c(), c().c1));
println (inside (c().c1, c().c1));
TEST71
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT71' && $CMP $stdout $ftemp2; then
1
1
1
1
1
1
0
0
0
0

1
1
1
1
1
1
0
0
0
0

1
1
1
1
1
1
1
0
0
1

1
1
1
1
1
1
1
0
0
1

1
1
1
1
1
1
1
0
0
1
OUTPUT71
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 72.
if test $result = ok -a $start_test_number -le 72; then
	echo test 72
        cat >$test_file <<'TEST72'
println (match ("aaa", "baaab"));
println (match ("(a)(a)(a)", "baaab"));
println (match ("aba", "baaab"));                 // no matching
println (match ("ab.", "baaab\n"));               // matching with NL
println (match ("[:alpha:]", "p"));
println (match ("^.aa", "baaab"));
println (match ("1", 10));
println (match ("1", 0));
println (match ("1", '1'));
println (match ("()aaa", "baaab"));
TEST72
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT72' && $CMP $stdout $ftemp2; then
[1, 4]
[1, 4, 1, 2, 2, 3, 3, 4]
nil
[3, 6]
[0, 1]
[0, 3]
[0, 1]
nil
[0, 1]
[1, 4, 1, 1]
OUTPUT72
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 73.
if test $result = ok -a $start_test_number -le 73; then
	echo test 73
        cat >$test_file <<'TEST73'
println (split ("aaa bbb ccc	ddd"));
println (split ("aaa bbb ccc	ddd", split_regex));
println (split ("aaa   bbb   ccc	  ddd"));
println (split ("  aaa   bbb   ccc	  ddd  "));
println (split ("abcdef", ""));
println (split ("  aaa   bbb   ccc ddd  ", " "));
println (split ("aaabbbcccddd"));
println (split (""));
println (split ("", ""));
println (split (10));
println (split ('c'));
println (split (10.0));
TEST73
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT73' && $CMP $stdout $ftemp2; then
["aaa", "bbb", "ccc", "ddd"]
["aaa", "bbb", "ccc", "ddd"]
["aaa", "bbb", "ccc", "ddd"]
["aaa", "bbb", "ccc", "ddd"]
["a", "b", "c", "d", "e", "f"]
["aaa", "bbb", "ccc", "ddd"]
["aaabbbcccddd"]
[""]
[""]
["10"]
["c"]
["10"]
OUTPUT73
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 74.
if test $result = ok -a $start_test_number -le 74; then
	echo test 74
        cat >$test_file <<'TEST74'
putln (sub ("aa", "abaabbaaaa", "11"));
putln (gsub ("aa", "abaabbaaaa", "11"), "\n");

putln (sub ("aa", "abaabbaaaa", "d&d"));
putln (gsub ("aa", "abaabbaaaa", "d&d"), "\n");

putln (sub ("(a)a", "abaabbaaaa", "d\\1d"));
putln (gsub ("(a)a", "abaabbaaaa", "d\\1d"), "\n");

putln (sub ("aa", "abaabbaaaa", "d\\2d"));
putln (gsub ("aa", "abaabbaaaa", "d\\2d"), "\n");

putln (sub ("aa", "abaabbaaaa", "d\\&d"));
putln (gsub ("aa", "abaabbaaaa", "d\\&d"), "\n");

putln (sub ("aa", "abaabbaaaa", "d\\\\d"));
putln (gsub ("aa", "abaabbaaaa", "d\\\\d"), "\n");

putln (sub ("", "abc", "d"));
putln (gsub ("", "abc", "d"), "\n");

putln (sub ("", "", "d"));
putln (gsub ("", "", "d"), "\n");

putln (sub ("a", "a", 10));
putln (sub ("a", "a", 'c'));
putln (sub ("a", "a", 10.0));
putln (sub ("8", 8, 10));
TEST74
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT74' && $CMP $stdout $ftemp2; then
ab11bbaaaa
ab11bb1111

abdaadbbaaaa
abdaadbbdaaddaad

abdadbbaaaa
abdadbbdaddad

abddbbaaaa
abddbbdddd

abd&dbbaaaa
abd&dbbd&dd&d

abd\dbbaaaa
abd\dbbd\dd\d

dabc
dadbdc

d
d

10
c
10
10
OUTPUT74
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 75.
if test $result = ok -a $start_test_number -le 75; then
	echo test 75
        cat >$test_file <<TEST75
println (sort (readdir ("__tempdir"), cmpv));

try {
println (readdir ("abracadabra"));
} catch (syserrors.enoent) {
  putln ("abracadabra: no such directory");
}

try {
println (readdir (1000022));
} catch (syserrors.enoent) {
  putln ("1000022: no such directory");
}
TEST75
        rm -rf $tempdir
        mkdir $tempdir
        echo > $tempdir/a
        echo > $tempdir/b
        echo > $tempdir/c
        echo > $tempdir/d
        echo > $tempdir/e
        echo > $tempdir/f
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT75' && $CMP $stdout $ftemp2; then
[".", "..", "a", "b", "c", "d", "e", "f"]
abracadabra: no such directory
1000022: no such directory
OUTPUT75
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 76.
if test $result = ok -a $start_test_number -le 76; then
	echo test 76
        cat >$test_file <<'TEST76'
var i = 0;
i[10]=0;
TEST76
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT76' && $CMP $stderr $ftemp2; then
test.d:2:2: run time error - index operation for non array
OUTPUT76
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 77.
if test $result = ok -a $start_test_number -le 77; then
	echo test 77
        cat >$test_file <<'TEST77'
try {
  var i = 0;
  i[10]=0;
} catch (except().error) {
  putln ("got it: ", e.msg);
}
TEST77
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT77' && $CMP $stdout $ftemp2; then
got it: run time error - index operation for non array
OUTPUT77
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 78.
if test $result = ok -a $start_test_number -le 78; then
	echo test 78
	cat >$test_file <<'TEST78'
var i = 0 / 0;
TEST78
	echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
	    if test `uname` = AIX && $CMP - $stderr <<'OUTPUT78'; then
OUTPUT78
		    result=ok
	    elif uname -a|fgrep Linux|fgrep ppc && $CMP - $stderr <<'OUTPUT78a'; then
OUTPUT78a
		    result=ok
	    elif uname -a|fgrep Linux|fgrep ia64 && $CMP - $stderr <<'OUTPUT78b'; then
OUTPUT78b
		    result=ok
	    else
		    result=fail
	    fi
	else
	    echo '      ' $CMP - $stderr
	    if cat >$ftemp2 <<'OUTPUT78-1' && $CMP $stderr $ftemp2; then
test.d:1:11: floating point exception
OUTPUT78-1
		    result=ok
	    else
                    result=fail
	    fi
        fi
fi

# Test 79.
if test $result = ok -a $start_test_number -le 79; then
	echo test 79
        if uname | fgrep CYGWIN; then
	    echo skip the test
	    result=ok
        else
	    cat >$test_file <<'TEST79'
for (var i = 0; i < 10; i++)
try {
  var i = 0 / 0;
} catch (except ().error) {
  putln ("got it: ", e.msg);
}
TEST79
	    echo '      ' $DINO $test_file "2>$stderr"
	    if $DINO $test_file 2>$stderr >$stdout; then
		    echo '      ' $CMP $stdout $ftemp2
		    if cat >$ftemp2 <<'OUTPUT79' && $CMP $stdout $ftemp2; then
OUTPUT79
			result=ok
		    elif cat >$ftemp2 <<'OUTPUT79-1' && $CMP $stdout $ftemp2; then
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
OUTPUT79-1
			    result=ok
		    else
			    result=fail
		    fi
	    else
		    result=fail
	    fi
        fi
fi

# Test 80.
if test $result = ok -a $start_test_number -le 80; then
	echo test 80: Forward and matched declarations
	cat >$test_file <<'TEST80'
func f;
class f () {}
TEST80
	echo '      ' $DINO $test_file "2>$stderr"
	if $DINO $test_file 2>$stderr >$stdout; then
	    result=fail
	else
	    echo '      ' $CMP - $stderr
	    if cat >$ftemp2 <<'OUTPUT80' && $CMP $stderr $ftemp2; then
test.d:2:7: forward and matched declarations of `f' are different entities
test.d:1:6: (previous declaration of identifier `f')
OUTPUT80
		    result=ok
	    else
		    result=fail
	    fi
        fi
fi

# Test 81.
if test $result = ok -a $start_test_number -le 81; then
	echo test 81
        if uname | fgrep CYGWIN; then
	    echo skip the test
	    result=ok
        else
	    cat >$test_file <<'TEST81'
for (var i = 0; i < 10; i++)
try {
  var i = 0 / 0;
} catch (signals.sigfpe) {
  putln ("got it: ", e.msg);
}
TEST81
	    echo '      ' $DINO $test_file "2>$stderr"
	    if $DINO $test_file 2>$stderr >$stdout; then
		    echo '      ' $CMP $stdout $ftemp2
		    if cat >$ftemp2 <<'OUTPUT81' && $CMP $stdout $ftemp2; then
OUTPUT81
			result=ok
		    elif cat >$ftemp2 <<'OUTPUT81-1' && $CMP $stdout $ftemp2; then
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
OUTPUT81-1
			    result=ok
		    else
			    result=fail
		    fi
	    else
		    result=fail
	    fi
        fi
fi

# Test 82.
if test $result = ok -a $start_test_number -le 82; then
	echo test 82
        cat >$test_file <<'TEST82'
match ("[a", "");
TEST82
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT82' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unmatched bracket list operators in regexp
OUTPUT82
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 83.
if test $result = ok -a $start_test_number -le 83; then
	echo test 83
        cat >$test_file <<'TEST83'
match ("[z-a]", "");
TEST83
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT83' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid use of the range operator in regexp
OUTPUT83
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 84.
if test $result = ok -a $start_test_number -le 84; then
	echo test 84
        cat >$test_file <<'TEST84'
match ("[[:foo:]]", "");
TEST84
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT84' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unknown character class name in regexp
OUTPUT84
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 85.
if test $result = ok -a $start_test_number -le 85; then
	echo test 85
        cat >$test_file <<'TEST85'
match ("(a", "");
TEST85
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT85' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unmatched parenthesis group operators in regexp
OUTPUT85
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 86.
if test $result = ok -a $start_test_number -le 86; then
	echo test 86
        cat >$test_file <<'TEST86'
match ("(a)\\2", "");
TEST86
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT86' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid back reference to a subexpr. in regexp
OUTPUT86
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 87.
if test $result = ok -a $start_test_number -le 87; then
	echo test 87
        cat >$test_file <<'TEST87'
match ("a\\", "");
TEST87
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT87' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid escape sequence in regexp
OUTPUT87
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 88.
if test $result = ok -a $start_test_number -le 88; then
	echo test 88
        cat >$test_file <<'TEST88'
val i;
i = 10;
putln(i);
TEST88
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT88' && $CMP $stderr $ftemp2; then
test.d:2:1: constant `i' in assignment statement
OUTPUT88
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 89.
if test $result = ok -a $start_test_number -le 89; then
	echo test 89
        cat >$test_file <<'TEST89'
func f (val i)
{
  i = 10;
  putln(i);
}
f (1);
TEST89
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT89' && $CMP $stderr $ftemp2; then
test.d:3:3: constant `i' in assignment statement
OUTPUT89
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 90.
if test $result = ok -a $start_test_number -le 90; then
	echo test 90
        cat >$test_file <<'TEST90'
val i = 10; putln(i);
func f (val i = 10)
{
  putln(i);
}
f (1);
f ();
class c (val i = 100)
{
  putln(i);
}
c (1);
c ();
TEST90
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT90' && $CMP $stdout $ftemp2; then
10
1
10
1
100
OUTPUT90
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 91.
if test $result = ok -a $start_test_number -le 91; then
	echo test 91
        cat >$test_file <<'TEST91'
final func f {putln ("hello, world # 0");}
f();
TEST91
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT91' && $CMP $stdout $ftemp2; then
hello, world # 0
OUTPUT91
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 92.
if test $result = ok -a $start_test_number -le 92; then
	echo test 92
        cat >$test_file <<'TEST92'
final class c (p)
{
  var i;
  i = 10;
  putln (i);
}

c (20);
TEST92
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT92' && $CMP $stdout $ftemp2; then
10
OUTPUT92
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 93.
if test $result = ok -a $start_test_number -le 93; then
	echo test 93
        cat >$test_file <<'TEST93'
class c (p)
{
  var i;
  i = 10;
  final func f {}
}

ext c {
  putln (i);putln (p);
}

c (20);
TEST93
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT93' && $CMP $stdout $ftemp2; then
10
20
OUTPUT93
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 94.
if test $result = ok -a $start_test_number -le 94; then
	echo test 94
        cat >$test_file <<'TEST94'
final func f {putln ("hello, world # 0");}
ext f {putln ("hello, world # 1");}
TEST94
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT94' && $CMP $stderr $ftemp2; then
test.d:2:5: extension of final func/class `f'
OUTPUT94
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 95.
if test $result = ok -a $start_test_number -le 95; then
	echo test 95
        cat >$test_file <<'TEST95'
final func f {putln ("hello, world # 0");}
ext f {putln ("hello, world # 1");}
TEST95
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT95' && $CMP $stderr $ftemp2; then
test.d:2:5: extension of final func/class `f'
OUTPUT95
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 96.
if test $result = ok -a $start_test_number -le 96; then
	echo test 96
        cat >$test_file <<'TEST96'
final class c (p)
{
  var i;
  i = 10;
}

ext c {
  func f {putln (i);putln (p);}
}

c (20).f();
TEST96
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT96' && $CMP $stderr $ftemp2; then
test.d:7:5: extension of final func/class `c'
OUTPUT96
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 97.
if test $result = ok -a $start_test_number -le 97; then
	echo test 97
        cat >$test_file <<'TEST97'
final class c (p)
{
  var i;
  i = 10;
}

ext c {
  func f {putln (i);putln (p);}
}

c (20).f();
TEST97
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT97' && $CMP $stderr $ftemp2; then
test.d:7:5: extension of final func/class `c'
OUTPUT97
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 98.
if test $result = ok -a $start_test_number -le 98; then
	echo test 98
        cat >$test_file <<'TEST98'
class c (p)
{
  var i;
  i = 10;
  final func f {}
}

ext c {
  ext f {putln (i);putln (p);}
}

c (20).f();
TEST98
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT98' && $CMP $stderr $ftemp2; then
test.d:9:7: extension of final func/class `f'
OUTPUT98
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 99.
if test $result = ok -a $start_test_number -le 99; then
	echo test 99
        cat >$test_file <<'TEST99'
seek (stdout, 10, 10);
TEST99
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT99' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `seek'
OUTPUT99
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 100.
if test $result = ok -a $start_test_number -le 100; then
	echo test 100
        if uname | fgrep Linux || uname | fgrep linux; then
	    cat >$test_file <<'TEST100'
seek (stdout, 10000, 'C');
TEST100
	    echo '      ' $DINO $test_file "2>$stderr"
	    if $DINO $test_file 2>$stderr; then
		    result=fail
	    else
		    echo '      ' $CMP - $stderr
		    if cat >$ftemp2 <<'OUTPUT100' && $CMP $stderr $ftemp2; then
test.d:1:6: system error - invalid seek: `seek'
OUTPUT100
			    result=ok
		    else
			    result=fail
		    fi
	    fi
        else
	    echo skip the test
	    result=ok
        fi
fi

# Test 101.
if test $result = ok -a $start_test_number -le 101; then
	echo test 101
        if uname | fgrep Linux || uname | fgrep linux; then
	    cat >$test_file <<'TEST101'
seek (stdout, 10, "c");
TEST101
	    echo '      ' $DINO $test_file "2>$stderr"
	    if $DINO $test_file 2>$stderr; then
		    result=fail
	    else
		    echo '      ' $CMP - $stderr
		    if cat >$ftemp2 <<'OUTPUT101' && $CMP $stderr $ftemp2; then
test.d:1:6: system error - invalid seek: `seek'
OUTPUT101
			    result=ok
		    else
			    result=fail
		    fi
	    fi
        else
	    echo skip the test
	    result=ok
        fi
fi

# Test 102.
if test $result = ok -a $start_test_number -le 102; then
	echo test 102
        cat >$test_file <<'TEST102'
seek (stdout, 10, "t");
TEST102
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT102' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `seek'
OUTPUT102
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 103.
if test $result = ok -a $start_test_number -le 103; then
	echo test 103
        cat >$test_file <<'TEST103'
seek (stdout, "aaa", 's');
TEST103
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT103' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `seek'
OUTPUT103
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT103' && $CMP $stderr $ftemp2; then
test.d:1:6: system error - invalid argument: `string-to-float conversion'
OUTPUT103
                        result=ok

                else
                        result=fail
                fi
        fi
fi

# Test 104.
if test $result = ok -a $start_test_number -le 104; then
	echo test 104
        cat >$test_file <<'TEST104'
seek (10, 10, 'e');
TEST104
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT104' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `seek'
OUTPUT104
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 105.
if test $result = ok -a $start_test_number -le 105; then
	echo test 105
        cat >$test_file <<'TEST105'
var f = open ("test.d", "r");
putln (tell (f));
seek (f, 10, 's');
putln (tell (f));
seek (f, -10, 'c');
putln (tell (f));
seek (f, 0, 'e');
putln (tell (f));
TEST105
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT105'\
		   && wc -c $test_file|awk '{print $1}' >>$ftemp2\
		   && $CMP $stdout $ftemp2; then
0
10
0
OUTPUT105
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 106.
if test $result = ok -a $start_test_number -le 106; then
	echo test 106
        cat >$test_file <<'TEST106'
putln (time ());
TEST106
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^[0-9][0-9][0-9][0-9][0-9]*$' $stdout
                if egrep '^[0-9][0-9][0-9][0-9][0-9]*$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 107.
if test $result = ok -a $start_test_number -le 107; then
	echo test 107
        cat >$test_file <<'TEST107'
time (10);
TEST107
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT107' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `time'
OUTPUT107
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 108.
if test $result = ok -a $start_test_number -le 108; then
	echo test 108
        cat >$test_file <<'TEST108'
strtime (10, nil, nil);
TEST108
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT108' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of actual parameters for `strtime'
OUTPUT108
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 109.
if test $result = ok -a $start_test_number -le 109; then
	echo test 109
        cat >$test_file <<'TEST109'
strtime (nil);
TEST109
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT109' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `strtime'
OUTPUT109
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 110.
if test $result = ok -a $start_test_number -le 110; then
	echo test 110
        cat >$test_file <<'TEST110'
strtime (10, nil);
TEST110
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT110' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `strtime'
OUTPUT110
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 111.
if test $result = ok -a $start_test_number -le 111; then
	echo test 111
        cat >$test_file <<'TEST111'
time_format = nil;
strtime ();
TEST111
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT111' && $CMP $stderr $ftemp2; then
test.d:2:9: run time error - bad value of environment variable `time_format'
OUTPUT111
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 112.
if test $result = ok -a $start_test_number -le 112; then
	echo test 112
        cat >$test_file <<'TEST112'
put (strtime ("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa "));
put (strtime ("%Y ", time()));
put (strtime (time_format, time()));
put (strtime (" %d "));
put (strtime ());
putln (strtime (" aa"));
TEST112
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa [0-9][0-9][0-9][0-9] [A-Za-z][A-Za-z]* [A-Za-z][A-Za-z]* [0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9] [A-Z]* [0-9][0-9][0-9][0-9] [0-3][0-9] [A-Za-z][A-Za-z]* [A-Za-z][A-Za-z]* [0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9] [A-Z]* [0-9][0-9][0-9][0-9] aa$' $stdout
                if egrep '^aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa [0-9][0-9][0-9][0-9] [A-Za-z][A-Za-z]* [A-Za-z][A-Za-z]* [0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9] [A-Z]* [0-9][0-9][0-9][0-9] [0-3][0-9] [A-Za-z][A-Za-z]* [A-Za-z][A-Za-z]* [0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9] [A-Z]* [0-9][0-9][0-9][0-9] aa$' $stdout; then
                        result=ok
                elif egrep '^aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa [0-9][0-9][0-9][0-9] [A-Za-z][A-Za-z]* [A-Za-z][A-Za-z]* [0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9] [A-Za-z]* [A-Za-z]* [A-Za-z]* [0-9][0-9][0-9][0-9] [0-3][0-9] [A-Za-z][A-Za-z]* [A-Za-z][A-Za-z]* [0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9] [A-Za-z]* [A-Za-z]* [A-Za-z]* [0-9][0-9][0-9][0-9] aa$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 113.
if test $result = ok -a $start_test_number -le 113; then
	echo test 113
        cat >$test_file <<'TEST113'
clock (nil);
TEST113
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT113' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `clock'
OUTPUT113
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 114.
if test $result = ok -a $start_test_number -le 114; then
	echo test 114
        cat >$test_file <<'TEST114'
putln (clock ());
TEST114
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^[0-1]\.?[0-9]*$' $stdout
                if egrep '^[0-1]\.?[0-9]*$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 115.
if test $result = ok -a $start_test_number -le 115; then
	echo test 115
        cat >$test_file <<'TEST115'
split_regex = nil;
println (split ("aaa bbb ccc	ddd"));
TEST115
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT115' && $CMP $stderr $ftemp2; then
test.d:2:16: run time error - bad value of environment variable `split_regex'
OUTPUT115
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 116.
if test $result = ok -a $start_test_number -le 116; then
	echo test 116
        cat >$test_file <<'TEST116'
throw except ();
TEST116
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT116' && $CMP $stderr $ftemp2; then
test.d:1:1: run time error - exception except has not been processed
OUTPUT116
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 117.
if test $result = ok -a $start_test_number -le 117; then
	echo test 117
        cat >$test_file <<'TEST117'
throw except (). error ("Error111");
TEST117
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT117' && $CMP $stderr $ftemp2; then
test.d:1:1: Error111
OUTPUT117
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 118.
if test $result = ok -a $start_test_number -le 118; then
	echo test 118
        cat >$test_file <<'TEST118'
for (var i = 0; i < 50;i++)
{
  try {
    putln ("in try");
    throw except ();
    putln ("after throw");
  } catch (except) {
    putln ("in catch");
  } 
  putln ("finish");
}
TEST118
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT118' && $CMP $stdout $ftemp2; then
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
OUTPUT118
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 119.
if test $result = ok -a $start_test_number -le 119; then
	echo test 119
        cat >$test_file <<'TEST119'
try {
  put ("Good");
} catch (except) {
}
putln (" and good");
TEST119
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT119' && $CMP $stdout $ftemp2; then
Good and good
OUTPUT119
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 120.
if test $result = ok -a $start_test_number -le 120; then
	echo test 120
        cat >$test_file <<'TEST120'
var f = open ("test.d", "r"), f1;
f1 = f;
println (f == f1);
println (type (f));
println (type (hide));
println (hide);
println (type (hideblock));
println (hideblock);
TEST120
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT120' && $CMP $stdout $ftemp2; then
1
class ()
type
hide
type
hideblock
OUTPUT120
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 121.
if test $result = ok -a $start_test_number -le 121; then
	echo test 121
        cat >$test_file <<'TEST121'
var v = [4, 2, 1, 3]; println (sort (v)); println (v);
v = [4.0, 2.0, 1.0, 3.0]; println (sort (v)); println (v);
v = ['4', '2', '1', '3']; println (sort (v)); println (v);
v = "5132"; println (sort (v)); println (v);

func c(i,j) {
  if (i < j)
    return -1;
  else if (i == j)
    return 0;
  else
    return 1;
}
v = [4, 2, 1, 3.5];
println (sort (v, c)); println (v);
TEST121
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT121' && $CMP $stdout $ftemp2; then
[1, 2, 3, 4]
[4, 2, 1, 3]
[1, 2, 3, 4]
[4, 2, 1, 3]
"1234"
"4213"
"1235"
"5132"
[1, 2, 3.5, 4]
[4, 2, 1, 3.5]
OUTPUT121
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 122.
if test $result = ok -a $start_test_number -le 122; then
	echo test 122
        cat >$test_file <<'TEST122'
var v = "5132"; println (sort ());
TEST122
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT122' && $CMP $stderr $ftemp2; then
test.d:1:31: run time error - invalid number of actual parameters for `sort'
OUTPUT122
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 123.
if test $result = ok -a $start_test_number -le 123; then
	echo test 123
        cat >$test_file <<'TEST123'
var v = "5132"; println (sort (nil, nil, nil));
TEST123
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT123' && $CMP $stderr $ftemp2; then
test.d:1:31: run time error - invalid number of actual parameters for `sort'
OUTPUT123
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 124.
if test $result = ok -a $start_test_number -le 124; then
	echo test 124
        cat >$test_file <<'TEST124'
println (sort (nil));
TEST124
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT124' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid parameter type of `sort'
OUTPUT124
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 125.
if test $result = ok -a $start_test_number -le 125; then
	echo test 125
        cat >$test_file <<'TEST125'
var v = [4.0, 2.0, 1.0, 3]; println (sort (v));
TEST125
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT125' && $CMP $stderr $ftemp2; then
test.d:1:43: run time error - invalid parameter type of `sort'
OUTPUT125
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 126.
if test $result = ok -a $start_test_number -le 126; then
	echo test 126
        cat >$test_file <<'TEST126'
var v = [nil, nil]; println (sort (v));
TEST126
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT126' && $CMP $stderr $ftemp2; then
test.d:1:35: run time error - invalid parameter type of `sort'
OUTPUT126
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 127.
if test $result = ok -a $start_test_number -le 127; then
	echo test 127
        cat >$test_file <<'TEST127'
var v = [2, 1]; println (sort (v, v));
TEST127
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT127' && $CMP $stderr $ftemp2; then
test.d:1:31: run time error - invalid parameter type of `sort'
OUTPUT127
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 128.
if test $result = ok -a $start_test_number -le 128; then
	echo test 128
        cat >$test_file <<'TEST128'
func c (i, j) {return nil;}
var v = [2, 1]; println (sort (v, c));
TEST128
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT128' && $CMP $stderr $ftemp2; then
test.d:2:31: run time error - invalid function result used by function `sort'
OUTPUT128
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 129.
if test $result = ok -a $start_test_number -le 129; then
	echo test 129
        cat >$test_file <<'TEST129'
putln (getpid (), " ", getun (), " ", geteun (), " ", getgn (), " ", getegn ());
TEST129
        echo '      ' $DINO $test_file "2>$stderr"
        if uname | fgrep CYGWIN; then
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^-?[0-9][0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]*$' $stdout
                if egrep '^-?[0-9][0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]*$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^[0-9][0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]*$' $stdout
                if egrep '^[0-9][0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]*$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	fi
fi

# Test 130.
if test $result = ok -a $start_test_number -le 130; then
	echo test 130
        cat >$test_file <<'TEST130'
getpid (1);
TEST130
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT130' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `getpid'
OUTPUT130
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 131.
if test $result = ok -a $start_test_number -le 130; then
	echo test 131
        cat >$test_file <<'TEST131'
getppid (1);
TEST131
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT131' && $CMP $stderr $ftemp2; then
test.d:1:1: undeclared identifier `getppid'
OUTPUT131
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 132.
if test $result = ok -a $start_test_number -le 132; then
	echo test 132
        cat >$test_file <<'TEST132'
getun (1);
TEST132
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT132' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `getun'
OUTPUT132
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 133.
if test $result = ok -a $start_test_number -le 133; then
	echo test 133
        cat >$test_file <<'TEST133'
geteun (1);
TEST133
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT133' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `geteun'
OUTPUT133
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 134.
if test $result = ok -a $start_test_number -le 134; then
	echo test 134
        cat >$test_file <<'TEST134'
getgn (1);
TEST134
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT134' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `getgn'
OUTPUT134
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 135.
if test $result = ok -a $start_test_number -le 135; then
	echo test 135
        cat >$test_file <<'TEST135'
getegn (1);
TEST135
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT135' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `getegn'
OUTPUT135
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 136.
if test $result = ok -a $start_test_number -le 136; then
	echo test 136
        cat >$test_file <<'TEST136'
putln (ftype ("test.d"));
putln (ftype ("."));
putln (ftype (stdin));
putln (ftype (stdout));
TEST136
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT136' && $CMP $stdout $ftemp2; then
f
d
c
f
OUTPUT136
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 137.
if test $result = ok -a $start_test_number -le 137; then
	echo test 137
        cat >$test_file <<'TEST137'
ftype ();
TEST137
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT137' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `ftype'
OUTPUT137
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 138.
if test $result = ok -a $start_test_number -le 138; then
	echo test 138
        cat >$test_file <<'TEST138'
ftype (nil, nil);
TEST138
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT138' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `ftype'
OUTPUT138
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 139.
if test $result = ok -a $start_test_number -le 139; then
	echo test 139
        cat >$test_file <<'TEST139'
ftype (nil);
TEST139
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT139' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `ftype'
OUTPUT139
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 140.
if test $result = ok -a $start_test_number -le 140; then
	echo test 140
        cat >$test_file <<'TEST140'
println (getgroups ());
TEST140
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                regex="^\[(\"[-_a-zA-Z0-9][-_a-zA-Z0-9]*\"(, \"[-_a-zA-Z0-9][-_a-zA-Z0-9]*\")*)?\]$"
                echo '      ' egrep \'$regex\' $stdout
                if egrep "$regex" $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 141.
if test $result = ok -a $start_test_number -le 141; then
	echo test 141
        cat >$test_file <<'TEST141'
getgroups (nil);
TEST141
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT141' && $CMP $stderr $ftemp2; then
test.d:1:11: run time error - invalid number of actual parameters for `getgroups'
OUTPUT141
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 142.
if test $result = ok -a $start_test_number -le 142; then
	echo test 142
        cat >$test_file <<'TEST142'
var i, j;
for (i=0;i<10000;i++)
  {
    j=0;
  }
putln (gc());
TEST142
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^[0-9][0-9][0-9][0-9][0-9][0-9]*$' $stdout
                if egrep '^[0-9][0-9][0-9][0-9][0-9][0-9]*$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 143.
if test $result = ok -a $start_test_number -le 143; then
	echo test 143
        cat >$test_file <<'TEST143'
gc (nil);
TEST143
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT143' && $CMP $stderr $ftemp2; then
test.d:1:4: run time error - invalid number of actual parameters for `gc'
OUTPUT143
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 144.
if test $result = ok -a $start_test_number -le 144; then
	echo test 144
        cat >$test_file <<'TEST144'
put (fun ("test.d"));
put (" ", fgn ("test.d"));
putln (" ", fsize ("test.d"));
TEST144
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		regex="^[a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* "
		regex=$regex`wc -c $test_file|awk '{print $1}'`\$
                echo '      \'$regex\' $stdout
                if egrep "$regex" $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 145.
if test $result = ok -a $start_test_number -le 145; then
	echo test 145
        cat >$test_file <<'TEST145'
put (fatime ("test.d"));
put (" ", fmtime ("test.d"));
putln (" ", fctime ("test.d"));
TEST145
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*( [0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*)*$' $stdout
                if egrep '^[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*( [0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*)*$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 146.
if test $result = ok -a $start_test_number -le 146; then
	echo test 146
        cat >$test_file <<'TEST146'
put (fumode ("test.d"));
put (" ", fgmode ("test.d"));
putln (" ", fomode ("test.d"));
TEST146
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^s?r?w?x? r?w?x? r?w?x?$' $stdout
                if egrep '^s?r?w?x? r?w?x? r?w?x?$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 147.
if test $result = ok -a $start_test_number -le 147; then
	echo test 147
        cat >$test_file <<'TEST147'
fatime ();
TEST147
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT147' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `fatime'
OUTPUT147
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 148.
if test $result = ok -a $start_test_number -le 148; then
	echo test 148
        cat >$test_file <<'TEST148'
fatime (nil);
TEST148
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT148' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `fatime'
OUTPUT148
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 149.
if test $result = ok -a $start_test_number -le 149; then
	echo test 149
        cat >$test_file <<'TEST149'
var i,t;
t = {};
for (i = 0; i < 10000; i++)
  t {i} = -i;
TEST149
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT149' && $CMP $stdout $ftemp2; then
OUTPUT149
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 150.
if test $result = ok -a $start_test_number -le 150; then
	echo test 150
        cat >$test_file <<'TEST150'
var c, i;
for (i = 0; i < 5; i++)
{
  c = get ();
  putln (c);
}
TEST150
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT150' && $CMP $stdout $ftemp2; then
a
b
c
d


OUTPUT150
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 151.
if test $result = ok -a $start_test_number -le 151; then
	echo test 151
        cat >$test_file <<'TEST151'
var c;
for (;1;)
{
  try {c = get ();} catch (invcalls.eof) {break;}
  putln (c);
}
TEST151
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT151' && $CMP $stdout $ftemp2; then
a
b
c
d


OUTPUT151
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 152.
if test $result = ok -a $start_test_number -le 152; then
	echo test 152
        cat >$test_file <<'TEST152'
var c, f = open ("test.d", "r");
for (;1;)
{
  try {c = fget (f);} catch (invcalls.eof) {break;}
  put (c);
}
TEST152
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT152' && $CMP $stdout $ftemp2; then
var c, f = open ("test.d", "r");
for (;1;)
{
  try {c = fget (f);} catch (invcalls.eof) {break;}
  put (c);
}
OUTPUT152
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 153.
if test $result = ok -a $start_test_number -le 153; then
	echo test 153
        cat >$test_file <<'TEST153'
var c;
for (;1;)
{
  c = get ();
  putln (c);
}
TEST153
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT153' && $CMP $stderr $ftemp2; then
test.d:4:11: run time error - EOF occured in `get'
OUTPUT153
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 154.
if test $result = ok -a $start_test_number -le 154; then
	echo test 154
        cat >$test_file <<'TEST154'
var c, f=open ("test.d", "r");
for (;1;)
{
  c = fget (f);
  put (c);
}
TEST154
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT154' && $CMP $stderr $ftemp2; then
test.d:4:12: run time error - EOF occured in `fget'
OUTPUT154
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 155.
if test $result = ok -a $start_test_number -le 155; then
	echo test 155
        cat >$test_file <<'TEST155'
var c = get (nil);
TEST155
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT155' && $CMP $stderr $ftemp2; then
test.d:1:13: run time error - invalid number of actual parameters for `get'
OUTPUT155
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 156.
if test $result = ok -a $start_test_number -le 156; then
	echo test 156
        cat >$test_file <<'TEST156'
var c = fget ();
TEST156
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT156' && $CMP $stderr $ftemp2; then
test.d:1:14: run time error - invalid number of actual parameters for `fget'
OUTPUT156
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 157.
if test $result = ok -a $start_test_number -le 157; then
	echo test 157
        cat >$test_file <<'TEST157'
var c = fget (nil);
TEST157
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT157' && $CMP $stderr $ftemp2; then
test.d:1:14: run time error - invalid parameter type of `fget'
OUTPUT157
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 158.
if test $result = ok -a $start_test_number -le 158; then
	echo test 158
        cat >$test_file <<'TEST158'
putln (getln());
TEST158
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT158' && $CMP $stdout $ftemp2; then
abcd
OUTPUT158
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 159.
if test $result = ok -a $start_test_number -le 159; then
	echo test 159
        cat >$test_file <<'TEST159'
var c, f = open ("test.d", "r");
for (;1;)
{
  try {putln (fgetln (f));} catch (invcalls.eof) {break;}
}
TEST159
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT159' && $CMP $stdout $ftemp2; then
var c, f = open ("test.d", "r");
for (;1;)
{
  try {putln (fgetln (f));} catch (invcalls.eof) {break;}
}
OUTPUT159
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 160.
if test $result = ok -a $start_test_number -le 160; then
	echo test 160
        cat >$test_file <<'TEST160'
putln (getln ());
putln (getln ());
TEST160
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT160' && $CMP $stderr $ftemp2; then
test.d:2:14: run time error - EOF occured in `getln'
OUTPUT160
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 161.
if test $result = ok -a $start_test_number -le 161; then
	echo test 161
        cat >$test_file <<'TEST161'
var c, f=open ("test.d", "r");
for (;1;)
  putln (fgetln (f));
TEST161
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT161' && $CMP $stderr $ftemp2; then
test.d:3:17: run time error - EOF occured in `fgetln'
OUTPUT161
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 162.
if test $result = ok -a $start_test_number -le 162; then
	echo test 162
        cat >$test_file <<'TEST162'
var c = getln (nil);
TEST162
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT162' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid number of actual parameters for `getln'
OUTPUT162
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 163.
if test $result = ok -a $start_test_number -le 163; then
	echo test 163
        cat >$test_file <<'TEST163'
var c = fgetln ();
TEST163
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT163' && $CMP $stderr $ftemp2; then
test.d:1:16: run time error - invalid number of actual parameters for `fgetln'
OUTPUT163
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 164.
if test $result = ok -a $start_test_number -le 164; then
	echo test 164
        cat >$test_file <<'TEST164'
var c = fgetln (nil);
TEST164
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT164' && $CMP $stderr $ftemp2; then
test.d:1:16: run time error - invalid parameter type of `fgetln'
OUTPUT164
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 165.
if test $result = ok -a $start_test_number -le 165; then
	echo test 165
        cat >$test_file <<'TEST165'
putln (nil);
TEST165
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT165' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `putln'
OUTPUT165
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 166.
if test $result = ok -a $start_test_number -le 166; then
	echo test 166
        cat >$test_file <<'TEST166'
put ([10]);
TEST166
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT166' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `put'
OUTPUT166
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 167.
if test $result = ok -a $start_test_number -le 167; then
	echo test 167
        cat >$test_file <<'TEST167'
fputln (nil);
TEST167
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT167' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `fputln'
OUTPUT167
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 168.
if test $result = ok -a $start_test_number -le 168; then
	echo test 168
        cat >$test_file <<'TEST168'
fput ([10]);
TEST168
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT168' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `fput'
OUTPUT168
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 169.
if test $result = ok -a $start_test_number -le 169; then
	echo test 169
        cat >$test_file <<'TEST169'
for (;1;)
{
  try {
    println (scanln ());
  } catch (invcalls.eof) {putln ("eof"); break;}
    catch (invcalls.invinput) {putln ("catch invalid input");}
}
TEST169
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout <<'INPUT169' ; then
'c'
"aaaaa"
1000
-1000
10e+10
-10e+10
[]
[2]
[2:2]
[2:[2]]
[2,2.2, 2:[10, 'c', "aaa", 10.7]]
{}
{10, 2:"10"}
{[2,5]:{1:5, 5}, 10:[10, 'c']}
[2,3] [3,2]
[2, a
[3,3]
INPUT169
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT169' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
-1000
1e+11
-1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{}
{2:"10", 10:10}
{10:[10, 'c'], [2, 5]:{1:5, 5:5}}
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT169
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT169-2' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
-1000
1e+011
-1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{}
{2:"10", 10:10}
{10:[10, 'c'], [2, 5]:{1:5, 5:5}}
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT169-2
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT169-3' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
-1000
1e+11
-1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{}
{2:"10", 10:10}
{[2, 5]:{1:5, 5:5}, 10:[10, 'c']}
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT169-3
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT169-4' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
-1000
1e+011
-1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{}
{2:"10", 10:10}
{[2, 5]:{1:5, 5:5}, 10:[10, 'c']}
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT169-4
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 170.
if test $result = ok -a $start_test_number -le 170; then
	echo test 170
        cat >$test_file <<'TEST170'
scan (nil);
TEST170
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT170' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `scan'
OUTPUT170
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 171.
if test $result = ok -a $start_test_number -le 171; then
	echo test 171
        cat >$test_file <<'TEST171'
scanln (nil);
TEST171
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT171' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `scanln'
OUTPUT171
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 172.
if test $result = ok -a $start_test_number -le 172; then
	echo test 172
        cat >$test_file <<'TEST172'
fscan ();
TEST172
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT172' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `fscan'
OUTPUT172
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 173.
if test $result = ok -a $start_test_number -le 173; then
	echo test 173
        cat >$test_file <<'TEST173'
fscanln ();
TEST173
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT173' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of actual parameters for `fscanln'
OUTPUT173
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 174.
if test $result = ok -a $start_test_number -le 174; then
	echo test 174
        cat >$test_file <<'TEST174'
fscan ([10]);
TEST174
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT174' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `fscan'
OUTPUT174
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 175.
if test $result = ok -a $start_test_number -le 175; then
	echo test 175
        cat >$test_file <<'TEST175'
fscanln ([10]);
TEST175
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT175' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `fscanln'
OUTPUT175
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 176.
if test $result = ok -a $start_test_number -le 176; then
	echo test 176
        cat >$test_file <<'TEST176'
for (;1;)
{
  try {
    println (scan ());
  } catch (invcalls.eof) {putln ("eof"); break;}
}
TEST176
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout <<'INPUT176' ; then
'c'"aaaaa"1000 10e+10[][2][2:2][2:[2]][2,2.2, 2:[10, 'c', "aaa", 10.7]]
{10, 2:"10"}{[2,5]:{1:5, 5}, 10:[10, 'c']}[2,3] [3,2] [3,3]
INPUT176
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT176' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{2:"10", 10:10}
{10:[10, 'c'], [2, 5]:{1:5, 5:5}}
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT176
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT176-2' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{2:"10", 10:10}
{10:[10, 'c'], [2, 5]:{1:5, 5:5}}
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT176-2
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT176-3' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{2:"10", 10:10}
{[2, 5]:{1:5, 5:5}, 10:[10, 'c']}
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT176-3
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT176-4' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{2:"10", 10:10}
{[2, 5]:{1:5, 5:5}, 10:[10, 'c']}
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT176-4
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 177.
if test $result = ok -a $start_test_number -le 177; then
	echo test 177
        cat >$test_file <<'TEST177'
var f = open ("_temp.out", "r");
for (;1;)
{
  try {
    println (fscanln (f));
  } catch (invcalls.eof) {putln ("eof"); break;}
    catch (invcalls.invinput) {putln ("catch invalid input");}
}
TEST177
        echo '      ' "$DINO $test_file 2>$stderr"
	cat >$ftemp  <<'INPUT177'
'c'
"aaaaa"
1000
10e+10
[]
[2]
[2:2]
[2:[2]]
[2,2.2, 2:[10, 'c', "aaa", 10.7]]
{10, 2:"10"}
{[2,5]:{1:5, 5}, 10:[10, 'c']}
[2,3] [3,2]
[2, a
[3,3]
INPUT177
        if $DINO $test_file 2>$stderr >$stdout ; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT177' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{2:"10", 10:10}
{10:[10, 'c'], [2, 5]:{1:5, 5:5}}
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT177
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT177-2' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{2:"10", 10:10}
{10:[10, 'c'], [2, 5]:{1:5, 5:5}}
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT177-2
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT177-3' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{2:"10", 10:10}
{[2, 5]:{1:5, 5:5}, 10:[10, 'c']}
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT177-3
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT177-4' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{2:"10", 10:10}
{[2, 5]:{1:5, 5:5}, 10:[10, 'c']}
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT177-4
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 178.
if test $result = ok -a $start_test_number -le 178; then
	echo test 178
        cat >$test_file <<'TEST178'
var f = open ("_temp.out", "r");
for (;1;)
{
  try {
    println (fscan (f));
  } catch (invcalls.eof) {putln ("eof"); break;}
    catch (invcalls.invinput) {putln ("catch invalid input");}
}
TEST178
        echo '      ' "$DINO $test_file 2>$stderr"
	cat >$ftemp  <<'INPUT178'
'c'"aaaaa"1000 10e+10[][2][2:2][2:[2]][2,2.2, 2:[10, 'c', "aaa", 10.7]]
{10, 2:"10"}{[2,5]:{1:5, 5}, 10:[10, 'c']}[2,3] [3,2] [3,3]
INPUT178
        if $DINO $test_file 2>$stderr >$stdout ; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT178' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{2:"10", 10:10}
{10:[10, 'c'], [2, 5]:{1:5, 5:5}}
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT178
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT178-2' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{2:"10", 10:10}
{10:[10, 'c'], [2, 5]:{1:5, 5:5}}
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT178-2
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT178-3' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{2:"10", 10:10}
{[2, 5]:{1:5, 5:5}, 10:[10, 'c']}
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT178-3
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT178-4' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{2:"10", 10:10}
{[2, 5]:{1:5, 5:5}, 10:[10, 'c']}
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT178-4
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 179.
if test $result = ok -a $start_test_number -le 179; then
	echo test 179
        cat >$test_file <<'TEST179'
println (scanln ());
TEST179
        echo '      ' "echo 1000000000000|$DINO $test_file 2>$stderr"
        if echo 1000000000000|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT179' && $CMP $stderr $ftemp2; then
test.d:1:17: system error - result too big (small): `string-to-int conversion'
OUTPUT179
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 180.
if test $result = ok -a $start_test_number -le 180; then
	echo test 180
        cat >$test_file <<'TEST180'
println (scanln ());
TEST180
        echo '      ' "echo 1000000000000e1000|$DINO $test_file 2>$stderr"
        if echo 1000000000000e1000|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT180' && $CMP $stderr $ftemp2; then
test.d:1:17: system error - result too big (small): `string-to-float conversion'
OUTPUT180
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 181.
if test $result = ok -a $start_test_number -le 181; then
	echo test 181
        cat >$test_file <<'TEST181'
println (scanln ());
TEST181
        echo '      ' "echo 1000000000000e-1000|$DINO $test_file 2>$stderr"
        if echo 1000000000000e-1000|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT181' && $CMP $stderr $ftemp2; then
test.d:1:17: system error - result too big (small): `string-to-float conversion'
OUTPUT181
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 182.
if test $result = ok -a $start_test_number -le 182; then
	echo test 182
        cat >$test_file <<'TEST182'
var i=100000000000;
TEST182
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT182' && $CMP $stderr $ftemp2; then
test.d:1:19: too big integer value
OUTPUT182
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 183.
if test $result = ok -a $start_test_number -le 183; then
	echo test 183
        cat >$test_file <<'TEST183'
var i=-100000000000;
TEST183
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT183' && $CMP $stderr $ftemp2; then
test.d:1:20: too big integer value
OUTPUT183
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 184.
if test $result = ok -a $start_test_number -le 184; then
	echo test 184
        cat >$test_file <<'TEST184'
var f=1000000000000e1000;
TEST184
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT184' && $CMP $stderr $ftemp2; then
test.d:1:25: too big or too small floating point value
OUTPUT184
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 185.
if test $result = ok -a $start_test_number -le 185; then
	echo test 185
        cat >$test_file <<'TEST185'
var f=1000000000000e-1000;
TEST185
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT185' && $CMP $stderr $ftemp2; then
test.d:1:26: too big or too small floating point value
OUTPUT185
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 186.
if test $result = ok -a $start_test_number -le 186; then
	echo test 186
        cat >$test_file <<'TEST186'
var f=-1000000000000e1000;
TEST186
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT186' && $CMP $stderr $ftemp2; then
test.d:1:26: too big or too small floating point value
OUTPUT186
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 187.
if test $result = ok -a $start_test_number -le 187; then
	echo test 187
        cat >$test_file <<'TEST187'
var i="1000000000000" + 0;
TEST187
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT187' && $CMP $stderr $ftemp2; then
test.d:1:23: system error - result too big (small): `string-to-int conversion'
OUTPUT187
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 188.
if test $result = ok -a $start_test_number -le 188; then
	echo test 188
        cat >$test_file <<'TEST188'
var f="1000000000000e1000" + 0.0;
TEST188
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT188' && $CMP $stderr $ftemp2; then
test.d:1:28: system error - result too big (small): `string-to-float conversion'
OUTPUT188
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 189.
if test $result = ok -a $start_test_number -le 189; then
	echo test 189
        cat >$test_file <<'TEST189'
thread t1 {
  put ("thread 1: ");print (curr_thread); put (" "); println (main_thread);
}

thread t2 {
  put ("thread 2: ");print (curr_thread); put (" "); println (main_thread);
}

put ("thread 2: ");print (curr_thread); put (" "); println (main_thread);

t1 ();
t2 ();
TEST189
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT189' && $CMP $ftemp $ftemp2; then
thread 2: main thread main thread
thread 1: thread 1 t1() main thread
thread 2: thread 2 t2() main thread
OUTPUT189
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 190.
if test $result = ok -a $start_test_number -le 190; then
	echo test 190
        cat >$test_file <<'TEST190'
var i;
for(i=0;;i++) {
  if (i == 10)
    break;
  putln (i);
}
TEST190
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout ; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT190' && $CMP $stdout $ftemp2; then
0
1
2
3
4
5
6
7
8
9
OUTPUT190
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 191.
if test $result = ok -a $start_test_number -le 191; then
	echo test 191
        cat >$test_file <<'TEST191'
var f = open ("1000000000000e1000", "r");
TEST191
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT191' && $CMP $stderr $ftemp2; then
test.d:1:14: system error - no such file or directory: `open'
OUTPUT191
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 192.
if test $result = ok -a $start_test_number -le 192; then
	echo test 192
        cat >$test_file <<'TEST192'
var f;
try {
 f = open ("1000000000000e1000", "r");
} catch (errors.invcall) {}
close (f);
TEST192
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT192' && $CMP $stderr $ftemp2; then
test.d:5:8: run time error - undefined `f' value access
OUTPUT192
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 193.
if test $result = ok -a $start_test_number -le 193; then
	echo test 193
        cat >$test_file <<'TEST193'
var f = open ("1000000000000e1000");
TEST193
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT193' && $CMP $stderr $ftemp2; then
test.d:1:14: run time error - invalid number of actual parameters for `open'
OUTPUT193
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 194.
if test $result = ok -a $start_test_number -le 194; then
	echo test 194
        cat >$test_file <<'TEST194'
var f = open ("1000000000000e1000", "k");
TEST194
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT194' && $CMP $stderr $ftemp2; then
test.d:1:14: system error - invalid argument: `open'
OUTPUT194
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 195.
if test $result = ok -a $start_test_number -le 195; then
	echo test 195
        cat >$test_file <<'TEST195'
var f = open ("1000000000000e1000", nil);
TEST195
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT195' && $CMP $stderr $ftemp2; then
test.d:1:14: run time error - invalid parameter type of `open'
OUTPUT195
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 196.
if test $result = ok -a $start_test_number -le 196; then
	echo test 196
        cat >$test_file <<'TEST196'
close ();
TEST196
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT196' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `close'
OUTPUT196
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 197.
if test $result = ok -a $start_test_number -le 197; then
	echo test 197
        cat >$test_file <<'TEST197'
close (nil);
TEST197
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT197' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `close'
OUTPUT197
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 198.
if test $result = ok -a $start_test_number -le 198; then
	echo test 198
        cat >$test_file <<'TEST198'
flush ();
TEST198
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT198' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `flush'
OUTPUT198
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 199.
if test $result = ok -a $start_test_number -le 199; then
	echo test 199
        cat >$test_file <<'TEST199'
flush (nil);
TEST199
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT199' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `flush'
OUTPUT199
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 200.
if test $result = ok -a $start_test_number -le 200; then
	echo test 200
        cat >$test_file <<'TEST200'
put ("aaaaaa");
fputln (stderr, "end of output");
flush (stdout);
fputln (stderr, "end of output");
TEST200
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT200' && $CMP $stdout $ftemp2; then
end of output
aaaaaaend of output
OUTPUT200
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT200-2' && $CMP $stdout $ftemp2; then
aaaaaaend of output
end of output
OUTPUT200-2
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 201.
if test $result = ok -a $start_test_number -le 201; then
	echo test 201
        cat >$test_file <<'TEST201'
var f = popen ("1000000000000e1000");
TEST201
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT201' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid number of actual parameters for `popen'
OUTPUT201
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 202.
if test $result = ok -a $start_test_number -le 202; then
	echo test 202
        cat >$test_file <<'TEST202'
var f=popen("cat test.d", "r"), l;
for (;;)
{
  try {l = fgetln (f);} catch (invcalls.eof) {break;}
  putln (l);
}
pclose (f);
TEST202
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT202' && $CMP $stdout $ftemp2; then
var f=popen("cat test.d", "r"), l;
for (;;)
{
  try {l = fgetln (f);} catch (invcalls.eof) {break;}
  putln (l);
}
pclose (f);
OUTPUT202
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 203.
if test $result = ok -a $start_test_number -le 203; then
	echo test 203
        cat >$test_file <<'TEST203'
var f=popen("cat >_temp.out", "w"), l;
fputln (f, "tests ");
fputln (f, "tests #1");
pclose (f);
TEST203
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT203' && $CMP $ftemp $ftemp2; then
tests 
tests #1
OUTPUT203
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 204.
if test $result = ok -a $start_test_number -le 204; then
	echo test 204
        cat >$test_file <<'TEST204'
var f = popen ("cat test.d", "rw");
TEST204
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT204' && $CMP $stderr $ftemp2; then
test.d:1:15: system error - invalid argument: `popen'
OUTPUT204
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 205.
if test $result = ok -a $start_test_number -le 205; then
	echo test 205
        cat >$test_file <<'TEST205'
var f = popen ("1000000000000e1000", nil);
TEST205
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT205' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid parameter type of `popen'
OUTPUT205
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 206.
if test $result = ok -a $start_test_number -le 206; then
	echo test 206
        cat >$test_file <<'TEST206'
pclose ();
TEST206
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT206' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `pclose'
OUTPUT206
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 207.
if test $result = ok -a $start_test_number -le 207; then
	echo test 207
        cat >$test_file <<'TEST207'
pclose (nil);
TEST207
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT207' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `pclose'
OUTPUT207
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 208.
if test $result = ok -a $start_test_number -le 208; then
	echo test 208
        cat >$test_file <<'TEST208'
println (eltype ([1,2,3]));
println (eltype ([1.0,2,'c']));
println (eltype ([]));
TEST208
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT208' && $CMP $stdout $ftemp2; then
int
nil
type (nil)
OUTPUT208
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 209.
if test $result = ok -a $start_test_number -le 209; then
	echo test 209
        cat >$test_file <<'TEST209'
eltype ();
TEST209
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT209' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `eltype'
OUTPUT209
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 210.
if test $result = ok -a $start_test_number -le 210; then
	echo test 210
        cat >$test_file <<'TEST210'
eltype (1);
TEST210
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT210' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `eltype'
OUTPUT210
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 211.
if false; then
# Removed deprecated operations.
	echo test 211
        cat >$test_file <<'TEST211'
class c {
var i = 10;
}
var i=c();
putln (("i")->i);
("i")->i = 20;
putln (("i")->i);
("i")->i = 30;
putln (("i")->i);
("i")->i = 40;
putln (("i")->i);
("i")->i = 50;
putln (("i")->i);
TEST211
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT211' && $CMP $stdout $ftemp2; then
10
20
30
40
50
OUTPUT211
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 212.
if false; then
# Removed deprecated operations.
	echo test 212
        cat >$test_file <<'TEST212'
class c {
var i = 10;
}
var i=c();
putln ((10)->i);
TEST212
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT212' && $CMP $stderr $ftemp2; then
test.d:5:13: left operand of arrow must be of string type
OUTPUT212
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 213.
if false; then
# Removed deprecated operations.
	echo test 213
        cat >$test_file <<'TEST213'
class c {
var i = 10;
}
var i=c();
var j=[];
putln ((j)->i);
TEST213
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT213' && $CMP $stderr $ftemp2; then
test.d:6:12: run time error - decl name is not string (operation "->" or "*")
OUTPUT213
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 214.
if false; then
# Removed deprecated operations.
	echo test 214
        cat >$test_file <<'TEST214'
class c {
var i = 10;
}
var i=c();
var j=10;
putln (("i")->k);
TEST214
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT214' && $CMP $stderr $ftemp2; then
test.d:6:14: there is no such declaration in a block
OUTPUT214
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 215.
if false; then
# Removed deprecated operations.
	echo test 215
        cat >$test_file <<'TEST215'
class c {
var i = 10;
}
var i=c();
var j=10;
putln (("i")->j);
TEST215
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT215' && $CMP $stderr $ftemp2; then
test.d:6:14: run time error - there is no such declaration in given class
OUTPUT215
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 216.
if test $result = ok -a $start_test_number -le 216; then
	echo test 216
        cat >$test_file <<'TEST216'
var f=open ("_temp2.out", "w");
close(f);
putln (ftype ("_temp2.out"));
remove ("_temp2.out");
TEST216
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT216' && $CMP $stdout $ftemp2; then
f
OUTPUT216
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 217.
if test $result = ok -a $start_test_number -le 217; then
	echo test 217
        cat >$test_file <<'TEST217'
remove ();
TEST217
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT217' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `remove'
OUTPUT217
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 218.
if test $result = ok -a $start_test_number -le 218; then
	echo test 218
        cat >$test_file <<'TEST218'
remove (nil);
TEST218
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT218' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `remove'
OUTPUT218
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 219.
if test $result = ok -a $start_test_number -le 219; then
	echo test 219
        cat >$test_file <<'TEST219'
var f=open ("_temp.out", "w");
close(f);
putln (ftype ("_temp.out"));
rename ("_temp.out", "_temp2.out");
putln (ftype ("_temp2.out"));
remove ("_temp2.out");
TEST219
	rm -f $ftemp2
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT219' && $CMP $stdout $ftemp2; then
f
f
OUTPUT219
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 220.
if test $result = ok -a $start_test_number -le 220; then
	echo test 220
        cat >$test_file <<'TEST220'
rename (nil);
TEST220
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT220' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `rename'
OUTPUT220
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 221.
if test $result = ok -a $start_test_number -le 221; then
	echo test 221
        cat >$test_file <<'TEST221'
rename ("aaa", nil);
TEST221
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT221' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `rename'
OUTPUT221
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 222.
if test $result = ok -a $start_test_number -le 222; then
	echo test 222
        cat >$test_file <<TEST222
mkdir ("__tempdir");
putln (ftype ("__tempdir"));
TEST222
        rm -rf $tempdir
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT222' && $CMP $stdout $ftemp2; then
d
OUTPUT222
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 223.
if test $result = ok -a $start_test_number -le 223; then
	echo test 223
        cat >$test_file <<'TEST223'
mkdir ();
TEST223
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT223' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `mkdir'
OUTPUT223
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 224.
if test $result = ok -a $start_test_number -le 224; then
	echo test 224
        cat >$test_file <<'TEST224'
mkdir (nil);
TEST224
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT224' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `mkdir'
OUTPUT224
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 225.
if test $result = ok -a $start_test_number -le 225; then
	echo test 225
        cat >$test_file <<TEST225
mkdir ("__tempdir");
putln (ftype ("__tempdir"));
rmdir ("__tempdir");
TEST225
        rm -rf $tempdir
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT225' && $CMP $stdout $ftemp2 && test ! -d $tempdir; then
d
OUTPUT225
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 226.
if test $result = ok -a $start_test_number -le 226; then
	echo test 226
        cat >$test_file <<'TEST226'
rmdir ();
TEST226
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT226' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `rmdir'
OUTPUT226
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 227.
if test $result = ok -a $start_test_number -le 227; then
	echo test 227
        cat >$test_file <<'TEST227'
rmdir (nil);
TEST227
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT227' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `rmdir'
OUTPUT227
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 228.
if test $result = ok -a $start_test_number -le 228; then
	echo test 228
        cat >$test_file <<TEST228
putln (getcwd ());
TEST228
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/^[A-Za-z]://' $stdout|sed 's,\\,/,g' >$ftemp
                echo '      ' egrep "$ftemp2" $ftemp
                if uname | fgrep CYGWIN && test x$msvc != x;then
                   echo `pwd`| sed 's%/cygdrive/[a-z]%%' >$ftemp2
                else
                   echo `pwd` >$ftemp2
                fi
                echo '      ' $CMP $ftemp2 $ftemp
                if $CMP $ftemp $ftemp2; then
                        result=ok
                else
                        result=ok
			echo difference in the expected and result:
                        diff -c $ftemp2 $ftemp
                fi
        else
                result=fail
        fi
fi

# Test 229.
if test $result = ok -a $start_test_number -le 229; then
	echo test 229
        cat >$test_file <<'TEST229'
getcwd (1);
TEST229
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT229' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `getcwd'
OUTPUT229
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 230.
if test $result = ok -a $start_test_number -le 230; then
	echo test 230
        cat >$test_file <<TEST230
chdir ("__tempdir");
putln (getcwd ());
TEST230
        rm -rf $tempdir
        mkdir $tempdir
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/^[A-Za-z]://' $stdout|sed 's,\\,/,g' >$ftemp
                if uname | fgrep CYGWIN && test x$msvc != x;then
                   echo `pwd`/$tempdir| sed 's%/cygdrive/[a-z]%%' >$ftemp2
                else
                   echo `pwd`/$tempdir >$ftemp2
                fi
                echo '      ' $CMP $ftemp $ftemp2
                if  $CMP $ftemp $ftemp2; then
                        result=ok
                else
                        result=ok
			echo difference in the expected and result:
                        diff -c $ftemp2 $ftemp
                fi
        else
                result=fail
        fi
fi

# Test 231.
if test $result = ok -a $start_test_number -le 231; then
	echo test 231
        cat >$test_file <<'TEST231'
chdir ();
TEST231
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT231' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `chdir'
OUTPUT231
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 232.
if test $result = ok -a $start_test_number -le 232; then
	echo test 232
        cat >$test_file <<'TEST232'
chdir (nil);
TEST232
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT232' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `chdir'
OUTPUT232
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 233.
if test $result = ok -a $start_test_number -le 233; then
	echo test 233
        cat >$test_file <<'TEST233'
chdir ("abracadabra");
TEST233
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT233' && $CMP $stderr $ftemp2; then
test.d:1:7: system error - no such file or directory: `chdir'
OUTPUT233
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 234.
if test $result = ok -a $start_test_number -le 234; then
	echo test 234
        cat >$test_file <<'TEST234'
rmdir ("abracadabra");
TEST234
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT234' && $CMP $stderr $ftemp2; then
test.d:1:7: system error - no such file or directory: `rmdir'
OUTPUT234
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 235.
if test $result = ok -a $start_test_number -le 235; then
	echo test 235
        cat >$test_file <<'TEST235'
mkdir ("abracadabra/abaraca");
TEST235
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT235' && $CMP $stderr $ftemp2; then
test.d:1:7: system error - no such file or directory: `mkdir'
OUTPUT235
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 236.
if test $result = ok -a $start_test_number -le 236; then
	echo test 236
        cat >$test_file <<TEST236
putln (isatty (open ("test.d", "r")));
TEST236
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT236' && $CMP $stdout $ftemp2; then
0
OUTPUT236
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 237.
if test $result = ok -a $start_test_number -le 237; then
	echo test 237
        cat >$test_file <<'TEST237'
isatty ();
TEST237
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT237' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `isatty'
OUTPUT237
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 238.
if test $result = ok -a $start_test_number -le 238; then
	echo test 238
        cat >$test_file <<'TEST238'
isatty (nil);
TEST238
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT238' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `isatty'
OUTPUT238
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 239.
if test $result = ok -a $start_test_number -le 239; then
	echo test 239
        cat >$test_file <<TEST239
chumod ("test.d", "rwx");
putln (fumode ("test.d"));
TEST239
        if uname | fgrep CYGWIN; then
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT239' && $CMP $stdout $ftemp2; then
rwx
OUTPUT239
                        result=ok
                elif  cat >$ftemp2 <<'OUTPUT239-1' && $CMP $stdout $ftemp2; then
rw
OUTPUT239-1
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT239-2' && $CMP $stdout $ftemp2; then
rwx
OUTPUT239-2
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	fi
fi

# Test 240.
if test $result = ok -a $start_test_number -le 240; then
	echo test 240
        cat >$test_file <<'TEST240'
chumod (nil);
TEST240
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT240' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `chumod'
OUTPUT240
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 241.
if test $result = ok -a $start_test_number -le 241; then
	echo test 241
        cat >$test_file <<'TEST241'
chumod (nil, "aaa");
TEST241
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT241' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `chumod'
OUTPUT241
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 242.
if test $result = ok -a $start_test_number -le 242; then
	echo test 242
        cat >$test_file <<'TEST242'
chumod ("abracadabra", "r");
TEST242
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT242' && $CMP $stderr $ftemp2; then
test.d:1:8: system error - no such file or directory: `chumod'
OUTPUT242
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 243.
if test $result = ok -a $start_test_number -le 243; then
	echo test 243
        cat >$test_file <<TEST243
chgmod ("test.d", "rwx");
putln (fgmode ("test.d"));
TEST243
        if uname | fgrep CYGWIN; then
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT243' && $CMP $stdout $ftemp2; then

OUTPUT243
                        result=ok
		elif cat >$ftemp2 <<'OUTPUT243-1' && $CMP $stdout $ftemp2; then
r
OUTPUT243-1
                        result=ok
		elif cat >$ftemp2 <<'OUTPUT243-11' && $CMP $stdout $ftemp2; then
rw
OUTPUT243-11
                        result=ok
		elif cat >$ftemp2 <<'OUTPUT243-12' && $CMP $stdout $ftemp2; then
rwx
OUTPUT243-12
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT243-2' && $CMP $stdout $ftemp2; then
rwx
OUTPUT243-2
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	fi
fi

# Test 244.
if test $result = ok -a $start_test_number -le 244; then
	echo test 244
        cat >$test_file <<'TEST244'
chgmod (nil);
TEST244
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT244' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `chgmod'
OUTPUT244
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 241.
if test $result = ok -a $start_test_number -le 245; then
	echo test 245
        cat >$test_file <<'TEST245'
chgmod (nil, "aaa");
TEST245
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT245' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `chgmod'
OUTPUT245
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 246.
if test $result = ok -a $start_test_number -le 246; then
	echo test 246
        cat >$test_file <<'TEST246'
chgmod ("abracadabra", "r");
TEST246
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT246' && $CMP $stderr $ftemp2; then
test.d:1:8: system error - no such file or directory: `chgmod'
OUTPUT246
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 247.
if test $result = ok -a $start_test_number -le 247; then
	echo test 247
        cat >$test_file <<TEST247
chomod ("test.d", "rwx");
putln (fomode ("test.d"));
TEST247
        if uname | fgrep CYGWIN; then
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT247' && $CMP $stdout $ftemp2; then

OUTPUT247
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT247-1' && $CMP $stdout $ftemp2; then
r
OUTPUT247-1
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT247-11' && $CMP $stdout $ftemp2; then
rw
OUTPUT247-11
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT247-12' && $CMP $stdout $ftemp2; then
rwx
OUTPUT247-12
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT247-2' && $CMP $stdout $ftemp2; then
rwx
OUTPUT247-2
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	fi
fi

# Test 248.
if test $result = ok -a $start_test_number -le 248; then
	echo test 248
        cat >$test_file <<'TEST248'
chomod (nil);
TEST248
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT248' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `chomod'
OUTPUT248
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 241.
if test $result = ok -a $start_test_number -le 249; then
	echo test 249
        cat >$test_file <<'TEST249'
chomod (nil, "aaa");
TEST249
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT249' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `chomod'
OUTPUT249
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 250.
if test $result = ok -a $start_test_number -le 250; then
	echo test 250
        cat >$test_file <<'TEST250'
chomod ("abracadabra", "r");
TEST250
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT250' && $CMP $stderr $ftemp2; then
test.d:1:8: system error - no such file or directory: `chomod'
OUTPUT250
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 251.
if false; then
# Removed deprecated operations.
	echo test 251
        cat >$test_file <<'TEST251'
func f ()
{
  putln ("call f");
}
class c ()
{
  putln ("call c");
}
var i = 10;
putln (*("i"));
*("i") = 20;
putln (*("i"));
*("i") = 30;
putln (*("i"));
*("i") = 40;
putln (*("i"));
*("i") = 50;
putln (*("i"));
*("f") ();
*("c") ();
TEST251
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT251' && $CMP $stdout $ftemp2; then
10
20
30
40
50
call f
call c
OUTPUT251
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 252.
if false; then
# Removed deprecated operations.
	echo test 252
        cat >$test_file <<'TEST252'
var i=10;
putln (*(10));
TEST252
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT252' && $CMP $stderr $ftemp2; then
test.d:2:8: operand of unary `*' must be of string type
OUTPUT252
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 253.
if false; then
# Removed deprecated operations.
	echo test 253
        cat >$test_file <<'TEST253'
var i=10;
var j={};
putln (*(j));
TEST253
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT253' && $CMP $stderr $ftemp2; then
test.d:3:8: run time error - decl name is not string (operation "->" or "*")
OUTPUT253
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 254.
if false; then
# Removed deprecated operations.
	echo test 254
        cat >$test_file <<'TEST254'
func f {}
*("f") = 10;
TEST254
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT254' && $CMP $stderr $ftemp2; then
test.d:2:1: run time error - usage function as variable
OUTPUT254
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 255.
if false; then
# Removed deprecated operations.
	echo test 255
        cat >$test_file <<'TEST255'
class c {}
*("c") = 10;
TEST255
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT255' && $CMP $stderr $ftemp2; then
test.d:2:1: run time error - usage class as variable
OUTPUT255
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 256.
if false; then
# Removed deprecated operations.
	echo test 256
        cat >$test_file <<'TEST256'
class c()
{
    func f {}
}
var i = c();
("i")->f = 10;
TEST256
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT256' && $CMP $stderr $ftemp2; then
test.d:6:7: run time error - usage function as variable
OUTPUT256
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 257.
if false; then
# Removed deprecated operations.
	echo test 257
        cat >$test_file <<'TEST257'
class c()
{
    class c {}
}
var i = c();
("i")->c = 10;
TEST257
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT257' && $CMP $stderr $ftemp2; then
test.d:6:7: run time error - usage class as variable
OUTPUT257
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 258.
if test $result = ok -a $start_test_number -le 258; then
	echo test 258: mpi package
        cat >$test_file <<'TEST258'
include "mpi";

var mpi1 = mpis.from_string(1, "10");
var mpi2 = mpis.from_string(1, "5");
putln (mpis.to_string (mpis.add (mpi1, mpi2)));
putln (mpis.to_string (mpis.subtract (mpi1, mpi2)));
putln (mpis.to_string (mpis.subtract (mpi2, mpi1)));
putln (mpis.to_string (mpis.multiply (mpi1, mpi2)));
putln (mpis.to_string (mpis.divide (mpi1, mpi2)));
putln (mpis.to_string (mpis.remainder (mpi1, mpi2)));
putln (mpis.eq (mpi1, mpi2));
putln (mpis.ne (mpi1, mpi2));
putln (mpis.lt (mpi1, mpi2));
putln (mpis.le (mpi1, mpi2));
putln (mpis.gt (mpi1, mpi2));
putln (mpis.ge (mpi1, mpi2));

try {
  mpis.multiply (mpis.multiply (mpi1, mpi2), mpis.multiply (mpi1, mpi2));
} catch (mpis.mpi_excepts.mpi_overflow) {
  putln ("got overflow 1");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.to_string (mpis.multiply (mpis.multiply (mpi1, mpi2), mpis.multiply (mpi1, mpi2))));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
mpi2 = mpis.from_string(2, "300");
try {
  mpis.change_size (mpi2, 1);
} catch (mpis.mpi_excepts.mpi_overflow) {
  putln ("got overflow 2");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.to_string (mpis.change_size (mpi2, 1)));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;

mpi1 = mpis.unsigned_from_string(1, "10");
mpi2 = mpis.unsigned_from_string(1, "5");
putln (mpis.unsigned_to_string (mpis.unsigned_add (mpi1, mpi2)));
putln (mpis.unsigned_to_string (mpis.unsigned_subtract (mpi1, mpi2)));
try {
  putln (mpis.unsigned_to_string (mpis.unsigned_subtract (mpi2, mpi1)));
} catch (mpis.mpi_excepts.mpi_overflow) {
  putln ("got overflow 3");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.unsigned_to_string (mpis.unsigned_subtract (mpi2, mpi1)));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
putln (mpis.unsigned_to_string (mpis.unsigned_multiply (mpi1, mpi2)));
putln (mpis.unsigned_to_string (mpis.unsigned_divide (mpi1, mpi2)));
putln (mpis.unsigned_to_string (mpis.unsigned_remainder (mpi1, mpi2)));
putln (mpis.unsigned_eq (mpi1, mpi2));
putln (mpis.unsigned_ne (mpi1, mpi2));
putln (mpis.unsigned_lt (mpi1, mpi2));
putln (mpis.unsigned_le (mpi1, mpi2));
putln (mpis.unsigned_gt (mpi1, mpi2));
putln (mpis.unsigned_ge (mpi1, mpi2));

try {
  mpis.unsigned_multiply (mpis.unsigned_multiply (mpi1, mpi2), mpis.unsigned_multiply (mpi1, mpi2));
} catch (mpis.mpi_excepts.mpi_overflow) {
  putln ("got overflow 4");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.unsigned_to_string (mpis.unsigned_multiply (mpis.unsigned_multiply (mpi1, mpi2), mpis.unsigned_multiply (mpi1, mpi2))));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
mpi2 = mpis.unsigned_from_string(2, "300");
try {
  mpis.unsigned_change_size (mpi2, 1);
} catch (mpis.mpi_excepts.mpi_overflow) {
  putln ("got overflow 5");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.unsigned_to_string (mpis.unsigned_change_size (mpi2, 1)));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;

mpi1 = mpis.from_string(50, "10000000000000000000000000000000000000000000000");
mpi2 = mpis.from_string(50, "5000000000000000000000000000000000000000000000");
putln (mpis.to_string (mpis.add (mpi1, mpi2)));
putln (mpis.to_string (mpis.subtract (mpi1, mpi2)));
putln (mpis.to_string (mpis.subtract (mpi2, mpi1)));
putln (mpis.to_string (mpis.multiply (mpi1, mpi2)));
putln (mpis.to_string (mpis.divide (mpi1, mpi2)));
putln (mpis.to_string (mpis.remainder (mpi1, mpi2)));
putln (mpis.eq (mpi1, mpi2));
putln (mpis.ne (mpi1, mpi2));
putln (mpis.lt (mpi1, mpi2));
putln (mpis.le (mpi1, mpi2));
putln (mpis.gt (mpi1, mpi2));
putln (mpis.ge (mpi1, mpi2));
try {
  mpis.multiply (mpis.multiply (mpi1, mpi2), mpis.multiply (mpi1, mpi2));
} catch (mpis.mpi_excepts.mpi_overflow) {
  putln ("got overflow 6");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.to_string (mpis.multiply (mpis.multiply (mpi1, mpi2), mpis.multiply (mpi1, mpi2))));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
try {
  mpis.change_size (mpi2, 2);
} catch (mpis.mpi_excepts.mpi_overflow) {
  putln ("got overflow 7");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.to_string (mpis.change_size (mpi2, 2)));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;

mpi1 = mpis.unsigned_from_string(50, "10000000000000000000000000000000000000000000000");
mpi2 = mpis.unsigned_from_string(50, "5000000000000000000000000000000000000000000000");
putln (mpis.unsigned_to_string (mpis.unsigned_add (mpi1, mpi2)));
putln (mpis.unsigned_to_string (mpis.unsigned_subtract (mpi1, mpi2)));
try {
  putln (mpis.unsigned_to_string (mpis.unsigned_subtract (mpi2, mpi1)));
} catch (mpis.mpi_excepts.mpi_overflow) {
  putln ("got overflow 8");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.unsigned_to_string (mpis.unsigned_subtract (mpi2, mpi1)));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
putln (mpis.unsigned_to_string (mpis.unsigned_multiply (mpi1, mpi2)));
putln (mpis.unsigned_to_string (mpis.unsigned_divide (mpi1, mpi2)));
putln (mpis.unsigned_to_string (mpis.unsigned_remainder (mpi1, mpi2)));
putln (mpis.unsigned_eq (mpi1, mpi2));
putln (mpis.unsigned_ne (mpi1, mpi2));
putln (mpis.unsigned_lt (mpi1, mpi2));
putln (mpis.unsigned_le (mpi1, mpi2));
putln (mpis.unsigned_gt (mpi1, mpi2));
putln (mpis.unsigned_ge (mpi1, mpi2));
try {
  mpis.unsigned_multiply (mpis.unsigned_multiply (mpi1, mpi2), mpis.unsigned_multiply (mpi1, mpi2));
} catch (mpis.mpi_excepts.mpi_overflow) {
  putln ("got overflow 9");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.unsigned_to_string (mpis.unsigned_multiply (mpis.unsigned_multiply (mpi1, mpi2), mpis.unsigned_multiply (mpi1, mpi2))));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
try {
  mpis.unsigned_change_size (mpi2, 2);
} catch (mpis.mpi_excepts.mpi_overflow) {
  putln ("got overflow 10");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.unsigned_to_string (mpis.unsigned_change_size (mpi2, 2)));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
TEST258
        if uname | fgrep CYGWIN; then
            echo '      ' $DINO -L./d_mpi.dll -I@srcdir@ $test_file "2>$stderr"
	    if $DINO -Lmpi.dll -I@srcdir@ $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT258' && $CMP $stdout $ftemp2; then
15
5
-5
50
2
0
0
1
0
0
1
1
got overflow 1
-60
ovfw=1
got overflow 2
44
ovfw=1
15
5
got overflow 3
251
ovfw=1
50
2
0
0
1
0
0
1
1
got overflow 4
196
ovfw=1
got overflow 5
44
ovfw=1
15000000000000000000000000000000000000000000000
5000000000000000000000000000000000000000000000
-5000000000000000000000000000000000000000000000
50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
2
0
0
1
0
0
1
1
got overflow 6
867904737743324110893126166364363704770614348168184133037106651590308130409865771824596108187979317115712568128322928640
ovfw=1
got overflow 7
0
ovfw=1
15000000000000000000000000000000000000000000000
5000000000000000000000000000000000000000000000
got overflow 8
2582249878086908589655919172003011874329705792829223512830659356540647622011841194629645353280137831435903171972747493376
ovfw=1
50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
2
0
0
1
0
0
1
1
got overflow 9
867904737743324110893126166364363704770614348168184133037106651590308130409865771824596108187979317115712568128322928640
ovfw=1
got overflow 10
0
ovfw=1
OUTPUT258
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
            echo '      ' $DINO -L./d_mpi.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file "2>$stderr"
	    if $DINO -L./d_mpi.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT258' && $CMP $stdout $ftemp2; then
15
5
-5
50
2
0
0
1
0
0
1
1
got overflow 1
-60
ovfw=1
got overflow 2
44
ovfw=1
15
5
got overflow 3
251
ovfw=1
50
2
0
0
1
0
0
1
1
got overflow 4
196
ovfw=1
got overflow 5
44
ovfw=1
15000000000000000000000000000000000000000000000
5000000000000000000000000000000000000000000000
-5000000000000000000000000000000000000000000000
50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
2
0
0
1
0
0
1
1
got overflow 6
867904737743324110893126166364363704770614348168184133037106651590308130409865771824596108187979317115712568128322928640
ovfw=1
got overflow 7
0
ovfw=1
15000000000000000000000000000000000000000000000
5000000000000000000000000000000000000000000000
got overflow 8
2582249878086908589655919172003011874329705792829223512830659356540647622011841194629645353280137831435903171972747493376
ovfw=1
50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
2
0
0
1
0
0
1
1
got overflow 9
867904737743324110893126166364363704770614348168184133037106651590308130409865771824596108187979317115712568128322928640
ovfw=1
got overflow 10
0
ovfw=1
OUTPUT258
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
        fi
fi

# Test 259.
if test $result = ok -a $start_test_number -le 259; then
	echo test 259: Redefinitions
        cat >$test_file <<'TEST259'
val i = 10;
func f { return i;}
val i = 20;
putln (f ());
func f { return i;}
putln (f ());
TEST259
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT259' && $CMP $stdout $ftemp2; then
10
20
OUTPUT259
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 260.
if test $result = ok -a $start_test_number -le 260; then
	echo test 260: Redefinitions
        cat >$test_file <<'TEST260'
val i = 10;
func f { return 10;}
val i = 20;
func f2 { return i + f ();}
putln (f2 ());
TEST260
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT260' && $CMP $stdout $ftemp2; then
30
OUTPUT260
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 261.
if test $result = ok -a $start_test_number -le 261; then
	echo test 261
        cat >$test_file <<'TEST261'
class c {
  var -i;
  i = 0;
}

var i;
i = c ();
i.i = 1;
TEST261
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT261' && $CMP $stderr $ftemp2; then
test.d:8:2: run time error - access to private decl `i' from outside
OUTPUT261
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 262.
if test $result = ok -a $start_test_number -le 262; then
	echo test 262
        cat >$test_file <<'TEST262'
var ci;
{
  var i;
  class c {
  }
  ci = c ();
  i = 0;
}

context(ci).i = 1;
TEST262
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT262' && $CMP $stderr $ftemp2; then
test.d:10:12: run time error - access to private decl `i' from outside
OUTPUT262
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 263.
if test $result = ok -a $start_test_number -le 263; then
	echo test 263: Forward and matched decl access
        cat >$test_file <<'TEST263'
func f;
func +f () {}
TEST263
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT263' && $CMP $stderr $ftemp2; then
test.d:2:7: forward and matched decls of `f' have different access/final attributes
test.d:1:6: (previous declaration of identifier `f')
OUTPUT263
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 264.
if test $result = ok -a $start_test_number -le 264; then
	echo test 264: Forward and matched decl final
        cat >$test_file <<'TEST264'
final class c;
class c () {}
TEST264
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT264' && $CMP $stderr $ftemp2; then
test.d:2:7: forward and matched decls of `c' have different access/final attributes
test.d:1:13: (previous declaration of identifier `c')
OUTPUT264
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 265.
if test $result = ok -a $start_test_number -le 265; then
	echo test 265
        cat >$test_file <<'TEST265'
func f;
func +f;
func f() {}
TEST265
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT265' && $CMP $stderr $ftemp2; then
test.d:2:7: forward and matched decls of `f' have different access/final attributes
test.d:1:6: (previous declaration of identifier `f')
test.d:3:6: forward and matched decls of `f' have different access/final attributes
test.d:2:7: (previous declaration of identifier `f')
OUTPUT265
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 266.
if test $result = ok -a $start_test_number -le 266; then
	echo test 266
        cat >$test_file <<'TEST266'
argv[0] = 1;
TEST266
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT266' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - attempt to modify immutable vector
OUTPUT266
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 267.
if test $result = ok -a $start_test_number -le 267; then
	echo test 267
        cat >$test_file <<'TEST267'
atan2 (10);
TEST267
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT267' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `atan2'
OUTPUT267
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 268.
if test $result = ok -a $start_test_number -le 268; then
	echo test 268
        cat >$test_file <<'TEST268'
atan2 ({}, 10);
TEST268
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT268' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `atan2'
OUTPUT268
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 269.
if test $result = ok -a $start_test_number -le 269; then
	echo test 269
        cat >$test_file <<'TEST269'
atan2 (10, 10, 10);
TEST269
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT269' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `atan2'
OUTPUT269
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 270.
if test $result = ok -a $start_test_number -le 270; then
	echo test 270
        cat >$test_file <<'TEST270'
atan2 ();
TEST270
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT270' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `atan2'
OUTPUT270
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 271.
if test $result = ok -a $start_test_number -le 271; then
	echo test 271
        cat >$test_file <<'TEST271'
class c () {
  return 10;
}

var i;

i = c ();
TEST271
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT271' && $CMP $stderr $ftemp2; then
test.d:2:3: statement return with result is in class
OUTPUT271
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 272.
if test $result = ok -a $start_test_number -le 272; then
	echo test 272
        cat >$test_file <<'TEST272'
class c {
  {
    return 10;
  }
}

var i;

i = c ();
TEST272
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT272' && $CMP $stderr $ftemp2; then
test.d:3:5: statement return with result is in class
OUTPUT272
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 273.
if test $result = ok -a $start_test_number -le 273; then
	echo test 273
        cat >$test_file <<'TEST273'
cos ();
TEST273
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT273' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `cos'
OUTPUT273
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 274.
if test $result = ok -a $start_test_number -le 274; then
	echo test 274
        cat >$test_file <<'TEST274'
cos ({});
TEST274
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT274' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `cos'
OUTPUT274
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 275.
if test $result = ok -a $start_test_number -le 275; then
	echo test 275
        cat >$test_file <<'TEST275'
del ();
TEST275
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT275' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `del'
OUTPUT275
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 276.
if test $result = ok -a $start_test_number -le 276; then
	echo test 276
        cat >$test_file <<'TEST276'
var v;
v = "123456"; del (v, 1);
TEST276
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT276' && $CMP $stderr $ftemp2; then
test.d:2:19: run time error - attempt to modify immutable vector
OUTPUT276
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 277.
if test $result = ok -a $start_test_number -le 277; then
	echo test 277
        cat >$test_file <<'TEST277'
var t;
t = final {1, 2, 3, 4, 5, 6}; del (t, 1);
TEST277
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT277' && $CMP $stderr $ftemp2; then
test.d:2:35: run time error - attempt to modify immutable table
OUTPUT277
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 278.
if test $result = ok -a $start_test_number -le 278; then
	echo test 278
        cat >$test_file <<'TEST278'
del (10);
TEST278
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT278' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `del'
OUTPUT278
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 279.
if test $result = ok -a $start_test_number -le 279; then
	echo test 279
        cat >$test_file <<'TEST279'
del (10, 10);
TEST279
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT279' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `del'
OUTPUT279
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 280.
if test $result = ok -a $start_test_number -le 280; then
	echo test 280
        cat >$test_file <<'TEST280'
del (10,10,10,10);
TEST280
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT280' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `del'
OUTPUT280
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 281.
if test $result = ok -a $start_test_number -le 281; then
	echo test 281
        cat >$test_file <<'TEST281'
var t;
t = {10}; del (t, 10, 10);
TEST281
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT281' && $CMP $stderr $ftemp2; then
test.d:2:15: run time error - invalid number of actual parameters for `del'
OUTPUT281
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 282.
if test $result = ok -a $start_test_number -le 282; then
	echo test 282
        cat >$test_file <<'TEST282'
var v;
v = []; del (v, {});
TEST282
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT282' && $CMP $stderr $ftemp2; then
test.d:2:13: run time error - invalid parameter type of `del'
OUTPUT282
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 283.
if test $result = ok -a $start_test_number -le 283; then
	echo test 283
        cat >$test_file <<'TEST283'
var v;
v = []; del (v, 0, {});
TEST283
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT283' && $CMP $stderr $ftemp2; then
test.d:2:13: run time error - invalid parameter type of `del'
OUTPUT283
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 284.
if test $result = ok -a $start_test_number -le 284; then
	echo test 284: Extension before
        cat >$test_file <<'TEST284'
ext c {};
class c {};
TEST284
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT284' && $CMP $stderr $ftemp2; then
test.d:1:5: extension `c' before extended func or class
OUTPUT284
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 285.
if test $result = ok -a $start_test_number -le 285; then
	echo test 285
        cat >$test_file <<'TEST285'
env {"PATH"} = "abracadabra";
TEST285
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT285' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - attempt to modify immutable table
OUTPUT285
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 286.
if test $result = ok -a $start_test_number -le 286; then
	echo test 286
        cat >$test_file <<'TEST286'
ins ();
TEST286
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT286' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `ins'
OUTPUT286
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 287.
if test $result = ok -a $start_test_number -le 287; then
	echo test 287
        cat >$test_file <<'TEST287'
var v;
v = "123456"; ins (v, 1);
TEST287
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT287' && $CMP $stderr $ftemp2; then
test.d:2:19: run time error - attempt to modify immutable vector
OUTPUT287
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 288.
if test $result = ok -a $start_test_number -le 288; then
	echo test 288
        cat >$test_file <<'TEST288'
ins (10);
TEST288
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT288' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `ins'
OUTPUT288
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 289.
if test $result = ok -a $start_test_number -le 289; then
	echo test 289
        cat >$test_file <<'TEST289'
ins (10, 10);
TEST289
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT289' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `ins'
OUTPUT289
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 290.
if test $result = ok -a $start_test_number -le 290; then
	echo test 290
        cat >$test_file <<'TEST290'
ins (10,10,10,10);
TEST290
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT290' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `ins'
OUTPUT290
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 291.
if test $result = ok -a $start_test_number -le 291; then
	echo test 291
        cat >$test_file <<'TEST291'
var v;
v = []; ins (v, 1, {});
TEST291
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT291' && $CMP $stderr $ftemp2; then
test.d:2:13: run time error - invalid parameter type of `ins'
OUTPUT291
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 292.
if test $result = ok -a $start_test_number -le 292; then
	echo test 292
        cat >$test_file <<'TEST292'
insv ();
TEST292
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT292' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `insv'
OUTPUT292
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 293.
if test $result = ok -a $start_test_number -le 293; then
	echo test 293
        cat >$test_file <<'TEST293'
var v;
v = "123456"; insv (v, [1]);
TEST293
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT293' && $CMP $stderr $ftemp2; then
test.d:2:20: run time error - attempt to modify immutable vector
OUTPUT293
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 294.
if test $result = ok -a $start_test_number -le 294; then
	echo test 294
        cat >$test_file <<'TEST294'
insv (10);
TEST294
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT294' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `insv'
OUTPUT294
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 295.
if test $result = ok -a $start_test_number -le 295; then
	echo test 295
        cat >$test_file <<'TEST295'
insv (10, 10);
TEST295
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT295' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `insv'
OUTPUT295
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 296.
if test $result = ok -a $start_test_number -le 296; then
	echo test 296
        cat >$test_file <<'TEST296'
insv (10,10,10,10);
TEST296
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT296' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `insv'
OUTPUT296
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 297.
if test $result = ok -a $start_test_number -le 297; then
	echo test 297
        cat >$test_file <<'TEST297'
var v;
v = []; insv (v, [1], {});
TEST297
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT297' && $CMP $stderr $ftemp2; then
test.d:2:14: run time error - invalid parameter type of `insv'
OUTPUT297
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 298.
if test $result = ok -a $start_test_number -le 298; then
	echo test 298
        cat >$test_file <<'TEST298'
var v;
v = []; insv (v, 1);
TEST298
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT298' && $CMP $stderr $ftemp2; then
test.d:2:14: run time error - invalid parameter type of `insv'
OUTPUT298
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 299.
if test $result = ok -a $start_test_number -le 299; then
	echo test 299
        cat >$test_file <<'TEST299'
func f () {}
class c {
  ext f {}
}
TEST299
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT299' && $CMP $stderr $ftemp2; then
test.d:3:7: extension `f' before extended func or class
OUTPUT299
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 300.
if test $result = ok -a $start_test_number -le 300; then
	echo test 300
        cat >$test_file <<'TEST300'
fput ();
TEST300
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT300' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `fput'
OUTPUT300
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 301.
if test $result = ok -a $start_test_number -le 301; then
	echo test 301
        cat >$test_file <<'TEST301'
fput ("AAAA");
TEST301
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT301' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `fput'
OUTPUT301
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 302.
if test $result = ok -a $start_test_number -le 302; then
	echo test 302: Extension of non func/class
        cat >$test_file <<'TEST302'
var c;
ext c {};
TEST302
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT302' && $CMP $stderr $ftemp2; then
test.d:2:5: extension `c' of non func/class
OUTPUT302
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 303.
if test $result = ok -a $start_test_number -le 303; then
	echo test 303: Extension of forward declaration
        cat >$test_file <<'TEST303'
class c;
ext c {};
TEST303
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT303' && $CMP $stderr $ftemp2; then
test.d:2:5: extension `c' of forward declaration of func/class
OUTPUT303
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 304.
if test $result = ok -a $start_test_number -le 304; then
	echo test 304: Forward declaration for recursion
        cat >$test_file <<'TEST304'
func even;
func odd (i) { if (i == 0) return 0; return even (i - 1);}
func even (i) { if (i == 0) return 1; return odd (i - 1);}
putln (odd (10));
TEST304
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT304' && $CMP $stdout $ftemp2; then
0
OUTPUT304
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 305.
if test $result = ok -a $start_test_number -le 305; then
	echo test 305
        cat >$test_file <<'TEST305'
inside ("");
TEST305
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT305' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `inside'
OUTPUT305
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 306.
if test $result = ok -a $start_test_number -le 306; then
	echo test 306
        cat >$test_file <<'TEST306'
class c {}
inside ("", c);
TEST306
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT306' && $CMP $stderr $ftemp2; then
test.d:2:8: run time error - invalid parameter type of `inside'
OUTPUT306
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 307.
if test $result = ok -a $start_test_number -le 307; then
	echo test 307
        cat >$test_file <<'TEST307'
class c {}
inside (c,"");
TEST307
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT307' && $CMP $stderr $ftemp2; then
test.d:2:8: run time error - invalid parameter type of `inside'
OUTPUT307
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 308.
if test $result = ok -a $start_test_number -le 308; then
	echo test 308
        cat >$test_file <<'TEST308'
match ("");
TEST308
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT308' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `match'
OUTPUT308
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 309.
if test $result = ok -a $start_test_number -le 309; then
	echo test 309
        cat >$test_file <<'TEST309'
match (nil, 10);
TEST309
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT309' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `match'
OUTPUT309
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 310.
if test $result = ok -a $start_test_number -le 310; then
	echo test 310
        cat >$test_file <<'TEST310'
match ("", nil);
TEST310
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT310' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `match'
OUTPUT310
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 311.
if test $result = ok -a $start_test_number -le 311; then
	echo test 311
        cat >$test_file <<'TEST311'
var s;
s = "aaaa";
s[1] = "b";
TEST311
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT311' && $CMP $stderr $ftemp2; then
test.d:3:2: run time error - attempt to modify immutable vector
OUTPUT311
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 312.
if test $result = ok -a $start_test_number -le 312; then
	echo test 312
        cat >$test_file <<'TEST312'
var s;
s = final {"a"};
s{"a"} = "b";
TEST312
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT312' && $CMP $stderr $ftemp2; then
test.d:3:2: run time error - attempt to modify immutable table
OUTPUT312
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 313.
if test $result = ok -a $start_test_number -le 313; then
	echo test 313
        cat >$test_file <<'TEST313'
var s, t;
s = ['a'];
t = {s:"a"};
s[0] = 'b';
TEST313
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT313' && $CMP $stderr $ftemp2; then
test.d:4:2: run time error - attempt to modify immutable vector
OUTPUT313
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 314.
if test $result = ok -a $start_test_number -le 314; then
	echo test 314
        cat >$test_file <<'TEST314'
class c()
{
  var i;
}
var o;
o = final c ();
o.i = 10;
TEST314
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT314' && $CMP $stderr $ftemp2; then
test.d:7:2: run time error - attempt to modify immutable instance
OUTPUT314
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 315.
if test $result = ok -a $start_test_number -le 315; then
	echo test 315
        cat >$test_file <<'TEST315'
var i;
i = nil;
i++;
TEST315
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT315' && $CMP $stderr $ftemp2; then
test.d:3:2: run time error - invalid types of operands of operator "+"
OUTPUT315
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 316.
if test $result = ok -a $start_test_number -le 316; then
	echo test 316
        cat >$test_file <<'TEST316'
rand (10);
TEST316
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT316' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `rand'
OUTPUT316
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 317.
if test $result = ok -a $start_test_number -le 317; then
	echo test 317
        cat >$test_file <<'TEST317'
rand (10, 10);
TEST317
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT317' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `rand'
OUTPUT317
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 318.
if test $result = ok -a $start_test_number -le 318; then
	echo test 318
        cat >$test_file <<'TEST318'
readdir ();
TEST318
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT318' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of actual parameters for `readdir'
OUTPUT318
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 319.
if test $result = ok -a $start_test_number -le 319; then
	echo test 319
        cat >$test_file <<'TEST319'
readdir ("1", "");
TEST319
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT319' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of actual parameters for `readdir'
OUTPUT319
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 320.
if test $result = ok -a $start_test_number -le 320; then
	echo test 320
        cat >$test_file <<'TEST320'
readdir (nil);
TEST320
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT320' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `readdir'
OUTPUT320
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 321.
if test $result = ok -a $start_test_number -le 321; then
	echo test 321
        cat >$test_file <<'TEST321'
func f {putln ("aa";return 1;}
func g {putln ("aa";return 1;}
TEST321
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT321' && $CMP $stderr $ftemp2; then
test.d:1:20: syntax error
test.d:2:20: syntax error
OUTPUT321
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 322.
if test $result = ok -a $start_test_number -le 322; then
	echo test 322
        cat >$test_file <<'TEST322'
func f {}
f = 1;
TEST322
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT322' && $CMP $stderr $ftemp2; then
test.d:2:1: non variable in assignment statement
OUTPUT322
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 323.
if test $result = ok -a $start_test_number -le 323; then
	echo test 323
        cat >$test_file <<'TEST323'
func f {}
var t;
t = {};
for (f in t);
TEST323
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT323' && $CMP $stderr $ftemp2; then
test.d:4:6: non variable in for-stmt left to `in'
OUTPUT323
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 324.
if test $result = ok -a $start_test_number -le 324; then
	echo test 324
        cat >$test_file <<'TEST324'
class c {
  func f {}
}
var o;
o = c();
o.f = 1;
TEST324
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT324' && $CMP $stderr $ftemp2; then
test.d:6:2: run time error - usage function as variable
OUTPUT324
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 325.
if test $result = ok -a $start_test_number -le 325; then
	echo test 325
        cat >$test_file <<'TEST325'
class c {
  func f {}
}
var o, t;
o = c();
t = {};
for (o.f in t);
TEST325
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT325' && $CMP $stderr $ftemp2; then
test.d:7:7: run time error - usage function as variable
OUTPUT325
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 326.
if test $result = ok -a $start_test_number -le 326; then
	echo test 326
        cat >$test_file <<'TEST326'
class c {
  class f {}
}
var o;
o = c();
o.f = 1;
TEST326
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT326' && $CMP $stderr $ftemp2; then
test.d:6:2: run time error - usage class as variable
OUTPUT326
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 327.
if test $result = ok -a $start_test_number -le 327; then
	echo test 327
        cat >$test_file <<'TEST327'
class c {
  class f {}
}
var o, t;
o = c();
t = {};
for (o.f in t);
TEST327
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT327' && $CMP $stderr $ftemp2; then
test.d:7:7: run time error - usage class as variable
OUTPUT327
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 328.
if test $result = ok -a $start_test_number -le 328; then
	echo test 328
        cat >$test_file <<'TEST328'
sin ();
TEST328
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT328' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `sin'
OUTPUT328
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 329.
if test $result = ok -a $start_test_number -le 329; then
	echo test 329
        cat >$test_file <<'TEST329'
sin ({});
TEST329
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT329' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `sin'
OUTPUT329
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 330.
if test $result = ok -a $start_test_number -le 330; then
	echo test 330
        cat >$test_file <<'TEST330'
split ("a", "A", "A");
TEST330
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT330' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `split'
OUTPUT330
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 331.
if test $result = ok -a $start_test_number -le 331; then
	echo test 331
        cat >$test_file <<'TEST331'
split ();
TEST331
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT331' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `split'
OUTPUT331
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 332.
if test $result = ok -a $start_test_number -le 332; then
	echo test 332
        cat >$test_file <<'TEST332'
split ("aaa", nil);
TEST332
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT332' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `split'
OUTPUT332
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 333.
if test $result = ok -a $start_test_number -le 333; then
	echo test 333
        cat >$test_file <<'TEST333'
split (nil);
TEST333
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT333' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `split'
OUTPUT333
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 334.
if test $result = ok -a $start_test_number -le 334; then
	echo test 334
        cat >$test_file <<'TEST334'
srand (10, 10);
TEST334
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT334' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `srand'
OUTPUT334
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 335.
if test $result = ok -a $start_test_number -le 335; then
	echo test 335
        cat >$test_file <<'TEST335'
srand ({});
TEST335
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT335' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `srand'
OUTPUT335
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 336.
if test $result = ok -a $start_test_number -le 336; then
	echo test 336
        cat >$test_file <<'TEST336'
sub ();
TEST336
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT336' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `sub'
OUTPUT336
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 337.
if test $result = ok -a $start_test_number -le 337; then
	echo test 337
        cat >$test_file <<'TEST337'
sub ("", "", "", "");
TEST337
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT337' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `sub'
OUTPUT337
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 338.
if test $result = ok -a $start_test_number -le 338; then
	echo test 338
        cat >$test_file <<'TEST338'
sub (nil, "", "");
TEST338
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT338' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `sub'
OUTPUT338
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 339.
if test $result = ok -a $start_test_number -le 339; then
	echo test 339
        cat >$test_file <<'TEST339'
sub (nil, "", "");
TEST339
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT339' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `sub'
OUTPUT339
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 340.
if test $result = ok -a $start_test_number -le 340; then
	echo test 340
        cat >$test_file <<'TEST340'
putln (system (10));
TEST340
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT340' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid parameter type of `system'
OUTPUT340
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 341.
if test $result = ok -a $start_test_number -le 341; then
	echo test 341
        cat >$test_file <<'TEST341'
putln (system ());
TEST341
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT341' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid number of actual parameters for `system'
OUTPUT341
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 342.
if test $result = ok -a $start_test_number -le 342; then
	echo test 342
        cat >$test_file <<'TEST342'
var t;
t = {};
putln (t{10});
TEST342
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT342' && $CMP $stderr $ftemp2; then
test.d:3:9: run time error - no such key in table
OUTPUT342
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 343.
if test $result = ok -a $start_test_number -le 343; then
	echo test 343
        cat >$test_file <<'TEST343'
var t;
t = 10;
putln (10 in t);
TEST343
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT343' && $CMP $stderr $ftemp2; then
test.d:3:11: run time error - non table right to `in'
OUTPUT343
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 344.
if test $result = ok -a $start_test_number -le 344; then
	echo test 344
        cat >$test_file <<'TEST344'
var t;
t = [];
putln (t{10});
TEST344
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT344' && $CMP $stderr $ftemp2; then
test.d:3:9: run time error - key index operation for non table
OUTPUT344
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 345.
if test $result = ok -a $start_test_number -le 345; then
	echo test 345
        cat >$test_file <<'TEST345'
var i,t;
t = [];
for (i in t) putln ("wrong");
TEST345
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT345' && $CMP $stderr $ftemp2; then
test.d:3:1: run time error - non table right to `in'
OUTPUT345
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 346.
if test $result = ok -a $start_test_number -le 346; then
	echo test 346
        cat >$test_file <<'TEST346'
thread f {
  return 10;
}

var t;

t = f ();
TEST346
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT346' && $CMP $stderr $ftemp2; then
test.d:2:3: statement return with result is in thread
OUTPUT346
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 347.
if test $result = ok -a $start_test_number -le 347; then
	echo test 347
        cat >$test_file <<'TEST347'
thread f {
  {
    return 10;
  }
}

var t;

t = f ();
TEST347
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT347' && $CMP $stderr $ftemp2; then
test.d:3:5: statement return with result is in thread
OUTPUT347
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 348.
if test $result = ok -a $start_test_number -le 348; then
	echo test 348
        cat >$test_file <<'TEST348'
wait (0);
TEST348
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT348' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - process deadlock
OUTPUT348
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 349.
if test $result = ok -a $start_test_number -le 349; then
	echo test 349
        cat >$test_file <<'TEST349'
thread t { wait (0);}
var p;
p = t ();
wait (0);
TEST349
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT349' && $CMP $stderr $ftemp2; then
test.d:1:18: run time error - process deadlock
OUTPUT349
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 350.
if test $result = ok -a $start_test_number -le 350; then
	echo test 350
        cat >$test_file <<'TEST350'
thread t { wait (0);}
var p;
p = t ();
TEST350
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT350' && $CMP $stderr $ftemp2; then
test.d:1:18: run time error - process deadlock
OUTPUT350
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 351.
if test $result = ok -a $start_test_number -le 351; then
	echo test 351
        cat >$test_file <<'TEST351'
func f() {return 1;}
wait (f());
TEST351
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT351' && $CMP $stderr $ftemp2; then
test.d:2:7: function call is present in wait statement
OUTPUT351
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 352.
if test $result = ok -a $start_test_number -le 352; then
	echo test 352
        cat >$test_file <<'TEST352'
class c(){}
if ({}) {}
var i;
for (i=0;c;i++) {}
wait (c);
for (i in 10) {}
try {
  throw 1;
}
catch 10 {
}
TEST352
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT352' && $CMP $stderr $ftemp2; then
test.d:2:5: invalid type of operand in logical operation
test.d:4:10: invalid type of operand in logical operation
test.d:5:7: invalid type of wait-expr
test.d:6:6: invalid type of foreach-table
test.d:8:3: invalid type of throw-expr
test.d:10:7: syntax error
OUTPUT352
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 353.
if test $result = ok -a $start_test_number -le 353; then
	echo test 353
        cat >$test_file <<'TEST353'
i := 10;
TEST353
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT353' && $CMP $stderr $ftemp2; then
test.d:1:3: syntax error
OUTPUT353
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 354.
if test $result = ok -a $start_test_number -le 354; then
	echo test 354
        cat >$test_file <<'TEST354'
var i;
for (i:=0; i<1000000; i:=i+1;)
 ;
TEST354
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT354' && $CMP $stderr $ftemp2; then
test.d:2:7: syntax error
test.d:2:13: syntax error
OUTPUT354
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 355.
if test $result = ok -a $start_test_number -le 355; then
	echo test 355
        cat >$test_file <<'TEST355'
var ctime;
ctime = 0.0;

func waitfor (n, t){
  var cont;
  wait (1) cont = 1;
  putln (n, " waitfor ", t, " ctime ", ctime);
  for (; cont;)
    try {
      wait (ctime == t) cont = 0;
    } catch (errors.deadlock) {
      wait (1) ctime++;
      putln ("tick ", ctime); 
    }
}

thread output {
  waitfor ("output", 2.0);
  putln ("output 1");
  waitfor ("output", 4.0);
  putln ("output 2");
}

thread move {
   waitfor ("move", 1.0);
   putln ("move 1");
   waitfor ("move", 3.0);
   putln ("move 2");
}

move ();
output ();
TEST355
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT355' && $CMP $stdout $ftemp2; then
move waitfor 1 ctime 0
output waitfor 2 ctime 0
tick 1
move 1
move waitfor 3 ctime 1
tick 2
output 1
output waitfor 4 ctime 2
tick 3
move 2
tick 4
output 2
OUTPUT355
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 356.
if test $result = ok -a $start_test_number -le 356; then
	echo test 356
        cat >$test_file <<'TEST356'
var ctime;
ctime = 0.0;
var X,Y,Z;
X = [1.0,0.0,0.0];
Y = [0.0,1.0,0.0];
Z = [0.0,0.0,1.0];
func fulfill (){ putln ("FULFILL");}
func publish (){ putln ("PUBLISH");}
func rotate (what, axis, angle){
  putln ("ROTATE ", what, " ",
         axis [0], " ", axis [1], " ", axis [2], " ", angle);
}

func waitfor (n, t){
  var cont;
  wait (1) cont = 1;
  putln ("waitfor ", n, " ", t, " ctime ", ctime);
  for (; cont;)
    try {
      wait (ctime == t) cont = 0;
    } catch (errors.deadlock) {
      wait (1) ctime++;
      putln ("tick ", ctime); 
    }
}

class back_leg(side){
  var angle;
  angle = 1.0;

  func step {
    var start;
    putln ("step ", ctime);
    start = ctime;
    rotate (side @ "_back_hoof", Z, -angle);
    waitfor (side, start+1);
    rotate (side @ "_back_hoof", Z, -angle);
    waitfor (side, start+2);
    rotate (side @ "_back_hoof", Z, angle);
    waitfor (side, start+3);
    rotate (side @ "_back_hoof", Z, angle);
  }

  thread move (start_ctime, steps_number) {
    waitfor (side, start_ctime);
    var i;
    for (i=0; i<steps_number; i = i+1)
	step ();
  }
}     

thread output(interval) {
  var i, cont;
  for (i=0; i<interval; i=i+1) {
    waitfor ("output", i + 0.0);
    fulfill ();
    publish ();
  }
}

var left_back_leg, right_back_leg;

left_back_leg = back_leg("left");
right_back_leg = back_leg("right");

left_back_leg.move (ctime, 10.0);
right_back_leg.move (ctime+1.0, 10.0);
output (32);
TEST356
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT356' && $CMP $stdout $ftemp2; then
waitfor left 0 ctime 0
step 0
ROTATE left_back_hoof 0 0 1 -1
waitfor left 1 ctime 0
waitfor right 1 ctime 0
waitfor output 0 ctime 0
FULFILL
PUBLISH
waitfor output 1 ctime 0
tick 1
ROTATE left_back_hoof 0 0 1 -1
waitfor left 2 ctime 1
step 1
ROTATE right_back_hoof 0 0 1 -1
waitfor right 2 ctime 1
FULFILL
PUBLISH
waitfor output 2 ctime 1
tick 2
ROTATE left_back_hoof 0 0 1 1
waitfor left 3 ctime 2
ROTATE right_back_hoof 0 0 1 -1
waitfor right 3 ctime 2
FULFILL
PUBLISH
waitfor output 3 ctime 2
tick 3
ROTATE left_back_hoof 0 0 1 1
step 3
ROTATE left_back_hoof 0 0 1 -1
waitfor left 4 ctime 3
ROTATE right_back_hoof 0 0 1 1
waitfor right 4 ctime 3
FULFILL
PUBLISH
waitfor output 4 ctime 3
tick 4
ROTATE left_back_hoof 0 0 1 -1
waitfor left 5 ctime 4
ROTATE right_back_hoof 0 0 1 1
step 4
ROTATE right_back_hoof 0 0 1 -1
waitfor right 5 ctime 4
FULFILL
PUBLISH
waitfor output 5 ctime 4
tick 5
ROTATE left_back_hoof 0 0 1 1
waitfor left 6 ctime 5
ROTATE right_back_hoof 0 0 1 -1
waitfor right 6 ctime 5
FULFILL
PUBLISH
waitfor output 6 ctime 5
tick 6
ROTATE left_back_hoof 0 0 1 1
step 6
ROTATE left_back_hoof 0 0 1 -1
waitfor left 7 ctime 6
ROTATE right_back_hoof 0 0 1 1
waitfor right 7 ctime 6
FULFILL
PUBLISH
waitfor output 7 ctime 6
tick 7
ROTATE left_back_hoof 0 0 1 -1
waitfor left 8 ctime 7
ROTATE right_back_hoof 0 0 1 1
step 7
ROTATE right_back_hoof 0 0 1 -1
waitfor right 8 ctime 7
FULFILL
PUBLISH
waitfor output 8 ctime 7
tick 8
ROTATE left_back_hoof 0 0 1 1
waitfor left 9 ctime 8
ROTATE right_back_hoof 0 0 1 -1
waitfor right 9 ctime 8
FULFILL
PUBLISH
waitfor output 9 ctime 8
tick 9
ROTATE left_back_hoof 0 0 1 1
step 9
ROTATE left_back_hoof 0 0 1 -1
waitfor left 10 ctime 9
ROTATE right_back_hoof 0 0 1 1
waitfor right 10 ctime 9
FULFILL
PUBLISH
waitfor output 10 ctime 9
tick 10
ROTATE left_back_hoof 0 0 1 -1
waitfor left 11 ctime 10
ROTATE right_back_hoof 0 0 1 1
step 10
ROTATE right_back_hoof 0 0 1 -1
waitfor right 11 ctime 10
FULFILL
PUBLISH
waitfor output 11 ctime 10
tick 11
ROTATE left_back_hoof 0 0 1 1
waitfor left 12 ctime 11
ROTATE right_back_hoof 0 0 1 -1
waitfor right 12 ctime 11
FULFILL
PUBLISH
waitfor output 12 ctime 11
tick 12
ROTATE left_back_hoof 0 0 1 1
step 12
ROTATE left_back_hoof 0 0 1 -1
waitfor left 13 ctime 12
ROTATE right_back_hoof 0 0 1 1
waitfor right 13 ctime 12
FULFILL
PUBLISH
waitfor output 13 ctime 12
tick 13
ROTATE left_back_hoof 0 0 1 -1
waitfor left 14 ctime 13
ROTATE right_back_hoof 0 0 1 1
step 13
ROTATE right_back_hoof 0 0 1 -1
waitfor right 14 ctime 13
FULFILL
PUBLISH
waitfor output 14 ctime 13
tick 14
ROTATE left_back_hoof 0 0 1 1
waitfor left 15 ctime 14
ROTATE right_back_hoof 0 0 1 -1
waitfor right 15 ctime 14
FULFILL
PUBLISH
waitfor output 15 ctime 14
tick 15
ROTATE left_back_hoof 0 0 1 1
step 15
ROTATE left_back_hoof 0 0 1 -1
waitfor left 16 ctime 15
ROTATE right_back_hoof 0 0 1 1
waitfor right 16 ctime 15
FULFILL
PUBLISH
waitfor output 16 ctime 15
tick 16
ROTATE left_back_hoof 0 0 1 -1
waitfor left 17 ctime 16
ROTATE right_back_hoof 0 0 1 1
step 16
ROTATE right_back_hoof 0 0 1 -1
waitfor right 17 ctime 16
FULFILL
PUBLISH
waitfor output 17 ctime 16
tick 17
ROTATE left_back_hoof 0 0 1 1
waitfor left 18 ctime 17
ROTATE right_back_hoof 0 0 1 -1
waitfor right 18 ctime 17
FULFILL
PUBLISH
waitfor output 18 ctime 17
tick 18
ROTATE left_back_hoof 0 0 1 1
step 18
ROTATE left_back_hoof 0 0 1 -1
waitfor left 19 ctime 18
ROTATE right_back_hoof 0 0 1 1
waitfor right 19 ctime 18
FULFILL
PUBLISH
waitfor output 19 ctime 18
tick 19
ROTATE left_back_hoof 0 0 1 -1
waitfor left 20 ctime 19
ROTATE right_back_hoof 0 0 1 1
step 19
ROTATE right_back_hoof 0 0 1 -1
waitfor right 20 ctime 19
FULFILL
PUBLISH
waitfor output 20 ctime 19
tick 20
ROTATE left_back_hoof 0 0 1 1
waitfor left 21 ctime 20
ROTATE right_back_hoof 0 0 1 -1
waitfor right 21 ctime 20
FULFILL
PUBLISH
waitfor output 21 ctime 20
tick 21
ROTATE left_back_hoof 0 0 1 1
step 21
ROTATE left_back_hoof 0 0 1 -1
waitfor left 22 ctime 21
ROTATE right_back_hoof 0 0 1 1
waitfor right 22 ctime 21
FULFILL
PUBLISH
waitfor output 22 ctime 21
tick 22
ROTATE left_back_hoof 0 0 1 -1
waitfor left 23 ctime 22
ROTATE right_back_hoof 0 0 1 1
step 22
ROTATE right_back_hoof 0 0 1 -1
waitfor right 23 ctime 22
FULFILL
PUBLISH
waitfor output 23 ctime 22
tick 23
ROTATE left_back_hoof 0 0 1 1
waitfor left 24 ctime 23
ROTATE right_back_hoof 0 0 1 -1
waitfor right 24 ctime 23
FULFILL
PUBLISH
waitfor output 24 ctime 23
tick 24
ROTATE left_back_hoof 0 0 1 1
step 24
ROTATE left_back_hoof 0 0 1 -1
waitfor left 25 ctime 24
ROTATE right_back_hoof 0 0 1 1
waitfor right 25 ctime 24
FULFILL
PUBLISH
waitfor output 25 ctime 24
tick 25
ROTATE left_back_hoof 0 0 1 -1
waitfor left 26 ctime 25
ROTATE right_back_hoof 0 0 1 1
step 25
ROTATE right_back_hoof 0 0 1 -1
waitfor right 26 ctime 25
FULFILL
PUBLISH
waitfor output 26 ctime 25
tick 26
ROTATE left_back_hoof 0 0 1 1
waitfor left 27 ctime 26
ROTATE right_back_hoof 0 0 1 -1
waitfor right 27 ctime 26
FULFILL
PUBLISH
waitfor output 27 ctime 26
tick 27
ROTATE left_back_hoof 0 0 1 1
step 27
ROTATE left_back_hoof 0 0 1 -1
waitfor left 28 ctime 27
ROTATE right_back_hoof 0 0 1 1
waitfor right 28 ctime 27
FULFILL
PUBLISH
waitfor output 28 ctime 27
tick 28
ROTATE left_back_hoof 0 0 1 -1
waitfor left 29 ctime 28
ROTATE right_back_hoof 0 0 1 1
step 28
ROTATE right_back_hoof 0 0 1 -1
waitfor right 29 ctime 28
FULFILL
PUBLISH
waitfor output 29 ctime 28
tick 29
ROTATE left_back_hoof 0 0 1 1
waitfor left 30 ctime 29
ROTATE right_back_hoof 0 0 1 -1
waitfor right 30 ctime 29
FULFILL
PUBLISH
waitfor output 30 ctime 29
tick 30
ROTATE left_back_hoof 0 0 1 1
ROTATE right_back_hoof 0 0 1 1
waitfor right 31 ctime 30
FULFILL
PUBLISH
waitfor output 31 ctime 30
tick 31
ROTATE right_back_hoof 0 0 1 1
FULFILL
PUBLISH
OUTPUT356
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 357.
if test $result = ok -a $start_test_number -le 357; then
	echo test 357
        cat >$test_file <<'TEST357'
var k;
//putln ("#env=", #env);
for (k in env)
  putln (k, "=", env {k});
TEST357
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sort $stdout | awk '/^(HOSTNAME|USER|MACHTYPE|TERMCAP|LANG|DISPLAY|LOGNAME|COLUMNS|TERM|OSTYPE)/ && length != 0' >$ftemp
		sh -c 'env' | sort | awk '/^(HOSTNAME|USER|MACHTYPE|TERMCAP|LANG|DISPLAY|LOGNAME|COLUMNS|TERM|OSTYPE)/ && length != 0' >$ftemp2
                echo '      ' $CMP $ftemp $ftemp2
                if $CMP $ftemp $ftemp2; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 358.
if test $result = ok -a $start_test_number -le 358; then
	echo test 358
        cat >$test_file <<'TEST358'
putln (log (-1.0));
TEST358
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT358' && $CMP $stderr $ftemp2; then
test.d:1:12: system error - domain error: `log'
OUTPUT358
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 359.
if test $result = ok -a $start_test_number -le 359; then
	echo test 359
        cat >$test_file <<'TEST359'
putln (pow (-10, 1000));
TEST359
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT359' && $CMP $stderr $ftemp2; then
test.d:1:12: system error - result too big (small): `pow'
OUTPUT359
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 360.
if test $result = ok -a $start_test_number -le 360; then
	echo test 360
        cat >$test_file <<'TEST360'
putln (sqrt (-10.0));
TEST360
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT360' && $CMP $stderr $ftemp2; then
test.d:1:13: system error - domain error: `sqrt'
OUTPUT360
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 361.
if test $result = ok -a $start_test_number -le 361; then
	echo test 361
        cat >$test_file <<'TEST361'
putln (rand ());
putln (rand ());
srand ();
putln (rand ());
putln (rand ());
srand ();
putln (rand ());
putln (rand ());
srand (10);
putln (rand ());
putln (rand ());
srand (10.0);
putln (rand ());
putln (rand ());
srand ("10.0");
putln (rand ());
putln (rand ());
TEST361
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		awk '!/^0\.[0-9]+$/' $stdout >$ftemp
                echo '      ' $CMP $ftemp $ftemp2
                if cat >$ftemp2 <<'OUTPUT361' && $CMP $ftemp $ftemp2; then
OUTPUT361
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 362.
if test $result = ok -a $start_test_number -le 362; then
	echo test 362
        cat >$test_file <<'TEST362'
println (table ([]));
println (table ([5:10]));
println (table (101));
println (table ('c'));
println (table (10.1));
println (table ([5:10, "c"]));
println (table ({}));
println (table ({"a":10.0, 10:5}));
println (vector ({}));
println (vector ({"e":5, "g": 6}));
println (vector (101));
println (vector ('c'));
println (vector (10.1));
println (vector ([]));
println (vector ("abcd"));
println (vector ([3:3]));
TEST362
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT362' && $CMP $stdout $ftemp2; then
{}
{0:10, 1:10, 2:10, 3:10, 4:10}
{0:'1', 1:'0', 2:'1'}
{0:'c'}
{0:'1', 1:'0', 2:'.', 3:'1'}
{0:10, 1:10, 2:10, 3:10, 4:10, 5:"c"}
{}
{10:5, "a":10}
[]
["e", 5, "g", 6]
"101"
"c"
"10.1"
[]
"abcd"
[3, 3, 3]
OUTPUT362
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 363.
if test $result = ok -a $start_test_number -le 363; then
	echo test 363
        cat >$test_file <<'TEST363'
func f {}
var v = table (f);
TEST363
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT363' && $CMP $stderr $ftemp2; then
test.d:2:16: invalid operand type table (...)
OUTPUT363
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 364.
if test $result = ok -a $start_test_number -le 364; then
	echo test 364
        cat >$test_file <<'TEST364'
var v = table (nil);
TEST364
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT364' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid type of operand of table (...)
OUTPUT364
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 365.
if test $result = ok -a $start_test_number -le 365; then
	echo test 365
        cat >$test_file <<'TEST365'
func f {}
var v = vector (f);
TEST365
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT365' && $CMP $stderr $ftemp2; then
test.d:2:17: invalid operand type vector (...)
OUTPUT365
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 366.
if test $result = ok -a $start_test_number -le 366; then
	echo test 366
        cat >$test_file <<'TEST366'
var v = vector (nil);
TEST366
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT366' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid type of operand of vector (...)
OUTPUT366
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 367.
if test $result = ok -a $start_test_number -le 367; then
	echo test 367
        cat >$test_file <<'TEST367'
println (keys ({}));
println (keys ({8:5, 7:7}));
println (keys ({"a":5, "ha":7}));
TEST367
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT367' && $CMP $stdout $ftemp2; then
[]
[7, 8]
["a", "ha"]
OUTPUT367
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 368.
if test $result = ok -a $start_test_number -le 368; then
	echo test 368
        cat >$test_file <<'TEST368'
var v = keys ([]);
TEST368
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT368' && $CMP $stderr $ftemp2; then
test.d:1:14: run time error - invalid parameter type of `keys'
OUTPUT368
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 369.
if test $result = ok -a $start_test_number -le 369; then
	echo test 369
        cat >$test_file <<'TEST369'
var v = keys ();
TEST369
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT369' && $CMP $stderr $ftemp2; then
test.d:1:14: run time error - invalid number of actual parameters for `keys'
OUTPUT369
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 370.
if test $result = ok -a $start_test_number -le 370; then
	echo test 370
        cat >$test_file <<'TEST370'
println (cmpv ("var", "if"));
println (cmpv ([10, 12], [10, 11, nil]));
println (cmpv ([10.0, 12.0], [10.0]));
println (cmpv ([10.0, 12], [10.0, 11, 13.0]));
println (cmpv ([10.0, 12.0], [10.0, 12.0]));
println (cmpv (10, 'c'));
println (cmpv ([], []));
println (cmpv ([], [10]));
TEST370
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT370' && $CMP $stdout $ftemp2; then
1
1
1
1
0
-1
0
-1
OUTPUT370
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 371.
if test $result = ok -a $start_test_number -le 371; then
	echo test 371
        cat >$test_file <<'TEST371'
cmpv ();
TEST371
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT371' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `cmpv'
OUTPUT371
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 372.
if test $result = ok -a $start_test_number -le 372; then
	echo test 372
        cat >$test_file <<'TEST372'
cmpv ([], nil);
TEST372
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT372' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `cmpv'
OUTPUT372
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 373.
if test $result = ok -a $start_test_number -le 373; then
	echo test 373
        cat >$test_file <<'TEST373'
cmpv ([10, 11], [10, 'c']);
TEST373
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT373' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `cmpv'
OUTPUT373
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 374.
if test $result = ok -a $start_test_number -le 374; then
	echo test 374
        cat >$test_file <<'TEST374'
var i, key, voc = {};
for (;;)
  try {
    var ln, a;

    ln = getln ();
    if (ln == "")
      continue;
    a = split (ln, "[^[:alnum:]]");
    for (i = 0; i < #a; i++)
      voc {a[i]} = (a[i] in voc ? voc {a[i]} + 1 : 1);
  } catch (invcalls.eof) {
    break;
  }
key = sort (keys (voc), cmpv);
for (i = 0; i < #key; i++)
  putln (key[i], " : ", voc{key[i]});
TEST374
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout <<'INPUT374' ; then

var i, prime, k, count, iter, flags;
val SieveSize = 8190;

flags = [SieveSize + 1 : 0];
for (iter = 0; iter < 10; iter++;)
  {
    count = 0;
    for (i = 0; i <= SieveSize; i++)
      flags[i] = 1;
    for (i = 0; i <= SieveSize; i++;)
      if (flags[i])
        {
          prime = i + i + 3;
          k = i + prime;
          for (;1;;)
            {
	      if (k > SieveSize)
                break;
              flags[k] = 0;
              k += prime;
            }
          count++;
        }
  }
putln (count);
INPUT374
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT374' && $CMP $stdout $ftemp2; then
0 : 6
1 : 3
10 : 1
3 : 1
8190 : 1
SieveSize : 5
break : 1
count : 4
flags : 5
for : 4
i : 12
if : 2
iter : 4
k : 5
prime : 4
putln : 1
val : 1
var : 1
OUTPUT374
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 375.
if test $result = ok -a $start_test_number -le 375; then
	echo test 375
        cat >$test_file <<'TEST375'
putln (tolower ("abcd"));
putln (tolower ("ABCD"));
putln (tolower (10));
putln (tolower (10e10));
putln (tolower ('c'));
putln (tolower ('C'));
//
putln (toupper ("abcd"));
putln (toupper ("ABCD"));
putln (toupper (10));
putln (toupper (10e10));
putln (toupper ('c'));
putln (toupper ('C'));
TEST375
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout ; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT375' && $CMP $stdout $ftemp2; then
abcd
abcd
10
1e+11
c
c
ABCD
ABCD
10
1E+11
C
C
OUTPUT375
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT375-1' && $CMP $stdout $ftemp2; then
abcd
abcd
10
1e+011
c
c
ABCD
ABCD
10
1E+011
C
C
OUTPUT375-1
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 376.
if test $result = ok -a $start_test_number -le 376; then
	echo test 376
        cat >$test_file <<'TEST376'
tolower ();
TEST376
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT376' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of actual parameters for `tolower'
OUTPUT376
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 377.
if test $result = ok -a $start_test_number -le 377; then
	echo test 377
        cat >$test_file <<'TEST377'
tolower (nil);
TEST377
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT377' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `tolower'
OUTPUT377
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 378.
if test $result = ok -a $start_test_number -le 378; then
	echo test 378
        cat >$test_file <<'TEST378'
tolower ();
TEST378
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT378' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of actual parameters for `tolower'
OUTPUT378
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 379.
if test $result = ok -a $start_test_number -le 379; then
	echo test 379
        cat >$test_file <<'TEST379'
tolower (nil);
TEST379
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT379' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `tolower'
OUTPUT379
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 380.
if test $result = ok -a $start_test_number -le 380; then
	echo test 380
        cat >$test_file <<'TEST380'
a
TEST380
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT380' && $CMP $stderr $ftemp2; then
test.d:2:1: syntax error
OUTPUT380
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 381.
if test $result = ok -a $start_test_number -le 381; then
	echo test 381
        cat >$test_file <<'TEST381'
// vector
var v;
// pack
v = [1, 2, 3, 4, 5, 6]; v = subv (v, 2); println (v);
v = [1, 2, 3, 4, 5, 6]; v = subv (v, -2, 2); println (v);
v = [1, 2, 3, 4, 5, 6]; v = subv (v, 2, 2); println (v);
v = [1, 2, 3, 4, 5, 6]; v = subv (v, 2, -1); println (v);
v = [1, 2, 3, 4, 5, 6]; v = subv (v, 2, 0); println (v);
// unpack
v = [1, 2.0, 3.0, 4, 5, 6]; v = subv (v, 2); println (v);
v = [1.0, 2, 3, 4, 5, 6]; v = subv (v, -2, 2); println (v);
v = [1.0, 2, 3, 4, 5, 6]; v = subv (v, 2, 2); println (v);
v = [1.0, 2, 3, 4, 5, 6]; v = subv (v, 2, -1); println (v);
v = [1.0, 2, 3, 4, 5, 6]; v = subv (v, 2, 0); println (v);
// empty
v = []; v = subv (v, 0); println (v);
v = []; v = subv (v, -2, 1); println (v);
v = []; v = subv (v, 0, 1); println (v);
v = []; v = subv (v, 1, 0); println (v);
v = []; v = subv (v, 0, -1); println (v);
// string
v = new "123456"; v = subv (v, 2, 2); putln (v);
v = new "123456"; v = subv (v, -2, 2); putln (v);
v = new "123456"; v = subv (v, 2, 0); println (v);
var i, iter, t;
for (iter = 0; iter < 1000; iter++)
  { 
    v = [1000:1];
    for (i = 0; i < 1000; i++)
      t = subv (v, 2, 2);
  }
println (t);
TEST381
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT381' && $CMP $stdout $ftemp2; then
[3, 4, 5, 6]
[1, 2]
[3, 4]
[3, 4, 5, 6]
[]
[3, 4, 5, 6]
[1, 2]
[3, 4]
[3, 4, 5, 6]
[]
[]
[]
[]
[]
[]
34
12
""
[1, 1]
OUTPUT381
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 382.
if test $result = ok -a $start_test_number -le 382; then
	echo test 382
        cat >$test_file <<'TEST382'
subv ();
TEST382
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT382' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `subv'
OUTPUT382
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 383.
if test $result = ok -a $start_test_number -le 383; then
	echo test 383
        cat >$test_file <<'TEST383'
subv (10);
TEST383
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT383' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `subv'
OUTPUT383
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 384.
if test $result = ok -a $start_test_number -le 384; then
	echo test 384
        cat >$test_file <<'TEST384'
subv (nil, 10);
TEST384
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT384' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `subv'
OUTPUT384
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 385.
if test $result = ok -a $start_test_number -le 385; then
	echo test 385
        cat >$test_file <<'TEST385'
subv (10,10,10,10);
TEST385
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT385' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `subv'
OUTPUT385
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 386.
if test $result = ok -a $start_test_number -le 386; then
	echo test 386
        cat >$test_file <<'TEST386'
var t;
t = {10}; subv (t, 10, 10);
TEST386
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT386' && $CMP $stderr $ftemp2; then
test.d:2:16: run time error - invalid parameter type of `subv'
OUTPUT386
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 387.
if test $result = ok -a $start_test_number -le 387; then
	echo test 387
        cat >$test_file <<'TEST387'
var v;
v = []; subv (v, {});
TEST387
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT387' && $CMP $stderr $ftemp2; then
test.d:2:14: run time error - invalid parameter type of `subv'
OUTPUT387
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 388.
if test $result = ok -a $start_test_number -le 388; then
	echo test 388
        cat >$test_file <<'TEST388'
var v;
v = []; subv (v, 0, {});
TEST388
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT388' && $CMP $stderr $ftemp2; then
test.d:2:14: run time error - invalid parameter type of `subv'
OUTPUT388
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 389.
if test $result = ok -a $start_test_number -le 389; then
	echo test 389
        cat >$test_file <<'TEST389'
exit (1);
putln (stderr, "ahaha");
TEST389
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT389' && $CMP $stderr $ftemp2; then
OUTPUT389
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 390.
if test $result = ok -a $start_test_number -le 390; then
	echo test 390
        cat >$test_file <<'TEST390'
exit (0);
putln ("ahaha");
TEST390
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT390' && $CMP $stdout $ftemp2; then
OUTPUT390
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 391.
if test $result = ok -a $start_test_number -le 391; then
	echo test 391
        cat >$test_file <<'TEST391'
exit ();
TEST391
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT391' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `exit'
OUTPUT391
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 392.
if test $result = ok -a $start_test_number -le 392; then
	echo test 392
        cat >$test_file <<'TEST392'
exit (1, 1);
TEST392
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT392' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `exit'
OUTPUT392
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 393.
if test $result = ok -a $start_test_number -le 393; then
	echo test 393
        cat >$test_file <<'TEST393'
exit (nil);
TEST393
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT393' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `exit'
OUTPUT393
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 394.
if test $result = ok -a $start_test_number -le 394; then
	echo test 394
        cat >$test_file <<'TEST394'
putln (max (1.5, 2));
putln (min (1.5, 2));
putln (max (1.5, 2, "3.0"));
putln (min (1.5, 2, "3.0"));
putln (min (1.5, 2, 'a'));
putln (max (1.5, 2, 'a'));
putln (min (1.5, 2, 'a'));
TEST394
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT394' && $CMP $stdout $ftemp2; then
2
1.5
3
1.5
1.5
97
1.5
OUTPUT394
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 395.
if test $result = ok -a $start_test_number -le 395; then
	echo test 395
        cat >$test_file <<'TEST395'
max (1);
TEST395
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT395' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `max'
OUTPUT395
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 396.
if test $result = ok -a $start_test_number -le 396; then
	echo test 396
        cat >$test_file <<'TEST396'
min (1);
TEST396
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT396' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `min'
OUTPUT396
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 397.
if test $result = ok -a $start_test_number -le 397; then
	echo test 397
        cat >$test_file <<'TEST397'
max ();
TEST397
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT397' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `max'
OUTPUT397
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 398.
if test $result = ok -a $start_test_number -le 398; then
	echo test 398
        cat >$test_file <<'TEST398'
min ();
TEST398
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT398' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `min'
OUTPUT398
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 399.
if test $result = ok -a $start_test_number -le 399; then
	echo test 399
        cat >$test_file <<'TEST399'
max (nil, nil);
TEST399
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT399' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `max'
OUTPUT399
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 400.
if test $result = ok -a $start_test_number -le 400; then
	echo test 400
        cat >$test_file <<'TEST400'
min (nil, nil);
TEST400
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT400' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `min'
OUTPUT400
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 401.
if test $result = ok -a $start_test_number -le 401; then
	echo test 401
        cat >$test_file <<'TEST401'
class c (par) {
  class sc (i) {
  }
}

var i=c(10).sc(20);
putln (i.par, " ", i.i);
i.par = 15;
putln (i.par, " ", i.i);
TEST401
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT401' && $CMP $stdout $ftemp2; then
10 20
15 20
OUTPUT401
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 402.
if test $result = ok -a $start_test_number -le 402; then
	echo test 402
        cat >$test_file <<'TEST402'
func f (par) {
  class sc (i) {
  }
  return sc;
}

var i=f(10)(20);
putln (i.par);
TEST402
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT402' && $CMP $stderr $ftemp2; then
test.d:8:9: run time error - there is no such declaration in given class
OUTPUT402
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 403.
if test $result = ok -a $start_test_number -le 403; then
	echo test 403
        cat >$test_file <<'TEST403'
var c;
{
  class sc (i) {
  }
  c = sc;
}

var i=c(20);
putln (i.par);
TEST403
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT403' && $CMP $stderr $ftemp2; then
test.d:9:8: there is no such declaration in a block
OUTPUT403
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 404.
if test $result = ok -a $start_test_number -le 404; then
	echo test 404
        cat >$test_file <<'TEST404'
var i = 0;
include "../DINO/../DINO/test1";
i = 1;
include +"../DINO/..//////DINO/test1";
i = 2;
{
  include "../DINO/../DINO/test1";
  i = 3;
  include "../DINO/..//////DINO/test1";
  i = 4;
  include +"../DINO/../DINO/test1";
}
i = 5;
include "../DINO/../DINO/test1";
i = 6;
include +"../DINO/..//////DINO/test1";
TEST404
        cat >$test_file_1 <<'TEST404-1'
putln (i);
TEST404-1
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT404' && $CMP $stdout $ftemp2; then
0
1
2
4
6
OUTPUT404
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 406.
if test $result = ok -a $start_test_number -le 406; then
	echo test 406
        cat >$test_file <<'TEST406'
inside (nil);
TEST406
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT406' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `inside'
OUTPUT406
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 407.
if test $result = ok -a $start_test_number -le 407; then
	echo test 407
        cat >$test_file <<'TEST407'
inside (nil, nil, nil, nil);
TEST407
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT407' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `inside'
OUTPUT407
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 408.
if test $result = ok -a $start_test_number -le 408; then
	echo test 408
        cat >$test_file <<'TEST408'
class c {}
inside (c, c, nil);
TEST408
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT408' && $CMP $stderr $ftemp2; then
test.d:2:8: run time error - invalid parameter type of `inside'
OUTPUT408
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 409.
if test $result = ok -a $start_test_number -le 409; then
	echo test 409
        cat >$test_file <<'TEST409'
class c {}
inside (c, c());
TEST409
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT409' && $CMP $stderr $ftemp2; then
test.d:2:8: run time error - invalid parameter type of `inside'
OUTPUT409
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 410.
if test $result = ok -a $start_test_number -le 410; then
	echo test 410: Parsing expression
        cat >$test_file <<'TEST410'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(a+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (p.ambiguous_p);
TEST410
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT410' && $CMP $stdout $ftemp2; then
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      $term(97, 5)
      mult(
        $term(97, 7)
        $term(97, 9)
      )
    )
  )
)
OUTPUT410
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 411.
if test $result = ok -a $start_test_number -le 411; then
	echo test 411: Undefined grammar
        cat >$test_file <<'TEST411'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST411
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT411' && $CMP $stderr $ftemp2; then
test.d:32:20: run time error (parse) -- undefined or bad grammar
OUTPUT411
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 412.
if test $result = ok -a $start_test_number -le 412; then
	echo test 412: Already defined grammar.
        cat >$test_file <<'TEST412'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);
p.set_grammar (g, 1);

var str = "a+a*(a+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST412
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT412' && $CMP $stdout $ftemp2; then
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      $term(97, 5)
      mult(
        $term(97, 7)
        $term(97, 9)
      )
    )
  )
)
OUTPUT412
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 413.
if test $result = ok -a $start_test_number -le 413; then
	echo test 413: Description syntax error.
        cat >$test_file <<'TEST413'
var g = "TERM 1\n\
         E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST413
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT413' && $CMP $stderr $ftemp2; then
test.d:16:15: run time error (set_grammar) -- description syntax error on ln 1
OUTPUT413
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 414.
if test $result = ok -a $start_test_number -le 414; then
	echo test 414: error in the left side of the rule.
        cat >$test_file <<'TEST414'
var g = "TERM;\n\
         error : T         # 0\n\
         E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST414
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT414' && $CMP $stderr $ftemp2; then
test.d:17:15: run time error (set_grammar) -- term `error' in the left hand side of rule
OUTPUT414
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 415.
if test $result = ok -a $start_test_number -le 415; then
	echo test 415: The same code for terminals.
        cat >$test_file <<'TEST415'
var g = "TERM ident=10 i=10;\n\
         E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST415
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT415' && $CMP $stderr $ftemp2; then
test.d:16:15: run time error (set_grammar) -- repeated code 10 in term `i'
OUTPUT415
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 416.
if test $result = ok -a $start_test_number -le 416; then
	echo test 416: No rules.
        cat >$test_file <<'TEST416'
var g = "TERM ident=10;\n";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST416
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT416' && $CMP $stderr $ftemp2; then
test.d:9:15: run time error (set_grammar) -- grammar does not contains rules
OUTPUT416
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 417.
if test $result = ok -a $start_test_number -le 417; then
	echo test 417: Term in the left hand side of rule.
        cat >$test_file <<'TEST417'
var g = "TERM ident=10;\n\
         ident : 'a'\n\
         E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST417
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT417' && $CMP $stderr $ftemp2; then
test.d:17:15: run time error (set_grammar) -- term `ident' in the left hand side of rule
OUTPUT417
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 418.
if test $result = ok -a $start_test_number -le 418; then
	echo test 418: Incorrect translation number.
        cat >$test_file <<'TEST418'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 1\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST418
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT418' && $CMP $stderr $ftemp2; then
test.d:15:15: run time error (set_grammar) -- translation symbol number 1 in rule for `E' is out of range
OUTPUT418
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 419.
if test $result = ok -a $start_test_number -le 419; then
	echo test 419: Repeated translation symbol number.
        cat >$test_file <<'TEST419'
var g = "E : E '+' T # plus (0 0)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST419
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT419' && $CMP $stderr $ftemp2; then
test.d:15:15: run time error (set_grammar) -- repeated translation symbol number 0 in rule for `E'
OUTPUT419
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 420.
if test $result = ok -a $start_test_number -le 420; then
	echo test 420: No derivations.
        cat >$test_file <<'TEST420'
var g = "E : 'a' E\n\
           | E '+'";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST420
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT420' && $CMP $stderr $ftemp2; then
test.d:10:15: run time error (set_grammar) -- nonterm `E' does not derive any term string
OUTPUT420
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 421.
if test $result = ok -a $start_test_number -le 421; then
	echo test 421: Grammar loops.
        cat >$test_file <<'TEST421'
var g = "E : A O O\n\
           | E 'a'\n\
           | 'b'\n\
           |\n\
         A : O O N\n\
         N : O E E O\n\
         O :\n";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST421
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT421' && $CMP $stderr $ftemp2; then
test.d:15:15: run time error (set_grammar) -- nonterm `E' can derive only itself (grammar with loops)
OUTPUT421
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 422.
if test $result = ok -a $start_test_number -le 422; then
	echo test 422: Invalid token code.
        cat >$test_file <<'TEST422'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*b)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST422
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT422' && $CMP $stderr $ftemp2; then
test.d:33:20: run time error (parse) -- invalid token code 98
OUTPUT422
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 423.
if test $result = ok -a $start_test_number -le 423; then
	echo test 423: Unaccessible nonterm.
        cat >$test_file <<'TEST423'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         G : 'a'       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*b)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST423
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT423' && $CMP $stderr $ftemp2; then
test.d:16:15: run time error (set_grammar) -- nonterm `G' is not accessible from axiom
OUTPUT423
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 424.
if test $result = ok -a $start_test_number -le 424; then
	echo test 424: Fixed name error.
        cat >$test_file <<'TEST424'
var g = "TERM error=10;\n\
         E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*b)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST424
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT424' && $CMP $stderr $ftemp2; then
test.d:16:15: run time error (set_grammar) -- do not use fixed name `error'
OUTPUT424
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 425.
if test $result = ok -a $start_test_number -le 425; then
	echo test 425: Error recovery.
        cat >$test_file <<'TEST425'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(a*+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST425
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT425' && $CMP $stdout $ftemp2; then
syntax error on token #7 (43) -- ignore 10 tokens starting with token #0
$nil
OUTPUT425
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 426.
if test $result = ok -a $start_test_number -le 426; then
	echo test 426: More error recovery.
        cat >$test_file <<'TEST426'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(a*+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST426
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT426' && $CMP $stdout $ftemp2; then
syntax error on token #7 (43) -- ignore 4 tokens starting with token #5
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    $error
  )
)
OUTPUT426
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 427.
if test $result = ok -a $start_test_number -le 427; then
	echo test 427: More error recovery.
        cat >$test_file <<'TEST427'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST427
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT427' && $CMP $stdout $ftemp2; then
syntax error on token #5 (42) -- ignore 4 tokens starting with token #5
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    $error
  )
)
OUTPUT427
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 428.
if test $result = ok -a $start_test_number -le 428; then
	echo test 428: Ambiguous grammar.
        cat >$test_file <<'TEST428'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | '(' E ')' # 1\n";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (1);
p.set_grammar (g, 1);

var str = "a+a*(a*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (!p.ambiguous_p);
TEST428
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT428' && $CMP $stdout $ftemp2; then
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      mult(
        $term(97, 5)
        $term(97, 7)
      )
      $term(97, 9)
    )
  )
)
OUTPUT428
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 429.
if test $result = ok -a $start_test_number -le 429; then
	echo test 429: More ambiguous grammar.
        cat >$test_file <<'TEST429'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | '(' E ')' # 1\n";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(a*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST429
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT429' && $CMP $stdout $ftemp2; then
$alt(
  mult(
    plus(
      $term(97, 0)
      $term(97, 2)
    )
    $alt(
      mult(
        $term(97, 5)
        plus(
          $term(97, 7)
          $term(97, 9)
        )
      )
      plus(
        mult(
          $term(97, 5)
          $term(97, 7)
        )
        $term(97, 9)
      )
    )
  )
  plus(
    $term(97, 0)
    mult(
      $term(97, 2)
      $alt(
        mult(
          $term(97, 5)
          plus(
            $term(97, 7)
            $term(97, 9)
          )
        )
        plus(
          mult(
            $term(97, 5)
            $term(97, 7)
          )
          $term(97, 9)
        )
      )
    )
  )
)
OUTPUT429
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 430.
if test $result = ok -a $start_test_number -le 430; then
	echo test 430: Ambiguous grammar with error recovery
        cat >$test_file <<'TEST430'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | '(' E ')' # 1\n";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (1);
p.set_grammar (g, 1);

var str = "a+a*(*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST430
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT430' && $CMP $stdout $ftemp2; then
syntax error on token #5 (42) -- ignore 10 tokens starting with token #0
$nil
OUTPUT430
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 431.
if test $result = ok -a $start_test_number -le 431; then
	echo test 431: More ambiguous grammar with error recovery
        cat >$test_file <<'TEST431'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1\n";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (1);
p.set_grammar (g, 1);

var str = "a+a*(*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST431
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT431' && $CMP $stdout $ftemp2; then
syntax error on token #5 (42) -- ignore 4 tokens starting with token #5
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    $error
  )
)
OUTPUT431
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 432.
if test $result = ok -a $start_test_number -le 432; then
	echo test 432: More ambiguous grammar with error recovery
        cat >$test_file <<'TEST432'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1\n";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST432
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT432' && $CMP $stdout $ftemp2; then
syntax error on token #5 (42) -- ignore 4 tokens starting with token #5
$alt(
  mult(
    plus(
      $term(97, 0)
      $term(97, 2)
    )
    $error
  )
  plus(
    $term(97, 0)
    mult(
      $term(97, 2)
      $error
    )
  )
)
OUTPUT432
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 433.
if test $result = ok -a $start_test_number -le 433; then
	echo test 433: Error recovery with 2 errors.
        cat >$test_file <<'TEST433'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(a*)+(*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST433
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT433' && $CMP $stdout $ftemp2; then
syntax error on token #7 (41) -- ignore 2 tokens starting with token #5
syntax error on token #10 (42) -- ignore 2 tokens starting with token #10
plus(
  plus(
    $term(97, 0)
    mult(
      $term(97, 2)
      $error
    )
  )
  $error
)
OUTPUT433
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 434.
if test $result = ok -a $start_test_number -le 434; then
	echo test 434: More error recovery with 2 errors.
        cat >$test_file <<'TEST434'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_recovery_match (4);
p.set_grammar (g, 1);

var str = "a+a*(a*)+(*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (p.ambiguous_p);
TEST434
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT434' && $CMP $stdout $ftemp2; then
syntax error on token #7 (41) -- ignore 4 tokens starting with token #5
plus(
  plus(
    $term(97, 0)
    mult(
      $term(97, 2)
      $error
    )
  )
  $error
)
OUTPUT434
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 435.
if test $result = ok -a $start_test_number -le 435; then
	echo test 435: More ambiguous grammar.
        cat >$test_file <<'TEST435'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | 'b' # 0\n\
           | 'c' # 0\n\
           | 'd' # 0\n\
           | '(' E ')' # 1\n";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+b*c+d";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST435
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT435' && $CMP $stdout $ftemp2; then
$alt(
  plus(
    $alt(
      mult(
        plus(
          $term(97, 0)
          $term(98, 2)
        )
        $term(99, 4)
      )
      plus(
        $term(97, 0)
        mult(
          $term(98, 2)
          $term(99, 4)
        )
      )
    )
    $term(100, 6)
  )
  mult(
    plus(
      $term(97, 0)
      $term(98, 2)
    )
    plus(
      $term(99, 4)
      $term(100, 6)
    )
  )
  plus(
    $term(97, 0)
    $alt(
      mult(
        $term(98, 2)
        plus(
          $term(99, 4)
          $term(100, 6)
        )
      )
      plus(
        mult(
          $term(98, 2)
          $term(99, 4)
        )
        $term(100, 6)
      )
    )
  )
)
OUTPUT435
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 436.
if test $result = ok -a $start_test_number -le 436; then
	echo test 436: More ambiguous grammar and GC.
        cat >$test_file <<'TEST436'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | 'b' # 0\n\
           | 'c' # 0\n\
           | 'd' # 0\n\
           | '(' E ')' # 1\n";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+b*c+a";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);

var v, iter;

for (iter = 0; iter < 1000; iter++) { 
  v = [];
  for (i = 0; i < 100; i++)
    insv (v, [1]);
  for (i = 0; i < 100; i++)
    del (v, 0);
}

println (v);

pr (root, 0);

exit (!p.ambiguous_p);
TEST436
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT436' && $CMP $stdout $ftemp2; then
$alt(
  plus(
    $term(97, 0)
    $alt(
      mult(
        $term(98, 2)
        plus(
          $term(99, 4)
          $term(97, 6)
        )
      )
      plus(
        mult(
          $term(98, 2)
          $term(99, 4)
        )
        $term(97, 6)
      )
    )
  )
  mult(
    plus(
      $term(97, 0)
      $term(98, 2)
    )
    plus(
      $term(99, 4)
      $term(97, 6)
    )
  )
  plus(
    $alt(
      mult(
        plus(
          $term(97, 0)
          $term(98, 2)
        )
        $term(99, 4)
      )
      plus(
        $term(97, 0)
        mult(
          $term(98, 2)
          $term(99, 4)
        )
      )
    )
    $term(97, 6)
  )
)
[]
$alt(
  plus(
    $term(97, 0)
    $alt(
      mult(
        $term(98, 2)
        plus(
          $term(99, 4)
          $term(97, 6)
        )
      )
      plus(
        mult(
          $term(98, 2)
          $term(99, 4)
        )
        $term(97, 6)
      )
    )
  )
  mult(
    plus(
      $term(97, 0)
      $term(98, 2)
    )
    plus(
      $term(99, 4)
      $term(97, 6)
    )
  )
  plus(
    $alt(
      mult(
        plus(
          $term(97, 0)
          $term(98, 2)
        )
        $term(99, 4)
      )
      plus(
        $term(97, 0)
        mult(
          $term(98, 2)
          $term(99, 4)
        )
      )
    )
    $term(97, 6)
  )
)
OUTPUT436
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 437.
if test $result = ok -a $start_test_number -le 437; then
	echo test 437: Debugging information.
        cat >$test_file <<'TEST437'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (1);
p.set_one_parse (0);
p.set_recovery_match (4);
p.set_grammar (g, 1);

var str = "a+a*(a*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (p.ambiguous_p);
TEST437
        echo '      ' "$DINO $test_file >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT437' && $CMP $stdout $ftemp2; then
Grammar: #terms = 7, #nonterms = 4, #rules = 8, rules size = 24
Input: #tokens = 12, #unique situations = 22
       #terminal sets = 30, their size = 240
       #unique set cores = 10, #their start situations = 25
       #parent indexes for some non start situations = 0
       #unique set dist. vects = 13, their length = 30
       #pairs(set core, symb) = 38, their trans+reduce vects length = 43
       #unique transition vectors = 12, their length = 16
       #unique reduce vectors = 4, their length = 4
       #term nodes = 5, #abstract nodes = 4
       #alternative nodes = 0, #all nodes = 9
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      mult(
        $term(97, 5)
        $term(97, 7)
      )
      $term(97, 9)
    )
  )
)
OUTPUT437
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT437' && $CMP $stdout $ftemp2; then
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      mult(
        $term(97, 5)
        $term(97, 7)
      )
      $term(97, 9)
    )
  )
)
Grammar: #terms = 7, #nonterms = 4, #rules = 8, rules size = 24
Input: #tokens = 12, #unique situations = 22
       #terminal sets = 30, their size = 240
       #unique set cores = 10, #their start situations = 25
       #parent indexes for some non start situations = 0
       #unique set dist. vects = 13, their length = 30
       #pairs(set core, symb) = 38, their trans+reduce vects length = 43
       #unique transition vectors = 12, their length = 16
       #unique reduce vectors = 4, their length = 4
       #term nodes = 5, #abstract nodes = 4
       #alternative nodes = 0, #all nodes = 9
OUTPUT437
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 438.
if test $result = ok -a $start_test_number -le 438; then
	echo test 438: Debugging information.
        cat >$test_file <<'TEST438'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (2);
p.set_one_parse (0);
p.set_recovery_match (4);
p.set_grammar (g, 1);

var str = "a+a*(a*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (p.ambiguous_p);
TEST438
        echo '      ' "$DINO $test_file >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT438' && $CMP $stdout $ftemp2; then
Translation:
      0: ABSTRACT: plus ( 1 2 )
      1: TERMINAL: code=97, repr='a'
      2: ABSTRACT: mult ( 3 4 )
      3: TERMINAL: code=97, repr='a'
      4: ABSTRACT: plus ( 5 6 )
      5: ABSTRACT: mult ( 7 8 )
      7: TERMINAL: code=97, repr='a'
      8: TERMINAL: code=97, repr='a'
      6: TERMINAL: code=97, repr='a'

Grammar: #terms = 7, #nonterms = 4, #rules = 8, rules size = 24
Input: #tokens = 12, #unique situations = 22
       #terminal sets = 30, their size = 240
       #unique set cores = 10, #their start situations = 25
       #parent indexes for some non start situations = 0
       #unique set dist. vects = 13, their length = 30
       #pairs(set core, symb) = 38, their trans+reduce vects length = 43
       #unique transition vectors = 12, their length = 16
       #unique reduce vectors = 4, their length = 4
       #term nodes = 5, #abstract nodes = 4
       #alternative nodes = 0, #all nodes = 9
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      mult(
        $term(97, 5)
        $term(97, 7)
      )
      $term(97, 9)
    )
  )
)
OUTPUT438
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT438' && $CMP $stdout $ftemp2; then
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      mult(
        $term(97, 5)
        $term(97, 7)
      )
      $term(97, 9)
    )
  )
)
Translation:
      0: ABSTRACT: plus ( 1 2 )
      1: TERMINAL: code=97, repr='a'
      2: ABSTRACT: mult ( 3 4 )
      3: TERMINAL: code=97, repr='a'
      4: ABSTRACT: plus ( 5 6 )
      5: ABSTRACT: mult ( 7 8 )
      7: TERMINAL: code=97, repr='a'
      8: TERMINAL: code=97, repr='a'
      6: TERMINAL: code=97, repr='a'

Grammar: #terms = 7, #nonterms = 4, #rules = 8, rules size = 24
Input: #tokens = 12, #unique situations = 22
       #terminal sets = 30, their size = 240
       #unique set cores = 10, #their start situations = 25
       #parent indexes for some non start situations = 0
       #unique set dist. vects = 13, their length = 30
       #pairs(set core, symb) = 38, their trans+reduce vects length = 43
       #unique transition vectors = 12, their length = 16
       #unique reduce vectors = 4, their length = 4
       #term nodes = 5, #abstract nodes = 4
       #alternative nodes = 0, #all nodes = 9
OUTPUT438
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 439.
if test $result = ok -a $start_test_number -le 439; then
	echo test 439: Parameter exception.
        cat >$test_file <<'TEST439'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (nil);
p.set_one_parse ("0");

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST439
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT439' && $CMP $stderr $ftemp2; then
test.d:12:13: run time error - invalid parameter type of `set_debug'
OUTPUT439
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 440.
if test $result = ok -a $start_test_number -le 440; then
	echo test 440: More parameter exception.
        cat >$test_file <<'TEST440'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug ("0");
p.set_one_parse (nil);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST440
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT440' && $CMP $stderr $ftemp2; then
test.d:13:17: run time error - invalid parameter type of `set_one_parse'
OUTPUT440
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 441.
if test $result = ok -a $start_test_number -le 441; then
	echo test 441: More parameter exception.
        cat >$test_file <<'TEST441'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery (nil);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST441
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT441' && $CMP $stderr $ftemp2; then
test.d:14:16: run time error - invalid parameter type of `set_recovery'
OUTPUT441
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 442.
if test $result = ok -a $start_test_number -le 442; then
	echo test 442: More parameter exception.
        cat >$test_file <<'TEST442'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match (nil);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST442
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT442' && $CMP $stderr $ftemp2; then
test.d:15:22: run time error - invalid parameter type of `set_recovery_match'
OUTPUT442
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 443.
if test $result = ok -a $start_test_number -le 443; then
	echo test 443: More parameter exception.
        cat >$test_file <<'TEST443'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (['T', 'E', 'R', 'M'], nil);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST443
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT443' && $CMP $stderr $ftemp2; then
test.d:17:15: run time error - invalid parameter type of `set_grammar'
OUTPUT443
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 444.
if test $result = ok -a $start_test_number -le 444; then
	echo test 444: More parameter exception.
        cat >$test_file <<'TEST444'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (nil, 0);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST444
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT444' && $CMP $stderr $ftemp2; then
test.d:17:15: run time error - invalid parameter type of `set_grammar'
OUTPUT444
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 445.
if test $result = ok -a $start_test_number -le 445; then
	echo test 445: More parameter exception.
        cat >$test_file <<'TEST445'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (0, 0);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST445
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT445' && $CMP $stderr $ftemp2; then
test.d:17:15: run time error - invalid parameter type of `set_grammar'
OUTPUT445
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 446.
if test $result = ok -a $start_test_number -le 446; then
	echo test 446: More parameter exception.
        cat >$test_file <<'TEST446'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, 0);
exit (0);
TEST446
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT446' && $CMP $stderr $ftemp2; then
test.d:35:20: run time error - invalid parameter type of `parse'
OUTPUT446
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 447.
if test $result = ok -a $start_test_number -le 447; then
	echo test 447: More parameter exception.
        cat >$test_file <<'TEST447'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (nil, error);
exit (0);
TEST447
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT447' && $CMP $stderr $ftemp2; then
test.d:35:20: run time error - invalid parameter type of `parse'
OUTPUT447
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 447.
if test $result = ok -a $start_test_number -le 447; then
	echo test 447: More parameter exception.
        cat >$test_file <<'TEST447'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (['a', 'b'], error);
exit (0);
TEST447
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT447' && $CMP $stderr $ftemp2; then
test.d:35:20: run time error - invalid parameter type of `parse'
OUTPUT447
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 448.
if test $result = ok -a $start_test_number -le 448; then
	echo test 448: More parameter exception.
        cat >$test_file <<'TEST448'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

{
 class token (c) {}
 var root = p.parse ([token ('a'), token ('b')], error);
}
exit (0);
TEST448
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT448' && $CMP $stderr $ftemp2; then
test.d:37:21: run time error (parse) -- invalid token #0
OUTPUT448
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 449.
if test $result = ok -a $start_test_number -le 449; then
	echo test 449: More parameter exception.
        cat >$test_file <<'TEST449'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (g, 0);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse ([token ('a'), token ('b')], error);
exit (0);
TEST449
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT449' && $CMP $stderr $ftemp2; then
test.d:35:20: run time error (parse) -- invalid code of token #0
OUTPUT449
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 450.
if test $result = ok -a $start_test_number -le 450; then
	echo test 450: More parameter exception.
        cat >$test_file <<'TEST450'
class c1 {friend g; var -a;}
TEST450
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT450' && $CMP $stderr $ftemp2; then
test.d:1:18: there is no declaration for identifier `g' in friend list
OUTPUT450
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 451.
if test $result = ok -a $start_test_number -le 451; then
	echo test 451: More parameter exception.
        cat >$test_file <<'TEST451'
var g;
class c1 {friend g; var -a;}
TEST451
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT451' && $CMP $stderr $ftemp2; then
test.d:2:18: friend identifier `g' is neither function nor class
OUTPUT451
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 452.
if test $result = ok -a $start_test_number -le 452; then
	echo test 452
        cat >$test_file <<'TEST452'
class c2;
class c1 {friend c2; var -a = 10;}
var i1 = c1 ();
class c2 {var a; a = i1.a;}
var i2 = c2 ();
putln (i2.a);
TEST452
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT452' && $CMP $stdout $ftemp2; then
10
OUTPUT452
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 453.
if test $result = ok -a $start_test_number -le 453; then
	echo test 453: IEEE package
        cat >$test_file <<'TEST453'
// There is no goal to test IEEE package we simply testing all
// functions of ieee.d

include "ieee";

var s1 = ieees.single(), s2 = ieees.single();
putln ("*******IEEE singles:**********");

putln ("pzero s1 (2, 4, 8, 16)=", s1.to_binary_string (2), ", ",
       s1.to_binary_string (4), ", ", s1.to_binary_string (8), ", ",
       s1.to_binary_string (16));
putln ("pzero s1=", s1.to_string ());
putln ("pzero s2 (2, 4, 8, 16)=", s2.to_binary_string (2), ", ",
       s2.to_binary_string (4), ", ", s2.to_binary_string (8), ", ",
       s2.to_binary_string (16));
putln ("pzero s2=", s2.to_string ());

s1 = ieees.single("0");
s2 = ieees.single("0");

s1.nzero();
putln ("-zero s1=", s1.to_string (), " s1 is -zero = ", s1.is_nzero ());
s1.nan();
putln ("nan s1=", s1.to_string (), " s1 is nan = ", s1.is_nan ());
s1.trap_nan();
putln ("trap nan s1=", s1.to_string (),
       " s1 is trap nan = ", s1.is_trap_nan ());
s1.pinfinity();
putln ("+infinity s1=", s1.to_string (),
       " s1 is +infinity = ", s1.is_pinfinity ());
s1.ninfinity();
putln ("-infinity s1=", s1.to_string (),
       " s1 is -infinity = ", s1.is_ninfinity ());
s1.pmax();
putln ("+max s1 (10, 16)=", s1.to_string (), ", ", s1.to_binary_string (16),
       " s1 is norm = ", s1.is_normalized ());
s1.nmax();
putln ("-max s1 (10, 16)=", s1.to_string (), ", ", s1.to_binary_string (16),
       " s1 is norm = ", s1.is_normalized ());
s1.pmin();
putln ("+min s1 (10, 16)=", s1.to_string (), ", ", s1.to_binary_string (16),
       " s1 is denorm = ", s1.is_denormalized ());
s1.nmin();
putln ("-min s1 (10,16)=", s1.to_string (), ", ", s1.to_binary_string (16),
       " s1 is denorm = ", s1.is_denormalized ());

s1.from_float(5.0);
s2.from_float(10.0);
putln ("s1 (10,2,4,8,16)= ", s1.to_string (), ", ", s1.to_binary_string (2),
       ", ", s1.to_binary_string (4), ", ", s1.to_binary_string (8),
       ", ", s1.to_binary_string (16));
putln ("s2 = ", s2.to_string ());

s1.from_string("5.0");
s2.from_string("10.0");
putln ("s1 = ", s1.to_string ());
putln ("s2 = ", s2.to_string ());

s1.from_binary_string("5.0", 16);
s2.from_binary_string("2.8p2", 16);
putln ("s1 = ", s1.to_string ());
putln ("s2 = ", s2.to_string ());

putln ("s1 + s2 = ", s1.add (s2).to_string ());
putln ("s1 - s2 = ", s1.subtract (s2).to_string ());
putln ("s2 - s1 = ", s2.subtract (s1).to_string ());
putln ("s1 * s2 = ", s1.multiply (s2).to_string ());
putln ("s1 / s2 = ", s1.divide (s2).to_string ());
putln ("s1 == s2 = ", s1.eq (s2));
putln ("s1 != s2 = ", s1.ne (s2));
putln ("s1 < s2 = ", s1.lt (s2));
putln ("s1 <= s2 = ", s1.le (s2));
putln ("s1 > s2 = ", s1.gt (s2));
putln ("s1 >= s2 = ", s1.ge (s2));

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

try {
  var s3 = ieees.single ();
  put (s1.to_string (), " / ", s3.to_string (), " ...");
  s1.divide (s3);
} catch (ieees.ieee_excepts.zero_division) {
  putln ("  got zero_division");
}

{
  var s3 = ieees.single (), st, res;
  ieees.ignore_excepts = 1;
  put (s1.to_string (), " / ", s3.to_string (), " = ");
  res = s1.divide (s3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.dz);
  ieees.ignore_excepts = 0;
}

try {
  var s3 = ieees.single ("3");
  put (s1.to_string (), " / ", s3.to_string (), " ...");
  s1.divide (s3);
} catch (ieees.ieee_excepts.imprecise_result) {
  putln ("  got imprecise result");
}

{
  var s3 = ieees.single ("3"), st, res;
  ieees.ignore_excepts = 1;
  put (s1.to_string (), " / ", s3.to_string (), " = ");
  res = s1.divide (s3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.imp);
  ieees.ignore_excepts = 0;
}

try {
  var s3 = ieees.single ();
  s3.pmax ();
  put (s3.to_string (), " + ", s3.to_string (), " ...");
  s3.add (s3);
} catch (ieees.ieee_excepts.overflow) {
  putln ("  got overflow");
}

{
  var s3 = ieees.single (), st, res;
  ieees.ignore_excepts = 1;
  s3.pmax ();
  put (s3.to_string (), " + ", s3.to_string (), " = ");
  res = s3.add (s3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ofl);
  ieees.ignore_excepts = 0;
}

try {
  var s3 = ieees.single ();
  s3.pmin ();
  put (s3.to_string (), " / 10 ...");
  s3.divide (ieees.single ("10"));
} catch (ieees.ieee_excepts.underflow) {
  putln ("  got underflow");
}

{
  var s3 = ieees.single (), st, res;
  s3.pmin ();
  ieees.ignore_excepts = 1;
  put (s3.to_string (), " / 10 = ");
  res = s3.divide (ieees.single ("10"));
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ufl);
  ieees.ignore_excepts = 0;
}

try {
  var s3 = ieees.single ("SNaN");
  put (s3.to_string (), " + ", s3.to_string (), " ...");
  s3.add (s3);
} catch (ieees.ieee_excepts.invalid_operation) {
  putln ("  got invalid operation");
}

{
  var s3 = ieees.single ("SNaN"), st, res;
  ieees.ignore_excepts = 1;
  put (s3.to_string (), " + ", s3.to_string (), " = ");
  res = s3.add (s3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.inv);
  ieees.ignore_excepts = 0;
}

try {
  var s3 = ieees.single ("QNaN");
  put (s3.to_string (), " + ", s3.to_string (), " ...");
  s3.add (s3);
} catch (ieees.ieee_excepts.reserved_operand) {
  putln ("  got reserved operand");
}

{
  var s3 = ieees.single ("QNaN"), st, res;
  ieees.ignore_excepts = 1;
  put (s3.to_string (), " + ", s3.to_string (), " = ");
  res = s3.add (s3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ro);
  ieees.ignore_excepts = 0;
}

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

putln ("trap mask = ", ieees.get_trap_mask ());

ieees.set_trap_mask (ieees.inv|ieees.ro|ieees.ofl
		     |ieees.ufl|ieees.imp|ieees.dz);
putln ("trap mask = ", ieees.get_trap_mask ());

var s3 = ieees.single ();
put (s1.to_string (), " / ", s3.to_string (), " = ");
putln (s1.divide (s3).to_string ());

s3 = ieees.single ("3");
put (s1.to_string (), " / ", s3.to_string (), " = ");
putln (s1.divide (s3).to_string ());

s3 = ieees.single ();
s3.pmax ();
put (s3.to_string (), " + ", s3.to_string (), " = ");
putln (s3.add (s3).to_string ());

s3 = ieees.single ();
s3.pmin ();
put (s3.to_string (), " / 10 = ");
putln (s3.divide (ieees.single ("10")).to_string ());

s3 = ieees.single ("SNaN");
put (s3.to_string (), " + ", s3.to_string (), " = ");
putln (s3.add (s3).to_string ());

s3 = ieees.single ("QNaN");
put (s3.to_string (), " + ", s3.to_string (), " = ");
putln (s3.add (s3).to_string ());

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

putln ("round = ", ieees.get_round ());

s3 = ieees.single ("1.23456788");
s1 = ieees.single ("0.00000001");
putln (s3.to_string (), " + ", s1.to_string (), " = ",
       s3.add (s1).to_string ());

ieees.set_round (ieees.rni);
putln ("round = ", ieees.get_round ());

s3 = ieees.single ("1.23456788");
s1 = ieees.single ("0.00000001");
putln (s3.to_string (), " + ", s1.to_string (), " = ",
       s3.add (s1).to_string ());

ieees.set_round (ieees.rpi);
putln ("round = ", ieees.get_round ());

s3 = ieees.single ("1.23456788");
s1 = ieees.single ("0.00000001");
putln (s3.to_string (), " + ", s1.to_string (), " = ",
       s3.add (s1).to_string ());

ieees.set_round (ieees.rz);
putln ("round = ", ieees.get_round ());

s3 = ieees.single ("1.23456788");
s1 = ieees.single ("0.00000001");
putln (s3.to_string (), " + ", s1.to_string (), " = ",
       s3.add (s1).to_string ());

try {
  ieees.set_round (6);
} catch (ieees.ieee_excepts.round_value) {
  putln ("  got invalid round value");
}

s1 = ieees.single ("5");
var ms = s1.to_mpi (4);
putln ("ms (from s1) = ", mpis.to_string (ms));
s1.from_mpi (ms);
putln ("s1 (from ms) = ", s1.to_string ());

//////////////////////////////////////////////////////////////

ieees.reset ();
var d1 = ieees.double(), d2 = ieees.double();
putln ("*******IEEE doubles:**********");

putln ("pzero d1 (2, 4, 8, 16)=", d1.to_binary_string (2), ", ",
       d1.to_binary_string (4), ", ", d1.to_binary_string (8), ", ",
       d1.to_binary_string (16));
putln ("pzero d1=", d1.to_string ());
putln ("pzero d2 (2, 4, 8, 16)=", d2.to_binary_string (2), ", ",
       d2.to_binary_string (4), ", ", d2.to_binary_string (8), ", ",
       d2.to_binary_string (16));
putln ("pzero d2=", d2.to_string ());

d1 = ieees.double("0");
d2 = ieees.double("0");

d1.nzero();
putln ("-zero d1=", d1.to_string (), " d1 is -zero = ", d1.is_nzero ());
d1.nan();
putln ("nan d1=", d1.to_string (), " d1 is nan = ", d1.is_nan ());
d1.trap_nan();
putln ("trap nan d1=", d1.to_string (),
       " d1 is trap nan = ", d1.is_trap_nan ());
d1.pinfinity();
putln ("+infinity d1=", d1.to_string (),
       " d1 is +infinity = ", d1.is_pinfinity ());
d1.ninfinity();
putln ("-infinity d1=", d1.to_string (),
       " d1 is -infinity = ", d1.is_ninfinity ());
d1.pmax();
putln ("+max d1 (10, 16)=", d1.to_string (), ", ", d1.to_binary_string (16),
       " d1 is norm = ", d1.is_normalized ());
d1.nmax();
putln ("-max d1 (10, 16)=", d1.to_string (), ", ", d1.to_binary_string (16),
       " d1 is norm = ", d1.is_normalized ());
d1.pmin();
putln ("+min d1 (10, 16)=", d1.to_string (), ", ", d1.to_binary_string (16),
       " d1 is denorm = ", d1.is_denormalized ());
d1.nmin();
putln ("-min d1 (10,16)=", d1.to_string (), ", ", d1.to_binary_string (16),
       " d1 is denorm = ", d1.is_denormalized ());

d1.from_float(5.0);
d2.from_float(10.0);
putln ("d1 (10,2,4,8,16)= ", d1.to_string (), ", ", d1.to_binary_string (2),
       ", ", d1.to_binary_string (4), ", ", d1.to_binary_string (8),
       ", ", d1.to_binary_string (16));
putln ("d2 = ", d2.to_string ());

d1.from_string("5.0");
d2.from_string("10.0");
putln ("d1 = ", d1.to_string ());
putln ("d2 = ", d2.to_string ());

d1.from_binary_string("5.0", 16);
d2.from_binary_string("2.8p2", 16);
putln ("d1 = ", d1.to_string ());
putln ("d2 = ", d2.to_string ());

putln ("d1 + d2 = ", d1.add (d2).to_string ());
putln ("d1 - d2 = ", d1.subtract (d2).to_string ());
putln ("d2 - d1 = ", d2.subtract (d1).to_string ());
putln ("d1 * d2 = ", d1.multiply (d2).to_string ());
putln ("d1 / d2 = ", d1.divide (d2).to_string ());
putln ("d1 == d2 = ", d1.eq (d2));
putln ("d1 != d2 = ", d1.ne (d2));
putln ("d1 < d2 = ", d1.lt (d2));
putln ("d1 <= d2 = ", d1.le (d2));
putln ("d1 > d2 = ", d1.gt (d2));
putln ("d1 >= d2 = ", d1.ge (d2));

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

try {
  var d3 = ieees.double ();
  put (d1.to_string (), " / ", d3.to_string (), " ...");
  d1.divide (d3);
} catch (ieees.ieee_excepts.zero_division) {
  putln ("  got zero_division");
}

{
  var d3 = ieees.double (), st, res;
  ieees.ignore_excepts = 1;
  put (d1.to_string (), " / ", d3.to_string (), " = ");
  res = d1.divide (d3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.dz);
  ieees.ignore_excepts = 0;
}

try {
  var d3 = ieees.double ("3");
  put (d1.to_string (), " / ", d3.to_string (), " ...");
  d1.divide (d3);
} catch (ieees.ieee_excepts.imprecise_result) {
  putln ("  got imprecise result");
}

{
  var d3 = ieees.double ("3"), st, res;
  ieees.ignore_excepts = 1;
  put (d1.to_string (), " / ", d3.to_string (), " = ");
  res = d1.divide (d3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.imp);
  ieees.ignore_excepts = 0;
}

try {
  var d3 = ieees.double ();
  d3.pmax ();
  put (d3.to_string (), " + ", d3.to_string (), " ...");
  d3.add (d3);
} catch (ieees.ieee_excepts.overflow) {
  putln ("  got overflow");
}

{
  var d3 = ieees.double (), st, res;
  ieees.ignore_excepts = 1;
  d3.pmax ();
  put (d3.to_string (), " + ", d3.to_string (), " = ");
  res = d3.add (d3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ofl);
  ieees.ignore_excepts = 0;
}

try {
  var d3 = ieees.double ();
  d3.pmin ();
  put (d3.to_string (), " / 10 ...");
  d3.divide (ieees.double ("10"));
} catch (ieees.ieee_excepts.underflow) {
  putln ("  got underflow");
}

{
  var d3 = ieees.double (), st, res;
  d3.pmin ();
  ieees.ignore_excepts = 1;
  put (d3.to_string (), " / 10 = ");
  res = d3.divide (ieees.double ("10"));
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ufl);
  ieees.ignore_excepts = 0;
}

try {
  var d3 = ieees.double ("SNaN");
  put (d3.to_string (), " + ", d3.to_string (), " ...");
  d3.add (d3);
} catch (ieees.ieee_excepts.invalid_operation) {
  putln ("  got invalid operation");
}

{
  var d3 = ieees.double ("SNaN"), st, res;
  ieees.ignore_excepts = 1;
  put (d3.to_string (), " + ", d3.to_string (), " = ");
  res = d3.add (d3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.inv);
  ieees.ignore_excepts = 0;
}

try {
  var d3 = ieees.double ("QNaN");
  put (d3.to_string (), " + ", d3.to_string (), " ...");
  d3.add (d3);
} catch (ieees.ieee_excepts.reserved_operand) {
  putln ("  got reserved operand");
}

{
  var d3 = ieees.double ("QNaN"), st, res;
  ieees.ignore_excepts = 1;
  put (d3.to_string (), " + ", d3.to_string (), " = ");
  res = d3.add (d3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ro);
  ieees.ignore_excepts = 0;
}

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

putln ("trap mask = ", ieees.get_trap_mask ());

ieees.set_trap_mask (ieees.inv|ieees.ro|ieees.ofl
		     |ieees.ufl|ieees.imp|ieees.dz);
putln ("trap mask = ", ieees.get_trap_mask ());

var d3 = ieees.double ();
put (d1.to_string (), " / ", d3.to_string (), " = ");
putln (d1.divide (d3).to_string ());

d3 = ieees.double ("3");
put (d1.to_string (), " / ", d3.to_string (), " = ");
putln (d1.divide (d3).to_string ());

d3 = ieees.double ();
d3.pmax ();
put (d3.to_string (), " + ", d3.to_string (), " = ");
putln (d3.add (d3).to_string ());

d3 = ieees.double ();
d3.pmin ();
put (d3.to_string (), " / 10 = ");
putln (d3.divide (ieees.double ("10")).to_string ());

d3 = ieees.double ("SNaN");
put (d3.to_string (), " + ", d3.to_string (), " = ");
putln (d3.add (d3).to_string ());

d3 = ieees.double ("QNaN");
put (d3.to_string (), " + ", d3.to_string (), " = ");
putln (d3.add (d3).to_string ());

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

putln ("round = ", ieees.get_round ());

d3 = ieees.double ("1.2345678901234567");
d1 = ieees.double ("0.0000000000000004");
putln (d3.to_string (), " + ", d1.to_string (), " = ",
       d3.add (d1).to_string ());

ieees.set_round (ieees.rni);
putln ("round = ", ieees.get_round ());

d3 = ieees.double ("1.2345678901234567");
d1 = ieees.double ("0.0000000000000004");
putln (d3.to_string (), " + ", d1.to_string (), " = ",
       d3.add (d1).to_string ());

ieees.set_round (ieees.rpi);
putln ("round = ", ieees.get_round ());

d3 = ieees.double ("1.2345678901234567");
d1 = ieees.double ("0.0000000000000004");
putln (d3.to_string (), " + ", d1.to_string (), " = ",
       d3.add (d1).to_string ());

ieees.set_round (ieees.rz);
putln ("round = ", ieees.get_round ());

d3 = ieees.double ("1.2345678901234567");
d1 = ieees.double ("0.0000000000000004");
putln (d3.to_string (), " + ", d1.to_string (), " = ",
       d3.add (d1).to_string ());

try {
  ieees.set_round (6);
} catch (ieees.ieee_excepts.round_value) {
  putln ("  got invalid round value");
}

d1 = ieees.double ("5");
var md = d1.to_mpi (4);
putln ("md (from d1) = ", mpis.to_string (md));
d1.from_mpi (md);
putln ("d1 (from md) = ", d1.to_string ());

//////////////////////////////////////////////////////////////

ieees.reset ();
var q1 = ieees.quad(), q2 = ieees.quad();
putln ("*******IEEE quads:**********");

putln ("pzero q1 (2, 4, 8, 16)=", q1.to_binary_string (2), ", ",
       q1.to_binary_string (4), ", ", q1.to_binary_string (8), ", ",
       q1.to_binary_string (16));
putln ("pzero q1=", q1.to_string ());
putln ("pzero q2 (2, 4, 8, 16)=", q2.to_binary_string (2), ", ",
       q2.to_binary_string (4), ", ", q2.to_binary_string (8), ", ",
       q2.to_binary_string (16));
putln ("pzero q2=", q2.to_string ());

q1 = ieees.quad("0");
q2 = ieees.quad("0");

q1.nzero();
putln ("-zero q1=", q1.to_string (), " q1 is -zero = ", q1.is_nzero ());
q1.nan();
putln ("nan q1=", q1.to_string (), " q1 is nan = ", q1.is_nan ());
q1.trap_nan();
putln ("trap nan q1=", q1.to_string (),
       " q1 is trap nan = ", q1.is_trap_nan ());
q1.pinfinity();
putln ("+infinity q1=", q1.to_string (),
       " q1 is +infinity = ", q1.is_pinfinity ());
q1.ninfinity();
putln ("-infinity q1=", q1.to_string (),
       " q1 is -infinity = ", q1.is_ninfinity ());
q1.pmax();
putln ("+max q1 (10, 16)=", q1.to_string (), ", ", q1.to_binary_string (16),
       " q1 is norm = ", q1.is_normalized ());
q1.nmax();
putln ("-max q1 (10, 16)=", q1.to_string (), ", ", q1.to_binary_string (16),
       " q1 is norm = ", q1.is_normalized ());
q1.pmin();
putln ("+min q1 (10, 16)=", q1.to_string (), ", ", q1.to_binary_string (16),
       " q1 is denorm = ", q1.is_denormalized ());
q1.nmin();
putln ("-min q1 (10,16)=", q1.to_string (), ", ", q1.to_binary_string (16),
       " q1 is denorm = ", q1.is_denormalized ());

q1.from_float(5.0);
q2.from_float(10.0);
putln ("q1 (10,2,4,8,16)= ", q1.to_string (), ", ", q1.to_binary_string (2),
       ", ", q1.to_binary_string (4), ", ", q1.to_binary_string (8),
       ", ", q1.to_binary_string (16));
putln ("q2 = ", q2.to_string ());

q1.from_string("5.0");
q2.from_string("10.0");
putln ("q1 = ", q1.to_string ());
putln ("q2 = ", q2.to_string ());

q1.from_binary_string("5.0", 16);
q2.from_binary_string("2.8p2", 16);
putln ("q1 = ", q1.to_string ());
putln ("q2 = ", q2.to_string ());

putln ("q1 + q2 = ", q1.add (q2).to_string ());
putln ("q1 - q2 = ", q1.subtract (q2).to_string ());
putln ("q2 - q1 = ", q2.subtract (q1).to_string ());
putln ("q1 * q2 = ", q1.multiply (q2).to_string ());
putln ("q1 / q2 = ", q1.divide (q2).to_string ());
putln ("q1 == q2 = ", q1.eq (q2));
putln ("q1 != q2 = ", q1.ne (q2));
putln ("q1 < q2 = ", q1.lt (q2));
putln ("q1 <= q2 = ", q1.le (q2));
putln ("q1 > q2 = ", q1.gt (q2));
putln ("q1 >= q2 = ", q1.ge (q2));

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

try {
  var q3 = ieees.quad ();
  put (q1.to_string (), " / ", q3.to_string (), " ...");
  q1.divide (q3);
} catch (ieees.ieee_excepts.zero_division) {
  putln ("  got zero_division");
}

{
  var q3 = ieees.quad (), st, res;
  ieees.ignore_excepts = 1;
  put (q1.to_string (), " / ", q3.to_string (), " = ");
  res = q1.divide (q3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.dz);
  ieees.ignore_excepts = 0;
}

try {
  var q3 = ieees.quad ("3");
  put (q1.to_string (), " / ", q3.to_string (), " ...");
  q1.divide (q3);
} catch (ieees.ieee_excepts.imprecise_result) {
  putln ("  got imprecise result");
}

{
  var q3 = ieees.quad ("3"), st, res;
  ieees.ignore_excepts = 1;
  put (q1.to_string (), " / ", q3.to_string (), " = ");
  res = q1.divide (q3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.imp);
  ieees.ignore_excepts = 0;
}

try {
  var q3 = ieees.quad ();
  q3.pmax ();
  put (q3.to_string (), " + ", q3.to_string (), " ...");
  q3.add (q3);
} catch (ieees.ieee_excepts.overflow) {
  putln ("  got overflow");
}

{
  var q3 = ieees.quad (), st, res;
  ieees.ignore_excepts = 1;
  q3.pmax ();
  put (q3.to_string (), " + ", q3.to_string (), " = ");
  res = q3.add (q3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ofl);
  ieees.ignore_excepts = 0;
}

try {
  var q3 = ieees.quad ();
  q3.pmin ();
  put (q3.to_string (), " / 10 ...");
  q3.divide (ieees.quad ("10"));
} catch (ieees.ieee_excepts.underflow) {
  putln ("  got underflow");
}

{
  var q3 = ieees.quad (), st, res;
  q3.pmin ();
  ieees.ignore_excepts = 1;
  put (q3.to_string (), " / 10 = ");
  res = q3.divide (ieees.quad ("10"));
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ufl);
  ieees.ignore_excepts = 0;
}

try {
  var q3 = ieees.quad ("SNaN");
  put (q3.to_string (), " + ", q3.to_string (), " ...");
  q3.add (q3);
} catch (ieees.ieee_excepts.invalid_operation) {
  putln ("  got invalid operation");
}

{
  var q3 = ieees.quad ("SNaN"), st, res;
  ieees.ignore_excepts = 1;
  put (q3.to_string (), " + ", q3.to_string (), " = ");
  res = q3.add (q3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.inv);
  ieees.ignore_excepts = 0;
}

try {
  var q3 = ieees.quad ("QNaN");
  put (q3.to_string (), " + ", q3.to_string (), " ...");
  q3.add (q3);
} catch (ieees.ieee_excepts.reserved_operand) {
  putln ("  got reserved operand");
}

{
  var q3 = ieees.quad ("QNaN"), st, res;
  ieees.ignore_excepts = 1;
  put (q3.to_string (), " + ", q3.to_string (), " = ");
  res = q3.add (q3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ro);
  ieees.ignore_excepts = 0;
}

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

putln ("trap mask = ", ieees.get_trap_mask ());

ieees.set_trap_mask (ieees.inv|ieees.ro|ieees.ofl
		     |ieees.ufl|ieees.imp|ieees.dz);
putln ("trap mask = ", ieees.get_trap_mask ());

var q3 = ieees.quad ();
put (q1.to_string (), " / ", q3.to_string (), " = ");
putln (q1.divide (q3).to_string ());

q3 = ieees.quad ("3");
put (q1.to_string (), " / ", q3.to_string (), " = ");
putln (q1.divide (q3).to_string ());

q3 = ieees.quad ();
q3.pmax ();
put (q3.to_string (), " + ", q3.to_string (), " = ");
putln (q3.add (q3).to_string ());

q3 = ieees.quad ();
q3.pmin ();
put (q3.to_string (), " / 10 = ");
putln (q3.divide (ieees.quad ("10")).to_string ());

q3 = ieees.quad ("SNaN");
put (q3.to_string (), " + ", q3.to_string (), " = ");
putln (q3.add (q3).to_string ());

q3 = ieees.quad ("QNaN");
put (q3.to_string (), " + ", q3.to_string (), " = ");
putln (q3.add (q3).to_string ());

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

putln ("round = ", ieees.get_round ());

q3 = ieees.quad ("1.23456789012345678901234567890123456");
q1 = ieees.quad ("0.00000000000000000000000000000000015");
putln (q3.to_string (), " + ", q1.to_string (), " = ",
       q3.add (q1).to_string ());

ieees.set_round (ieees.rni);
putln ("round = ", ieees.get_round ());

q3 = ieees.quad ("1.23456789012345678901234567890123456");
q1 = ieees.quad ("0.00000000000000000000000000000000015");
putln (q3.to_string (), " + ", q1.to_string (), " = ",
       q3.add (q1).to_string ());

ieees.set_round (ieees.rpi);
putln ("round = ", ieees.get_round ());

q3 = ieees.quad ("1.23456789012345678901234567890123456");
q1 = ieees.quad ("0.00000000000000000000000000000000015");
putln (q3.to_string (), " + ", q1.to_string (), " = ",
       q3.add (q1).to_string ());

ieees.set_round (ieees.rz);
putln ("round = ", ieees.get_round ());

q3 = ieees.quad ("1.23456789012345678901234567890123456");
q1 = ieees.quad ("0.00000000000000000000000000000000015");
putln (q3.to_string (), " + ", q1.to_string (), " = ",
       q3.add (q1).to_string ());

try {
  ieees.set_round (6);
} catch (ieees.ieee_excepts.round_value) {
  putln ("  got invalid round value");
}

q1 = ieees.quad ("5");
var mq = q1.to_mpi (4);
putln ("mq (from q1) = ", mpis.to_string (mq));
q1.from_mpi (mq);
putln ("q1 (from mq) = ", q1.to_string ());

// Transformation single -> double -> quad

d1 = s1.to_double ();
putln ("single ", s1.to_string (), " -> double ", d1.to_string ());
q1 = s1.to_quad ();
putln ("single ", s1.to_string (), " -> quad ", q1.to_string ());

s1 = d1.to_single ();
putln ("double ", d1.to_string (), " -> single ", s1.to_string ());
q1 = d1.to_quad ();
putln ("double ", d1.to_string (), " -> quad ", q1.to_string ());

s1 = q1.to_single ();
putln ("quad ", q1.to_string (), " -> single ", s1.to_string ());
d1 = q1.to_double ();
putln ("quad ", q1.to_string (), " -> double ", d1.to_string ());
TEST453
        if uname | fgrep CYGWIN; then
            echo '      ' $DINO -L./d_ieee.dll -L./d_mpi.dll -I@srcdir@ $test_file "2>$stderr"
	    if $DINO -Lieee.dll -Lmpi.dll -I@srcdir@ $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT453' && $CMP $stdout $ftemp2; then
*******IEEE singles:**********
pzero s1 (2, 4, 8, 16)=+0, +0, +0, +0
pzero s1=+0
pzero s2 (2, 4, 8, 16)=+0, +0, +0, +0
pzero s2=+0
-zero s1=-0 s1 is -zero = 1
nan s1=QNaN s1 is nan = 1
trap nan s1=SNaN s1 is trap nan = 1
+infinity s1=+Inf s1 is +infinity = 1
-infinity s1=-Inf s1 is -infinity = 1
+max s1 (10, 16)=3.40282347e38, 1.fffffep127 s1 is norm = 1
-max s1 (10, 16)=-3.40282347e38, -1.fffffep127 s1 is norm = 1
+min s1 (10, 16)=1.40129846e-45, 1.p-149 s1 is denorm = 1
-min s1 (10,16)=-1.40129846e-45, -1.p-149 s1 is denorm = 1
s1 (10,2,4,8,16)= 5.00000000, 1.01p2, 1.1p2, 1.2p2, 1.4p2
s2 = 1.00000000e1
s1 = 5.00000000
s2 = 1.00000000e1
s1 = 5.00000000
s2 = 1.00000000e1
s1 + s2 = 1.50000000e1
s1 - s2 = -5.00000000
s2 - s1 = 5.00000000
s1 * s2 = 5.00000000e1
s1 / s2 = 5.00000000e-1
s1 == s2 = 0
s1 != s2 = 1
s1 < s2 = 1
s1 <= s2 = 1
s1 > s2 = 0
s1 >= s2 = 0
sticky status bits = 0
5.00000000 / +0 ...  got zero_division
5.00000000 / +0 = +Inf status bits = 32, 32
5.00000000 / 3.00000000 ...  got imprecise result
5.00000000 / 3.00000000 = 1.66666663 status bits = 16, 16
3.40282347e38 + 3.40282347e38 ...  got overflow
3.40282347e38 + 3.40282347e38 = +Inf status bits = 4, 4
1.40129846e-45 / 10 ...  got underflow
1.40129846e-45 / 10 = +0 status bits = 24, 8
SNaN + SNaN ...  got invalid operation
SNaN + SNaN = QNaN status bits = 3, 1
QNaN + QNaN ...  got reserved operand
QNaN + QNaN = QNaN status bits = 2, 2
sticky status bits = 0
trap mask = 0
trap mask = 63
5.00000000 / +0 = +Inf
5.00000000 / 3.00000000 = 1.66666663
3.40282347e38 + 3.40282347e38 = +Inf
1.40129846e-45 / 10 = +0
SNaN + SNaN = QNaN
QNaN + QNaN = QNaN
sticky status bits = 63
round = 0
1.23456788 + 9.99999994e-9 = 1.23456788
round = 1
1.23456776 + 9.99999994e-9 = 1.23456776
round = 2
1.23456788 + 1.00000008e-8 = 1.23456800
round = 3
1.23456776 + 9.99999994e-9 = 1.23456776
  got invalid round value
ms (from s1) = 5
s1 (from ms) = 5.00000000
*******IEEE doubles:**********
pzero d1 (2, 4, 8, 16)=+0, +0, +0, +0
pzero d1=+0
pzero d2 (2, 4, 8, 16)=+0, +0, +0, +0
pzero d2=+0
-zero d1=-0 d1 is -zero = 1
nan d1=QNaN d1 is nan = 1
trap nan d1=SNaN d1 is trap nan = 1
+infinity d1=+Inf d1 is +infinity = 1
-infinity d1=-Inf d1 is -infinity = 1
+max d1 (10, 16)=1.7976931348623157e308, 1.fffffffffffffp1023 d1 is norm = 1
-max d1 (10, 16)=-1.7976931348623157e308, -1.fffffffffffffp1023 d1 is norm = 1
+min d1 (10, 16)=4.9406564584124654e-324, 1.p-1074 d1 is denorm = 1
-min d1 (10,16)=-4.9406564584124654e-324, -1.p-1074 d1 is denorm = 1
d1 (10,2,4,8,16)= 5.0000000000000000, 1.01p2, 1.1p2, 1.2p2, 1.4p2
d2 = 1.0000000000000000e1
d1 = 5.0000000000000000
d2 = 1.0000000000000000e1
d1 = 5.0000000000000000
d2 = 1.0000000000000000e1
d1 + d2 = 1.5000000000000000e1
d1 - d2 = -5.0000000000000000
d2 - d1 = 5.0000000000000000
d1 * d2 = 5.0000000000000000e1
d1 / d2 = 5.0000000000000000e-1
d1 == d2 = 0
d1 != d2 = 1
d1 < d2 = 1
d1 <= d2 = 1
d1 > d2 = 0
d1 >= d2 = 0
sticky status bits = 0
5.0000000000000000 / +0 ...  got zero_division
5.0000000000000000 / +0 = +Inf status bits = 32, 32
5.0000000000000000 / 3.0000000000000000 ...  got imprecise result
5.0000000000000000 / 3.0000000000000000 = 1.6666666666666667 status bits = 16, 16
1.7976931348623157e308 + 1.7976931348623157e308 ...  got overflow
1.7976931348623157e308 + 1.7976931348623157e308 = +Inf status bits = 4, 4
4.9406564584124654e-324 / 10 ...  got underflow
4.9406564584124654e-324 / 10 = +0 status bits = 24, 8
SNaN + SNaN ...  got invalid operation
SNaN + SNaN = QNaN status bits = 3, 1
QNaN + QNaN ...  got reserved operand
QNaN + QNaN = QNaN status bits = 2, 2
sticky status bits = 0
trap mask = 0
trap mask = 63
5.0000000000000000 / +0 = +Inf
5.0000000000000000 / 3.0000000000000000 = 1.6666666666666667
1.7976931348623157e308 + 1.7976931348623157e308 = +Inf
4.9406564584124654e-324 / 10 = +0
SNaN + SNaN = QNaN
QNaN + QNaN = QNaN
sticky status bits = 63
round = 0
1.2345678901234567 + 3.9999999999999999e-16 = 1.2345678901234571
round = 1
1.2345678901234567 + 3.9999999999999999e-16 = 1.2345678901234569
round = 2
1.2345678901234569 + 4.0000000000000004e-16 = 1.2345678901234574
round = 3
1.2345678901234567 + 3.9999999999999999e-16 = 1.2345678901234569
  got invalid round value
md (from d1) = 5
d1 (from md) = 5.0000000000000000
*******IEEE quads:**********
pzero q1 (2, 4, 8, 16)=+0, +0, +0, +0
pzero q1=+0
pzero q2 (2, 4, 8, 16)=+0, +0, +0, +0
pzero q2=+0
-zero q1=-0 q1 is -zero = 1
nan q1=QNaN q1 is nan = 1
trap nan q1=SNaN q1 is trap nan = 1
+infinity q1=+Inf q1 is +infinity = 1
-infinity q1=-Inf q1 is -infinity = 1
+max q1 (10, 16)=1.18973149535723176508575932662800702e4932, 1.ffffffffffffffffffffffffffffp16383 q1 is norm = 1
-max q1 (10, 16)=-1.18973149535723176508575932662800702e4932, -1.ffffffffffffffffffffffffffffp16383 q1 is norm = 1
+min q1 (10, 16)=6.47517511943802511092443895822764655e-4966, 1.p-16494 q1 is denorm = 1
-min q1 (10,16)=-6.47517511943802511092443895822764655e-4966, -1.p-16494 q1 is denorm = 1
q1 (10,2,4,8,16)= 5.00000000000000000000000000000000000, 1.01p2, 1.1p2, 1.2p2, 1.4p2
q2 = 1.00000000000000000000000000000000000e1
q1 = 5.00000000000000000000000000000000000
q2 = 1.00000000000000000000000000000000000e1
q1 = 5.00000000000000000000000000000000000
q2 = 1.00000000000000000000000000000000000e1
q1 + q2 = 1.50000000000000000000000000000000000e1
q1 - q2 = -5.00000000000000000000000000000000000
q2 - q1 = 5.00000000000000000000000000000000000
q1 * q2 = 5.00000000000000000000000000000000000e1
q1 / q2 = 5.00000000000000000000000000000000000e-1
q1 == q2 = 0
q1 != q2 = 1
q1 < q2 = 1
q1 <= q2 = 1
q1 > q2 = 0
q1 >= q2 = 0
sticky status bits = 0
5.00000000000000000000000000000000000 / +0 ...  got zero_division
5.00000000000000000000000000000000000 / +0 = +Inf status bits = 32, 32
5.00000000000000000000000000000000000 / 3.00000000000000000000000000000000000 ...  got imprecise result
5.00000000000000000000000000000000000 / 3.00000000000000000000000000000000000 = 1.66666666666666666666666666666666673 status bits = 16, 16
1.18973149535723176508575932662800702e4932 + 1.18973149535723176508575932662800702e4932 ...  got overflow
1.18973149535723176508575932662800702e4932 + 1.18973149535723176508575932662800702e4932 = +Inf status bits = 4, 4
6.47517511943802511092443895822764655e-4966 / 10 ...  got underflow
6.47517511943802511092443895822764655e-4966 / 10 = +0 status bits = 24, 8
SNaN + SNaN ...  got invalid operation
SNaN + SNaN = QNaN status bits = 3, 1
QNaN + QNaN ...  got reserved operand
QNaN + QNaN = QNaN status bits = 2, 2
sticky status bits = 0
trap mask = 0
trap mask = 63
5.00000000000000000000000000000000000 / +0 = +Inf
5.00000000000000000000000000000000000 / 3.00000000000000000000000000000000000 = 1.66666666666666666666666666666666673
1.18973149535723176508575932662800702e4932 + 1.18973149535723176508575932662800702e4932 = +Inf
6.47517511943802511092443895822764655e-4966 / 10 = +0
SNaN + SNaN = QNaN
QNaN + QNaN = QNaN
sticky status bits = 63
round = 0
1.23456789012345678901234567890123455 + 1.49999999999999999999999999999999996e-34 = 1.23456789012345678901234567890123475
round = 1
1.23456789012345678901234567890123455 + 1.49999999999999999999999999999999996e-34 = 1.23456789012345678901234567890123455
round = 2
1.23456789012345678901234567890123475 + 1.50000000000000000000000000000000015e-34 = 1.23456789012345678901234567890123494
round = 3
1.23456789012345678901234567890123455 + 1.49999999999999999999999999999999996e-34 = 1.23456789012345678901234567890123455
  got invalid round value
mq (from q1) = 5
q1 (from mq) = 5.00000000000000000000000000000000000
single 5.00000000 -> double 5.0000000000000000
single 5.00000000 -> quad 5.00000000000000000000000000000000000
double 5.0000000000000000 -> single 5.00000000
double 5.0000000000000000 -> quad 5.00000000000000000000000000000000000
quad 5.00000000000000000000000000000000000 -> single 5.00000000
quad 5.00000000000000000000000000000000000 -> double 5.0000000000000000
OUTPUT453
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
            echo '      ' $DINO -L./d_ieee.@EXTERN_LIB_SUFFIX@ -L./d_mpi.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file "2>$stderr"
	    if $DINO -L./d_ieee.@EXTERN_LIB_SUFFIX@ -L./d_mpi.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT453' && $CMP $stdout $ftemp2; then
*******IEEE singles:**********
pzero s1 (2, 4, 8, 16)=+0, +0, +0, +0
pzero s1=+0
pzero s2 (2, 4, 8, 16)=+0, +0, +0, +0
pzero s2=+0
-zero s1=-0 s1 is -zero = 1
nan s1=QNaN s1 is nan = 1
trap nan s1=SNaN s1 is trap nan = 1
+infinity s1=+Inf s1 is +infinity = 1
-infinity s1=-Inf s1 is -infinity = 1
+max s1 (10, 16)=3.40282347e38, 1.fffffep127 s1 is norm = 1
-max s1 (10, 16)=-3.40282347e38, -1.fffffep127 s1 is norm = 1
+min s1 (10, 16)=1.40129846e-45, 1.p-149 s1 is denorm = 1
-min s1 (10,16)=-1.40129846e-45, -1.p-149 s1 is denorm = 1
s1 (10,2,4,8,16)= 5.00000000, 1.01p2, 1.1p2, 1.2p2, 1.4p2
s2 = 1.00000000e1
s1 = 5.00000000
s2 = 1.00000000e1
s1 = 5.00000000
s2 = 1.00000000e1
s1 + s2 = 1.50000000e1
s1 - s2 = -5.00000000
s2 - s1 = 5.00000000
s1 * s2 = 5.00000000e1
s1 / s2 = 5.00000000e-1
s1 == s2 = 0
s1 != s2 = 1
s1 < s2 = 1
s1 <= s2 = 1
s1 > s2 = 0
s1 >= s2 = 0
sticky status bits = 0
5.00000000 / +0 ...  got zero_division
5.00000000 / +0 = +Inf status bits = 32, 32
5.00000000 / 3.00000000 ...  got imprecise result
5.00000000 / 3.00000000 = 1.66666663 status bits = 16, 16
3.40282347e38 + 3.40282347e38 ...  got overflow
3.40282347e38 + 3.40282347e38 = +Inf status bits = 4, 4
1.40129846e-45 / 10 ...  got underflow
1.40129846e-45 / 10 = +0 status bits = 24, 8
SNaN + SNaN ...  got invalid operation
SNaN + SNaN = QNaN status bits = 3, 1
QNaN + QNaN ...  got reserved operand
QNaN + QNaN = QNaN status bits = 2, 2
sticky status bits = 0
trap mask = 0
trap mask = 63
5.00000000 / +0 = +Inf
5.00000000 / 3.00000000 = 1.66666663
3.40282347e38 + 3.40282347e38 = +Inf
1.40129846e-45 / 10 = +0
SNaN + SNaN = QNaN
QNaN + QNaN = QNaN
sticky status bits = 63
round = 0
1.23456788 + 9.99999994e-9 = 1.23456788
round = 1
1.23456776 + 9.99999994e-9 = 1.23456776
round = 2
1.23456788 + 1.00000008e-8 = 1.23456800
round = 3
1.23456776 + 9.99999994e-9 = 1.23456776
  got invalid round value
ms (from s1) = 5
s1 (from ms) = 5.00000000
*******IEEE doubles:**********
pzero d1 (2, 4, 8, 16)=+0, +0, +0, +0
pzero d1=+0
pzero d2 (2, 4, 8, 16)=+0, +0, +0, +0
pzero d2=+0
-zero d1=-0 d1 is -zero = 1
nan d1=QNaN d1 is nan = 1
trap nan d1=SNaN d1 is trap nan = 1
+infinity d1=+Inf d1 is +infinity = 1
-infinity d1=-Inf d1 is -infinity = 1
+max d1 (10, 16)=1.7976931348623157e308, 1.fffffffffffffp1023 d1 is norm = 1
-max d1 (10, 16)=-1.7976931348623157e308, -1.fffffffffffffp1023 d1 is norm = 1
+min d1 (10, 16)=4.9406564584124654e-324, 1.p-1074 d1 is denorm = 1
-min d1 (10,16)=-4.9406564584124654e-324, -1.p-1074 d1 is denorm = 1
d1 (10,2,4,8,16)= 5.0000000000000000, 1.01p2, 1.1p2, 1.2p2, 1.4p2
d2 = 1.0000000000000000e1
d1 = 5.0000000000000000
d2 = 1.0000000000000000e1
d1 = 5.0000000000000000
d2 = 1.0000000000000000e1
d1 + d2 = 1.5000000000000000e1
d1 - d2 = -5.0000000000000000
d2 - d1 = 5.0000000000000000
d1 * d2 = 5.0000000000000000e1
d1 / d2 = 5.0000000000000000e-1
d1 == d2 = 0
d1 != d2 = 1
d1 < d2 = 1
d1 <= d2 = 1
d1 > d2 = 0
d1 >= d2 = 0
sticky status bits = 0
5.0000000000000000 / +0 ...  got zero_division
5.0000000000000000 / +0 = +Inf status bits = 32, 32
5.0000000000000000 / 3.0000000000000000 ...  got imprecise result
5.0000000000000000 / 3.0000000000000000 = 1.6666666666666667 status bits = 16, 16
1.7976931348623157e308 + 1.7976931348623157e308 ...  got overflow
1.7976931348623157e308 + 1.7976931348623157e308 = +Inf status bits = 4, 4
4.9406564584124654e-324 / 10 ...  got underflow
4.9406564584124654e-324 / 10 = +0 status bits = 24, 8
SNaN + SNaN ...  got invalid operation
SNaN + SNaN = QNaN status bits = 3, 1
QNaN + QNaN ...  got reserved operand
QNaN + QNaN = QNaN status bits = 2, 2
sticky status bits = 0
trap mask = 0
trap mask = 63
5.0000000000000000 / +0 = +Inf
5.0000000000000000 / 3.0000000000000000 = 1.6666666666666667
1.7976931348623157e308 + 1.7976931348623157e308 = +Inf
4.9406564584124654e-324 / 10 = +0
SNaN + SNaN = QNaN
QNaN + QNaN = QNaN
sticky status bits = 63
round = 0
1.2345678901234567 + 3.9999999999999999e-16 = 1.2345678901234571
round = 1
1.2345678901234567 + 3.9999999999999999e-16 = 1.2345678901234569
round = 2
1.2345678901234569 + 4.0000000000000004e-16 = 1.2345678901234574
round = 3
1.2345678901234567 + 3.9999999999999999e-16 = 1.2345678901234569
  got invalid round value
md (from d1) = 5
d1 (from md) = 5.0000000000000000
*******IEEE quads:**********
pzero q1 (2, 4, 8, 16)=+0, +0, +0, +0
pzero q1=+0
pzero q2 (2, 4, 8, 16)=+0, +0, +0, +0
pzero q2=+0
-zero q1=-0 q1 is -zero = 1
nan q1=QNaN q1 is nan = 1
trap nan q1=SNaN q1 is trap nan = 1
+infinity q1=+Inf q1 is +infinity = 1
-infinity q1=-Inf q1 is -infinity = 1
+max q1 (10, 16)=1.18973149535723176508575932662800702e4932, 1.ffffffffffffffffffffffffffffp16383 q1 is norm = 1
-max q1 (10, 16)=-1.18973149535723176508575932662800702e4932, -1.ffffffffffffffffffffffffffffp16383 q1 is norm = 1
+min q1 (10, 16)=6.47517511943802511092443895822764655e-4966, 1.p-16494 q1 is denorm = 1
-min q1 (10,16)=-6.47517511943802511092443895822764655e-4966, -1.p-16494 q1 is denorm = 1
q1 (10,2,4,8,16)= 5.00000000000000000000000000000000000, 1.01p2, 1.1p2, 1.2p2, 1.4p2
q2 = 1.00000000000000000000000000000000000e1
q1 = 5.00000000000000000000000000000000000
q2 = 1.00000000000000000000000000000000000e1
q1 = 5.00000000000000000000000000000000000
q2 = 1.00000000000000000000000000000000000e1
q1 + q2 = 1.50000000000000000000000000000000000e1
q1 - q2 = -5.00000000000000000000000000000000000
q2 - q1 = 5.00000000000000000000000000000000000
q1 * q2 = 5.00000000000000000000000000000000000e1
q1 / q2 = 5.00000000000000000000000000000000000e-1
q1 == q2 = 0
q1 != q2 = 1
q1 < q2 = 1
q1 <= q2 = 1
q1 > q2 = 0
q1 >= q2 = 0
sticky status bits = 0
5.00000000000000000000000000000000000 / +0 ...  got zero_division
5.00000000000000000000000000000000000 / +0 = +Inf status bits = 32, 32
5.00000000000000000000000000000000000 / 3.00000000000000000000000000000000000 ...  got imprecise result
5.00000000000000000000000000000000000 / 3.00000000000000000000000000000000000 = 1.66666666666666666666666666666666673 status bits = 16, 16
1.18973149535723176508575932662800702e4932 + 1.18973149535723176508575932662800702e4932 ...  got overflow
1.18973149535723176508575932662800702e4932 + 1.18973149535723176508575932662800702e4932 = +Inf status bits = 4, 4
6.47517511943802511092443895822764655e-4966 / 10 ...  got underflow
6.47517511943802511092443895822764655e-4966 / 10 = +0 status bits = 24, 8
SNaN + SNaN ...  got invalid operation
SNaN + SNaN = QNaN status bits = 3, 1
QNaN + QNaN ...  got reserved operand
QNaN + QNaN = QNaN status bits = 2, 2
sticky status bits = 0
trap mask = 0
trap mask = 63
5.00000000000000000000000000000000000 / +0 = +Inf
5.00000000000000000000000000000000000 / 3.00000000000000000000000000000000000 = 1.66666666666666666666666666666666673
1.18973149535723176508575932662800702e4932 + 1.18973149535723176508575932662800702e4932 = +Inf
6.47517511943802511092443895822764655e-4966 / 10 = +0
SNaN + SNaN = QNaN
QNaN + QNaN = QNaN
sticky status bits = 63
round = 0
1.23456789012345678901234567890123455 + 1.49999999999999999999999999999999996e-34 = 1.23456789012345678901234567890123475
round = 1
1.23456789012345678901234567890123455 + 1.49999999999999999999999999999999996e-34 = 1.23456789012345678901234567890123455
round = 2
1.23456789012345678901234567890123475 + 1.50000000000000000000000000000000015e-34 = 1.23456789012345678901234567890123494
round = 3
1.23456789012345678901234567890123455 + 1.49999999999999999999999999999999996e-34 = 1.23456789012345678901234567890123455
  got invalid round value
mq (from q1) = 5
q1 (from mq) = 5.00000000000000000000000000000000000
single 5.00000000 -> double 5.0000000000000000
single 5.00000000 -> quad 5.00000000000000000000000000000000000
double 5.0000000000000000 -> single 5.00000000
double 5.0000000000000000 -> quad 5.00000000000000000000000000000000000
quad 5.00000000000000000000000000000000000 -> single 5.00000000
quad 5.00000000000000000000000000000000000 -> double 5.0000000000000000
OUTPUT453
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
        fi
fi

# Test 454.
if test $result = ok -a $start_test_number -le 454; then
	echo test 454
        cat >$test_file <<'TEST454'
println (gmatch ("aa", "aaaaa"));
TEST454
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT454' && $CMP $stdout $ftemp2; then
[0, 2, 2, 4]
OUTPUT454
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 455.
if test $result = ok -a $start_test_number -le 455; then
	echo test 455
        cat >$test_file <<'TEST455'
println (gmatch ("aa", "aaaaa", 1));
TEST455
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT455' && $CMP $stdout $ftemp2; then
[0, 2, 1, 3, 2, 4, 3, 5]
OUTPUT455
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 456.
if test $result = ok -a $start_test_number -le 456; then
	echo test 456
        cat >$test_file <<'TEST456'
var i;
for (i = 0; i < 300000; i++)
  gmatch ("aa", "aaaaa", 1);
TEST456
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT456' && $CMP $stdout $ftemp2; then
OUTPUT456
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 457.
if test $result = ok -a $start_test_number -le 457; then
	echo test 457
        cat >$test_file <<'TEST457'
gmatch ("aa", "aaaaa", nil);
TEST457
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=fail
        elif $SCMP $stderr - <<'TEST457-1'; then
test.d:1:8: run time error - invalid parameter type of `gmatch'
TEST457-1
                result=ok
        else
                result=fail
        fi
fi

# Test 458.
if test $result = ok -a $start_test_number -le 458; then
	echo test 458
        cat >$test_file <<'TEST458'
gmatch ("aa");
TEST458
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=fail
        elif $SCMP $stderr - <<'TEST458-1'; then
test.d:1:8: run time error - invalid number of actual parameters for `gmatch'
TEST458-1
                result=ok
        else
                result=fail
        fi
fi

# Test 459.
if test $result = ok -a $start_test_number -le 459; then
	echo test 459
        cat >$test_file <<'TEST459'
gmatch ("[aa", "aa");
TEST459
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=fail
        elif $SCMP $stderr - <<'TEST459-1'; then
test.d:1:8: run time error - unmatched bracket list operators in regexp
TEST459-1
                result=ok
        else
                result=fail
        fi
fi

# Test 460.
if test $result = ok -a $start_test_number -le 460; then
	echo test 460
        cat >$test_file <<'TEST460'
gmatch (nil, "aa");
TEST460
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=fail
        elif $SCMP $stderr - <<'TEST460-1'; then
test.d:1:8: run time error - invalid parameter type of `gmatch'
TEST460-1
                result=ok
        else
                result=fail
        fi
fi

# Test 461.
if test $result = ok -a $start_test_number -le 461; then
	echo test 461
        cat >$test_file <<'TEST461'
gmatch ("aa", nil);
TEST461
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=fail
        elif $SCMP $stderr - <<'TEST461-1'; then
test.d:1:8: run time error - invalid parameter type of `gmatch'
TEST461-1
                result=ok
        else
                result=fail
        fi
fi

# Test 462.
if test $result = ok -a $start_test_number -le 462; then
	echo test 462
        cat >$test_file <<'TEST462'
put (getf());
TEST462
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT462' && $CMP $stdout $ftemp2; then
abcd
OUTPUT462
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 463.
if test $result = ok -a $start_test_number -le 463; then
	echo test 463
        cat >$test_file <<'TEST463'
var c, f = open ("test.d", "r");
put (fgetf (f));
TEST463
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT463' && $CMP $stdout $ftemp2; then
var c, f = open ("test.d", "r");
put (fgetf (f));
OUTPUT463
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 464.
if test $result = ok -a $start_test_number -le 464; then
	echo test 464
        cat >$test_file <<'TEST464'
put (getf ());
put (getf ());
TEST464
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT464' && $CMP $stderr $ftemp2; then
test.d:2:11: run time error - EOF occured in `getf'
OUTPUT464
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 465.
if test $result = ok -a $start_test_number -le 465; then
	echo test 465
        cat >$test_file <<'TEST465'
var c, f=open ("test.d", "r");
for (;1;)
  put (fgetf (f));
TEST465
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT465' && $CMP $stderr $ftemp2; then
test.d:3:14: run time error - EOF occured in `fgetf'
OUTPUT465
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 466.
if test $result = ok -a $start_test_number -le 466; then
	echo test 466
        cat >$test_file <<'TEST466'
var c = getf (nil);
TEST466
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT466' && $CMP $stderr $ftemp2; then
test.d:1:14: run time error - invalid parameter type of `getf'
OUTPUT466
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 467.
if test $result = ok -a $start_test_number -le 467; then
	echo test 467
        cat >$test_file <<'TEST467'
var c = fgetf ();
TEST467
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT467' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid number of actual parameters for `fgetf'
OUTPUT467
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 468.
if test $result = ok -a $start_test_number -le 468; then
	echo test 468
        cat >$test_file <<'TEST468'
var c = fgetf (nil);
TEST468
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT468' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid parameter type of `fgetf'
OUTPUT468
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 469.
if test $result = ok -a $start_test_number -le 469; then
	echo test 469
        cat >$test_file <<'TEST469'
var c = fgetf (stdin, nil);
TEST469
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT469' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid parameter type of `fgetf'
OUTPUT469
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 470.
if test $result = ok -a $start_test_number -le 470; then
	echo test 470
        cat >$test_file <<'TEST470'
println (char ('a'));
println (char ("97"));
TEST470
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT470' && $CMP $stdout $ftemp2; then
'a'
'a'
OUTPUT470
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 471.
if test $result = ok -a $start_test_number -le 471; then
	echo test 471
        cat >$test_file <<'TEST471'
println (int (10.0));
println (int ("10"));
TEST471
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT471' && $CMP $stdout $ftemp2; then
10
10
OUTPUT471
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 472.
if test $result = ok -a $start_test_number -le 472; then
	echo test 472
        cat >$test_file <<'TEST472'
println (float (10.5));
println (float ("10.5"));
println (float (10));
TEST472
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT472' && $CMP $stdout $ftemp2; then
10.5
10.5
10
OUTPUT472
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 473.
if test $result = ok -a $start_test_number -le 473; then
	echo test 473
        cat >$test_file <<'TEST473'
println (char (nil));
TEST473
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT473' && $CMP $stderr $ftemp2; then
test.d:1:10: run time error - invalid type of operand of char (...)
OUTPUT473
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 474.
if test $result = ok -a $start_test_number -le 474; then
	echo test 474
        cat >$test_file <<'TEST474'
println (char ({}));
TEST474
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT474' && $CMP $stderr $ftemp2; then
test.d:1:16: invalid operand type in char (...)
OUTPUT474
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 475.
if test $result = ok -a $start_test_number -le 475; then
	echo test 475
        cat >$test_file <<'TEST475'
println (char (300));
TEST475
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT475' && $CMP $stderr $ftemp2; then
test.d:1:10: system error - result too big (small): `int-to-char conversion'
OUTPUT475
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 476.
if test $result = ok -a $start_test_number -le 476; then
	echo test 476
        cat >$test_file <<'TEST476'
println (char ("30000000000000000"));
TEST476
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT476' && $CMP $stderr $ftemp2; then
test.d:1:10: system error - result too big (small): `string-to-int conversion'
OUTPUT476
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 477.
if test $result = ok -a $start_test_number -le 477; then
	echo test 477
        cat >$test_file <<'TEST477'
println (int (nil));
TEST477
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT477' && $CMP $stderr $ftemp2; then
test.d:1:10: run time error - invalid type of operand of int (...)
OUTPUT477
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 478.
if test $result = ok -a $start_test_number -le 478; then
	echo test 478
        cat >$test_file <<'TEST478'
println (int ({}));
TEST478
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT478' && $CMP $stderr $ftemp2; then
test.d:1:15: invalid operand type in int (...)
OUTPUT478
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 479.
if test $result = ok -a $start_test_number -le 479; then
	echo test 479
        cat >$test_file <<'TEST479'
println (int ("30000000000000000"));
TEST479
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT479' && $CMP $stderr $ftemp2; then
test.d:1:10: system error - result too big (small): `string-to-int conversion'
OUTPUT479
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 480.
if test $result = ok -a $start_test_number -le 480; then
	echo test 480
        cat >$test_file <<'TEST480'
println (float (nil));
TEST480
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT480' && $CMP $stderr $ftemp2; then
test.d:1:10: run time error - invalid type of operand of float (...)
OUTPUT480
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 481.
if test $result = ok -a $start_test_number -le 481; then
	echo test 481
        cat >$test_file <<'TEST481'
println (float ({}));
TEST481
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT481' && $CMP $stderr $ftemp2; then
test.d:1:17: invalid operand type in float (...)
OUTPUT481
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 482.
if test $result = ok -a $start_test_number -le 482; then
	echo test 482
        cat >$test_file <<'TEST482'
println (float ("1e500"));
TEST482
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT482' && $CMP $stderr $ftemp2; then
test.d:1:10: system error - result too big (small): `string-to-float conversion'
OUTPUT482
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 483.
if test $result = ok -a $start_test_number -le 483; then
	echo test 483
        cat >$test_file <<'TEST483'
println (float ("1e-500"));
TEST483
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT483' && $CMP $stdout $ftemp2; then
0
OUTPUT483
                        result=ok
                else
                        result=fail
                fi
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT483-1' && $CMP $stderr $ftemp2; then
test.d:1:10: system error - result too big (small): `string-to-float conversion'
OUTPUT483-1
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 484.
if test $result = ok -a $start_test_number -le 484; then
	echo test 484
        cat >$test_file <<'TEST484'
putln (version);
TEST484
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                regex="^[0-9]\.[0-9][0-9]$"
                echo '      ' egrep \'$regex\' $stdout
                if egrep "$regex" $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 485.
if test $result = ok -a $start_test_number -le 485; then
	echo test 485
        cat >$test_file <<'TEST485'
var objs_number = 0;
class obj {
  var -n = objs_number;
  objs_number++;
  putln ("creating ", n);
  func -destroy {objs_number--; putln ("destroying ", n);}
}

var i;
for (i = 0; i < 20; i++)
  obj ();
gc ();
putln (objs_number);
TEST485
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT485' && $CMP $stdout $ftemp2; then
creating 0
creating 1
creating 2
creating 3
creating 4
creating 5
creating 6
creating 7
creating 8
creating 9
creating 10
creating 11
creating 12
creating 13
creating 14
creating 15
creating 16
creating 17
creating 18
creating 19
destroying 0
destroying 1
destroying 2
destroying 3
destroying 4
destroying 5
destroying 6
destroying 7
destroying 8
destroying 9
destroying 10
destroying 11
destroying 12
destroying 13
destroying 14
destroying 15
destroying 16
destroying 17
destroying 18
destroying 19
0
OUTPUT485
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 486.
if test $result = ok -a $start_test_number -le 486; then
	echo test 486
        cat >$test_file <<'TEST486'
put (sprint (nil));put (" ");
put (sprint (10));put (" ");
put (sprint (10.2e10));put (" ");
put (sprint ('c'));put (" ");
put (sprintln ("ssss"));
put (sprintln (["aaa", "bbb", "ccc"]));
put (sprintln (["v1", {"key":"val", {"key1":"val1"}}]));
func f {}
put (sprintln (f));
class c {}
put (sprintln (c));
put (sprintln (c ()));
var stop;
stop = 0;
thread t {wait (stop);}
put (sprintln (t()));
wait (1) stop = 1;
TEST486
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT486' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+11 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", {"key":"val", {"key1":"val1"}:nil}]
func f
class c
instance c()
thread 1 t()
OUTPUT486
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT486-1' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+011 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", {"key":"val", {"key1":"val1"}:nil}]
func f
class c
instance c()
thread 1 t()
OUTPUT486-1
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT486-2' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+11 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", {{"key1":"val1"}:nil, "key":"val"}]
func f
class c
instance c()
thread 1 t()
OUTPUT486-2
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT486-3' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+011 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", {{"key1":"val1"}:nil, "key":"val"}]
func f
class c
instance c()
thread 1 t()
OUTPUT486-3
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 487.
if test $result = ok -a $start_test_number -le 487; then
	echo test 487
        cat >$test_file <<'TEST487'
put (sput (10));put (" ");
put (sput (10.2e10, " "));
put (sputln ('c', " ", "ssss"));
TEST487
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT487' && $CMP $stdout $ftemp2; then
10 1.02e+11 c ssss
OUTPUT487
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT487a' && $CMP $stdout $ftemp2; then
10 1.02e+011 c ssss
OUTPUT487a
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 488.
if test $result = ok -a $start_test_number -le 488; then
	echo test 488
        cat >$test_file <<'TEST488'
sputln (nil);
TEST488
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT488' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `sputln'
OUTPUT488
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 489.
if test $result = ok -a $start_test_number -le 489; then
	echo test 489
        cat >$test_file <<'TEST489'
sput ([10]);
TEST489
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT489' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `sput'
OUTPUT489
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 490.
if test $result = ok -a $start_test_number -le 490; then
	echo test 490: More error recovery with 2 errors.
        cat >$test_file <<'TEST490'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_recovery (0);
p.set_grammar (g, 1);

var str = "a+a*(a*)+(*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

println (root);
exit (p.ambiguous_p);
TEST490
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT490' && $CMP $stdout $ftemp2; then
syntax error on token #7 (41) -- ignore 0 tokens starting with token #-1
nil
OUTPUT490
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 491.
if test $result = ok -a $start_test_number -le 491; then
	echo test 491: Parsing expression without lookahead
        cat >$test_file <<'TEST491'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
println (p.set_lookahead (0));
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(a+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
println (p.set_lookahead (1));
exit (p.ambiguous_p);
TEST491
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT491' && $CMP $stdout $ftemp2; then
1
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      $term(97, 5)
      mult(
        $term(97, 7)
        $term(97, 9)
      )
    )
  )
)
0
OUTPUT491
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 492.
if test $result = ok -a $start_test_number -le 492; then
	echo test 492: More parameter exception.
        cat >$test_file <<'TEST492'
var p = parser ();
p.set_lookahead ("0");
p.set_debug ("0");
p.set_lookahead (nil);
exit (0);
TEST492
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT492' && $CMP $stderr $ftemp2; then
test.d:4:17: run time error - invalid parameter type of `set_lookahead'
OUTPUT492
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 493.
if test $result = ok -a $start_test_number -le 493; then
	echo test 493: gethostinfo.
        cat >$test_file <<'TEST493'
include "socket";
var hi = sockets.gethostinfo (argv [0]);
println (hi.name, hi.aliases, hi.ipaddrs);
exit (0);
TEST493
        if uname | fgrep CYGWIN; then
            echo '      ' "$DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@  $test_file 127.0.0.1 >$stdout"
            if $DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file 127.0.0.1 >$stdout; then
                echo '      ' egrep '^".+"\[.*\]\[".+"\]$' $stdout
                if egrep '^".+"\[.*\]\[".+"\]$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
            else
                result=fail
            fi
        else
            echo '      ' "$DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file 127.0.0.1 >$stdout"
            if $DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 127.0.0.1 >$stdout; then
                echo '      ' egrep '^".+"\[.*\]\[".+"\]$' $stdout
                if egrep '^".+"\[.*\]\[".+"\]$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
            else
                result=fail
            fi
	fi
fi

# Test 494.
if test $result = ok -a $start_test_number -le 494; then
	echo test 494: getservbyname.
        cat >$test_file <<'TEST494'
include "socket";

var s = sockets.getservbyname (argv[0], "tcp");
if (s != nil)
  println (s.name, s.aliases, s.port, s.proto);
exit (0);
TEST494
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@  $test_file time >$stdout"
        if $DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file time >$stdout; then
                echo '      ' egrep '^".+"\[".+"\]37"tcp"$' $stdout
                if egrep '^".+"\[".+"\]37"tcp"$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     else
        echo '      ' "$DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file time >$stdout"
        if $DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file time >$stdout; then
                echo '      ' egrep '^".+"\[".+"\]37"tcp"$' $stdout
                if egrep '^".+"\[".+"\]37"tcp"$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     fi
fi

# Test 495.
if test $result = ok; then
	echo test 495: Skipping daytime udp.
elif test $result = ok -a $start_test_number -le 495; then
	echo test 495: daytime udp.
        cat >$test_file <<'TEST495'
include "socket";

var str, s = sockets.dgram_client ();
s.sendto ("get me date", "tock.usno.navy.mil", 13);
var d = s.recvfrom (300);
putln (d.str);
exit (0);
TEST495
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@  $test_file time >$stdout"
        if $DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file time >$stdout; then
                echo '      ' egrep '^[A-Za-z]+ [A-Za-z]+ [0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9]' $stdout
                if egrep '^[A-Za-z]+ [A-Za-z]+ [0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9]' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     else
        echo '      ' "$DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file time >$stdout"
        if $DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file time >$stdout; then
                echo '      ' egrep '^[A-Za-z]+ [A-Za-z]+ [0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9]' $stdout
                if egrep '^[A-Za-z]+ [A-Za-z]+ [0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9]' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     fi
fi

# Test 496.
if test $result = ok -a $start_test_number -le 496; then
	echo test 496: daytime udp.
        cat >$test_file <<'TEST496'
include "socket";

var str, s = sockets.stream_client ("time.ien.it", 13);

str = "";
try {
  for (;;) {str @= s.read (20);}
} catch (socket_excepts.eof) {
}

putln (str);
exit (0);
TEST496
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@  $test_file time >$stdout"
        if $DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file time >$stdout; then
                echo '      ' egrep '(^[A-Za-z]+ [A-Za-z]+[ ]+[0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [0-9][0-9][0-9][0-9])|(^[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z0-9]+)' $stdout
                if egrep '(^[A-Za-z]+ [A-Za-z]+[ ]+[0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [0-9][0-9][0-9][0-9])|(^[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z0-9]+)' $stdout; then
                        result=ok
                else
			cat $stdout
                        result=fail
                fi
        else
                result=fail
        fi
     else
        echo '      ' "$DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file time >$stdout"
        if $DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file time >$stdout; then
                echo '      ' egrep '(^[A-Za-z]+ [A-Za-z]+[ ]+[0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [0-9][0-9][0-9][0-9])|(^[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z0-9]+)' $stdout
                if egrep '(^[A-Za-z]+ [A-Za-z]+[ ]+[0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [0-9][0-9][0-9][0-9])|(^[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z0-9]+)' $stdout; then
                        result=ok
                else
			cat $stdout
                        result=fail
                fi
        else
                result=fail
        fi
     fi
fi

# Test 497.
if test $result = ok -a $start_test_number -le 497; then
	echo test 497: host is unknown
        cat >$test_file <<'TEST497'
include "socket";
var cl, send, rec, i;
cl = sockets.stream_client ("abracadabra", 10003);
exit (0);
TEST497
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file 2>$stderr"
        if $DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file 2>$stderr >$stdout; then
                result=fail
        else
		sed 's,\\,/,g' $stderr|sed 's%^.*socket.d%@srcdir@/socket.d%' >$ftemp
                echo '      ' $CMP $ftemp $ftemp2
                if cat >$ftemp2 <<'OUTPUT497' && $CMP $ftemp $ftemp2; then
In file processed from test.d:1:18:
@srcdir@/socket.d:59:7: host is unknown
OUTPUT497
                        result=ok
                else
                        result=fail
                fi
        fi
     else
        echo '      ' "$DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 2>$stderr"
        if $DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 2>$stderr >$stdout; then
                result=fail
        else
		sed 's,\\,/,g' $stderr|sed 's%^.*socket.d%@srcdir@/socket.d%' >$ftemp
                echo '      ' $CMP $ftemp $ftemp2
                if cat >$ftemp2 <<'OUTPUT497' && $CMP $ftemp $ftemp2; then
In file processed from test.d:1:18:
@srcdir@/socket.d:59:7: host is unknown
OUTPUT497
                        result=ok
                else
                        result=fail
                fi
        fi
     fi
fi

# Test 498.
if test $result = ok -a $start_test_number -le 498; then
	echo test 498: Contexts and internal caches.
        cat >$test_file <<'TEST498'
class a (i, n) {
  func ex {
    putln ("before = ", i);
    if (n != nil) n.ex ();
    putln ("after = ", i);
  }
}

var o = a (1, a (10, nil));

o.ex ();
TEST498
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT498' && $CMP $stdout $ftemp2; then
before = 1
before = 10
after = 10
after = 1
OUTPUT498
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 499.
if test $result = ok -a $start_test_number -le 499; then
	echo test 499: getservbyport.
        cat >$test_file <<'TEST499'
include "socket";

var s = sockets.getservbyport (argv [0] + 0, "tcp");
if (s != nil)
  println (s.name, s.aliases, s.port, s.proto);
exit (0);
TEST499
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@  $test_file 37 >$stdout"
        if $DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file 37 >$stdout; then
                echo '      ' test -z "\`cat $stdout\`" '|| egrep ^".+"\[".+"\]37"tcp"$' $stdout
                if test -z "`cat $stdout`" || egrep '^".+"\[".+"\]37"tcp"$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     else
        echo '      ' "$DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file 37 >$stdout"
        if $DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 37 >$stdout; then
                echo '      ' test -z "\`cat $stdout\`" '|| egrep ^".+"\[".+"\]37"tcp"$' $stdout
                if test -z "`cat $stdout`" || egrep '^".+"\[".+"\]37"tcp"$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     fi
fi

# Test 500.
if test $result = ok -a $start_test_number -le 500; then
	echo test 500: getservbyname for unknown name.
        cat >$test_file <<'TEST500'
include "socket";

var s = sockets.getservbyname (argv[0], "tcp");
if (s != nil)
  println (s.name, s.aliases, s.port, s.proto);
exit (0);
TEST500
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@  $test_file abracadabra >$stdout"
        if $DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file abracadabra >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT500' && $CMP $stdout $ftemp2; then
OUTPUT500
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     else
        echo '      ' "$DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file abracadabra >$stdout"
        if $DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file abracadabra >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT500a' && $CMP $stdout $ftemp2; then
OUTPUT500a
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     fi
fi

# Test 501.
if test $result = ok -a $start_test_number -le 501; then
	echo test 501: getservbyport for unknown port.
        cat >$test_file <<'TEST501'
include "socket";

var s = sockets.getservbyport (argv[0] + 0, "tcp");
if (s != nil)
  println (s.name, s.aliases, s.port, s.proto);
exit (0);
TEST501
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@  $test_file 313131 >$stdout"
        if $DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file 313131 >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT501' && $CMP $stdout $ftemp2; then
OUTPUT501
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     else
        echo '      ' "$DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file 313131 >$stdout"
        if $DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 313131 >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT501a' && $CMP $stdout $ftemp2; then
OUTPUT501a
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     fi
fi

# Test 502.
if test $result = ok -a $start_test_number -le 502; then
	echo test 502: Final destroying by implicit program finish.
        cat >$test_file <<'TEST502'
class c {
  putln ("creating instance");
  func destroy {putln ("destroying instance");}
}

var i = c ();
TEST502
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT502' && $CMP $stdout $ftemp2; then
creating instance
destroying instance
OUTPUT502
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 503.
if test $result = ok -a $start_test_number -le 503; then
	echo test 503: Final destroying by zero exit.
        cat >$test_file <<'TEST503'
class c {
  putln ("creating instance");
  func destroy {putln ("destroying instance");}
}

var i = c ();
exit (0);
TEST503
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT503' && $CMP $stdout $ftemp2; then
creating instance
destroying instance
OUTPUT503
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 504.
if test $result = ok -a $start_test_number -le 504; then
	echo test 504: Final destroying by nonzero exit.
        cat >$test_file <<'TEST504'
class c {
  putln ("creating instance");
  func destroy {putln ("destroying instance");}
}

var i = c ();
exit (1);
TEST504
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT504' && $CMP $stdout $ftemp2; then
creating instance
destroying instance
OUTPUT504
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 505.
if test $result = ok -a $start_test_number -le 505; then
	echo test 505: Final destroying by throw.
        cat >$test_file <<'TEST505'
class c {
  putln ("creating instance");
  func destroy {putln ("destroying instance");}
}

var i = c ();
throw except ();
TEST505
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT505' && $CMP $stdout $ftemp2; then
creating instance
destroying instance
OUTPUT505
	           if cat >$ftemp2 <<'OUTPUT505a' && $CMP $stderr $ftemp2; then
test.d:7:1: run time error - exception except has not been processed
OUTPUT505a
                        result=ok
                   else
                        result=fail
                   fi
                else
                        result=fail
                fi
        fi
fi

# Test 506.
if test $result = ok -a $start_test_number -le 506; then
	echo test 506: Serhei\'s interpereter -- big program - 1500 lines.
	echo '      ' rm -rf $tempdir
	echo '      ' mkdir $tempdir
	if rm -rf $tempdir && mkdir $tempdir; then
	  echo '      ' Forming Grip interpriter files and test program in $tempdir
	  cat >$tempdir/anode_work.d <<'TEST506'
/***********************************************************
** These functions are used to translate a given object   **
** of class anode() to the equivalent object of class     **
** prog().                                                **
***********************************************************/
// For elaborate dumpings:
var dumpfl = 0;
func bad_anode; func parse_instruction_anode; func check_block;
func parse_expression_anode; func flatten;
// Here is the function to parse a program anode. It is very trivial and
// is included for the client's convenience.
func parse_program_anode (program_anode, local_dumpfl = 1) {
  // Initialize the dumpings.
  dumpfl = local_dumpfl;
  var object_program = prog (), intermediate_view;
  if (program_anode.name != "program") { // Wrong node.
    putln ("! Wrong grammar. Root anode name is : ", program_anode.name);
    bad_anode ();
  }
  if (dumpfl) putln ("& Entering translation phase.");
  intermediate_view =
  parse_instruction_anode (program_anode.transl[0]);
  // If we parsed a block, we return it as the object program so as to
  // have a bit of efficiency.
  if (intermediate_view. name == "block")
    object_program = intermediate_view.args[0];
  // Otherwise we copy the instruction.
  else object_program.exec = [intermediate_view];
  if (dumpfl)
    putln ("& Entering semantical checking phase.");
  object_program = check_block (object_program);
  if (dumpfl) {
    if (global_errfl) putln ("! Semantic check failed.");
    else putln ("& Semantic check sucessful.");
  }
  return object_program;
}
/* The function parse_instruction_anode() is used to parse an instruction. */
func parse_instruction_anode (instruction_anode) {
  // We declare a variable to work on the result, which is an object of class
  // instr().
  if (dumpfl) {
    putln ("@ Initializing instruction parsing operation with node:");
    print_anode (instruction_anode);
  }
  var result = instr ();
  if (instruction_anode.name == "assign") { // Assignment statement.
    if (dumpfl) putln ("* Identified assignment statement.");
    result.name = "assign";
    result.args = [3 : nil];
    result.args [0] = instruction_anode.transl [0].transl [0].transl;
    result.args [2] = parse_expression_anode (instruction_anode.transl[1]);
    result.args [1] = (instruction_anode.transl [0].transl [0].transl.type0
                      == 'I' ?
                      instruction_anode.transl [0].transl :
                      bad_anode () );
    if (instruction_anode.transl [0].name == "array")
      result.args [1] = parse_expression_anode (instruction_anode.
                       transl [0].transl [1]);
    else if (instruction_anode.transl [0].name == "varac") {
      result.args [1] = expression ();
      result.args [1].opr = "num";
      result.args [1].opa1 = token (0);
      // For compatibility with the semantic checker.
      result.args [1].opa1.type0 = "I";
      result.args [1].opa1.value = "0";
      result.args [1].opa2 = "integer";
    } else bad_anode ();
  } else if (instruction_anode.name == "vblock") {
    // Parse the block now.
    if (dumpfl) putln ("@ Initiating block parsing.");
    result.name = "block";
    result.args = [1 : nil];
    result.args [0] = prog ();
    // A block should be an object of class prog().
    // Process the declarations:
    if (dumpfl) putln ("@ Processing declarations...");
    var declarations = flatten (instruction_anode.transl[0], 2),
    current_identifier_declared_flag = new {};
    for (var current_declaration_processed = 0;
         current_declaration_processed < #declarations;
         current_declaration_processed++) {
      // "Flatten" the identifiers we want to declare.
      var identifiers_on_wait = flatten (
                                declarations [current_declaration_processed]
                              . transl[0], 1),
      // Analyze the specification.
      current_specification_analysis =
      component (declarations [current_declaration_processed]
                . transl [1]. transl [0],
                declarations [current_declaration_processed]
                . transl [1]. name);
      // We just assigned an object of class anode() where it is
      // not needed, so we must eradicate that.

      // Here we declare a shortcut variable used to declare arrays.
      var array_translation = current_specification_analysis.value;

      // Declare arrays here by deriving their size.
      if (current_specification_analysis.type0 != "constant")
        current_specification_analysis.arrfl +=
                      ( array_translation.name == "$nil" ? 0
                      : array_translation.name == "$term" ?
                        array_translation.transl.value
                      : bad_anode () ); // The grammar is corrupted.
      current_specification_analysis.value =
                   ( current_specification_analysis.type0 == "constant" ?
                     +array_translation.transl.value
                   : array_translation.name == "$nil" ? 0
                   : [current_specification_analysis.arrfl : 0]
                   // For arrays.
                   );
      // Now that we have the specification, we may introduce the identifiers
      // into the environment.
      if (dumpfl) putln ("@ Declaring identifiers...");
      for (var current_identifier_processing = 0;
           current_identifier_processing < #identifiers_on_wait;
           current_identifier_processing++) {
        if (identifiers_on_wait [current_identifier_processing]
           . transl [0].transl in current_identifier_declared_flag) {
          if (dumpfl) putln ("! Identifier declared twice.");
          put (program_file, ":",
               identifiers_on_wait [current_identifier_processing]
               . transl [0].transl.line_num, ":", identifiers_on_wait
               [current_identifier_processing]. transl [0].transl.char_num,
               ": ");
          error ("Attempt to declare an identifier twice.");
        }
        result.args [0].vartable
        {identifiers_on_wait [current_identifier_processing]
        . transl [0].transl} = new current_specification_analysis;
        // Now we make a note of the fact that we have just declared the
        // identifier to solve the fact that the semantic checker that is
        // applied later to the block has no way of knowing that we attempted
        // to declare an identifier twice, so we check it right now.
        current_identifier_declared_flag
        {identifiers_on_wait
        [current_identifier_processing].transl [0].transl} = 1;
      }
    }
    // In case we stumble on a wrong node.
    /* The rest is pretty easy sailing. All we have to do now
    is let the instructions be parsed, and convert tokens in the table to
    strings. */
    var current_declaration, declarations_to_convert =
    keys (result.args [0].vartable);
    if (dumpfl) putln ("* Convert values : ",
                       sprint (declarations_to_convert));
    for (var current_declaration_num = 0;
         current_declaration_num < #declarations_to_convert;
         current_declaration_num++) {
      current_declaration = declarations_to_convert [current_declaration_num];
      if (dumpfl)
        putln ("* Conversion of ",
               sprint (current_declaration));
      if (type (current_declaration) == class ()) {
        if (dumpfl)
          putln ("* Conversion worthy to ",
                 sprint (current_declaration.value));
        result.args [0].vartable {current_declaration.value} =
        result.args [0].vartable {current_declaration};
        result.args [0].vartable =
        del (result.args [0].vartable, current_declaration);
      } else if (dumpfl) putln ("* Conversion unworthy.");
    }
    if (dumpfl) {
      putln ("* Result variables :");
      println (result.args [0].vartable);
      putln ("@ Parsing the instructions...");
    }
    var instructions = flatten (instruction_anode.transl [1],
                                1);
    // We recursively call parse_instruction_anode() for each instruction.
    for (var current_instruction_number = 0;
         current_instruction_number < #instructions;
         current_instruction_number++) {
      result.args [0].exec @=
      [parse_instruction_anode (instructions [current_instruction_number].
                               transl [0])];
    }
    func redeclare_block;
    // Now we must declare the configuration of variables here for the
    // other blocks.
    if (dumpfl) putln ("@ Redeclaring underlying blocks...");
    result.args [0] = redeclare_block (result.args [0]);
    func redeclare_block (block) {
      func do_redeclaration (block_to_redeclare) {
        // We have a block we need to define with synchronized variables.
        var current_identifier_processed_key;
        for (current_identifier_processed_key in block.vartable)
          if (!(current_identifier_processed_key
	        in block_to_redeclare.vartable)) {
            block_to_redeclare.vartable {current_identifier_processed_key} =
            block.vartable {current_identifier_processed_key};
          }
          redeclare_block (block_to_redeclare);
      }
      func do_instruction (instr) {
        if (instr.name == "block") {
          do_redeclaration (instr.args [0]);
        } else if (instr.name == "for") {
          do_instruction (instr.args [0]);
          do_instruction (instr.args [2]);
          do_instruction (instr.args [3]);
        } else if (instr.name == "cond") {
          for (var current_alternative_processing = 1;
               current_alternative_processing < #instr.args;
               current_alternative_processing += 2)
            do_instruction (instr.args [current_alternative_processing]);
        }
      }
      try {
        for (var current_candidate_number = 0;
             current_candidate_number < #block.exec;
             current_candidate_number++)
          do_instruction (block.exec [current_candidate_number]);
      } catch (except (). error ()) {
        if (dumpfl) putln ("! Synchronization of declarations failed.");
        bad_anode();
      }
      return block;
    }
    if (dumpfl) putln ("@ Block parsing over.");
    // Now we are done with our work on the block.
  } else if (instruction_anode.name == "condit") { // The GRIP conditional.
    /* In general, a GRIP conditional is written like this:
       'cond' '{'
        (<condition> <statement>)...
        ['else'      <statement>]
       '}'
       Not unlike the LISP version. */
       if (dumpfl) putln ("* Processing conditional.");
       // Do any initial poking around with the nodes:
       result = instr ();
       result.name = "cond";
       var option_list = flatten (instruction_anode.transl [0], 2);
       /* Now that we've done that, let's translate that conditional.
       Args[] for a cond statement look like this:
        [condition, statement,...]
       and the else part is represented by a expression evaluating to 1. */
       for (var current_option_number = 0;
            current_option_number < #option_list;
            current_option_number++) {
         var temp, current_parsed_option;
         if (option_list [current_option_number].name == "elsif")
           temp = parse_expression_anode (option_list [current_option_number].
                                          transl [0]);
         else if (option_list [current_option_number].name == "else") {
           temp = expression ();
           temp.opr = "num";
           temp.opa1 = token (3);
           temp.opa1.type0 = 'I';
           temp.opa1.value = "1";
           temp.opa2 = "integer";
         } else bad_anode ();
         result.args @= [temp, parse_instruction_anode
                        (option_list [current_option_number].transl [1])];
       }
  } else if (instruction_anode.name == "foritr") {
  /* The GRIP for statement is exactly like the C one,
     except for the fact that a guard expression is REQUIRED.
     The internal representation is self-explanatory and represented
     by the tuple [initialization, guard, increment, body]. */
    // This is a quite trivial process:
    if (dumpfl) putln ("* For loop identified.");
    result.name = "for";
    result.args = [parse_instruction_anode (instruction_anode.transl [0]),
                   parse_expression_anode  (instruction_anode.transl [1]),
                   parse_instruction_anode (instruction_anode.transl [2]),
                   parse_instruction_anode (instruction_anode.transl [3])];
  /* The remaining commands are very trivial: The put statement, and the
     empty statement. */
  } else if (instruction_anode.name == "output") {
  /* The put statement outputs all its parameters with an additional newline
     character at the end. */
    // Trivial stuff first:
    if (dumpfl) putln ("* Analyzing output statement.");
    result.name = "put";
    var objects_on_wait_list = flatten (instruction_anode.transl [0],
                                        1);
    // Now, a loop to deal with every object we want to output.
    for (var current_object_processing = 0;
         current_object_processing < #objects_on_wait_list;
         current_object_processing++) {
      if (objects_on_wait_list [current_object_processing].name
          == "expressionel")
        result.args @= [parse_expression_anode
                       (objects_on_wait_list
                       [current_object_processing].transl [0])];
      else if (objects_on_wait_list [current_object_processing].name
               == "stringel") {
        var temp = expression ();
        temp.opr = "num";
        temp.opa1 = objects_on_wait_list [current_object_processing].transl[0]
                                         . transl;
        temp.opa2 = "string";
        result.args @= [temp];
      } else {
        if (dumpfl) putln ("! Wrong instruction node, name : ",               
                           instruction_anode.name);
        bad_anode ();
      }
    }
  } else if (instruction_anode.name == "$nil") {
    // The empty statement is represented by a nil-anode.
    if (dumpfl) putln ("* Conversion $nil -> empty statement.");
    result.name = "empty";
  /* If we get an unknown node, we finish with a fatal error message. */
  } else {
    if (dumpfl) putln ("! Unknown node name : ", instruction_anode.name);
    bad_anode ();
  }
  return result; // Now the result is returned.
}

func parse_expression_anode (expression_anode) {
  /* This function parses an expression node into an object of
     class expression(). It can take both a factor and an expression. */
  if (dumpfl) {
    putln ("@ Initiating expression parsing with node :");
    print_anode (expression_anode);
  }
  // A variable on which to work and then return.
  var result = expression ();
  // For describing a factor.
  if (expression_anode.name == "factor") {
    if (dumpfl) putln ("* Identified a factor.");
    if (expression_anode.transl [0].name == "$term") { // Literal numbers.
      if (dumpfl) putln ("* Found literal number.");
      result.opr = "num";
      result.opa1 = expression_anode.transl [0].transl;
      result.opa2 = (expression_anode.transl [0].transl.value ==
                     int (expression_anode.transl [0].transl.value) ?
                     "integer" : "real");
    } else if (expression_anode.transl [0].name == "varac") {
      // Variable acessing.
      result.opr = "var";
      result.opa1 = expression_anode.transl [0].transl [0].transl;
      result.opa2 = expression ();
      result.opa2.opr = "num";
      result.opa2.opa1 = token (3);
      result.opa2.opa1.type0 = 'N';
      result.opa2.opa1.value = "0";
      result.opa2.opa2 = "integer";
      if (dumpfl) putln ("* Parsed an variable reference.");
    } else if (expression_anode.transl [0].name == "array") {
      // Array referencing -- done by the same operator.
      result.opr = "var";
      result.opa1 = expression_anode.transl [0].transl [0].transl;
      result.opa2 = parse_expression_anode
      (expression_anode.transl [0].transl [1]);
      if (dumpfl) putln ("* Parsed an array reference.");
    } else if (expression_anode.transl [0].name == "expression" ||
               expression_anode.transl [0].name == "double" ||
               expression_anode.transl [0].name == "single") {
      // We have a parenthesized expression for which we just recursively
      // invoke parse_expression_anode().
      result = parse_expression_anode (expression_anode.transl [0]);
      if (dumpfl) putln ("* Processed parenthesized expression.");
    } else {
      if (dumpfl) putln ("! Bad node, name is ", expression_anode.name);
      bad_anode ();
    }
  } else if (expression_anode.name == "double") { // Binary operators.
    result.opr = (expression_anode.transl [1].transl.code == 21 ? // Plus.
                  "add" :
                  expression_anode.transl [1].transl.code == 22 ? // Minus.
                  "sub" :
                  expression_anode.transl [1].transl.code == 23 ? // Times.
                  "mul" :
                  expression_anode.transl [1].transl.code == 24 ?
                  // Division.
                  "div" :
                  expression_anode.transl [1].transl.code == 26 ?
                  // Logical or.
                  "or " :
                  expression_anode.transl [1].transl.code == 25 ?
                  // Logical and.
                  "and" :
                  expression_anode.transl [1].transl.code == 14 ?
                  "gtt" :
                  expression_anode.transl [1].transl.code == 13 ?
                  "ltt" :
                  expression_anode.transl [1].transl.code == 29 ?
                  "eqs" : bad_anode () );
    result.opa1 = parse_expression_anode (expression_anode.transl [0]);
    result.opa2 = parse_expression_anode (expression_anode.transl [2]);
    /* Now, for efficiency we replace ltt (A,B) by gtt (B,A). */
    if (result.opr == "ltt") {
        // Swap the operands.
        var temp = result.opa1;
        result.opa1 = result.opa2;
        result.opa2 = temp;
        // Rename the operator.
        result.opr = "gtt";
    }
  } else if (expression_anode.name == "single") {
    // To work on unary operators.
    if (expression_anode.transl [0].transl.code == 21) {
      // We have a unary plus operation that does not affect the operand.
      result = parse_expression_anode (expression_anode.transl [1]);
    } else {
      // Other possible operators include unary minus and negation (!).
      result.opr = ( expression_anode.transl [0].transl.code == 22 ?
                     // Unary minus.
                     "neg" :
                     expression_anode.transl [0].transl.code == 27 ?
                     // Logical negation.
                     "not" : bad_anode () );
      result.opa1 = parse_expression_anode (expression_anode.transl [1]);
    }
  } else if (expression_anode.name == "expression") {
    // This is a reference to a factor.
    result = parse_expression_anode (expression_anode.transl [0]);
  } else bad_anode ();
  return result;
}
       /**************************************************
       ** These are the functions to perform semantical **
       ** checking. The errors recognized are:          **
       ** 1. Attempt to declare identifier twice (found **
       ** at translation time).                         **
       ** 2. No such identifier declared.               **
       ** 3. Vector in a context expecting a scalar     **
       ** value.                                        **
       ** 4. Attempt to extract an element of a scalar  **
       ** value.                                        **
       ** 5. Attempt to assign to a constant.           **
       **************************************************/
// The function to check a block does nothing but introduce a name scope for
// its two internal functions and call check_instruction() for each statement.
func check_block (block) {
  func check_expression;
  /* check_block() has two internal functions that work on an instruction
     (check_instruction()) and expression (check_expression()). */
  func check_instruction (instruction) {
    /* Most of the commands just cause invocations of other functions,
       but assignment finds four important semantic errors (see #2-5). */
    // Most important parts first this time.
    if (instruction.name == "assign") {
      if (dumpfl) putln ("* Checking an assignment statement.");
      /* First, check for error #2. */
      if (!(instruction.args [0].value in block.vartable)) {
        put (program_file, ":", instruction.args [0].line_num, ":",
        instruction.args [0].char_num, ": ");
        error ("No such variable declared.");
      } else {
        /* If these would have appeared after the conditional, !keyvalue would
           be generated, which is undesirable. */
        /* Now, we may check for error #3. */
//        if (type (block.vartable {instruction.args [0].value}.value)
//            == vector 
//            && instruction.args [1].opr == "num" &&
//            int (instruction.args [1].opa1.value) == 0) {
//          put (program_file, ":", instruction.args [0].line_num, ":",
//               instruction.args [0].char_num, ": ");
//          error ("Structured value in scalar context.");
//        }
//        /* Lastly, error #4 must be checked. "elsif" is used for efficiency. */
//        else
        if (type (block.vartable {instruction.args [0].value}.value) !=
                 vector &&
                 instruction.args [1].opr != "num" &&
                 int (instruction.args [1].opa1.value) != 0) {
          put (program_file, ":", instruction.args [0].line_num, ":",
               instruction.args [0].char_num, ": ");
          error ("Attempt to reference element of scalar value.");
        } else if (block.vartable {instruction.args [0].value}.type0 ==
                   "constant") {
          put (program_file, ":", instruction.args [0].line_num, ":",
               instruction.args [0].char_num, ": ");
          error ("Attempt to assign to a constant.");
        }
      }
      // Here, we change the token to its value field.
      instruction.args [0] = instruction.args [0].value;
      // Now, we invoke check_expression to check two of the expressions:
      instruction.args [1] = check_expression (instruction.args [1]);
      instruction.args [2] = check_expression (instruction.args [2]);
      // Now we are done with our work.
    } else if (instruction.name == "put") {
      if (dumpfl) putln ("* Checking a put statement.");
    /* Here we just invoke check_expression() for every expression. */
      for (var current_object_num = 0;
           current_object_num < #instruction.args;
           current_object_num++) {
       instruction.args [current_object_num] =
        check_expression (instruction.args [current_object_num]);
      }
    } else if (instruction.name == "empty") {
      if (dumpfl) putln ("* Checking an empty statement.");
      // The empty statement is automatically correct.
    /* All the recursion is done by the statements that are structured. */
    } else if (instruction.name == "cond") {
      // Here we juct iterate through all the possible alternatives,
      // verifying whether each is correct.
      for (var current_alternative_num = 0;
           current_alternative_num < #instruction.args;
           current_alternative_num += 2) {
        instruction.args [current_alternative_num] =
        check_expression (instruction.args [current_alternative_num]);
        instruction.args [current_alternative_num + 1] =
        check_instruction (instruction.args [current_alternative_num + 1]);
      }
    } else if (instruction.name == "for") {
      // Here, it is even more basic.
      if (dumpfl) putln ("* Checking a for loop.");
      instruction.args [0] = check_instruction (instruction.args [0]);
      instruction.args [2] = check_instruction (instruction.args [2]);
      instruction.args [3] = check_instruction (instruction.args [3]);
      instruction.args [1] = check_expression  (instruction.args [1]);
    } else if (instruction.name == "block") {
      /* The block statement is resolved by a recursive invocation of
         check_block(). */
      instruction.args [0] = check_block (instruction.args [0]);
    } else fatal_error ("Internal error in translator.");
    if (dumpfl) {
      putln ("* Checked instruction, value :");
      print_instruction (instruction);
    }
    return instruction;
  }
  /* This function is used to check an expression and replace all tokens with
     corresponding values. */
  func check_expression (expression) {
    /* Let us discuss the values that we need to check. Our errors
       shall be found all in one operator: var. Its internal representation
       is as follows:
       | opr   | opa1  | opa2    |
       +-------+-------+---------+
       | "var" | IDENT | ELEMENT |
       As you can see, it acts both as a reference to a scalar value
       and a vector. The other operators are trivial:
       num : don't do anything.
       neg, not : check opa1 only.
       Otherwise, we check both operands. */
    if (expression.opr == "num") { // Don't do anything except replace tokens:
      expression.opa1 = expression.opa1.value;
    } else if (expression.opr == "neg" ||
               expression.opr == "not") { // Check opa1:
      expression.opa1 = check_expression (expression.opa1);
    } else if (expression.opr == "var") { // Check for errors.
      /* The same errors are fixed here as the ones in the assignment
         statement. In fact, almost the same procedure is used here,
         except that we do only one recursive invokation at the end, and we
         work on a different domain of objects. For a more detailed explanation
         of the algorithm's quirks, see the procedure for assignment.*/
      if (!(expression.opa1.value in block.vartable)) {
        put (program_file, ":", expression.opa1.line_num, ":0: ");
        error ("No such variable declared.");
      } else {
        /* Check for error #3. */
//        if (type (block.vartable {expression.opa1.value}.value) == vector &&
//            expression.opa2.opr == "num" &&
//            int (expression.opa2.opa1.value) == 0) {
//          put (program_file, ":", expression.opa1.line_num, ":0: ");
//          error ("Structured value in scalar context.");
//        }
//        else
          if (type (block.vartable {expression.opa1.value}.value) !=
                 vector &&
                 expression.opa2.opr != "num" &&
                 int (expression.opa2.opa1.value) != 0) {
          put (program_file, ":", expression.opa1.value, ":0: ");
          error ("Scalar value in structured context.");
        }
      }
      expression.opa1 = expression.opa1.value;
      expression.opa2 = check_expression (expression.opa2);
    } else { // A binary operator. Recursively invoke check_expression():
      expression.opa1 = check_expression (expression.opa1);
      expression.opa2 = check_expression (expression.opa2);
    }
    return expression;
  }
  if (dumpfl) putln ("@ Initiating block checking.");
  /* The main body of the function is quite trivial and consists of just a
     for-loop. Also, we must process the declarations. */
  for (var current_instruction_num = 0;
       current_instruction_num < #block.exec;
       current_instruction_num++)
    block.exec [current_instruction_num] =
    check_instruction (block.exec [current_instruction_num]);
  // Process the declarations.
  var current_declaration;
  return block;
}
/* What we have left now is a couple of common tasks I found to be
   easier to put in separate functions. */
// When an anode that is not supposed to turn up turns up, we finish
// with a diagnostic message.
func bad_anode {
  fatal_error ("Grammar 'grip.g' corrupted or internal error.");
}
// For flattening recursive lists. This is so easily encoded in functional
// programming languages like ML! Wish I could use it here, but the SPI
// doesn't allow it.
func flatten (list_anode_to_flatten, next_num) {
  if (dumpfl) {
    putln ("@ Executing flatten operation with:");
    println (list_anode_to_flatten.transl);
    print_anode (list_anode_to_flatten);
  }
  return // Last element or not?
         (list_anode_to_flatten.name != "$nil" ?
          [list_anode_to_flatten] @
          flatten (list_anode_to_flatten.transl [next_num], next_num) : []);
}
TEST506
	  cat >$tempdir/error.d <<'TEST506a'
/* If an error arises, this function shall perform the necessary dumping, and
   increment global_errfl. Other procedures check this variable occasionally,
   and if it isn't zero, call abend(). */
var global_errfl = 0;

func error (message, ...) {
  putln ("Error : ", message); // Print a general description of the problem.
  // Do any dumping necessary to roughly locate the problem.
  if (#args != 0)
    for (var i = 0; i < #args; i++)
      try {putln(args[i]);} catch (except (). error (). invcall (). partype)
          {println(args[i]);}
  global_errfl++; // Increment the global error counter.
}

// For fatal errors :
func fatal_error (message, ...) {
  putln ("Fatal Error : ", message);
  if (#args != 0)
    for (var i = 0; i < #args; i++)
      try {putln (args[i]);}
      catch (except (). error (). invcall (). partype ())
          {println (args[i]);}
  exit (3);
}

// To assist with abnormal endings.

func abend (message) {
  putln (global_errfl, message, "error" @ (global_errfl == 1 ? "." : "s."));
  exit (2);
}

// To print out abstract nodes in a readable manner:

func print_anode (node_to_print, tablevel = 0, tabchar = ' ') {
  for (var i = 0; i < tablevel; i++) put (tabchar);
  put (node_to_print.name, " ");
  if (node_to_print.name == "$nil") println ();
  else if (node_to_print.name == "$term")
    putln (node_to_print.transl.code, ":",
           node_to_print.transl.type0, ":",
           sprint (node_to_print.transl.value));
  else {
    putln ("(");
    for (i = 0; i < #node_to_print.transl; i++)
      print_anode (node_to_print.transl [i], tablevel + 2, tabchar);
    for (i = 0; i < tablevel; i++) put (tabchar);
    putln (")");
  }
}

// For printing objects of class expr().

func print_expression (expr, tablevel = 0, tabchar = ' ') {
  for (var i = 0; i < tablevel; i++) put (tabchar);
  if (expr == nil) return;
  if (expr.opr == "num") putln (sprint (expr.opa1), " : ", sprint (expr.opa2));
  else if (expr.opr == "var") {
    put ("$", sprint (expr.opa1));
    if (!(expr.opa2.opr == "num" && expr.opa2.opa1 == "0")) {
      putln (" [");
      print_expression (expr.opa2, tablevel + 2, tabchar);
      for (i = 0; i < tablevel; i++) put (tabchar);
      putln ("]");
    } else putln ();
  } else {
    putln (expr.opr, " (");
    print_expression (expr.opa1, tablevel + 2, tabchar);
    print_expression (expr.opa2, tablevel + 2, tabchar);
    for (i = 0; i < tablevel; i++) put (tabchar);
    putln (")");
  }
}
// This function is used to print an instruction:
func print_instruction (instruction, tablevel = 0, tabchar = ' ') {
  for (var i = 0; i < tablevel; i++) put (tabchar);
  if (instruction.name == "empty") putln ("-");
  else {
    put (instruction.name, " ");
    if (instruction.name == "block") {
      putln ("{");
      for (i in instruction.args [0].vartable) {
        for (var j = 0; j < tablevel + 2; j++) put (tabchar);
        putln ("$", sprint (i), " : ", instruction.args [0].vartable {i}.type0,
               instruction.args [0].vartable {i}.arrfl ?
               " [" @ instruction.args [0].vartable {i}.arrfl @ "]" : "");
      }
      for (i = 0; i < #instruction.args [0].exec; i++)
        print_instruction (instruction.args [0].exec [i],
                           tablevel + 2, tabchar);
      for (i = 0; i < tablevel; i++) put (tabchar);
      putln ("}");
    } else if (instruction.name == "for") {
      putln ();
      for (i = 0; i < tablevel + 2; i++) put (tabchar);
      putln ("Initialization : ");
      print_instruction (instruction.args [0], tablevel + 2, tabchar);
      for (i = 0; i < tablevel + 2; i++) put (tabchar);
      putln ("---");
      for (i = 0; i < tablevel + 2; i++) put (tabchar);
      putln ("Condition : ");
      print_expression (instruction.args [1], tablevel + 2, tabchar);
      for (i = 0; i < tablevel + 2; i++) put (tabchar);
      putln ("Body : ");
      print_instruction (instruction.args [3], tablevel + 2, tabchar);
      for (i = 0; i < tablevel + 2; i++) put (tabchar);
      put ("Increment : ");
      print_instruction (instruction.args [2]);
    } else if (instruction.name == "cond") {
      putln ();
      for (i = 0; i < #instruction.args; i += 2) {
        print_expression  (instruction.args [i], tablevel + 2, tabchar);
        print_instruction (instruction.args [i + 1], tablevel + 2, tabchar);
        if (i < #instruction.args - 1) {
          for (var j = 0; j < tablevel; j++) put (tabchar);
          putln ("---");
        }
      }
    } else if (instruction.name == "assign") {
      put ("$", sprint (instruction.args [0]));
      if (!(instruction.args [1].opr == "num" &&
            instruction.args [1].opa1 == "0")) {
        putln (" [");
        print_expression (instruction.args [1], tablevel + 2, tabchar);
        for (i = 0; i < tablevel; i++) put (tabchar);
        putln ("]");
      } else putln ();
      print_expression (instruction.args [2], tablevel + 2, tabchar);
    } else if (instruction.name == "put") {
      putln ();
      for (i = 0; i < #instruction.args; i++)
        print_expression (instruction.args [i], tablevel + 2, tabchar);
      }
    }
}
TEST506a
	  cat >$tempdir/grip.d <<'TEST506b'
////////////////////////////////////////////////////////////////
// Grip 0.5s54 Designed and implemented by: Serhei Makarov.   //
// Special thanks to: Vladimir Makarov, for mentoring and     //
// moral support,                                             //
//                    Nadia Makarov, for moral support, and   //
//                    The person who invented ISPs, otherwise //
// I might not have gotten time to get such a head start in   //
// programming language design.                               //
////////////////////////////////////////////////////////////////

// GRIP 0.5 is a structured language roughly capable of performing
// algorhythmic calculations, e.g. a sieve for primes.
// WARNING : WE HAVE NOT IMPLEMENTED ANY INPUT DEVICES.

// Command line options :
//  -v
//  --verbose       Turns on dumpings at runtime.
//
//  -t
//  --parse-results Output the results of parsing.
//
//  -d
//  --full-parse    Output information about how
//                  the parse went.
//
//  -h
//  --help          Print possible command line
//                  options and quit.
//
//  -n
//  --version       Print version number and quit.
//
//  filename        Interpret 'filename'.
var verbose_flag = 0, debug_level = 0, file_name = "";

include "error"; // The error management package.
include "intrep"; // Interpretation package.
include "parser"; // Translation package.

var translator = grip_parser(), db_fl = 0;

// Db_fl is defined to find conflicting -td options and for -hn option usage.
// Find if we just want help.
if (#argv == 0) {
  putln ("No arguments found. Use 'grip --help' for help.");
  exit (0);
}
for (var argpos = 0; argpos < #argv; argpos++)
  if (argv[argpos] == "--help" ||
      argv[argpos] == "-h") {
    putln ("GRIP 0.5s54.");
    putln ("Usage: grip (option | filename)...");
    putln ("Options:");
    putln ("POSIX one character | GNU style long");
    putln (" -v                 | --verbose       : ",
           "Turn on dumpings at runtime.");
    putln (" -t                 | --parse-results : ",
           "Show the results of parsing.");
    putln (" -d                 | --full-parse    : ",
           "Show how the parse went.");
    putln (" -n                 | --version       : ",
           "Print version number and quit.");
    putln (" -h                 | --help          : ",
           "Show this screen.");
    putln ();
    putln ("Grip returns 0 on success, 2 on a non-fatal error, and");
    putln ("3 on a fatal error that prevents its functioning properly."); 
    exit (0);
  } else if (argv[argpos] == "-n" ||
             argv[argpos] == "--version") {
    putln ("GRIP 0.5s54 designed and implemented by Serhei V. Makarov.");
    putln ("Special thanks to:");
    putln ("                   Vladimir Makarov, for mentoring and");
    putln ("                   moral support, and");
    putln ("                   Nadia Makarov, for moral support.");
    exit (0);
  }
// Analyze argv[] to find out the filename needed.
for (argpos = 0; argpos < #argv; argpos++) {
  if (argv[argpos] == "-v" ||
      argv[argpos] == "--verbose") verbose_flag = 1;
  else if (argv[argpos] == "-t" ||
           argv[argpos] == "--parse-results") if (!db_fl) {
                debug_level = 2;
                db_fl++;
        } else error ("Conflicting '-t' and '-d' options.");
  else if (argv[argpos] == "-d" ||
           argv[argpos] == "--full-parse") if (!db_fl) {
                debug_level = 5;
                db_fl++;
        } else error ("Conflicting '-t' and '-d' options.");
  else if (argv[argpos] == "-" && file_name == "") file_name = "/dev/stdin";
  else if (file_name == "") file_name = argv[argpos];
  else error ("Too many arguments or arguments invalid.");
}
if (file_name == "") error ("No file name specified or file name invalid");
if (global_errfl) abend (" command line ");
// Translate and interpret.
var executable_program = 
translator.parse_file(file_name, debug_level, verbose_flag);
executable_program.execute (verbose_flag, verbose_flag, verbose_flag);
exit(0);
TEST506b
	  cat >$tempdir/grip.g <<'TEST506c'
TERM string = 1
      ident = 2
     number = 3
   programk = 4
        ddt = 5
   constant = 6
    integer = 7
       real = 8
       cond = 9
        for = 10
        put = 11
       else = 12
        lts = 13
        gts = 14
        lfp = 15
        rtp = 16
        lbr = 17
        rbr = 18
        lsb = 19
        rsb = 20
        pls = 21
        mns = 22
        str = 23
        fsl = 24
        amp = 25
        vrt = 26
        exc = 27
        smc = 28
        eqs = 29
        spc = 30
    invalid = 31;
program : programk ident statement # program (2)
statement : varac lts mns expression smc # assign (0 3)
          | lbr decl st_list rbr         # vblock (1 2)
          | cond lbr c_list              # condit (2)
          | for lfp statement expression smc statement rtp statement # foritr (2 3 5 7)
          | put p_list smc               # output (1)
          | smc                          # -
expression : expression dop factor # double (0 1 2)
           | uop factor            # single (0 1)
           | factor                # expression (0)
factor : varac              # factor (0)
       | number             # factor (0)
       | lfp expression rtp # factor (1)
dop : pls # 0
    | mns # 0
    | str # 0
    | fsl # 0
    | vrt # 0
    | amp # 0
    | eqs # 0
    | gts # 0
    | lts # 0
uop : pls # 0
    | mns # 0
    | exc # 0
decl : ident_list ddt specif smc decl # declare (0 2 4)
     |                                # -
ident_list : ident ident_list  # idl (0 1)
           |                   # -
specif : integer as      # integer (1)
       | real as         # real (1)
       | constant number # constant (1)
as : lsb number rsb # 1
   |                # -
st_list : statement st_list # st_list (0 1)
        |                   # -
c_list : expression statement c_list # elsif (0 1 2)
       | else statement rbr          # else (- 1 -)
       | rbr                         # -
p_list : expression p_list # expressionel (0 1)
       | string p_list     # stringel (0 1)
       |                   # -
varac : ident                    # varac (0)
      | ident lsb expression rsb # array (0 2)
TEST506c
	  cat >$tempdir/intrep.d <<'TEST506d'
// Here follows the internal representation of a GRIP program.
/* This is a variable cell class, designed for use with eval(). */
class component (value, type0) {
  var arrfl = 0;
}
/* This is a simple instruction definition, with a descriptor and arguments. */
class instr (){
  var name = "", args = [];
}
/* This is an expression class. Note that at most two operands are allowed. */
class expression (){
  var opr, opa1, opa2;
}

/******************************************************************************
** This is the definition for the actual internal representation of the      **
** program. Note that the high level structure is almost just an abstract    **
** form of the source code. There are only two variables: exec, which is     **
** a vector of instructions, and vartable, a table of component cells.       **
** This class also contains a virtual machine capable of executing the code. **
******************************************************************************/
class prog {
  var exec = []; // The executable code.
  var vartable = new {};
  // The environment, statically derived during translation.
  func eval (expr, dumpfl = 0) { // The expression evaluator.
    var res; // The result is retained for debugging purposes.
    if (dumpfl) putln ("@ Initiating expression evaluator.");
    func ovrlap (type1, type2) // A function to derive the type of the result. 
      { return type1 == "real" || type2 == "real" ? "real" : "integer"; }
    if (expr.opr == "num") res = component(expr.opa1,expr.opa2);
                           /* Expression is a single constant */
    else if (expr.opr == "var") {
      var index = eval (expr.opa2, dumpfl).value;

      res = vartable {expr.opa1};
      if (type (res.value) == vector) {
	//        println (index, "--", #res.value);
	if (index < 1 || index > #res.value) {
	  error ("Runtime error : Array index out of bounds.");
	  exit (2);
	}
        res = component (res.value [index - 1], res.type0);
      }
    }
    // Variable reference.
    else if (expr.opr == "neg") // Unary minus.
      res = component (-eval (expr.opa1, dumpfl).value,
                        eval (expr.opa1, dumpfl).type0);
    else if (expr.opr == "add") // Addition.
      res = component (eval (expr.opa1, dumpfl).value +
                       eval (expr.opa2, dumpfl).value,
                       ovrlap (eval (expr.opa1, dumpfl).type0,
                               eval (expr.opa2, dumpfl).type0));
    else if (expr.opr == "sub") // Subtraction.
      res = component (eval (expr.opa1, dumpfl).value -
                       eval (expr.opa2, dumpfl).value,
                       ovrlap (eval (expr.opa1, dumpfl).type0,
                               eval (expr.opa2, dumpfl).type0));
    else if (expr.opr == "mul") // Multiplication.
      res = component (eval (expr.opa1, dumpfl).value *
                       eval (expr.opa2, dumpfl).value,
                       ovrlap (eval (expr.opa1, dumpfl).type0,
                               eval (expr.opa2, dumpfl).type0));
    else if (expr.opr == "div") {// Division.
      res = component (eval (expr.opa1, dumpfl).value /
                       eval (expr.opa2, dumpfl).value,
                       ovrlap (eval (expr.opa1, dumpfl).type0,
                               eval (expr.opa2, dumpfl).type0));
    }
    else if (expr.opr == "and") // Logical and.
      res = component (eval (expr.opa1, dumpfl).value &&
                       eval (expr.opa2, dumpfl).value,
                       "integer");
    else if (expr.opr == "or ") // Logical or.
      res = component (eval (expr.opa1, dumpfl).value ||
                       eval (expr.opa2, dumpfl).value,
                       "integer");
    else if (expr.opr == "not") // Logical negation
      res = component (!eval (expr.opa1, dumpfl).value, "integer");
    else if (expr.opr == "gtt") // Greater than.
      res = component (eval (expr.opa1, dumpfl).value >
                       eval (expr.opa2, dumpfl).value,
                       "integer");
    // The lack of a less than operation is for the fact that x<y <=> y>x.
    else if (expr.opr == "eqs") // Equals.
      res = component (eval (expr.opa1, dumpfl).value ==
                       eval (expr.opa2, dumpfl).value,
                       "integer");
    else {
      // If opr is not one of the specified operations, then there is an
      // error in the coding.
      putln ("Fatal Error : Internal error in expression generator :");
      print_expression (expr);
    }
    if (dumpfl) { // Dumping.
      putln ("* Expression Dumping:\n", sprint (res.value), " : ",
             sprint (res.type0));
      if (expr.opr != "num") print_expression (expr);
      putln ();
    }
    return res; // Now the result is made available to the client function.
  }
  /***********************************************************************
  ** This is the actual execution function. It invokes execinstr(), a   **
  ** function internal to execute(), which may recursively invoke       **
  ** itself, eval(), and execute() to evaluate expressions, or use      **
  ** structures.                                                        **
  ***********************************************************************/
  func execute (dumpfl, strdumpfl, edumpfl) {
    if (dumpfl) putln ("& Entering execution phase.");
    // Dumping for blocks :
    if (dumpfl) {
      putln ("* Preliminary dumping of variables for this block:\n",
             vartable != {} ?
             sprint (vartable) : "", "\n"); 
    }
    func execinstr;
    for (var instr = 0; instr < #exec; instr++) {
      // Sequentially perform statements.
      execinstr (exec [instr], strdumpfl, edumpfl); 
      /* Invoke execinstr() with the current instruction. */
    }
    if (global_errfl) abend (" runtime ");
    /*******************************************************
    ** Implementation of execinstr(). Like eval(), it     **
    ** chooses from a list of possible operations it can  **
    ** do, and executes the corresponding procedure       **
    ** needed to do the job.                              **
    *******************************************************/
    func execinstr (currinstr, dumpfl, edumpfl = 0) {
      // Dumping for instructions :
      if (dumpfl) { putln ("@ Executing of instruction #",
                           instr + 1, ", value:");
                    print_instruction (currinstr);
      }
      if (currinstr.name == "cond") { /* Conditional branch. */
        for (var current_option_number = 0;
             current_option_number < #currinstr.args;
             current_option_number += 2) {
          /* This loop iterates through all of the
             alternatives, checking each one. */
          if (eval (currinstr.args [current_option_number], edumpfl).value) { 
            /* Check the current alternative. */
            execinstr (currinstr.args [current_option_number + 1], dumpfl); 
            // True: Execute this branch.
            break; // Exit the loop : No more altenatives need to be checked. 
          }
        }
      } else if (currinstr.name == "for") {
         // C-style 'for' loop implementation. Note that this statement can
         // loop at most 100,000 times.
         var g = 0; // This variable is used for enforcing the iteration limit.
         for (execinstr (currinstr.args [0], dumpfl); // Initialization.
              eval (currinstr.args [1], edumpfl). value; // Condition.
              execinstr (currinstr.args [2], dumpfl)) { // Increment.
           execinstr (currinstr.args [3], dumpfl); // Execute the body.
           g++; // Iteration count.
           if (g > 99999) { // Kill the for loop if alloted
                            // iterations are used up.
             if (dumpfl) putln ("! For loop ran out of iterations.");
             putln ("Warning: Iteration limit exceeded: For loop killed.");
             break; // Kill the loop.
           }
         }
       } else if (currinstr.name == "assign") {
         // Classical absolute assignment.
         var res = eval (currinstr.args [2], edumpfl),
             index = eval (currinstr.args [1], edumpfl).value,
             ourtype;
         // Ourtype is for real <- int compatibility.
         if (vartable  {currinstr.args [0]}.type0 == "real") ourtype = "real";
         else ourtype = "integer";
         var target = vartable {currinstr.args [0]};
         if (type (target.value) != vector) {
           // Is this an array? If no :
          target.value = (ourtype == "real"
			  ? float (res. value) : int (res. value));
         } else { // If yes :
           if (#target.value < index || index < 1) {
             error ("Runtime error : Array index out of bounds.");
             exit (2);
           }
           target.value [index - 1] = res.value;
         }
         vartable {currinstr.args [0]}.type0 = ourtype;
       } else if (currinstr.name == "block") { // The compound statement.
         currinstr.args [0].execute (dumpfl, dumpfl, edumpfl);
       } else if (currinstr.name == "put") { // Output statement.
         var put_objs = []; // So as not to intermingle output with dumpings.
         for (var i = 0; i < #currinstr.args; i++)
           put_objs @= eval (currinstr.args [i], edumpfl).value;
         for (i = 0; i < #put_objs; i++)
           put (put_objs [i]);
           // Output the values of all expressions.
         putln (); // Don't forget a newline.
       } else if (currinstr.name == "empty") {
         // The nil statement - does nothing.
       } else { // Coding error.
         putln ("Fatal Error : Internal parsing error : ",
                "Illegal instruction generated as follows :");
         print_instruction (currinstr.name, currinstr.args);
         exit (3);
       }
     }
     // Dumping for blocks :
     if (dumpfl) {
       putln ("* Dumping of variables for this block:\n", #vartable != 0 ?
              sprint (vartable) : "", "\n"); 
     }
   } // End execute().
} // End class prog.
TEST506d
	  cat >$tempdir/parser.d <<'TEST506e'
/****************************************************************************
** This is the translator for the source code.                             **
****************************************************************************/
ext token { // For encoding of identifiers, etc.
  var value, type0, line_num, char_num;
}
class grip_parser {
  // The grip_parser class, using the Earley parser.
  var grammar, source_code; // Grammar is the Earley Parser code.
  include "scanner"; // Lexical analysis.
  include "translates"; // Syntactical and semantical analysis.
}
TEST506e
	  cat >$tempdir/scanner.d <<'TEST506f'
 /*****************************************************************
 ** The scanner() function does lexical analysis, i.e. finding   **
 ** numbers, and returns a vector of tokens ready for parsing.   **
 *****************************************************************/
func scanner (code) {
  var tokens = [],
  /* Array that will later be translated to tokens and returned,
     which will be called the "token stream". */
  lexem = "", /* Lexem will accumulate characters in case we wanted to
  make a token with more than one character, i.e. an identifier.
  (Will be referred to as the "accumulation stream".) */
  /* Note on streams: We can't write to the token stream unless
                      accumulation stream is empty.
  */
  /* Next come two important tables to increase parsing efficiency. */
  character = final {':' : 5,
                     '<' : 13,
                     '>' : 14,
                     '(' : 15,
                     ')' : 16,
                     '{' : 17,
                     '}' : 18,
                     '[' : 19,
                     ']' : 20,
                     '+' : 21,
                     '-' : 22,
                     '*' : 23,
                     '/' : 24,
                     '&' : 25,
                     '|' : 26,
                     '!' : 27,
                     ';' : 28,
                     '=' : 29,
                     ' ' : 30}, // For encoding special characters.
  keyword = final {"program" : 4,
                   "constant" : 6,
                   "integer" : 7,
                   "real" : 8,
                   "for" : 10,
                   "cond" : 9,
                   "else" : 12,
                   "put" : 11}, // For encoding keywords.
  char0, /* Counter for the loop that follows. */
  lx = 0,
  lnn = 1; // For retaining the line number of a token.
  for (char0 = 0; char0 < #code;) { // Build up tokens[].
    if (char0 != 0 &&
        code[char0 - 1] == '\n') lnn++;
    if (code[char0] == '/') { // Value might be a comment.
      var nofl = 1; // Tells us whether we should keep the slash.
      char0++; // Look at the next character.
      if (code[char0] == '*') {
        nofl = 0; // Don't put the slash to tokens[].
        for (;; char0++) // It is a comment.
          if (code[char0] == '*') { // Comment might end.
            char0++; // Look at next character.
            if (code[char0] == '/') {
              char0++;
              break; // Comment is over.
            }
          }
      }
      // So that the slash is preserved if there was no comment.
      if (nofl) tokens = tokens @ '/';
    } else if (code[char0] <= '9' && code[char0] >= '0') {
      var realfl = 0; // For support of reals.
      lexem = "N";
      for (;; char0++) {
        for (; code[char0] <= '9' && code[char0] >= '0'; char0++)
          lexem = lexem @ code[char0];
        if (code[char0] == '.' && ! realfl) {
          realfl++; // To avoid meaningless constructs such as 2.3.56.
          continue; // For scanning reals.
        }
        break;
      }
      tokens = ins (tokens, lexem, #tokens);
      lexem = "";
    } else if (code [char0] <= 'z' &&
               code [char0] >= 'a' || code[char0] <= 'Z' &&
               code [char0] >= 'A') {
      lexem = "I";
      for (; code [char0] <= 'z' && code[char0] >= 'a'
             || code [char0] <= 'Z' && code [char0] >= 'A'
             || code [char0] <= '9' && code [char0] >= '0';
             char0++)
        lexem = lexem @ tolower (code [char0]);
      tokens = ins (tokens, lexem, #tokens);
      lexem = "";
    } else if (char0 < #code && (code [char0] == ' '  ||
                                 code [char0] == '\n' ||
                                 code [char0] == '\t' ||
                                 code [char0] == '\f' ||
                                 code [char0] == '\r' ||
                                 code [char0] == '\v')) {
      for (; char0 < #code && (code [char0] == ' '  ||
                               code [char0] == '\n' ||
                               code [char0] == '\t' ||
                               code [char0] == '\f' ||
                               code [char0] == '\r' ||
                               code [char0] == '\v');
           char0++)
        if (char0 != 0 && code [char0 - 1] == '\n') lnn++;
    } else if (code[char0] == '"'){
      char0++;
      lexem = "S";
      for (; char0 < #code && code[char0] != '"'; char0++)
        lexem = lexem @ code[char0];
      char0++;
      tokens = ins (tokens, lexem, #tokens);
      lexem = "";
    } else {
      tokens = ins (tokens, code[char0], #tokens);
      char0++;
    }
    // Translate what we got to a token.
    if (lx < #tokens &&
        type (tokens[lx]) != char) { // Are we dealing with a string?
      if (tokens[lx][0] == 'S') { // We have a string constant.
        var temp = token (1); // Token with code 1.
        temp.type0 = tokens[lx][0]; // Add the type specifier.
        temp.value = del (tokens[lx], 0, 1); // Put the rest into value.
        tokens[lx] = temp; // Put the result into tokens.
      } else if (tokens[lx][0] == 'I') { // Identifier.
        var temp;
        if (del (tokens[lx], 0, 1) in keyword) {
          // Translate it into a keyword token if it's a keyword.
          temp = token(keyword{tokens[lx]});
          // Look it up in the keyword table.
          temp.type0 = 'K';
          // Give it type "K".
          temp.value = tokens[lx];
          // Give its reproduction for the syntax error manager.
        } else {
          temp = token (2); // Token - code 2.
          temp.type0 = 'I';
          temp.value = tokens[lx];
          // Same procedure here as for string constants.
        }
        tokens[lx] = temp;
      } else if (tokens[lx][0] == 'N') { // Number.
        var temp = token (3); // Token - code 3.
        temp.type0 = tokens[lx][0];
        temp.value = del (tokens[lx], 0, 1);
        tokens[lx] = temp;
      } else fatal_error ("Internal scanner error.", tokens, tokens[lx]);
      // Scanner malfunction.
    } else if (lx < #tokens) { // Single character.
      if (!(tokens[lx] in character)) { 
        // We have a bad character that we know the parser will spit out.
        put (file_name, ":", lnn, ":", char0 % lnn, ": ");
        error ("Lexical error: Invalid character -- no encoding available.",
               sprint(tokens[lx]));
        /* Generate an invalid token that the parser recognizes, but does
           not use in any rule. */
        tokens [lx] = token (31);
        lx++;
        continue;
      } else {
        var temp = token(character {tokens[lx]});
        temp.type0 = 'C';
        temp.value = tokens[lx];
        tokens[lx] = temp;
      }
    }
    if (lx < #tokens) {
      tokens[lx].line_num = lnn;
      tokens[lx].char_num = char0 % lnn;
      lx++;
    }
  }
  return tokens; // Make the result available to the client.
}
TEST506f
	  cat >$tempdir/translates.d <<'TEST506g'
 /*************************************************************************
 ** This is the actual translation function. It does any necessary       **
 ** operations that are done after the translation, so all the main      **
 ** block needs to do is analyze args and determine the parameters to    **
 ** this method.                                                         **
 *************************************************************************/
func parse_file (program_file, debug_level, verbose_flag) {
  if (verbose_flag) putln ("& Entering parsing phase.");
  var token_vector,
  outside = except (). error (). invcall (). syserror(); // To save typing.
  /* The following function is called by the parser to
     do any error messaging. */
  func syntax_error (error_token_index,
                     error_token_value,
                     first_ignored_token_index,
                     first_ignored_token_value,
                     new_starting_token_index,
                     new_starting_token_value) {
    if (error_token_value == nil ||
        error_token_value.code != 31) {
      if (verbose_flag) putln ("! Syntax error.");
      if (error_token_value != nil)
        put (program_file, ":", error_token_value.line_num, ":0: ");
      error (sput ("Syntax error at token value ",
                        error_token_value
                        == nil ? "EOF" :
                        error_token_value.code,
                   ":", error_token_value
                        == nil ? "EOF" :
                        error_token_value.type0,
                   ":", error_token_value
                        == nil ? "EOF" :
                        sprint (error_token_value.value)
                  )
            );
    }
  }
  // The next few lines install the grammar.
  try { // In case we can't find the file.
    var tape = open (env {"GRAMMARPATH"},"read");
    grammar = fgetf (tape);
    close (tape);
  } catch (outside. eaccess,
           outside. eagain,
           outside. ebadf,
           outside. ebusy,
           outside. edom,
           outside. efault,
           outside. efbig,
           outside. eio,
           outside. eisdir,
           outside. emfile,
           outside. emlink,
           outside. enametoolong,
           outside. enfile,
           outside. enodev,
           outside. enoent,
           outside. enomem,
           outside. eperm,
           outside. epipe,
           outside. espipe,
           outside. exdev)
  {fatal_error ("Could not find grammar file 'grip.g'.");}
  var program, // Source code.
  abstract_tree; // Intermediate code.
  try { // To cause exception !pmemory to die with a graceful error message.
    var +machine = parser();
    machine.set_grammar (grammar, 1);
    machine.set_debug (debug_level); // Turns on verbose mode if applicable.
    machine.set_one_parse (1); // In case the grammar is ambiguous.
    machine.set_recovery (1); // Turn off error recovery.
    machine.set_recovery_match (0); // Shift 5 tokens when error is found.
    try { // To cover 'no such file' errors.
      program = open (program_file, "read"); // Get the source code.
    } catch (outside. eaccess,
             outside. eagain,
             outside. ebadf,
             outside. ebusy,
             outside. edom,
             outside. efault,
             outside. efbig,
             outside. eio,
             outside. eisdir,
             outside. emfile,
             outside. emlink,
             outside. enametoolong,
             outside. enfile,
             outside. enodev,
             outside. enoent,
             outside. enomem,
             outside. eperm,
             outside. epipe,
             outside. espipe,
             outside. exdev
             ) { // No such file in reach.
      putln ("Error: No valid file named ",
             sprint (program_file), " found.");
      global_errfl++;
      abend (" I/O ");
    }
    source_code = fgetf (program) @ " ";
    // So we don't get out-of range array bounds during scanning.
    close(program);
    if (verbose_flag) putln ("@ Initiating scanner.");
    token_vector = scanner (source_code);
    if (verbose_flag && global_errfl)
      putln ("! Scanner failed, working in error recovery mode.");
    // Use scanner() to process source_code.
    if (verbose_flag) putln ("@ Initiating Earley's Parser.");
    abstract_tree =
    machine.parse (token_vector, syntax_error);
    // Parse token_vector into abstract_tree.
  } catch (except (). error (). invcall (). invparser (). pmemory) {
    // There wasn't enough memory to parse the program.
    if (verbose_flag)
      putln ("! Insufficient memory to set up parser, parsing failed.");
    error ("Insufficient memory for parser.");
  }
  if (global_errfl) { // If syntax errors were found, stop the program.
    if (verbose_flag) putln ("! Syntax error: Terminating now.");
    abend (" syntax ");
  } else if (verbose_flag) {
    putln ("& Parsing phase sucessful.");
  /* Here ends the grammar checking. abstract_tree contains the
     intermediate representation of the program. The task now is
     to translate it into an object of class prog, and check it
     for semantical correctness. */
  }
  include "anode_work"; // Used to derive an object of class prog().
  if (verbose_flag) print_anode (abstract_tree);
  return parse_program_anode (abstract_tree, verbose_flag);
}
TEST506g
	  cat >$tempdir/sieve.g <<'TEST506h'
/* The program heading. The identifier can conflict with identifiers in
   the statement. */
program primeSieve 
/* This is all one block statement. A GRIP program in fact consists of
    only one statement. */
{
        /* Constant declarations. */
        sievesize : constant 100;
        /* Global variables. */
        i count : integer;
        /* An array. */
        flags : integer [100];
        /* Initialize count and flags. */
        count <- 0;
        /* If it isn't the C-style for loop :-) */
        for (i <- 0; i < sievesize; i <- i + 1; /* This semicolon has to be here. */)
                flags[i + 1] <- 1;
        /* Now get to work! */
        for (i <- 0; i < sievesize; i <- i + 1;)
                /* This is a multi-branch form of if-then-else. */
                cond { /* This is NOT a block statement. Negative. */
                        flags[i + 1] { /* This is another block-statement. */
                                /* Two local variables. */
                                k prime : integer;
                                prime <- 2 * i + 3;
                                k <- prime + i;
                                for (; k < sievesize; k <- k + prime;)
                                        flags[k + 1] <- 0;
                                count <- count + 1;
                        }
                        /* Here would have been "else blablablablabla...", but primeSieve has no
                            need for "else blablablablabla..." */
                }
        /* I/O, unfortunately without the I. Maybe later ;-( */
        put "The number of primes less than " sievesize " is " count;
}
/* This has all of the constructs available to a GRIP programmer. Not much, eh? :-| */
TEST506h
	  echo '      ' GRAMMARPATH=$tempdir/grip.g $DINO $tempdir/grip.d $tempdir/sieve.g
          if GRAMMARPATH=$tempdir/grip.g $DINO $tempdir/grip.d $tempdir/sieve.g 2>$stderr >$stdout; then
              echo '      ' $CMP $stdout $ftemp2
              if cat >$ftemp2 <<'OUTPUT506-2' && $CMP $stdout $ftemp2; then
The number of primes less than 100 is 45
OUTPUT506-2
                  result=ok
              else
                  result=fail
              fi
          else
              result=fail
          fi
        else
          result=fail
        fi
        if test $result = ok; then
          echo '      ' Serhei\'s interpreter test is ok  -- rm -rf $tempdir
          rm -rf $tempdir
        else
          echo '      ' Serhei\'s interpreter test failed -- look at directory $tempdir
        fi
fi

# Test 507.
if test $result = ok -a $start_test_number -le 507; then
	echo test 507: Check bug of deleting elements from table.
        cat >$test_file <<'TEST507'
var ts = ["MII", "MI;I", "MMI", "M;MI", "MFI", "MMF", "BBB", "MBB",
	  "MIB", "MMB", "MFB", "MIb", "MMb", "MFb"];
var seq = {}, ignore = {}, useq;

func add_transl (seq, s, t) {
  var i;

  if (s in seq) {
    for (i = 0; i < #seq {s}; i++)
      if (seq {s} [i] == t)
	return;
    seq {s} = seq {s} @ [t];
  } else
    seq {s} = [t];
}

func add_seq (str) {
  var start, i, j, s;
  start = 0;
  for (i = 0; i < #str; i++)
    if (str [i] == ';') {
      s = subv (str, start, i + 1 - start);
      start = i + 1;
      for (j = start; j < #str; j++)
        if (str [j] == 't')
          break;
      if (!(s in ignore))
	add_transl (seq, s, subv (str, start, j - start));
    }
  if (#str - start >= 3) {
    s = subv (str, start, -1);
    if (!(s in ignore))
      add_transl (seq, s, "");
  }
}

func build_start_seqs {
  var i, j;

  for (i = 0; i < #ts; i++) {
    add_seq ("t" @ ts [i] @ ";");
    for (j = 0; j < #ts; j++) {
      add_seq ("t" @ ts [i] @ "t" @ ts [j] @ ";");
      add_seq ("t" @ ts [i] @ "t" @ ts [j]);
    }
  }
}

func subscr_divide (s) {
  var v = [nil, nil], k, m = 0, i = 0, f = 0, b = 0, nopb = 0;
  
  for (k = 0; k < #s; k++)
    if (s [k] == 'I') {
      if (i == 2)
        break;
      i++;
    } else if (s [k] == 'M') {
      if (m == 2)
        break;
      m++;
    } else if (s [k] == 'F') {
      if (f == 2)
        break;
      f++;
    } else if (s [k] == 'B' || s [k] == 'b') {
      if (nopb && (k != 0 && s [k - 1] == 't' || s [k] == 'b') || b == 3)
        break; // conflict on B0
      if (s [k] == 'b')
	nopb = 1;
      b++;
    }
  if (k < #s && s [k - 1] == 't')
    k--;
  v [0] = subv (s, 0, k);
  if (k < #s)
    v [1] = subv (s, k, -1);
  return v;
}

func build_all_seqs (seq) {
  var i, j, v, cont, p, s;

  for (;;) {
    cont = 0;
    v = vector (seq);
    for (i = 0; i < #v; i += 2) {
      s = v [i];
      p = subscr_divide (s);
      if (p [1] != nil) {
	ignore {s} = nil;
	del (seq, s);
	add_transl (seq, p[0], p [1][0] != 't' ? p[1] : "");
	if (p [1][0] != 't') {
	  add_transl (seq, p[1], "");
	  for (j = 0; j < #ts; j++) {
	    add_seq (p [1] @ "t" @ ts [j] @ ";");
	    add_seq (p [1] @ "t" @ ts [j]);
	  }
	}
	cont = 1;
      }
    }
    if (!cont)
      break;
  }
}

build_start_seqs ();
build_all_seqs (seq);
TEST507
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        else
                result=fail
        fi
fi

# Test 508.
if test $result = ok -a $start_test_number -le 508; then
	echo test 508: Check bug of deleting elements from table.
        cat >$test_file <<'TEST508'
class c (i) {
  class sc (ai) {}
}
var i = c (10);
putln (i.sc (20) == i.sc (20));
putln (i.sc (20) == i.sc (30));
putln (i.sc (20) == c(10).sc (20));
putln (i.sc (20) == c(30).sc (20));
TEST508
        echo '      ' $DINO $test_file ">$stdout" "2>$stderr"
        if $DINO $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT508' && $CMP $stdout $ftemp2; then
1
0
0
0
OUTPUT508
                  result=ok
                else
                  result=fail
                fi
        else
                result=fail
        fi
fi


# Test 509.
if test $result = ok -a $start_test_number -le 509; then
	echo test 509: Checking that return is in function/class/ext.
        cat >$test_file <<'TEST509'
return 10;
TEST509
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST509-1'; then
test.d:1:1: statement return is not in function, class, or extension
TEST509-1
                result=ok
        else
                result=fail
        fi
fi

# Test 510.
if test $result = ok -a $start_test_number -le 510; then
	echo test 510: Checking that return is in function/class/ext.
        cat >$test_file <<'TEST510'
var k = "aaa", t = {};
t {k} = 10;
k [1] = 'b';
TEST510
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST510-1'; then
test.d:3:3: run time error - attempt to modify immutable vector
TEST510-1
                result=ok
        else
                result=fail
        fi
fi

# Test 511.
if test $result = ok -a $start_test_number -le 511; then
	echo test 511: format output
        cat >$test_file <<'TEST511'
// default conversion
putf ("%d\n", 10);
putf ("%o\n", 10);
putf ("%x\n", 10);
putf ("%X\n", 10);
putf ("%e\n", 10.5);
putf ("%E\n", 10.5);
putf ("%f\n", 10.5);
putf ("%g\n", 10.5);
putf ("%G\n", 10.5);
putf ("%c\n", 'z');
putf ("%s\n", "Abracadabra");
// width
putf ("%15d\n", 10);
putf ("%15o\n", 10);
putf ("%15x\n", 10);
putf ("%15X\n", 10);
putf ("%15e\n", 10.5);
putf ("%15E\n", 10.5);
putf ("%15f\n", 10.5);
putf ("%15g\n", 10.5);
putf ("%15G\n", 10.5);
putf ("%15c\n", 'z');
putf ("%15s\n", "Abracadabra");
// flag -
putf ("%-15d\n", 10);
putf ("%-15o\n", 10);
putf ("%-15x\n", 10);
putf ("%-15X\n", 10);
putf ("%-15e\n", 10.5);
putf ("%-15E\n", 10.5);
putf ("%-15f\n", 10.5);
putf ("%-15g\n", 10.5);
putf ("%-15G\n", 10.5);
putf ("%-15c\n", 'z');
putf ("%-15s\n", "Abracadabra");
// flag #
putf ("%#o\n", 10);
putf ("%#x\n", 10);
putf ("%#X\n", 10);
putf ("%#e\n", 10.5);
putf ("%#E\n", 10.5);
putf ("%#f\n", 10.5);
putf ("%#g\n", 10.5);
putf ("%#G\n", 10.5);
// flag 0
putf ("%015d\n", 10);
putf ("%015o\n", 10);
putf ("%015x\n", 10);
putf ("%015X\n", 10);
putf ("%015e\n", 10.5);
putf ("%015E\n", 10.5);
putf ("%015f\n", 10.5);
putf ("%015g\n", 10.5);
putf ("%015G\n", 10.5);
// flag <blank>
putf ("% 15d\n", 10);
putf ("% 15e\n", 10.5);
putf ("% 15E\n", 10.5);
putf ("% 15f\n", 10.5);
putf ("% 15g\n", 10.5);
putf ("% 15G\n", 10.5);
// flag +
putf ("%+15d\n", 10);
putf ("%+15e\n", 10.5);
putf ("%+15E\n", 10.5);
putf ("%+15f\n", 10.5);
putf ("%+15g\n", 10.5);
putf ("%+15G\n", 10.5);
// flag + and <blank> -> ignore blank
putf ("%+ 15d\n", 10);
putf ("%+ 15e\n", 10.5);
putf ("%+ 15E\n", 10.5);
putf ("%+ 15f\n", 10.5);
putf ("%+ 15g\n", 10.5);
putf ("%+ 15G\n", 10.5);
// flag - and 0 -> ignore 0
putf ("%-015d\n", 10);
putf ("%-015o\n", 10);
putf ("%-015x\n", 10);
putf ("%-015X\n", 10);
putf ("%-015e\n", 10.5);
putf ("%-015E\n", 10.5);
putf ("%-015f\n", 10.5);
putf ("%-015g\n", 10.5);
putf ("%-015G\n", 10.5);
// parameter defined width
putf ("%*d\n", 15, 10);
putf ("%*o\n", 15, 10);
putf ("%*x\n", 15, 10);
putf ("%*X\n", 15, 10);
putf ("%*e\n", 15, 10.5);
putf ("%*E\n", 15, 10.5);
putf ("%*f\n", 15, 10.5);
putf ("%*g\n", 15, 10.5);
putf ("%*G\n", 15, 10.5);
putf ("%*c\n", 15, 'z');
// negative width -> absolute value and flag -
putf ("%*s\n", 15, "Abracadabra");
putf ("%*d\n", -15, 10);
putf ("%*o\n", -15, 10);
putf ("%*x\n", -15, 10);
putf ("%*X\n", -15, 10);
putf ("%*e\n", -15, 10.5);
putf ("%*E\n", -15, 10.5);
putf ("%*f\n", -15, 10.5);
putf ("%*g\n", -15, 10.5);
putf ("%*G\n", -15, 10.5);
putf ("%*c\n", -15, 'z');
putf ("%*s\n", -15, "Abracadabra");
// zero width
putf ("%*d\n", 0, 10);
putf ("%*o\n", 0, 10);
putf ("%*x\n", 0, 10);
putf ("%*X\n", 0, 10);
putf ("%*e\n", 0, 10.5);
putf ("%*E\n", 0, 10.5);
putf ("%*f\n", 0, 10.5);
putf ("%*g\n", 0, 10.5);
putf ("%*G\n", 0, 10.5);
putf ("%*c\n", 0, 'z');
putf ("%*s\n", 0, "Abracadabra");
// zero precision value
putf ("%.0d\n", 10);
putf ("%.0o\n", 10);
putf ("%.0x\n", 10);
putf ("%.0X\n", 10);
putf ("%.0e\n", 10.5);
putf ("%.0E\n", 10.5);
putf ("%.0f\n", 10.5);
putf ("%.0g\n", 10.5);
putf ("%.0G\n", 10.5);
putf ("%.0s\n", "Abracadabra");
// absent precision value -> zero value
putf ("%.d\n", 10);
putf ("%.o\n", 10);
putf ("%.x\n", 10);
putf ("%.X\n", 10);
putf ("%.e\n", 10.5);
putf ("%.E\n", 10.5);
putf ("%.f\n", 10.5);
putf ("%.g\n", 10.5);
putf ("%.G\n", 10.5);
putf ("%.s\n", "Abracadabra");
// precision with numeric conversion and flag 0 -> ignore flag 0
putf ("%05.0d\n", 10);
putf ("%05.0o\n", 10);
putf ("%05.0x\n", 10);
putf ("%05.0X\n", 10);
putf ("%05.d\n", 10);
putf ("%05.o\n", 10);
putf ("%05.x\n", 10);
putf ("%05.X\n", 10);
// precision value 10
putf ("%.10d\n", 10);
putf ("%.10o\n", 10);
putf ("%.10x\n", 10);
putf ("%.10X\n", 10);
putf ("%.10e\n", 10.5);
putf ("%.10E\n", 10.5);
putf ("%.10f\n", 10.5);
putf ("%.10g\n", 10.5);
putf ("%.10G\n", 10.5);
putf ("%.10s\n", "Abracadabra");
// precision value as parameter
putf ("%.*d\n", 10, 10);
putf ("%.*o\n", 10, 10);
putf ("%.*x\n", 10, 10);
putf ("%.*X\n", 10, 10);
putf ("%.*e\n", 10, 10.5);
putf ("%.*E\n", 10, 10.5);
putf ("%.*f\n", 10, 10.5);
putf ("%.*g\n", 10, 10.5);
putf ("%.*G\n", 10, 10.5);
putf ("%.*s\n", 10, "Abracadabra");
// negative precision value -> value zero
putf ("%.*d\n", -10, 10);
putf ("%.*o\n", -10, 10);
putf ("%.*x\n", -10, 10);
putf ("%.*X\n", -10, 10);
putf ("%.*e\n", -10, 10.5);
putf ("%.*E\n", -10, 10.5);
putf ("%.*f\n", -10, 10.5);
putf ("%.*g\n", -10, 10.5);
putf ("%.*G\n", -10, 10.5);
putf ("%.*s\n", -10, "Abracadabra");
// zero precision value for outputing zero
putf ("%.0d\n", 0);
putf ("%.0o\n", 0);
putf ("%.0x\n", 0);
putf ("%.0X\n", 0);
// %
putf ("%%\n");

// The same for fputf
// default conversion
fputf (stdout, "%d\n", 10);
fputf (stdout, "%o\n", 10);
fputf (stdout, "%x\n", 10);
fputf (stdout, "%X\n", 10);
fputf (stdout, "%e\n", 10.5);
fputf (stdout, "%E\n", 10.5);
fputf (stdout, "%f\n", 10.5);
fputf (stdout, "%g\n", 10.5);
fputf (stdout, "%G\n", 10.5);
fputf (stdout, "%c\n", 'z');
fputf (stdout, "%s\n", "Abracadabra");
// width
fputf (stdout, "%15d\n", 10);
fputf (stdout, "%15o\n", 10);
fputf (stdout, "%15x\n", 10);
fputf (stdout, "%15X\n", 10);
fputf (stdout, "%15e\n", 10.5);
fputf (stdout, "%15E\n", 10.5);
fputf (stdout, "%15f\n", 10.5);
fputf (stdout, "%15g\n", 10.5);
fputf (stdout, "%15G\n", 10.5);
fputf (stdout, "%15c\n", 'z');
fputf (stdout, "%15s\n", "Abracadabra");
// flag -
fputf (stdout, "%-15d\n", 10);
fputf (stdout, "%-15o\n", 10);
fputf (stdout, "%-15x\n", 10);
fputf (stdout, "%-15X\n", 10);
fputf (stdout, "%-15e\n", 10.5);
fputf (stdout, "%-15E\n", 10.5);
fputf (stdout, "%-15f\n", 10.5);
fputf (stdout, "%-15g\n", 10.5);
fputf (stdout, "%-15G\n", 10.5);
fputf (stdout, "%-15c\n", 'z');
fputf (stdout, "%-15s\n", "Abracadabra");
// flag #
fputf (stdout, "%#o\n", 10);
fputf (stdout, "%#x\n", 10);
fputf (stdout, "%#X\n", 10);
fputf (stdout, "%#e\n", 10.5);
fputf (stdout, "%#E\n", 10.5);
fputf (stdout, "%#f\n", 10.5);
fputf (stdout, "%#g\n", 10.5);
fputf (stdout, "%#G\n", 10.5);
// flag 0
fputf (stdout, "%015d\n", 10);
fputf (stdout, "%015o\n", 10);
fputf (stdout, "%015x\n", 10);
fputf (stdout, "%015X\n", 10);
fputf (stdout, "%015e\n", 10.5);
fputf (stdout, "%015E\n", 10.5);
fputf (stdout, "%015f\n", 10.5);
fputf (stdout, "%015g\n", 10.5);
fputf (stdout, "%015G\n", 10.5);
// flag <blank>
fputf (stdout, "% 15d\n", 10);
fputf (stdout, "% 15e\n", 10.5);
fputf (stdout, "% 15E\n", 10.5);
fputf (stdout, "% 15f\n", 10.5);
fputf (stdout, "% 15g\n", 10.5);
fputf (stdout, "% 15G\n", 10.5);
// flag +
fputf (stdout, "%+15d\n", 10);
fputf (stdout, "%+15e\n", 10.5);
fputf (stdout, "%+15E\n", 10.5);
fputf (stdout, "%+15f\n", 10.5);
fputf (stdout, "%+15g\n", 10.5);
fputf (stdout, "%+15G\n", 10.5);
// flag + and <blank> -> ignore blank
fputf (stdout, "%+ 15d\n", 10);
fputf (stdout, "%+ 15e\n", 10.5);
fputf (stdout, "%+ 15E\n", 10.5);
fputf (stdout, "%+ 15f\n", 10.5);
fputf (stdout, "%+ 15g\n", 10.5);
fputf (stdout, "%+ 15G\n", 10.5);
// flag - and 0 -> ignore 0
fputf (stdout, "%-015d\n", 10);
fputf (stdout, "%-015o\n", 10);
fputf (stdout, "%-015x\n", 10);
fputf (stdout, "%-015X\n", 10);
fputf (stdout, "%-015e\n", 10.5);
fputf (stdout, "%-015E\n", 10.5);
fputf (stdout, "%-015f\n", 10.5);
fputf (stdout, "%-015g\n", 10.5);
fputf (stdout, "%-015G\n", 10.5);
// parameter defined width
fputf (stdout, "%*d\n", 15, 10);
fputf (stdout, "%*o\n", 15, 10);
fputf (stdout, "%*x\n", 15, 10);
fputf (stdout, "%*X\n", 15, 10);
fputf (stdout, "%*e\n", 15, 10.5);
fputf (stdout, "%*E\n", 15, 10.5);
fputf (stdout, "%*f\n", 15, 10.5);
fputf (stdout, "%*g\n", 15, 10.5);
fputf (stdout, "%*G\n", 15, 10.5);
fputf (stdout, "%*c\n", 15, 'z');
// negative width -> absolute value and flag -
fputf (stdout, "%*s\n", 15, "Abracadabra");
fputf (stdout, "%*d\n", -15, 10);
fputf (stdout, "%*o\n", -15, 10);
fputf (stdout, "%*x\n", -15, 10);
fputf (stdout, "%*X\n", -15, 10);
fputf (stdout, "%*e\n", -15, 10.5);
fputf (stdout, "%*E\n", -15, 10.5);
fputf (stdout, "%*f\n", -15, 10.5);
fputf (stdout, "%*g\n", -15, 10.5);
fputf (stdout, "%*G\n", -15, 10.5);
fputf (stdout, "%*c\n", -15, 'z');
fputf (stdout, "%*s\n", -15, "Abracadabra");
// zero width
fputf (stdout, "%*d\n", 0, 10);
fputf (stdout, "%*o\n", 0, 10);
fputf (stdout, "%*x\n", 0, 10);
fputf (stdout, "%*X\n", 0, 10);
fputf (stdout, "%*e\n", 0, 10.5);
fputf (stdout, "%*E\n", 0, 10.5);
fputf (stdout, "%*f\n", 0, 10.5);
fputf (stdout, "%*g\n", 0, 10.5);
fputf (stdout, "%*G\n", 0, 10.5);
fputf (stdout, "%*c\n", 0, 'z');
fputf (stdout, "%*s\n", 0, "Abracadabra");
// zero precision value
fputf (stdout, "%.0d\n", 10);
fputf (stdout, "%.0o\n", 10);
fputf (stdout, "%.0x\n", 10);
fputf (stdout, "%.0X\n", 10);
fputf (stdout, "%.0e\n", 10.5);
fputf (stdout, "%.0E\n", 10.5);
fputf (stdout, "%.0f\n", 10.5);
fputf (stdout, "%.0g\n", 10.5);
fputf (stdout, "%.0G\n", 10.5);
fputf (stdout, "%.0s\n", "Abracadabra");
// absent precision value -> zero value
fputf (stdout, "%.d\n", 10);
fputf (stdout, "%.o\n", 10);
fputf (stdout, "%.x\n", 10);
fputf (stdout, "%.X\n", 10);
fputf (stdout, "%.e\n", 10.5);
fputf (stdout, "%.E\n", 10.5);
fputf (stdout, "%.f\n", 10.5);
fputf (stdout, "%.g\n", 10.5);
fputf (stdout, "%.G\n", 10.5);
fputf (stdout, "%.s\n", "Abracadabra");
// precision with numeric conversion and flag 0 -> ignore flag 0
fputf (stdout, "%05.0d\n", 10);
fputf (stdout, "%05.0o\n", 10);
fputf (stdout, "%05.0x\n", 10);
fputf (stdout, "%05.0X\n", 10);
fputf (stdout, "%05.d\n", 10);
fputf (stdout, "%05.o\n", 10);
fputf (stdout, "%05.x\n", 10);
fputf (stdout, "%05.X\n", 10);
// precision value 10
fputf (stdout, "%.10d\n", 10);
fputf (stdout, "%.10o\n", 10);
fputf (stdout, "%.10x\n", 10);
fputf (stdout, "%.10X\n", 10);
fputf (stdout, "%.10e\n", 10.5);
fputf (stdout, "%.10E\n", 10.5);
fputf (stdout, "%.10f\n", 10.5);
fputf (stdout, "%.10g\n", 10.5);
fputf (stdout, "%.10G\n", 10.5);
fputf (stdout, "%.10s\n", "Abracadabra");
// precision value as parameter
fputf (stdout, "%.*d\n", 10, 10);
fputf (stdout, "%.*o\n", 10, 10);
fputf (stdout, "%.*x\n", 10, 10);
fputf (stdout, "%.*X\n", 10, 10);
fputf (stdout, "%.*e\n", 10, 10.5);
fputf (stdout, "%.*E\n", 10, 10.5);
fputf (stdout, "%.*f\n", 10, 10.5);
fputf (stdout, "%.*g\n", 10, 10.5);
fputf (stdout, "%.*G\n", 10, 10.5);
fputf (stdout, "%.*s\n", 10, "Abracadabra");
// negative precision value -> value zero
fputf (stdout, "%.*d\n", -10, 10);
fputf (stdout, "%.*o\n", -10, 10);
fputf (stdout, "%.*x\n", -10, 10);
fputf (stdout, "%.*X\n", -10, 10);
fputf (stdout, "%.*e\n", -10, 10.5);
fputf (stdout, "%.*E\n", -10, 10.5);
fputf (stdout, "%.*f\n", -10, 10.5);
fputf (stdout, "%.*g\n", -10, 10.5);
fputf (stdout, "%.*G\n", -10, 10.5);
fputf (stdout, "%.*s\n", -10, "Abracadabra");
// zero precision value for outputing zero
fputf (stdout, "%.0d\n", 0);
fputf (stdout, "%.0o\n", 0);
fputf (stdout, "%.0x\n", 0);
fputf (stdout, "%.0X\n", 0);
// %
fputf (stdout, "%%\n");

// The same for sputf
// default conversion
put (sputf ("%d\n", 10));
put (sputf ("%o\n", 10));
put (sputf ("%x\n", 10));
put (sputf ("%X\n", 10));
put (sputf ("%e\n", 10.5));
put (sputf ("%E\n", 10.5));
put (sputf ("%f\n", 10.5));
put (sputf ("%g\n", 10.5));
put (sputf ("%G\n", 10.5));
put (sputf ("%c\n", 'z'));
put (sputf ("%s\n", "Abracadabra"));
// width
put (sputf ("%15d\n", 10));
put (sputf ("%15o\n", 10));
put (sputf ("%15x\n", 10));
put (sputf ("%15X\n", 10));
put (sputf ("%15e\n", 10.5));
put (sputf ("%15E\n", 10.5));
put (sputf ("%15f\n", 10.5));
put (sputf ("%15g\n", 10.5));
put (sputf ("%15G\n", 10.5));
put (sputf ("%15c\n", 'z'));
put (sputf ("%15s\n", "Abracadabra"));
// flag -
put (sputf ("%-15d\n", 10));
put (sputf ("%-15o\n", 10));
put (sputf ("%-15x\n", 10));
put (sputf ("%-15X\n", 10));
put (sputf ("%-15e\n", 10.5));
put (sputf ("%-15E\n", 10.5));
put (sputf ("%-15f\n", 10.5));
put (sputf ("%-15g\n", 10.5));
put (sputf ("%-15G\n", 10.5));
put (sputf ("%-15c\n", 'z'));
put (sputf ("%-15s\n", "Abracadabra"));
// flag #
put (sputf ("%#o\n", 10));
put (sputf ("%#x\n", 10));
put (sputf ("%#X\n", 10));
put (sputf ("%#e\n", 10.5));
put (sputf ("%#E\n", 10.5));
put (sputf ("%#f\n", 10.5));
put (sputf ("%#g\n", 10.5));
put (sputf ("%#G\n", 10.5));
// flag 0
put (sputf ("%015d\n", 10));
put (sputf ("%015o\n", 10));
put (sputf ("%015x\n", 10));
put (sputf ("%015X\n", 10));
put (sputf ("%015e\n", 10.5));
put (sputf ("%015E\n", 10.5));
put (sputf ("%015f\n", 10.5));
put (sputf ("%015g\n", 10.5));
put (sputf ("%015G\n", 10.5));
// flag <blank>
put (sputf ("% 15d\n", 10));
put (sputf ("% 15e\n", 10.5));
put (sputf ("% 15E\n", 10.5));
put (sputf ("% 15f\n", 10.5));
put (sputf ("% 15g\n", 10.5));
put (sputf ("% 15G\n", 10.5));
// flag +
put (sputf ("%+15d\n", 10));
put (sputf ("%+15e\n", 10.5));
put (sputf ("%+15E\n", 10.5));
put (sputf ("%+15f\n", 10.5));
put (sputf ("%+15g\n", 10.5));
put (sputf ("%+15G\n", 10.5));
// flag + and <blank> -> ignore blank
put (sputf ("%+ 15d\n", 10));
put (sputf ("%+ 15e\n", 10.5));
put (sputf ("%+ 15E\n", 10.5));
put (sputf ("%+ 15f\n", 10.5));
put (sputf ("%+ 15g\n", 10.5));
put (sputf ("%+ 15G\n", 10.5));
// flag - and 0 -> ignore 0
put (sputf ("%-015d\n", 10));
put (sputf ("%-015o\n", 10));
put (sputf ("%-015x\n", 10));
put (sputf ("%-015X\n", 10));
put (sputf ("%-015e\n", 10.5));
put (sputf ("%-015E\n", 10.5));
put (sputf ("%-015f\n", 10.5));
put (sputf ("%-015g\n", 10.5));
put (sputf ("%-015G\n", 10.5));
// parameter defined width
put (sputf ("%*d\n", 15, 10));
put (sputf ("%*o\n", 15, 10));
put (sputf ("%*x\n", 15, 10));
put (sputf ("%*X\n", 15, 10));
put (sputf ("%*e\n", 15, 10.5));
put (sputf ("%*E\n", 15, 10.5));
put (sputf ("%*f\n", 15, 10.5));
put (sputf ("%*g\n", 15, 10.5));
put (sputf ("%*G\n", 15, 10.5));
put (sputf ("%*c\n", 15, 'z'));
// negative width -> absolute value and flag -
put (sputf ("%*s\n", 15, "Abracadabra"));
put (sputf ("%*d\n", -15, 10));
put (sputf ("%*o\n", -15, 10));
put (sputf ("%*x\n", -15, 10));
put (sputf ("%*X\n", -15, 10));
put (sputf ("%*e\n", -15, 10.5));
put (sputf ("%*E\n", -15, 10.5));
put (sputf ("%*f\n", -15, 10.5));
put (sputf ("%*g\n", -15, 10.5));
put (sputf ("%*G\n", -15, 10.5));
put (sputf ("%*c\n", -15, 'z'));
put (sputf ("%*s\n", -15, "Abracadabra"));
// zero width
put (sputf ("%*d\n", 0, 10));
put (sputf ("%*o\n", 0, 10));
put (sputf ("%*x\n", 0, 10));
put (sputf ("%*X\n", 0, 10));
put (sputf ("%*e\n", 0, 10.5));
put (sputf ("%*E\n", 0, 10.5));
put (sputf ("%*f\n", 0, 10.5));
put (sputf ("%*g\n", 0, 10.5));
put (sputf ("%*G\n", 0, 10.5));
put (sputf ("%*c\n", 0, 'z'));
put (sputf ("%*s\n", 0, "Abracadabra"));
// zero precision value
put (sputf ("%.0d\n", 10));
put (sputf ("%.0o\n", 10));
put (sputf ("%.0x\n", 10));
put (sputf ("%.0X\n", 10));
put (sputf ("%.0e\n", 10.5));
put (sputf ("%.0E\n", 10.5));
put (sputf ("%.0f\n", 10.5));
put (sputf ("%.0g\n", 10.5));
put (sputf ("%.0G\n", 10.5));
put (sputf ("%.0s\n", "Abracadabra"));
// absent precision value -> zero value
put (sputf ("%.d\n", 10));
put (sputf ("%.o\n", 10));
put (sputf ("%.x\n", 10));
put (sputf ("%.X\n", 10));
put (sputf ("%.e\n", 10.5));
put (sputf ("%.E\n", 10.5));
put (sputf ("%.f\n", 10.5));
put (sputf ("%.g\n", 10.5));
put (sputf ("%.G\n", 10.5));
put (sputf ("%.s\n", "Abracadabra"));
// precision with numeric conversion and flag 0 -> ignore flag 0
put (sputf ("%05.0d\n", 10));
put (sputf ("%05.0o\n", 10));
put (sputf ("%05.0x\n", 10));
put (sputf ("%05.0X\n", 10));
put (sputf ("%05.d\n", 10));
put (sputf ("%05.o\n", 10));
put (sputf ("%05.x\n", 10));
put (sputf ("%05.X\n", 10));
// precision value 10
put (sputf ("%.10d\n", 10));
put (sputf ("%.10o\n", 10));
put (sputf ("%.10x\n", 10));
put (sputf ("%.10X\n", 10));
put (sputf ("%.10e\n", 10.5));
put (sputf ("%.10E\n", 10.5));
put (sputf ("%.10f\n", 10.5));
put (sputf ("%.10g\n", 10.5));
put (sputf ("%.10G\n", 10.5));
put (sputf ("%.10s\n", "Abracadabra"));
// precision value as parameter
put (sputf ("%.*d\n", 10, 10));
put (sputf ("%.*o\n", 10, 10));
put (sputf ("%.*x\n", 10, 10));
put (sputf ("%.*X\n", 10, 10));
put (sputf ("%.*e\n", 10, 10.5));
put (sputf ("%.*E\n", 10, 10.5));
put (sputf ("%.*f\n", 10, 10.5));
put (sputf ("%.*g\n", 10, 10.5));
put (sputf ("%.*G\n", 10, 10.5));
put (sputf ("%.*s\n", 10, "Abracadabra"));
// negative precision value -> value zero
put (sputf ("%.*d\n", -10, 10));
put (sputf ("%.*o\n", -10, 10));
put (sputf ("%.*x\n", -10, 10));
put (sputf ("%.*X\n", -10, 10));
put (sputf ("%.*e\n", -10, 10.5));
put (sputf ("%.*E\n", -10, 10.5));
put (sputf ("%.*f\n", -10, 10.5));
put (sputf ("%.*g\n", -10, 10.5));
put (sputf ("%.*G\n", -10, 10.5));
put (sputf ("%.*s\n", -10, "Abracadabra"));
// zero precision value for outputing zero
put (sputf ("%.0d\n", 0));
put (sputf ("%.0o\n", 0));
put (sputf ("%.0x\n", 0));
put (sputf ("%.0X\n", 0));
// %
put (sputf ("%%\n"));
// big precision
putf ("%.21474836s", "stop\n");
TEST511
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT511' && $CMP $stdout $ftemp2; then
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
012
0xa
0XA
1.050000e+01
1.050000E+01
10.500000
10.5000
10.5000
000000000000010
000000000000012
00000000000000a
00000000000000A
0001.050000e+01
0001.050000E+01
00000010.500000
0000000000010.5
0000000000010.5
             10
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

   10
   12
    a
    A
   10
   12
    a
    A
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01





%
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
012
0xa
0XA
1.050000e+01
1.050000E+01
10.500000
10.5000
10.5000
000000000000010
000000000000012
00000000000000a
00000000000000A
0001.050000e+01
0001.050000E+01
00000010.500000
0000000000010.5
0000000000010.5
             10
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

   10
   12
    a
    A
   10
   12
    a
    A
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01





%
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
012
0xa
0XA
1.050000e+01
1.050000E+01
10.500000
10.5000
10.5000
000000000000010
000000000000012
00000000000000a
00000000000000A
0001.050000e+01
0001.050000E+01
00000010.500000
0000000000010.5
0000000000010.5
             10
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

   10
   12
    a
    A
   10
   12
    a
    A
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01





%
stop
OUTPUT511
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT511-1' && $CMP $stdout $ftemp2; then
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
012
0xa
0XA
1.050000e+01
1.050000E+01
10.500000
10.5000
10.5000
000000000000010
000000000000012
00000000000000a
00000000000000A
0001.050000e+01
0001.050000E+01
00000010.500000
0000000000010.5
0000000000010.5
             10
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

   10
   12
    a
    A
   10
   12
    a
    A
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01





%
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
012
0xa
0XA
1.050000e+01
1.050000E+01
10.500000
10.5000
10.5000
000000000000010
000000000000012
00000000000000a
00000000000000A
0001.050000e+01
0001.050000E+01
00000010.500000
0000000000010.5
0000000000010.5
             10
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

   10
   12
    a
    A
   10
   12
    a
    A
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01





%
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
012
0xa
0XA
1.050000e+01
1.050000E+01
10.500000
10.5000
10.5000
000000000000010
000000000000012
00000000000000a
00000000000000A
0001.050000e+01
0001.050000E+01
00000010.500000
0000000000010.5
0000000000010.5
             10
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

   10
   12
    a
    A
   10
   12
    a
    A
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01





%
stop
OUTPUT511-1
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 512.
if test $result = ok -a $start_test_number -le 512; then
	echo test 512: adjustment for %d
        cat >$test_file <<'TEST512'
sputf ("%#d", 10);
TEST512
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST512-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST512-1
                result=ok
        else
                result=fail
        fi
fi

# Test 513.
if test $result = ok -a $start_test_number -le 513; then
	echo test 513: adjustment for %c
        cat >$test_file <<'TEST513'
sputf ("%#c", 10);
TEST513
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST513-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST513-1
                result=ok
        else
                result=fail
        fi
fi

# Test 514.
if test $result = ok -a $start_test_number -le 514; then
	echo test 514: blank flag for %o
        cat >$test_file <<'TEST514'
sputf ("% o", 10);
TEST514
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST514-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST514-1
                result=ok
        else
                result=fail
        fi
fi

# Test 515.
if test $result = ok -a $start_test_number -le 515; then
	echo test 515: adjustment for %s
        cat >$test_file <<'TEST515'
sputf ("%#s", "Abracadabra");
TEST515
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST515-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST515-1
                result=ok
        else
                result=fail
        fi
fi

# Test 516.
if test $result = ok -a $start_test_number -le 516; then
	echo test 516: zero flag for %c
        cat >$test_file <<'TEST516'
sputf ("%015c", 'z');
TEST516
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST516-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST516-1
                result=ok
        else
                result=fail
        fi
fi

# Test 517.
if test $result = ok -a $start_test_number -le 517; then
	echo test 517: zero flag for %s
        cat >$test_file <<'TEST517'
sputf ("%015s", "Abracadabra");
TEST517
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST517-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST517-1
                result=ok
        else
                result=fail
        fi
fi

# Test 518.
if test $result = ok -a $start_test_number -le 518; then
	echo test 518: blank flag for %o
        cat >$test_file <<'TEST518'
sputf ("% 15o", 10);
TEST518
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST518-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST518-1
                result=ok
        else
                result=fail
        fi
fi

# Test 519.
if test $result = ok -a $start_test_number -le 519; then
	echo test 519: blank flag for %x
        cat >$test_file <<'TEST519'
sputf ("% 15x", 10);
TEST519
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST519-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST519-1
                result=ok
        else
                result=fail
        fi
fi

# Test 520.
if test $result = ok -a $start_test_number -le 520; then
	echo test 520: blank flag for %X
        cat >$test_file <<'TEST520'
sputf ("% 15X", 10);
TEST520
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST520-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST520-1
                result=ok
        else
                result=fail
        fi
fi

# Test 521.
if test $result = ok -a $start_test_number -le 521; then
	echo test 521: blank flag for %c
        cat >$test_file <<'TEST521'
sputf ("% 15c", 10);
TEST521
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST521-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST521-1
                result=ok
        else
                result=fail
        fi
fi

# Test 522.
if test $result = ok -a $start_test_number -le 522; then
	echo test 522: blank flag for %s
        cat >$test_file <<'TEST522'
sputf ("% 15s", "Abracadabra");
TEST522
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST522-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST522-1
                result=ok
        else
                result=fail
        fi
fi

# Test 523.
if test $result = ok -a $start_test_number -le 523; then
	echo test 523: flag + for %o
        cat >$test_file <<'TEST523'
sputf ("%+15o", 10);
TEST523
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST523-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST523-1
                result=ok
        else
                result=fail
        fi
fi

# Test 524.
if test $result = ok -a $start_test_number -le 524; then
	echo test 524: flag + for %x
        cat >$test_file <<'TEST524'
sputf ("%+15x", 10);
TEST524
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST524-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST524-1
                result=ok
        else
                result=fail
        fi
fi

# Test 525.
if test $result = ok -a $start_test_number -le 525; then
	echo test 525: flag + for %X
        cat >$test_file <<'TEST525'
sputf ("%+15X", 10);
TEST525
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST525-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST525-1
                result=ok
        else
                result=fail
        fi
fi

# Test 526.
if test $result = ok -a $start_test_number -le 526; then
	echo test 526: flag + for %c
        cat >$test_file <<'TEST526'
sputf ("%+15c", 10);
TEST526
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST526-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST526-1
                result=ok
        else
                result=fail
        fi
fi

# Test 527.
if test $result = ok -a $start_test_number -le 527; then
	echo test 527: flag + for %s
        cat >$test_file <<'TEST527'
sputf ("%+15s", 10);
TEST527
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST527-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST527-1
                result=ok
        else
                result=fail
        fi
fi

# Test 528.
if test $result = ok -a $start_test_number -le 528; then
	echo test 528: Few arguments for format
        cat >$test_file <<'TEST528'
sputf ("%d");
TEST528
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST528-1'; then
test.d:1:7: run time error - invalid number of actual parameters for `sputf'
TEST528-1
                result=ok
        else
                result=fail
        fi
fi

# Test 529.
if test $result = ok -a $start_test_number -le 529; then
	echo test 529: Few arguments for format
        cat >$test_file <<'TEST529'
sputf ("%*d", 10);
TEST529
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST529-1'; then
test.d:1:7: run time error - invalid number of actual parameters for `sputf'
TEST529-1
                result=ok
        else
                result=fail
        fi
fi

# Test 530.
if test $result = ok -a $start_test_number -le 530; then
	echo test 530: Too many parameters
        cat >$test_file <<'TEST530'
sputf ("%*d", 10, 10, 10);
TEST530
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST530-1'; then
test.d:1:7: run time error - invalid number of actual parameters for `sputf'
TEST530-1
                result=ok
        else
                result=fail
        fi
fi

# Test 531.
if test $result = ok -a $start_test_number -le 531; then
	echo test 531: Too many parameters
        cat >$test_file <<'TEST531'
sputf ("%d", 10, 10);
TEST531
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST531-1'; then
test.d:1:7: run time error - invalid number of actual parameters for `sputf'
TEST531-1
                result=ok
        else
                result=fail
        fi
fi

# Test 532.
if test $result = ok -a $start_test_number -le 532; then
	echo test 532: Parameter does not correspond to conversion
        cat >$test_file <<'TEST532'
sputf ("%d", "");
TEST532
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST532-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST532-1
                result=ok
        else
                result=fail
        fi
fi

# Test 533.
if test $result = ok -a $start_test_number -le 533; then
	echo test 533: Parameter does not correspond to conversion
        cat >$test_file <<'TEST533'
sputf ("%d", 'c');
TEST533
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST533-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST533-1
                result=ok
        else
                result=fail
        fi
fi

# Test 534.
if test $result = ok -a $start_test_number -le 534; then
	echo test 534: Parameter does not correspond to conversion
        cat >$test_file <<'TEST534'
sputf ("%d", 10.0);
TEST534
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST534-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST534-1
                result=ok
        else
                result=fail
        fi
fi

# Test 535.
if test $result = ok -a $start_test_number -le 535; then
	echo test 535: Parameter does not correspond to conversion
        cat >$test_file <<'TEST535'
sputf ("%c", 10);
TEST535
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST535-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST535-1
                result=ok
        else
                result=fail
        fi
fi

# Test 536.
if test $result = ok -a $start_test_number -le 536; then
	echo test 536: Parameter does not correspond to conversion
        cat >$test_file <<'TEST536'
sputf ("%c", "");
TEST536
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST536-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST536-1
                result=ok
        else
                result=fail
        fi
fi

# Test 537.
if test $result = ok -a $start_test_number -le 537; then
	echo test 537: Parameter does not correspond to conversion
        cat >$test_file <<'TEST537'
sputf ("%c", 10.0);
TEST537
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST537-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST537-1
                result=ok
        else
                result=fail
        fi
fi

# Test 538.
if test $result = ok -a $start_test_number -le 538; then
	echo test 538: Parameter does not correspond to conversion
        cat >$test_file <<'TEST538'
sputf ("%g", "");
TEST538
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST538-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST538-1
                result=ok
        else
                result=fail
        fi
fi

# Test 539.
if test $result = ok -a $start_test_number -le 539; then
	echo test 539: Parameter does not correspond to conversion
        cat >$test_file <<'TEST539'
sputf ("%g", 'c');
TEST539
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST539-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST539-1
                result=ok
        else
                result=fail
        fi
fi

# Test 540.
if test $result = ok -a $start_test_number -le 540; then
	echo test 540: Parameter does not correspond to conversion
        cat >$test_file <<'TEST540'
sputf ("%g", 10);
TEST540
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST540-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST540-1
                result=ok
        else
                result=fail
        fi
fi

# Test 541.
if test $result = ok -a $start_test_number -le 541; then
	echo test 541: Absent format
        cat >$test_file <<'TEST541'
sputf ();
TEST541
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST541-1'; then
test.d:1:7: run time error - invalid number of actual parameters for `sputf'
TEST541-1
                result=ok
        else
                result=fail
        fi
fi

# Test 542.
if test $result = ok -a $start_test_number -le 542; then
	echo test 542: Absent format
        cat >$test_file <<'TEST542'
fputf (stdout);
TEST542
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST542-1'; then
test.d:1:7: run time error - invalid number of actual parameters for `fputf'
TEST542-1
                result=ok
        else
                result=fail
        fi
fi

# Test 543.
if test $result = ok -a $start_test_number -le 543; then
	echo test 543: Invalid parameter
        cat >$test_file <<'TEST543'
sputf ([]);
TEST543
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST543-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST543-1
                result=ok
        else
                result=fail
        fi
fi

# Test 544.
if test $result = ok -a $start_test_number -le 544; then
	echo test 544: Invalid %%
        cat >$test_file <<'TEST544'
sputf ("%#%");
TEST544
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST544-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST544-1
                result=ok
        else
                result=fail
        fi
fi

# Test 545.
if test $result = ok -a $start_test_number -le 545; then
	echo test 545: Invalid %%
        cat >$test_file <<'TEST545'
sputf ("%0%");
TEST545
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST545-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST545-1
                result=ok
        else
                result=fail
        fi
fi

# Test 546.
if test $result = ok -a $start_test_number -le 546; then
	echo test 546: Invalid %%
        cat >$test_file <<'TEST546'
sputf ("%-%");
TEST546
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST546-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST546-1
                result=ok
        else
                result=fail
        fi
fi

# Test 547.
if test $result = ok -a $start_test_number -le 547; then
	echo test 547: Invalid %%
        cat >$test_file <<'TEST547'
sputf ("% %");
TEST547
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST547-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST547-1
                result=ok
        else
                result=fail
        fi
fi

# Test 548.
if test $result = ok -a $start_test_number -le 548; then
	echo test 548: Invalid %%
        cat >$test_file <<'TEST548'
sputf ("%+%");
TEST548
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST548-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST548-1
                result=ok
        else
                result=fail
        fi
fi

# Test 549.
if test $result = ok -a $start_test_number -le 549; then
	echo test 549: Unknown conversion
        cat >$test_file <<'TEST549'
sputf ("%w", 10);
TEST549
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST549-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST549-1
                result=ok
        else
                result=fail
        fi
fi

# Test 550.
if test $result = ok -a $start_test_number -le 550; then
	echo test 550: Too big width
        cat >$test_file <<'TEST550'
sputf ("%214748364s", "");
TEST550
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST550-1'; then
test.d:1:7: no memory
TEST550-1
                result=ok
        else
                result=fail
        fi
fi

# Test 551.
if test $result = ok -a $start_test_number -le 551; then
	echo test 551: Too big width
        cat >$test_file <<'TEST551'
sputf ("%2147483648s", "");
TEST551
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST551-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST551-1
                result=ok
        else
                result=fail
        fi
fi

# Test 552.
if test $result = ok -a $start_test_number -le 552; then
	echo test 552: Too big precision
        cat >$test_file <<'TEST552'
sputf ("%.2147483648s", "");
TEST552
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST552-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST552-1
                result=ok
        else
                result=fail
        fi
fi

# Test 553.
if test $result = ok -a $start_test_number -le 553; then
	echo test 553: Precision with %c
        cat >$test_file <<'TEST553'
sputf ("%.0c", 'z');
TEST553
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST553-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST553-1
                result=ok
        else
                result=fail
        fi
fi

# Test 553.
if test $result = ok -a $start_test_number -le 553; then
	echo test 553: Ackermann from Language Shootout
        cat >$test_file <<'TEST553'
func Ack (m, n) {
  if (m == 0) return n + 1;
  if (n == 0) return Ack (m - 1, 1);
  return Ack (m - 1, Ack (m, n - 1));
}

var N = int (#argv < 1 ? 1 : argv [0]);
putln ("Ack(3,", N ,"): ", Ack (3, N));

TEST553
        echo '      ' $DINO $test_file 9 "2>$stderr"
        if $DINO $test_file 9 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT553' && $CMP $stdout $ftemp2; then
Ack(3,9): 4093
OUTPUT553
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 554.
if test $result = ok -a $start_test_number -le 554; then
	echo test 554: Binary Trees from Language Shootout
        cat >$test_file <<'TEST554'
class node (item, left, right) {}

func BottomUpTree (item, depth) {
  if (depth <= 0) return item;
  var i = item + item;

  depth--;
  return node (item, BottomUpTree (i - 1, depth), BottomUpTree (i, depth));
}

func ItemCheck (tree) {
  return (type (tree) != class ()
	  ? tree : tree.item + ItemCheck (tree.left) - ItemCheck (tree.right));
}

var N = int (#argv < 1 ? 0 : argv [0]);
var mindepth = 4, maxdepth = max (N, mindepth + 2);
var stretchdepth = maxdepth + 1, stretchtree = BottomUpTree (0, stretchdepth);

putf ("stretch tree of depth %d\t  check: %d\n", stretchdepth,
      ItemCheck (stretchtree));

var i, depth, longlivedtree = BottomUpTree (0, maxdepth);

for (depth = mindepth; depth <= maxdepth; depth += 2) {
  var iterations = 1 << (maxdepth - depth + mindepth), check = 0;

  for (i = 0; i < iterations; i++)
    check += (ItemCheck (BottomUpTree (1, depth))
	      + ItemCheck (BottomUpTree (-1, depth)));
  putf ("%d\t  trees of depth %d\t  check: %d\n", iterations*2, depth, check);
}

putf ("long lived tree of depth %d\t  check: %d\n",
      maxdepth, ItemCheck (longlivedtree));
TEST554
        echo '      ' $DINO $test_file 12 "2>$stderr"
        if $DINO $test_file 12 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT554' && $CMP $stdout $ftemp2; then
stretch tree of depth 13	  check: -1
8192	  trees of depth 4	  check: -8192
2048	  trees of depth 6	  check: -2048
512	  trees of depth 8	  check: -512
128	  trees of depth 10	  check: -128
32	  trees of depth 12	  check: -32
long lived tree of depth 12	  check: -1
OUTPUT554
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 555.
if test $result = ok -a $start_test_number -le 555; then
	echo test 555: Chameneos from Language Shootout
        cat >$test_file <<'TEST555'
val blue = 0, red = 1, yellow = 2, faded = 3;
var colors = [blue, red, yellow, blue], N = int (#argv < 1 ? 10 : argv [0]);
var first = nil, second = nil;

// Create a very social creature.
class creature (my_color, creatures_met = 0) {
  thread be {
    for (;my_color != faded;) {
      var other;

      wait (second == nil); // Wait until meeting place clears.
      if (first != nil) { // Hey, I found a new friend!
	other = first; wait (1) {first = nil; second = my_color;}
      } else if (N > 0) { // Sniff, nobody here (yet).
	N--; first = my_color;
	wait (second != nil);
	other = second; wait (1) second = nil;
      } else other = faded; // meeting place is closed

      // change color
      if (other == faded) my_color = other;
      else {
	creatures_met++;
	if (my_color == other) ;
	else if (my_color == blue) my_color = (other == red ? yellow : red);
	else if (my_color == red) my_color = (other == blue ? yellow : blue);
	else if (my_color == yellow) my_color = (other == blue ? red : blue);
      }
    }
  }
}

var i, meetings = 0, creatures = [#colors : nil];

for (i = 0; i < #colors; i++) {
  creatures [i] = creature (colors [i]); creatures [i].be ();
}

for (i = 0; i < #colors; i++) {
  wait (creatures [i].my_color == faded);
  meetings += creatures [i].creatures_met;
}
putln (meetings);
TEST555
        echo '      ' $DINO $test_file 1000000 "2>$stderr"
        if $DINO $test_file 1000000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT555' && $CMP $stdout $ftemp2; then
2000000
OUTPUT555
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 556.
if test $result = ok -a $start_test_number -le 556; then
	echo test 556: Cheap Concurrency from Language Shootout
        cat >$test_file <<'TEST556'
var N = int (#argv < 1 ? 10 : argv [0]);
var cont_p = 1, i, t, first = nil, last = nil, count = 0;

class thread_node (next = nil, n = -1) {
  thread start {
    for (; cont_p;) {
      wait (n >= 0 || ! cont_p);
      if (next != nil) {next.n = n + 1; n = -1;}
    }
  }
}


for (i = 0; i < 500; i++) {
  t = thread_node (); t.start ();
  if (last == nil) {last = t; first = last;}
  else {last.next = t; last = last.next;}
}

for (i = 0; i < N; i++) {
  first.n = count; wait (last.n >= 0); count = last.n + 1; last.n = -1;
}
wait (1) cont_p = 0; putln (count);
TEST556
        echo '      ' $DINO $test_file 3000 "2>$stderr"
        if $DINO $test_file 3000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT556' && $CMP $stdout $ftemp2; then
1500000
OUTPUT556
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 557.
if test $result = ok -a $start_test_number -le 557; then
	echo test 557: Cheap Concurrency from Language Shootout
        cat >$test_file <<'TEST557'
var N = int (#argv < 1 ? 10 : argv [0]);
var cont_p = 1, i, t, first = nil, last = nil, count = 0;

class thread_node (next = nil, n = -1) {
  thread start {
    for (; cont_p;) {
      wait (n >= 0 || ! cont_p);
      if (next != nil) {next.n = n + 1; n = -1;}
    }
  }
}


for (i = 0; i < 500; i++) {
  t = thread_node (); t.start ();
  if (last == nil) {last = t; first = last;}
  else {last.next = t; last = last.next;}
}

for (i = 0; i < N; i++) {
  first.n = count; wait (last.n >= 0); count = last.n + 1; last.n = -1;
}
wait (1)cont_p = 0; putln (count);
TEST557
        echo '      ' $DINO $test_file 3000 "2>$stderr"
        if $DINO $test_file 3000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT557' && $CMP $stdout $ftemp2; then
1500000
OUTPUT557
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 558.
if test $result = ok -a $start_test_number -le 558; then
	echo test 558: Fasta from Language Shootout
        cat >$test_file <<'TEST558'
var IM = 139968, IA = 3877, IC = 29573, Last = 42;

func random (max) {
  Last = (Last * IA + IC) % IM;
  return (max * Last) / IM;
}

class freq (c, p) {}

// Weighted selection from alphabet

func makeCumulative (a) {
  var i, cp = 0, len = #a;

   for (i = 0; i < len; i++) {
     cp += a [i].p; a [i].p = cp;
   }
}

func selectRandom (a) {
  var i, len = #a, r = random (1.0);

  for (i = 0; i < len; i++)
    if (r < a[i].p) return a [i].c;
  return a [len - 1].c;
}

// Generate and write FASTA format

func makeRandomFasta (id, desc, a, n) {
  var i, m, length = 60;

  putln (">", id, " ", desc);
  for (;n > 0; n -= length) {
    m = (n < length ? n : length);
    for (i = 0; i < m; i++)
      put (selectRandom (a));
    putln ();
  }
}

func makeRepeatFasta (id, desc, s, n) {
  var i, m, todo = n, length = 60, k = 0, kn = #s;

  putln (">", id, " ", desc);
  for (; todo > 0;) {
    m = (todo < length ? todo : length);
    for (i = 0; i < m; i++) {
      if (k >= kn)
	k = 0;
      put (s [k]);
      k++;
    }
    putln ();
    todo -= length;
  }
}


// Main -- define alphabets, make 3 fragments

var alu =   "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG"
          @ "GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA"
          @ "CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT"
          @ "ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA"
          @ "GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG"
	  @ "AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC"
          @ "AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA";

var iub = [ freq ('a', 0.27), freq ('c', 0.12), freq ('g', 0.12),
	    freq ('t', 0.27), freq ('B', 0.02), freq ('D', 0.02),
	    freq ('H', 0.02), freq ('K', 0.02), freq ('M', 0.02),
	    freq ('N', 0.02), freq ('R', 0.02), freq ('S', 0.02),
	    freq ('V', 0.02), freq ('W', 0.02), freq ('Y', 0.02) ];
makeCumulative (iub);

var homosapiens = [ freq ('a', 0.3029549426680), freq ('c', 0.1979883004921),
		    freq ('g', 0.1975473066391), freq ('t', 0.3015094502008) ];
makeCumulative (homosapiens);

var N = int (#argv < 1 ? 1000 : argv [0]);
makeRepeatFasta ("ONE", "Homo sapiens alu", alu, N * 2);
makeRandomFasta ("TWO", "IUB ambiguity codes", iub, N * 3);
makeRandomFasta ("THREE", "Homo sapiens frequency", homosapiens, N * 5);
TEST558
        echo '      ' $DINO $test_file 1000 "2>$stderr"
        if $DINO $test_file 1000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT558' && $CMP $stdout $ftemp2; then
>ONE Homo sapiens alu
GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGA
TCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACT
AAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAG
GCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCG
CCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGT
GGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCA
GGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAA
TTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAG
AATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCA
GCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGT
AATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACC
AGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTG
GTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACC
CGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAG
AGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTT
TGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACA
TGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCT
GTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGG
TTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGT
CTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGG
CGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCG
TCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTA
CTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCG
AGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCG
GGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACC
TGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAA
TACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGA
GGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACT
GCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTC
ACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGT
TCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGC
CGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCG
CTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTG
GGCGACAGAGCGAGACTCCG
>TWO IUB ambiguity codes
cttBtatcatatgctaKggNcataaaSatgtaaaDcDRtBggDtctttataattcBgtcg
tactDtDagcctatttSVHtHttKtgtHMaSattgWaHKHttttagacatWatgtRgaaa
NtactMcSMtYtcMgRtacttctWBacgaaatatagScDtttgaagacacatagtVgYgt
cattHWtMMWcStgttaggKtSgaYaaccWStcgBttgcgaMttBYatcWtgacaYcaga
gtaBDtRacttttcWatMttDBcatWtatcttactaBgaYtcttgttttttttYaaScYa
HgtgttNtSatcMtcVaaaStccRcctDaataataStcYtRDSaMtDttgttSagtRRca
tttHatSttMtWgtcgtatSSagactYaaattcaMtWatttaSgYttaRgKaRtccactt
tattRggaMcDaWaWagttttgacatgttctacaaaRaatataataaMttcgDacgaSSt
acaStYRctVaNMtMgtaggcKatcttttattaaaaagVWaHKYagtttttatttaacct
tacgtVtcVaattVMBcttaMtttaStgacttagattWWacVtgWYagWVRctDattBYt
gtttaagaagattattgacVatMaacattVctgtBSgaVtgWWggaKHaatKWcBScSWa
accRVacacaaactaccScattRatatKVtactatatttHttaagtttSKtRtacaaagt
RDttcaaaaWgcacatWaDgtDKacgaacaattacaRNWaatHtttStgttattaaMtgt
tgDcgtMgcatBtgcttcgcgaDWgagctgcgaggggVtaaScNatttacttaatgacag
cccccacatYScaMgtaggtYaNgttctgaMaacNaMRaacaaacaKctacatagYWctg
ttWaaataaaataRattagHacacaagcgKatacBttRttaagtatttccgatctHSaat
actcNttMaagtattMtgRtgaMgcataatHcMtaBSaRattagttgatHtMttaaKagg
YtaaBataSaVatactWtataVWgKgttaaaacagtgcgRatatacatVtHRtVYataSa
KtWaStVcNKHKttactatccctcatgWHatWaRcttactaggatctataDtDHBttata
aaaHgtacVtagaYttYaKcctattcttcttaataNDaaggaaaDYgcggctaaWSctBa
aNtgctggMBaKctaMVKagBaactaWaDaMaccYVtNtaHtVWtKgRtcaaNtYaNacg
gtttNattgVtttctgtBaWgtaattcaagtcaVWtactNggattctttaYtaaagccgc
tcttagHVggaYtgtNcDaVagctctctKgacgtatagYcctRYHDtgBattDaaDgccK
tcHaaStttMcctagtattgcRgWBaVatHaaaataYtgtttagMDMRtaataaggatMt
ttctWgtNtgtgaaaaMaatatRtttMtDgHHtgtcattttcWattRSHcVagaagtacg
ggtaKVattKYagactNaatgtttgKMMgYNtcccgSKttctaStatatNVataYHgtNa
BKRgNacaactgatttcctttaNcgatttctctataScaHtataRagtcRVttacDSDtt
aRtSatacHgtSKacYagttMHtWataggatgactNtatSaNctataVtttRNKtgRacc
tttYtatgttactttttcctttaaacatacaHactMacacggtWataMtBVacRaSaatc
cgtaBVttccagccBcttaRKtgtgcctttttRtgtcagcRttKtaaacKtaaatctcac
aattgcaNtSBaaccgggttattaaBcKatDagttactcttcattVtttHaaggctKKga
tacatcBggScagtVcacattttgaHaDSgHatRMaHWggtatatRgccDttcgtatcga
aacaHtaagttaRatgaVacttagattVKtaaYttaaatcaNatccRttRRaMScNaaaD
gttVHWgtcHaaHgacVaWtgttScactaagSgttatcttagggDtaccagWattWtRtg
ttHWHacgattBtgVcaYatcggttgagKcWtKKcaVtgaYgWctgYggVctgtHgaNcV
taBtWaaYatcDRaaRtSctgaHaYRttagatMatgcatttNattaDttaattgttctaa
ccctcccctagaWBtttHtBccttagaVaatMcBHagaVcWcagBVttcBtaYMccagat
gaaaaHctctaacgttagNWRtcggattNatcRaNHttcagtKttttgWatWttcSaNgg
gaWtactKKMaacatKatacNattgctWtatctaVgagctatgtRaHtYcWcttagccaa
tYttWttaWSSttaHcaaaaagVacVgtaVaRMgattaVcDactttcHHggHRtgNcctt
tYatcatKgctcctctatVcaaaaKaaaagtatatctgMtWtaaaacaStttMtcgactt
taSatcgDataaactaaacaagtaaVctaggaSccaatMVtaaSKNVattttgHccatca
cBVctgcaVatVttRtactgtVcaattHgtaaattaaattttYtatattaaRSgYtgBag
aHSBDgtagcacRHtYcBgtcacttacactaYcgctWtattgSHtSatcataaatataHt
cgtYaaMNgBaatttaRgaMaatatttBtttaaaHHKaatctgatWatYaacttMctctt
ttVctagctDaaagtaVaKaKRtaacBgtatccaaccactHHaagaagaaggaNaaatBW
attccgStaMSaMatBttgcatgRSacgttVVtaaDMtcSgVatWcaSatcttttVatag
ttactttacgatcaccNtaDVgSRcgVcgtgaacgaNtaNatatagtHtMgtHcMtagaa
attBgtataRaaaacaYKgtRccYtatgaagtaataKgtaaMttgaaRVatgcagaKStc
tHNaaatctBBtcttaYaBWHgtVtgacagcaRcataWctcaBcYacYgatDgtDHccta
>THREE Homo sapiens frequency
aacacttcaccaggtatcgtgaaggctcaagattacccagagaacctttgcaatataaga
atatgtatgcagcattaccctaagtaattatattctttttctgactcaaagtgacaagcc
ctagtgtatattaaatcggtatatttgggaaattcctcaaactatcctaatcaggtagcc
atgaaagtgatcaaaaaagttcgtacttataccatacatgaattctggccaagtaaaaaa
tagattgcgcaaaattcgtaccttaagtctctcgccaagatattaggatcctattactca
tatcgtgtttttctttattgccgccatccccggagtatctcacccatccttctcttaaag
gcctaatattacctatgcaaataaacatatattgttgaaaattgagaacctgatcgtgat
tcttatgtgtaccatatgtatagtaatcacgcgactatatagtgctttagtatcgcccgt
gggtgagtgaatattctgggctagcgtgagatagtttcttgtcctaatatttttcagatc
gaatagcttctatttttgtgtttattgacatatgtcgaaactccttactcagtgaaagtc
atgaccagatccacgaacaatcttcggaatcagtctcgttttacggcggaatcttgagtc
taacttatatcccgtcgcttactttctaacaccccttatgtatttttaaaattacgttta
ttcgaacgtacttggcggaagcgttattttttgaagtaagttacattgggcagactcttg
acattttcgatacgactttctttcatccatcacaggactcgttcgtattgatatcagaag
ctcgtgatgattagttgtcttctttaccaatactttgaggcctattctgcgaaatttttg
ttgccctgcgaacttcacataccaaggaacacctcgcaacatgccttcatatccatcgtt
cattgtaattcttacacaatgaatcctaagtaattacatccctgcgtaaaagatggtagg
ggcactgaggatatattaccaagcatttagttatgagtaatcagcaatgtttcttgtatt
aagttctctaaaatagttacatcgtaatgttatctcgggttccgcgaataaacgagatag
attcattatatatggccctaagcaaaaacctcctcgtattctgttggtaattagaatcac
acaatacgggttgagatattaattatttgtagtacgaagagatataaaaagatgaacaat
tactcaagtcaagatgtatacgggatttataataaaaatcgggtagagatctgctttgca
attcagacgtgccactaaatcgtaatatgtcgcgttacatcagaaagggtaactattatt
aattaataaagggcttaatcactacatattagatcttatccgatagtcttatctattcgt
tgtatttttaagcggttctaattcagtcattatatcagtgctccgagttctttattattg
ttttaaggatgacaaaatgcctcttgttataacgctgggagaagcagactaagagtcgga
gcagttggtagaatgaggctgcaaaagacggtctcgacgaatggacagactttactaaac
caatgaaagacagaagtagagcaaagtctgaagtggtatcagcttaattatgacaaccct
taatacttccctttcgccgaatactggcgtggaaaggttttaaaagtcgaagtagttaga
ggcatctctcgctcataaataggtagactactcgcaatccaatgtgactatgtaatactg
ggaacatcagtccgcgatgcagcgtgtttatcaaccgtccccactcgcctggggagacat
gagaccacccccgtggggattattagtccgcagtaatcgactcttgacaatccttttcga
ttatgtcatagcaatttacgacagttcagcgaagtgactactcggcgaaatggtattact
aaagcattcgaacccacatgaatgtgattcttggcaatttctaatccactaaagcttttc
cgttgaatctggttgtagatatttatataagttcactaattaagatcacggtagtatatt
gatagtgatgtctttgcaagaggttggccgaggaatttacggattctctattgatacaat
ttgtctggcttataactcttaaggctgaaccaggcgtttttagacgacttgatcagctgt
tagaatggtttggactccctctttcatgtcagtaacatttcagccgttattgttacgata
tgcttgaacaatattgatctaccacacacccatagtatattttataggtcatgctgttac
ctacgagcatggtattccacttcccattcaatgagtattcaacatcactagcctcagaga
tgatgacccacctctaataacgtcacgttgcggccatgtgaaacctgaacttgagtagac
gatatcaagcgctttaaattgcatataacatttgagggtaaagctaagcggatgctttat
ataatcaatactcaataataagatttgattgcattttagagttatgacacgacatagttc
actaacgagttactattcccagatctagactgaagtactgatcgagacgatccttacgtc
gatgatcgttagttatcgacttaggtcgggtctctagcggtattggtacttaaccggaca
ctatactaataacccatgatcaaagcataacagaatacagacgataatttcgccaacata
tatgtacagaccccaagcatgagaagctcattgaaagctatcattgaagtcccgctcaca
atgtgtcttttccagacggtttaactggttcccgggagtcctggagtttcgacttacata
aatggaaacaatgtattttgctaatttatctatagcgtcatttggaccaatacagaatat
tatgttgcctagtaatccactataacccgcaagtgctgatagaaaatttttagacgattt
ataaatgccccaagtatccctcccgtgaatcctccgttatactaattagtattcgttcat
acgtataccgcgcatatatgaacatttggcgataaggcgcgtgaattgttacgtgacaga
gatagcagtttcttgtgatatggttaacagacgtacatgaagggaaactttatatctata
gtgatgcttccgtagaaataccgccactggtctgccaatgatgaagtatgtagctttagg
tttgtactatgaggctttcgtttgtttgcagagtataacagttgcgagtgaaaaaccgac
gaatttatactaatacgctttcactattggctacaaaatagggaagagtttcaatcatga
gagggagtatatggatgctttgtagctaaaggtagaacgtatgtatatgctgccgttcat
tcttgaaagatacataagcgataagttacgacaattataagcaacatccctaccttcgta
acgatttcactgttactgcgcttgaaatacactatggggctattggcggagagaagcaga
tcgcgccgagcatatacgagacctataatgttgatgatagagaaggcgtctgaattgata
catcgaagtacactttctttcgtagtatctctcgtcctctttctatctccggacacaaga
attaagttatatatatagagtcttaccaatcatgttgaatcctgattctcagagttcttt
ggcgggccttgtgatgactgagaaacaatgcaatattgctccaaatttcctaagcaaatt
ctcggttatgttatgttatcagcaaagcgttacgttatgttatttaaatctggaatgacg
gagcgaagttcttatgtcggtgtgggaataattcttttgaagacagcactccttaaataa
tatcgctccgtgtttgtatttatcgaatgggtctgtaaccttgcacaagcaaatcggtgg
tgtatatatcggataacaattaatacgatgttcatagtgacagtatactgatcgagtcct
ctaaagtcaattacctcacttaacaatctcattgatgttgtgtcattcccggtatcgccc
gtagtatgtgctctgattgaccgagtgtgaaccaaggaacatctactaatgcctttgtta
ggtaagatctctctgaattccttcgtgccaacttaaaacattatcaaaatttcttctact
tggattaactacttttacgagcatggcaaattcccctgtggaagacggttcattattatc
ggaaaccttatagaaattgcgtgttgactgaaattagatttttattgtaagagttgcatc
tttgcgattcctctggtctagcttccaatgaacagtcctcccttctattcgacatcgggt
ccttcgtacatgtctttgcgatgtaataattaggttcggagtgtggccttaatgggtgca
actaggaatacaacgcaaatttgctgacatgatagcaaatcggtatgccggcaccaaaac
gtgctccttgcttagcttgtgaatgagactcagtagttaaataaatccatatctgcaatc
gattccacaggtattgtccactatctttgaactactctaagagatacaagcttagctgag
accgaggtgtatatgactacgctgatatctgtaaggtaccaatgcaggcaaagtatgcga
gaagctaataccggctgtttccagctttataagattaaaatttggctgtcctggcggcct
cagaattgttctatcgtaatcagttggttcattaattagctaagtacgaggtacaactta
tctgtcccagaacagctccacaagtttttttacagccgaaacccctgtgtgaatcttaat
atccaagcgcgttatctgattagagtttacaactcagtattttatcagtacgttttgttt
ccaacattacccggtatgacaaaatgacgccacgtgtcgaataatggtctgaccaatgta
ggaagtgaaaagataaatat
OUTPUT558
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 559.
if test $result = ok -a $start_test_number -le 559; then
	echo test 559: Fannkuch from Language Shootout
        cat >$test_file <<'TEST559'
func fannkuch (n) {
   var perm, maxperm, perm1 = [n : 0], count = [n : 0];
   var i, k, t, flipscount, maxflipscount = 0, m = n - 1, r = n, check = 0;

   for (i = 0; i < n; i++) perm1 [i] = i;
   for (;;) {
      if (check < 30) {
         for (i = 0; i < n; i++) put (perm1 [i] + 1);
         putln (); check++;
      }

      for (; r != 1; r--) count [r - 1] = r;
      if (perm1 [0] != 0 && perm1 [m] != m) {
	perm = new perm1;
	for (flipscount = 0;; flipscount++) {
	  k = perm [0];
	  if (k == 0) break;
	  for (i = (k + 1) / 2 - 1; i >= 0 ; i--) {
            t = perm [i]; perm [i] = perm [k - i]; perm[k - i] = t;
          }
	}

	if (flipscount > maxflipscount) {
	  maxflipscount = flipscount; maxperm = new perm1;
	}
      }

      for (;;r++) {
         if (r == n) return maxflipscount;
         t = perm1 [0];
         for (i = 0; i < r; i++) perm1 [i] = perm1 [i + 1];
         perm1 [r] = t;
	 count [r]--;
         if (count [r] > 0) break;
      }
   }
}

var n = int (#argv < 1 ? 1 : argv [0]);
putln ("Pfannkuchen(", n, ") = ", fannkuch(n));
TEST559
        echo '      ' $DINO $test_file 9 "2>$stderr"
        if $DINO $test_file 9 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT559' && $CMP $stdout $ftemp2; then
123456789
213456789
231456789
321456789
312456789
132456789
234156789
324156789
342156789
432156789
423156789
243156789
341256789
431256789
413256789
143256789
134256789
314256789
412356789
142356789
124356789
214356789
241356789
421356789
234516789
324516789
342516789
432516789
423516789
243516789
Pfannkuchen(9) = 30
OUTPUT559
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 560.
if test $result = ok -a $start_test_number -le 560; then
	echo test 560: Harmonic from Language Shootout
        cat >$test_file <<'TEST560'
var d, partialSum = 0.0, n = int (#argv < 1 ? 10000000 : argv [0]);

for (d = 1; d <= n; d++) partialSum += 1.0 / d;
putf ("%0.9f\n", partialSum);
TEST560
        echo '      ' $DINO $test_file 10000000 "2>$stderr"
        if $DINO $test_file 10000000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT560' && $CMP $stdout $ftemp2; then
16.695311366
OUTPUT560
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 561.
if test $result = ok -a $start_test_number -le 561; then
	echo test 561: K-nucleotide from Language Shootout
        cat >$test_file <<'TEST561'
func kfrequency (seq, freq, k, frame) {
  var i, c, stop = #seq - k + 1;

  for (i = frame; i < stop; i += k) {
    c = subv (seq, i, k);
    if (c in freq) freq {c}++;
    else freq {c} = 1;
  }
}

func count (seq, frag) {
  var frame, k = #frag, freq = {};

  for (frame = 0; frame < k; frame++) kfrequency (seq, freq, k, frame);
  putln (frag in freq ? freq {frag} : 0, "\t", frag);
}

func frequency (seq, k) {
  var i, c, sum, frame, freq = {}, sfreq = [];
  func freq_cmp (el1, el2) {
    return freq {el2} - freq {el1};
  }

  for (frame = 0; frame < k; frame++) kfrequency (seq, freq, k, frame);
  for (c in freq) ins (sfreq, c, -1);
  sfreq = sort (sfreq, freq_cmp);
  sum = #seq - k + 1;
  for (i = 0; i < #sfreq; i++) {
    c = sfreq [i];
    putf ("%s %0.3f\n", c, (freq {c} * 100.) / sum);
  }
  putln ();
}

func readseq {
  var c, line, lines = [];

  try {
    for (;;) {
      line = getln ();
      if (line [0] == '>' && subv (line, 1, 5) == "THREE") break;
    }
    for (;;) {
      line = getln ();
      c = line [0];
      if (c == '>')
	break;
      else if (c != ';')
	insv (lines, toupper (line), -1);
    }
  } catch (invcalls.eof) {}
  return lines;
}

var seq = readseq ();
frequency (seq, 1);
frequency (seq, 2);
count (seq, "GGT");
count (seq, "GGTA");
count (seq, "GGTATT");
count (seq, "GGTATTTTAATT");
count (seq, "GGTATTTTAATTTATAGT");
TEST561
        echo '      ' $DINO $test_file 1000 "2>$stderr"
        if $DINO $test_file 1000 <<'INPUT561' 2>$stderr >$stdout; then
>ONE Homo sapiens alu
GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGA
TCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACT
AAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAG
GCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCG
CCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGT
GGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCA
GGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAA
TTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAG
AATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCA
GCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGT
AATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACC
AGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTG
GTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACC
CGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAG
AGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTT
TGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACA
TGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCT
GTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGG
TTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGT
CTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGG
CGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCG
TCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTA
CTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCG
AGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCG
GGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACC
TGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAA
TACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGA
GGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACT
GCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTC
ACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGT
TCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGC
CGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCG
CTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTG
GGCGACAGAGCGAGACTCCG
>TWO IUB ambiguity codes
cttBtatcatatgctaKggNcataaaSatgtaaaDcDRtBggDtctttataattcBgtcg
tactDtDagcctatttSVHtHttKtgtHMaSattgWaHKHttttagacatWatgtRgaaa
NtactMcSMtYtcMgRtacttctWBacgaaatatagScDtttgaagacacatagtVgYgt
cattHWtMMWcStgttaggKtSgaYaaccWStcgBttgcgaMttBYatcWtgacaYcaga
gtaBDtRacttttcWatMttDBcatWtatcttactaBgaYtcttgttttttttYaaScYa
HgtgttNtSatcMtcVaaaStccRcctDaataataStcYtRDSaMtDttgttSagtRRca
tttHatSttMtWgtcgtatSSagactYaaattcaMtWatttaSgYttaRgKaRtccactt
tattRggaMcDaWaWagttttgacatgttctacaaaRaatataataaMttcgDacgaSSt
acaStYRctVaNMtMgtaggcKatcttttattaaaaagVWaHKYagtttttatttaacct
tacgtVtcVaattVMBcttaMtttaStgacttagattWWacVtgWYagWVRctDattBYt
gtttaagaagattattgacVatMaacattVctgtBSgaVtgWWggaKHaatKWcBScSWa
accRVacacaaactaccScattRatatKVtactatatttHttaagtttSKtRtacaaagt
RDttcaaaaWgcacatWaDgtDKacgaacaattacaRNWaatHtttStgttattaaMtgt
tgDcgtMgcatBtgcttcgcgaDWgagctgcgaggggVtaaScNatttacttaatgacag
cccccacatYScaMgtaggtYaNgttctgaMaacNaMRaacaaacaKctacatagYWctg
ttWaaataaaataRattagHacacaagcgKatacBttRttaagtatttccgatctHSaat
actcNttMaagtattMtgRtgaMgcataatHcMtaBSaRattagttgatHtMttaaKagg
YtaaBataSaVatactWtataVWgKgttaaaacagtgcgRatatacatVtHRtVYataSa
KtWaStVcNKHKttactatccctcatgWHatWaRcttactaggatctataDtDHBttata
aaaHgtacVtagaYttYaKcctattcttcttaataNDaaggaaaDYgcggctaaWSctBa
aNtgctggMBaKctaMVKagBaactaWaDaMaccYVtNtaHtVWtKgRtcaaNtYaNacg
gtttNattgVtttctgtBaWgtaattcaagtcaVWtactNggattctttaYtaaagccgc
tcttagHVggaYtgtNcDaVagctctctKgacgtatagYcctRYHDtgBattDaaDgccK
tcHaaStttMcctagtattgcRgWBaVatHaaaataYtgtttagMDMRtaataaggatMt
ttctWgtNtgtgaaaaMaatatRtttMtDgHHtgtcattttcWattRSHcVagaagtacg
ggtaKVattKYagactNaatgtttgKMMgYNtcccgSKttctaStatatNVataYHgtNa
BKRgNacaactgatttcctttaNcgatttctctataScaHtataRagtcRVttacDSDtt
aRtSatacHgtSKacYagttMHtWataggatgactNtatSaNctataVtttRNKtgRacc
tttYtatgttactttttcctttaaacatacaHactMacacggtWataMtBVacRaSaatc
cgtaBVttccagccBcttaRKtgtgcctttttRtgtcagcRttKtaaacKtaaatctcac
aattgcaNtSBaaccgggttattaaBcKatDagttactcttcattVtttHaaggctKKga
tacatcBggScagtVcacattttgaHaDSgHatRMaHWggtatatRgccDttcgtatcga
aacaHtaagttaRatgaVacttagattVKtaaYttaaatcaNatccRttRRaMScNaaaD
gttVHWgtcHaaHgacVaWtgttScactaagSgttatcttagggDtaccagWattWtRtg
ttHWHacgattBtgVcaYatcggttgagKcWtKKcaVtgaYgWctgYggVctgtHgaNcV
taBtWaaYatcDRaaRtSctgaHaYRttagatMatgcatttNattaDttaattgttctaa
ccctcccctagaWBtttHtBccttagaVaatMcBHagaVcWcagBVttcBtaYMccagat
gaaaaHctctaacgttagNWRtcggattNatcRaNHttcagtKttttgWatWttcSaNgg
gaWtactKKMaacatKatacNattgctWtatctaVgagctatgtRaHtYcWcttagccaa
tYttWttaWSSttaHcaaaaagVacVgtaVaRMgattaVcDactttcHHggHRtgNcctt
tYatcatKgctcctctatVcaaaaKaaaagtatatctgMtWtaaaacaStttMtcgactt
taSatcgDataaactaaacaagtaaVctaggaSccaatMVtaaSKNVattttgHccatca
cBVctgcaVatVttRtactgtVcaattHgtaaattaaattttYtatattaaRSgYtgBag
aHSBDgtagcacRHtYcBgtcacttacactaYcgctWtattgSHtSatcataaatataHt
cgtYaaMNgBaatttaRgaMaatatttBtttaaaHHKaatctgatWatYaacttMctctt
ttVctagctDaaagtaVaKaKRtaacBgtatccaaccactHHaagaagaaggaNaaatBW
attccgStaMSaMatBttgcatgRSacgttVVtaaDMtcSgVatWcaSatcttttVatag
ttactttacgatcaccNtaDVgSRcgVcgtgaacgaNtaNatatagtHtMgtHcMtagaa
attBgtataRaaaacaYKgtRccYtatgaagtaataKgtaaMttgaaRVatgcagaKStc
tHNaaatctBBtcttaYaBWHgtVtgacagcaRcataWctcaBcYacYgatDgtDHccta
>THREE Homo sapiens frequency
aacacttcaccaggtatcgtgaaggctcaagattacccagagaacctttgcaatataaga
atatgtatgcagcattaccctaagtaattatattctttttctgactcaaagtgacaagcc
ctagtgtatattaaatcggtatatttgggaaattcctcaaactatcctaatcaggtagcc
atgaaagtgatcaaaaaagttcgtacttataccatacatgaattctggccaagtaaaaaa
tagattgcgcaaaattcgtaccttaagtctctcgccaagatattaggatcctattactca
tatcgtgtttttctttattgccgccatccccggagtatctcacccatccttctcttaaag
gcctaatattacctatgcaaataaacatatattgttgaaaattgagaacctgatcgtgat
tcttatgtgtaccatatgtatagtaatcacgcgactatatagtgctttagtatcgcccgt
gggtgagtgaatattctgggctagcgtgagatagtttcttgtcctaatatttttcagatc
gaatagcttctatttttgtgtttattgacatatgtcgaaactccttactcagtgaaagtc
atgaccagatccacgaacaatcttcggaatcagtctcgttttacggcggaatcttgagtc
taacttatatcccgtcgcttactttctaacaccccttatgtatttttaaaattacgttta
ttcgaacgtacttggcggaagcgttattttttgaagtaagttacattgggcagactcttg
acattttcgatacgactttctttcatccatcacaggactcgttcgtattgatatcagaag
ctcgtgatgattagttgtcttctttaccaatactttgaggcctattctgcgaaatttttg
ttgccctgcgaacttcacataccaaggaacacctcgcaacatgccttcatatccatcgtt
cattgtaattcttacacaatgaatcctaagtaattacatccctgcgtaaaagatggtagg
ggcactgaggatatattaccaagcatttagttatgagtaatcagcaatgtttcttgtatt
aagttctctaaaatagttacatcgtaatgttatctcgggttccgcgaataaacgagatag
attcattatatatggccctaagcaaaaacctcctcgtattctgttggtaattagaatcac
acaatacgggttgagatattaattatttgtagtacgaagagatataaaaagatgaacaat
tactcaagtcaagatgtatacgggatttataataaaaatcgggtagagatctgctttgca
attcagacgtgccactaaatcgtaatatgtcgcgttacatcagaaagggtaactattatt
aattaataaagggcttaatcactacatattagatcttatccgatagtcttatctattcgt
tgtatttttaagcggttctaattcagtcattatatcagtgctccgagttctttattattg
ttttaaggatgacaaaatgcctcttgttataacgctgggagaagcagactaagagtcgga
gcagttggtagaatgaggctgcaaaagacggtctcgacgaatggacagactttactaaac
caatgaaagacagaagtagagcaaagtctgaagtggtatcagcttaattatgacaaccct
taatacttccctttcgccgaatactggcgtggaaaggttttaaaagtcgaagtagttaga
ggcatctctcgctcataaataggtagactactcgcaatccaatgtgactatgtaatactg
ggaacatcagtccgcgatgcagcgtgtttatcaaccgtccccactcgcctggggagacat
gagaccacccccgtggggattattagtccgcagtaatcgactcttgacaatccttttcga
ttatgtcatagcaatttacgacagttcagcgaagtgactactcggcgaaatggtattact
aaagcattcgaacccacatgaatgtgattcttggcaatttctaatccactaaagcttttc
cgttgaatctggttgtagatatttatataagttcactaattaagatcacggtagtatatt
gatagtgatgtctttgcaagaggttggccgaggaatttacggattctctattgatacaat
ttgtctggcttataactcttaaggctgaaccaggcgtttttagacgacttgatcagctgt
tagaatggtttggactccctctttcatgtcagtaacatttcagccgttattgttacgata
tgcttgaacaatattgatctaccacacacccatagtatattttataggtcatgctgttac
ctacgagcatggtattccacttcccattcaatgagtattcaacatcactagcctcagaga
tgatgacccacctctaataacgtcacgttgcggccatgtgaaacctgaacttgagtagac
gatatcaagcgctttaaattgcatataacatttgagggtaaagctaagcggatgctttat
ataatcaatactcaataataagatttgattgcattttagagttatgacacgacatagttc
actaacgagttactattcccagatctagactgaagtactgatcgagacgatccttacgtc
gatgatcgttagttatcgacttaggtcgggtctctagcggtattggtacttaaccggaca
ctatactaataacccatgatcaaagcataacagaatacagacgataatttcgccaacata
tatgtacagaccccaagcatgagaagctcattgaaagctatcattgaagtcccgctcaca
atgtgtcttttccagacggtttaactggttcccgggagtcctggagtttcgacttacata
aatggaaacaatgtattttgctaatttatctatagcgtcatttggaccaatacagaatat
tatgttgcctagtaatccactataacccgcaagtgctgatagaaaatttttagacgattt
ataaatgccccaagtatccctcccgtgaatcctccgttatactaattagtattcgttcat
acgtataccgcgcatatatgaacatttggcgataaggcgcgtgaattgttacgtgacaga
gatagcagtttcttgtgatatggttaacagacgtacatgaagggaaactttatatctata
gtgatgcttccgtagaaataccgccactggtctgccaatgatgaagtatgtagctttagg
tttgtactatgaggctttcgtttgtttgcagagtataacagttgcgagtgaaaaaccgac
gaatttatactaatacgctttcactattggctacaaaatagggaagagtttcaatcatga
gagggagtatatggatgctttgtagctaaaggtagaacgtatgtatatgctgccgttcat
tcttgaaagatacataagcgataagttacgacaattataagcaacatccctaccttcgta
acgatttcactgttactgcgcttgaaatacactatggggctattggcggagagaagcaga
tcgcgccgagcatatacgagacctataatgttgatgatagagaaggcgtctgaattgata
catcgaagtacactttctttcgtagtatctctcgtcctctttctatctccggacacaaga
attaagttatatatatagagtcttaccaatcatgttgaatcctgattctcagagttcttt
ggcgggccttgtgatgactgagaaacaatgcaatattgctccaaatttcctaagcaaatt
ctcggttatgttatgttatcagcaaagcgttacgttatgttatttaaatctggaatgacg
gagcgaagttcttatgtcggtgtgggaataattcttttgaagacagcactccttaaataa
tatcgctccgtgtttgtatttatcgaatgggtctgtaaccttgcacaagcaaatcggtgg
tgtatatatcggataacaattaatacgatgttcatagtgacagtatactgatcgagtcct
ctaaagtcaattacctcacttaacaatctcattgatgttgtgtcattcccggtatcgccc
gtagtatgtgctctgattgaccgagtgtgaaccaaggaacatctactaatgcctttgtta
ggtaagatctctctgaattccttcgtgccaacttaaaacattatcaaaatttcttctact
tggattaactacttttacgagcatggcaaattcccctgtggaagacggttcattattatc
ggaaaccttatagaaattgcgtgttgactgaaattagatttttattgtaagagttgcatc
tttgcgattcctctggtctagcttccaatgaacagtcctcccttctattcgacatcgggt
ccttcgtacatgtctttgcgatgtaataattaggttcggagtgtggccttaatgggtgca
actaggaatacaacgcaaatttgctgacatgatagcaaatcggtatgccggcaccaaaac
gtgctccttgcttagcttgtgaatgagactcagtagttaaataaatccatatctgcaatc
gattccacaggtattgtccactatctttgaactactctaagagatacaagcttagctgag
accgaggtgtatatgactacgctgatatctgtaaggtaccaatgcaggcaaagtatgcga
gaagctaataccggctgtttccagctttataagattaaaatttggctgtcctggcggcct
cagaattgttctatcgtaatcagttggttcattaattagctaagtacgaggtacaactta
tctgtcccagaacagctccacaagtttttttacagccgaaacccctgtgtgaatcttaat
atccaagcgcgttatctgattagagtttacaactcagtattttatcagtacgttttgttt
ccaacattacccggtatgacaaaatgacgccacgtgtcgaataatggtctgaccaatgta
ggaagtgaaaagataaatat
INPUT561
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT561' && $CMP $stdout $ftemp2; then
T 31.520
A 29.600
C 19.480
G 19.400

AT 9.922
TT 9.602
TA 9.402
AA 8.402
GA 6.321
TC 6.301
TG 6.201
GT 6.041
CT 5.961
AG 5.841
CA 5.461
AC 5.441
CC 4.041
CG 4.021
GC 3.701
GG 3.341

54	GGT
24	GGTA
4	GGTATT
0	GGTATTTTAATT
0	GGTATTTTAATTTATAGT
OUTPUT561
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 562.
if test $result = ok -a $start_test_number -le 562; then
	echo test 562: Fasta from Language Shootout
        cat >$test_file <<'TEST562'
var PI = 3.141592653589793;
var SOLAR_MASS = 4 * PI * PI;
var DAYS_PER_YEAR = 365.24;

class body (x, y, z, vx, vy, vz, mass) {}

var Jupiter = body (4.84143144246472090e+00,
		    -1.16032004402742839e+00,
	            -1.03622044471123109e-01,
		    1.66007664274403694e-03 * DAYS_PER_YEAR,
		    7.69901118419740425e-03 * DAYS_PER_YEAR,
		    -6.90460016972063023e-05 * DAYS_PER_YEAR,
		    9.54791938424326609e-04 * SOLAR_MASS);

var Saturn = body (8.34336671824457987e+00,
		   4.12479856412430479e+00,
		   -4.03523417114321381e-01,
		   -2.76742510726862411e-03 * DAYS_PER_YEAR,
		   4.99852801234917238e-03 * DAYS_PER_YEAR,
		   2.30417297573763929e-05 * DAYS_PER_YEAR,
		   2.85885980666130812e-04 * SOLAR_MASS);

var Uranus = body (1.28943695621391310e+01,
		   -1.51111514016986312e+01,
		   -2.23307578892655734e-01,
		   2.96460137564761618e-03 * DAYS_PER_YEAR,
		   2.37847173959480950e-03 * DAYS_PER_YEAR,
		   -2.96589568540237556e-05 * DAYS_PER_YEAR,
		   4.36624404335156298e-05 * SOLAR_MASS);

var Neptune = body (1.53796971148509165e+01,
		    -2.59193146099879641e+01,
		    1.79258772950371181e-01,
		    2.68067772490389322e-03 * DAYS_PER_YEAR,
		    1.62824170038242295e-03 * DAYS_PER_YEAR,
		    -9.51592254519715870e-05 * DAYS_PER_YEAR,
		    5.15138902046611451e-05 * SOLAR_MASS);

var Sun = body (0., 0., 0., 0., 0., 0., SOLAR_MASS);

func advance (bodies, dt) {
  var i, j;

  for (i = 0; i < #bodies; i++) {
    var bi = bodies [i];
    var bix = bi.x, biy = bi.y, biz = bi.z, bimass = bi.mass;
    var bivx = bi.vx, bivy = bi.vy, bivz = bi.vz;

    for (j = i + 1; j < #bodies; j++) {
      var bj = bodies [j];
      var dx = bix - bj.x, dy = biy - bj.y, dz = biz - bj.z;
      var distance = sqrt (dx * dx + dy * dy + dz * dz);
      var mag = dt / (distance * distance * distance);
      var bim = bimass * mag, bjm = bj.mass * mag;
      
      bivx -= dx * bjm; bivy -= dy * bjm; bivz -= dz * bjm;
      bj.vx += dx * bim; bj.vy += dy * bim; bj.vz += dz * bim;
    }
    bi.vx = bivx; bi.vy = bivy; bi.vz = bivz;
  }
  for (i = 0; i < #bodies; i++) {
    var bi = bodies[i];

    bi.x += dt * bi.vx; bi.y += dt * bi.vy; bi.z += dt * bi.vz;
  }
}

func energy (bodies) {
  var i, j, e = 0.;

  for (i = 0; i < #bodies; i++) {
    var bi = bodies [i];
    var vx = bi.vx, vy = bi.vy, vz = bi.vz, bim = bi.mass;

    e = e + (0.5 * bim * (vx * vx + vy * vy + vz * vz));
    for (j = i + 1; j < #bodies; j++) {
      var bj = bodies [j];
      var dx = bi.x - bj.x, dy = bi.y - bj.y, dz = bi.z - bj.z;
      var distance = sqrt (dx * dx + dy * dy + dz * dz);

      e = e - ((bim * bj.mass) / distance);
    }
  }
  return e;
}

func offsetMomentum (b) {
  var i, px = 0., py = 0., pz = 0.;

  for (i = 0; i < #b; i++) {
    var bi = b [i];
    var bim = bi.mass;

    px = px + (bi.vx * bim);
    py = py + (bi.vy * bim);
    pz = pz + (bi.vz * bim);
  }
  b [0].vx = -px / SOLAR_MASS;
  b [0].vy = -py / SOLAR_MASS;
  b [0].vz = -pz / SOLAR_MASS;
}

var i, N = int (#argv < 1 ? 1000 : argv [0]);
var bodies = [Sun, Jupiter, Saturn, Uranus, Neptune];

offsetMomentum (bodies);
putf ("%0.9f\n", energy (bodies));
for (i = 0; i < N; i++) {advance (bodies, 0.01);}
putf ("%0.9f\n", energy (bodies));
TEST562
        echo '      ' $DINO $test_file 100000 "2>$stderr"
        if $DINO $test_file 100000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT562' && $CMP $stdout $ftemp2; then
-0.169075164
-0.169079859
OUTPUT562
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 563.
if test $result = ok -a $start_test_number -le 563; then
	echo test 563: Nsieve from Language Shootout
        cat >$test_file <<'TEST563'
func nsieve (m) {
  var i, k, flags = [m + 1 : 1], count = 0;
  
  for (i = 2; i <= m; i++)
    if (flags [i]) {
      for (k = i + i; k <= m; k += i)
	flags [k] = 0;
      count++;
    }
  return count;
}

var i, m, n = max (2, int (#argv < 1 ? 1 : argv [0]));

for (i = 0; i <= 2; i++) {
  m = (1 << (n - i)) * 10000; putf ("Primes up to %8d %8d\n", m, nsieve (m));
}
TEST563
        echo '      ' $DINO $test_file 8 "2>$stderr"
        if $DINO $test_file 8 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT563' && $CMP $stdout $ftemp2; then
Primes up to  2560000   187134
Primes up to  1280000    98610
Primes up to   640000    52074
OUTPUT563
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 564.
if test $result = ok -a $start_test_number -le 564; then
	echo test 564: Nsieve Bits from Language Shootout
        cat >$test_file <<'TEST564'
var power = 5, precision = 1 << power, mask = precision - 1;

func nsieve (m) {
  var i, k, cm = (m + precision) / precision, flags = [cm : ~0], count = 0;
  
  for (i = 2; i <= m; i++)
    if (flags [i >> power] & (1 << (i & mask))) {
      for (k = i + i; k <= m; k += i)
	flags [k >> power] &= ~(1 << (k & mask));
      count++;
    }
  return count;
}


var i, m, N = max (2, int (#argv < 1 ? 1 : argv [0]));

for (i = 0; i <= 2; i++) {
  m = (1 << (N - i)) * 10000;
  putf ("Primes up to %8d %8d\n", m, nsieve (m));
}
TEST564
        echo '      ' $DINO $test_file 8 "2>$stderr"
        if $DINO $test_file 8 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT564' && $CMP $stdout $ftemp2; then
Primes up to  2560000   187134
Primes up to  1280000    98610
Primes up to   640000    52074
OUTPUT564
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 565.
if test $result = ok -a $start_test_number -le 565; then
	echo test 565: Pidigits from Language Shootout
        cat >$test_file <<'TEST565'
include "gmp";

var k = 0, z = [mpzs.mpz (1), mpzs.mpz (0), mpzs.mpz (0), mpzs.mpz (1)];

func extract_digit; func compose; func next_lft;

func next_digit {
  var y;

  for (;;) {
    y = extract_digit (3);
    if (y == extract_digit (4)) {
      z = compose ([mpzs.mpz (10), mpzs.mpz (-10 * y),
		    mpzs.mpz (0), mpzs.mpz (1)], z);
      return y;
    }
    z = compose (z, next_lft ());
  }
}

func next_lft {
  k++;
  return [mpzs.mpz (k), mpzs.mpz (4 * k + 2),
	  mpzs.mpz (0), mpzs.mpz (2 * k + 1)];
}

func extract_digit (x) {
  var xx = mpzs.mpz (x);

  return mpzs.get_i (mpzs.div (mpzs.add (mpzs.mul (z [0], xx), z [1]),
			       mpzs.add (mpzs.mul (z [2], xx), z [3])));
}

func compose (z, w) {
  return [mpzs.add (mpzs.mul (z [0], w [0]), mpzs.mul (z [1], w [2])),
	  mpzs.add (mpzs.mul (z [0], w [1]), mpzs.mul (z [1], w [3])),
	  mpzs.add (mpzs.mul (z [2], w [0]), mpzs.mul (z [3], w [2])),
	  mpzs.add (mpzs.mul (z [2], w [1]), mpzs.mul (z [3], w [3]))];
}

// main loop

var i, j, n = int (argv [0]);

for(i = 1; i <= n; i++) {
  put (next_digit());
  if (i % 10 == 0) putln ("\t:", i);
}

if (n % 10 != 0) {
  for (j = n % 10; j <= 10; j++) put (" ");
  putln ("\t:", n);
}
TEST565
        echo '      ' $DINO -L./d_gmp.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 1000 "2>$stderr"
        if $DINO -L./d_gmp.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 1000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT565' && $CMP $stdout $ftemp2; then
3141592653	:10
5897932384	:20
6264338327	:30
9502884197	:40
1693993751	:50
0582097494	:60
4592307816	:70
4062862089	:80
9862803482	:90
5342117067	:100
9821480865	:110
1328230664	:120
7093844609	:130
5505822317	:140
2535940812	:150
8481117450	:160
2841027019	:170
3852110555	:180
9644622948	:190
9549303819	:200
6442881097	:210
5665933446	:220
1284756482	:230
3378678316	:240
5271201909	:250
1456485669	:260
2346034861	:270
0454326648	:280
2133936072	:290
6024914127	:300
3724587006	:310
6063155881	:320
7488152092	:330
0962829254	:340
0917153643	:350
6789259036	:360
0011330530	:370
5488204665	:380
2138414695	:390
1941511609	:400
4330572703	:410
6575959195	:420
3092186117	:430
3819326117	:440
9310511854	:450
8074462379	:460
9627495673	:470
5188575272	:480
4891227938	:490
1830119491	:500
2983367336	:510
2440656643	:520
0860213949	:530
4639522473	:540
7190702179	:550
8609437027	:560
7053921717	:570
6293176752	:580
3846748184	:590
6766940513	:600
2000568127	:610
1452635608	:620
2778577134	:630
2757789609	:640
1736371787	:650
2146844090	:660
1224953430	:670
1465495853	:680
7105079227	:690
9689258923	:700
5420199561	:710
1212902196	:720
0864034418	:730
1598136297	:740
7477130996	:750
0518707211	:760
3499999983	:770
7297804995	:780
1059731732	:790
8160963185	:800
9502445945	:810
5346908302	:820
6425223082	:830
5334468503	:840
5261931188	:850
1710100031	:860
3783875288	:870
6587533208	:880
3814206171	:890
7766914730	:900
3598253490	:910
4287554687	:920
3115956286	:930
3882353787	:940
5937519577	:950
8185778053	:960
2171226806	:970
6130019278	:980
7661119590	:990
9216420198	:1000
OUTPUT565
                        result=ok
                else
                        result=fail
                fi
       elif fgrep 'run time error - can not find external function' $stderr >/dev/null;then
		echo GMP package is absent -- skip
                result=ok
        else
                result=fail
        fi
fi

# Test 567.
if test $result = ok -a $start_test_number -le 566; then
	echo test 566: Random from Language Shootout
        cat >$test_file <<'TEST567'
var c, i, vec, seq = getf (), ilen = #seq;

seq = gsub (">[^\n]+\n|\n", seq, "");

var clen = #seq;
var variants = ["agggtaaa|tttaccct", "[cgt]gggtaaa|tttaccc[acg]",
		"a[act]ggtaaa|tttacc[agt]t", "ag[act]gtaaa|tttac[agt]ct",
		"agg[act]taaa|ttta[agt]cct", "aggg[acg]aaa|ttt[cgt]ccct",
		"agggt[cgt]aa|tt[acg]accct", "agggta[cgt]a|t[acg]taccct",
		"agggtaa[cgt]|[acg]ttaccct"];

for (i = 0; i < #variants; i++) {
  vec = gmatch (variants [i], seq);
  putln (variants [i], " ", vec == nil ? 0 : #vec / 2);
}

var subst = {
  "B" : "(c|g|t)", "D" : "(a|g|t)", "H" : "(a|c|t)", "K" : "(g|t)",
  "M" : "(a|c)", "N" : "(a|c|g|t)", "R" : "(a|g)", "S" : "(c|g)",
  "V" : "(a|c|g)", "W" : "(a|t)", "Y" : "(c|t)"
};

for (c in subst)
  seq = gsub (c, seq, subst {c});

putln ("\n", ilen, "\n", clen, "\n", #seq);
TEST567
        echo '      ' $DINO $test_file 1000 "2>$stderr"
        if $DINO $test_file 1000 <<'INPUT567' 2>$stderr >$stdout; then
>ONE Homo sapiens alu
GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGA
TCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACT
AAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAG
GCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCG
CCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGT
GGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCA
GGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAA
TTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAG
AATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCA
GCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGT
AATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACC
AGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTG
GTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACC
CGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAG
AGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTT
TGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACA
TGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCT
GTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGG
TTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGT
CTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGG
CGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCG
TCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTA
CTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCG
AGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCG
GGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACC
TGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAA
TACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGA
GGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACT
GCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTC
ACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGT
TCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGC
CGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCG
CTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTG
GGCGACAGAGCGAGACTCCG
>TWO IUB ambiguity codes
cttBtatcatatgctaKggNcataaaSatgtaaaDcDRtBggDtctttataattcBgtcg
tactDtDagcctatttSVHtHttKtgtHMaSattgWaHKHttttagacatWatgtRgaaa
NtactMcSMtYtcMgRtacttctWBacgaaatatagScDtttgaagacacatagtVgYgt
cattHWtMMWcStgttaggKtSgaYaaccWStcgBttgcgaMttBYatcWtgacaYcaga
gtaBDtRacttttcWatMttDBcatWtatcttactaBgaYtcttgttttttttYaaScYa
HgtgttNtSatcMtcVaaaStccRcctDaataataStcYtRDSaMtDttgttSagtRRca
tttHatSttMtWgtcgtatSSagactYaaattcaMtWatttaSgYttaRgKaRtccactt
tattRggaMcDaWaWagttttgacatgttctacaaaRaatataataaMttcgDacgaSSt
acaStYRctVaNMtMgtaggcKatcttttattaaaaagVWaHKYagtttttatttaacct
tacgtVtcVaattVMBcttaMtttaStgacttagattWWacVtgWYagWVRctDattBYt
gtttaagaagattattgacVatMaacattVctgtBSgaVtgWWggaKHaatKWcBScSWa
accRVacacaaactaccScattRatatKVtactatatttHttaagtttSKtRtacaaagt
RDttcaaaaWgcacatWaDgtDKacgaacaattacaRNWaatHtttStgttattaaMtgt
tgDcgtMgcatBtgcttcgcgaDWgagctgcgaggggVtaaScNatttacttaatgacag
cccccacatYScaMgtaggtYaNgttctgaMaacNaMRaacaaacaKctacatagYWctg
ttWaaataaaataRattagHacacaagcgKatacBttRttaagtatttccgatctHSaat
actcNttMaagtattMtgRtgaMgcataatHcMtaBSaRattagttgatHtMttaaKagg
YtaaBataSaVatactWtataVWgKgttaaaacagtgcgRatatacatVtHRtVYataSa
KtWaStVcNKHKttactatccctcatgWHatWaRcttactaggatctataDtDHBttata
aaaHgtacVtagaYttYaKcctattcttcttaataNDaaggaaaDYgcggctaaWSctBa
aNtgctggMBaKctaMVKagBaactaWaDaMaccYVtNtaHtVWtKgRtcaaNtYaNacg
gtttNattgVtttctgtBaWgtaattcaagtcaVWtactNggattctttaYtaaagccgc
tcttagHVggaYtgtNcDaVagctctctKgacgtatagYcctRYHDtgBattDaaDgccK
tcHaaStttMcctagtattgcRgWBaVatHaaaataYtgtttagMDMRtaataaggatMt
ttctWgtNtgtgaaaaMaatatRtttMtDgHHtgtcattttcWattRSHcVagaagtacg
ggtaKVattKYagactNaatgtttgKMMgYNtcccgSKttctaStatatNVataYHgtNa
BKRgNacaactgatttcctttaNcgatttctctataScaHtataRagtcRVttacDSDtt
aRtSatacHgtSKacYagttMHtWataggatgactNtatSaNctataVtttRNKtgRacc
tttYtatgttactttttcctttaaacatacaHactMacacggtWataMtBVacRaSaatc
cgtaBVttccagccBcttaRKtgtgcctttttRtgtcagcRttKtaaacKtaaatctcac
aattgcaNtSBaaccgggttattaaBcKatDagttactcttcattVtttHaaggctKKga
tacatcBggScagtVcacattttgaHaDSgHatRMaHWggtatatRgccDttcgtatcga
aacaHtaagttaRatgaVacttagattVKtaaYttaaatcaNatccRttRRaMScNaaaD
gttVHWgtcHaaHgacVaWtgttScactaagSgttatcttagggDtaccagWattWtRtg
ttHWHacgattBtgVcaYatcggttgagKcWtKKcaVtgaYgWctgYggVctgtHgaNcV
taBtWaaYatcDRaaRtSctgaHaYRttagatMatgcatttNattaDttaattgttctaa
ccctcccctagaWBtttHtBccttagaVaatMcBHagaVcWcagBVttcBtaYMccagat
gaaaaHctctaacgttagNWRtcggattNatcRaNHttcagtKttttgWatWttcSaNgg
gaWtactKKMaacatKatacNattgctWtatctaVgagctatgtRaHtYcWcttagccaa
tYttWttaWSSttaHcaaaaagVacVgtaVaRMgattaVcDactttcHHggHRtgNcctt
tYatcatKgctcctctatVcaaaaKaaaagtatatctgMtWtaaaacaStttMtcgactt
taSatcgDataaactaaacaagtaaVctaggaSccaatMVtaaSKNVattttgHccatca
cBVctgcaVatVttRtactgtVcaattHgtaaattaaattttYtatattaaRSgYtgBag
aHSBDgtagcacRHtYcBgtcacttacactaYcgctWtattgSHtSatcataaatataHt
cgtYaaMNgBaatttaRgaMaatatttBtttaaaHHKaatctgatWatYaacttMctctt
ttVctagctDaaagtaVaKaKRtaacBgtatccaaccactHHaagaagaaggaNaaatBW
attccgStaMSaMatBttgcatgRSacgttVVtaaDMtcSgVatWcaSatcttttVatag
ttactttacgatcaccNtaDVgSRcgVcgtgaacgaNtaNatatagtHtMgtHcMtagaa
attBgtataRaaaacaYKgtRccYtatgaagtaataKgtaaMttgaaRVatgcagaKStc
tHNaaatctBBtcttaYaBWHgtVtgacagcaRcataWctcaBcYacYgatDgtDHccta
>THREE Homo sapiens frequency
aacacttcaccaggtatcgtgaaggctcaagattacccagagaacctttgcaatataaga
atatgtatgcagcattaccctaagtaattatattctttttctgactcaaagtgacaagcc
ctagtgtatattaaatcggtatatttgggaaattcctcaaactatcctaatcaggtagcc
atgaaagtgatcaaaaaagttcgtacttataccatacatgaattctggccaagtaaaaaa
tagattgcgcaaaattcgtaccttaagtctctcgccaagatattaggatcctattactca
tatcgtgtttttctttattgccgccatccccggagtatctcacccatccttctcttaaag
gcctaatattacctatgcaaataaacatatattgttgaaaattgagaacctgatcgtgat
tcttatgtgtaccatatgtatagtaatcacgcgactatatagtgctttagtatcgcccgt
gggtgagtgaatattctgggctagcgtgagatagtttcttgtcctaatatttttcagatc
gaatagcttctatttttgtgtttattgacatatgtcgaaactccttactcagtgaaagtc
atgaccagatccacgaacaatcttcggaatcagtctcgttttacggcggaatcttgagtc
taacttatatcccgtcgcttactttctaacaccccttatgtatttttaaaattacgttta
ttcgaacgtacttggcggaagcgttattttttgaagtaagttacattgggcagactcttg
acattttcgatacgactttctttcatccatcacaggactcgttcgtattgatatcagaag
ctcgtgatgattagttgtcttctttaccaatactttgaggcctattctgcgaaatttttg
ttgccctgcgaacttcacataccaaggaacacctcgcaacatgccttcatatccatcgtt
cattgtaattcttacacaatgaatcctaagtaattacatccctgcgtaaaagatggtagg
ggcactgaggatatattaccaagcatttagttatgagtaatcagcaatgtttcttgtatt
aagttctctaaaatagttacatcgtaatgttatctcgggttccgcgaataaacgagatag
attcattatatatggccctaagcaaaaacctcctcgtattctgttggtaattagaatcac
acaatacgggttgagatattaattatttgtagtacgaagagatataaaaagatgaacaat
tactcaagtcaagatgtatacgggatttataataaaaatcgggtagagatctgctttgca
attcagacgtgccactaaatcgtaatatgtcgcgttacatcagaaagggtaactattatt
aattaataaagggcttaatcactacatattagatcttatccgatagtcttatctattcgt
tgtatttttaagcggttctaattcagtcattatatcagtgctccgagttctttattattg
ttttaaggatgacaaaatgcctcttgttataacgctgggagaagcagactaagagtcgga
gcagttggtagaatgaggctgcaaaagacggtctcgacgaatggacagactttactaaac
caatgaaagacagaagtagagcaaagtctgaagtggtatcagcttaattatgacaaccct
taatacttccctttcgccgaatactggcgtggaaaggttttaaaagtcgaagtagttaga
ggcatctctcgctcataaataggtagactactcgcaatccaatgtgactatgtaatactg
ggaacatcagtccgcgatgcagcgtgtttatcaaccgtccccactcgcctggggagacat
gagaccacccccgtggggattattagtccgcagtaatcgactcttgacaatccttttcga
ttatgtcatagcaatttacgacagttcagcgaagtgactactcggcgaaatggtattact
aaagcattcgaacccacatgaatgtgattcttggcaatttctaatccactaaagcttttc
cgttgaatctggttgtagatatttatataagttcactaattaagatcacggtagtatatt
gatagtgatgtctttgcaagaggttggccgaggaatttacggattctctattgatacaat
ttgtctggcttataactcttaaggctgaaccaggcgtttttagacgacttgatcagctgt
tagaatggtttggactccctctttcatgtcagtaacatttcagccgttattgttacgata
tgcttgaacaatattgatctaccacacacccatagtatattttataggtcatgctgttac
ctacgagcatggtattccacttcccattcaatgagtattcaacatcactagcctcagaga
tgatgacccacctctaataacgtcacgttgcggccatgtgaaacctgaacttgagtagac
gatatcaagcgctttaaattgcatataacatttgagggtaaagctaagcggatgctttat
ataatcaatactcaataataagatttgattgcattttagagttatgacacgacatagttc
actaacgagttactattcccagatctagactgaagtactgatcgagacgatccttacgtc
gatgatcgttagttatcgacttaggtcgggtctctagcggtattggtacttaaccggaca
ctatactaataacccatgatcaaagcataacagaatacagacgataatttcgccaacata
tatgtacagaccccaagcatgagaagctcattgaaagctatcattgaagtcccgctcaca
atgtgtcttttccagacggtttaactggttcccgggagtcctggagtttcgacttacata
aatggaaacaatgtattttgctaatttatctatagcgtcatttggaccaatacagaatat
tatgttgcctagtaatccactataacccgcaagtgctgatagaaaatttttagacgattt
ataaatgccccaagtatccctcccgtgaatcctccgttatactaattagtattcgttcat
acgtataccgcgcatatatgaacatttggcgataaggcgcgtgaattgttacgtgacaga
gatagcagtttcttgtgatatggttaacagacgtacatgaagggaaactttatatctata
gtgatgcttccgtagaaataccgccactggtctgccaatgatgaagtatgtagctttagg
tttgtactatgaggctttcgtttgtttgcagagtataacagttgcgagtgaaaaaccgac
gaatttatactaatacgctttcactattggctacaaaatagggaagagtttcaatcatga
gagggagtatatggatgctttgtagctaaaggtagaacgtatgtatatgctgccgttcat
tcttgaaagatacataagcgataagttacgacaattataagcaacatccctaccttcgta
acgatttcactgttactgcgcttgaaatacactatggggctattggcggagagaagcaga
tcgcgccgagcatatacgagacctataatgttgatgatagagaaggcgtctgaattgata
catcgaagtacactttctttcgtagtatctctcgtcctctttctatctccggacacaaga
attaagttatatatatagagtcttaccaatcatgttgaatcctgattctcagagttcttt
ggcgggccttgtgatgactgagaaacaatgcaatattgctccaaatttcctaagcaaatt
ctcggttatgttatgttatcagcaaagcgttacgttatgttatttaaatctggaatgacg
gagcgaagttcttatgtcggtgtgggaataattcttttgaagacagcactccttaaataa
tatcgctccgtgtttgtatttatcgaatgggtctgtaaccttgcacaagcaaatcggtgg
tgtatatatcggataacaattaatacgatgttcatagtgacagtatactgatcgagtcct
ctaaagtcaattacctcacttaacaatctcattgatgttgtgtcattcccggtatcgccc
gtagtatgtgctctgattgaccgagtgtgaaccaaggaacatctactaatgcctttgtta
ggtaagatctctctgaattccttcgtgccaacttaaaacattatcaaaatttcttctact
tggattaactacttttacgagcatggcaaattcccctgtggaagacggttcattattatc
ggaaaccttatagaaattgcgtgttgactgaaattagatttttattgtaagagttgcatc
tttgcgattcctctggtctagcttccaatgaacagtcctcccttctattcgacatcgggt
ccttcgtacatgtctttgcgatgtaataattaggttcggagtgtggccttaatgggtgca
actaggaatacaacgcaaatttgctgacatgatagcaaatcggtatgccggcaccaaaac
gtgctccttgcttagcttgtgaatgagactcagtagttaaataaatccatatctgcaatc
gattccacaggtattgtccactatctttgaactactctaagagatacaagcttagctgag
accgaggtgtatatgactacgctgatatctgtaaggtaccaatgcaggcaaagtatgcga
gaagctaataccggctgtttccagctttataagattaaaatttggctgtcctggcggcct
cagaattgttctatcgtaatcagttggttcattaattagctaagtacgaggtacaactta
tctgtcccagaacagctccacaagtttttttacagccgaaacccctgtgtgaatcttaat
atccaagcgcgttatctgattagagtttacaactcagtattttatcagtacgttttgttt
ccaacattacccggtatgacaaaatgacgccacgtgtcgaataatggtctgaccaatgta
ggaagtgaaaagataaatat
INPUT567
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT567' && $CMP $stdout $ftemp2; then
agggtaaa|tttaccct 1
[cgt]gggtaaa|tttaccc[acg] 0
a[act]ggtaaa|tttacc[agt]t 0
ag[act]gtaaa|tttac[agt]ct 0
agg[act]taaa|ttta[agt]cct 1
aggg[acg]aaa|ttt[cgt]ccct 0
agggt[cgt]aa|tt[acg]accct 0
agggta[cgt]a|t[acg]taccct 0
agggtaa[cgt]|[acg]ttaccct 2

10245
10000
13348
OUTPUT567
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 568.
if test $result = ok -a $start_test_number -le 568; then
	echo test 568: Reverse Complement from Language Shootout
        cat >$test_file <<'TEST568'
var tr =   "ACBDGHKMNSRUTWVYacbdghkmnsrutwvy";
var subst = "TGVHCDMKNSYAAWBRTGVHCDMKNSYAAWBR";
var line, seq = [];

func output_seq (seq) {
  var i;

  for (i = 0; i < #seq; i += 60) putln (subv (seq, i, 60));
}

try {
  for (;;) {
    line = getln ();
    if (line [0] != '>') insv (seq, line, -1);
    else {
      output_seq (transliterate (rev (seq), tr, subst));
      del (seq, 0, -1); putln (line);
    }
  }
} catch (invcalls.eof) {}

output_seq (transliterate (rev (seq), tr, subst));
TEST568
        echo '      ' $DINO $test_file 1000 "2>$stderr"
        if $DINO $test_file 1000 <<'INPUT568' 2>$stderr >$stdout; then
>ONE Homo sapiens alu
GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGA
TCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACT
AAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAG
GCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCG
CCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGT
GGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCA
GGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAA
TTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAG
AATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCA
GCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGT
AATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACC
AGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTG
GTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACC
CGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAG
AGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTT
TGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACA
TGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCT
GTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGG
TTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGT
CTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGG
CGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCG
TCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTA
CTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCG
AGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCG
GGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACC
TGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAA
TACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGA
GGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACT
GCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTC
ACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGT
TCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGC
CGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCG
CTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTG
GGCGACAGAGCGAGACTCCG
>TWO IUB ambiguity codes
cttBtatcatatgctaKggNcataaaSatgtaaaDcDRtBggDtctttataattcBgtcg
tactDtDagcctatttSVHtHttKtgtHMaSattgWaHKHttttagacatWatgtRgaaa
NtactMcSMtYtcMgRtacttctWBacgaaatatagScDtttgaagacacatagtVgYgt
cattHWtMMWcStgttaggKtSgaYaaccWStcgBttgcgaMttBYatcWtgacaYcaga
gtaBDtRacttttcWatMttDBcatWtatcttactaBgaYtcttgttttttttYaaScYa
HgtgttNtSatcMtcVaaaStccRcctDaataataStcYtRDSaMtDttgttSagtRRca
tttHatSttMtWgtcgtatSSagactYaaattcaMtWatttaSgYttaRgKaRtccactt
tattRggaMcDaWaWagttttgacatgttctacaaaRaatataataaMttcgDacgaSSt
acaStYRctVaNMtMgtaggcKatcttttattaaaaagVWaHKYagtttttatttaacct
tacgtVtcVaattVMBcttaMtttaStgacttagattWWacVtgWYagWVRctDattBYt
gtttaagaagattattgacVatMaacattVctgtBSgaVtgWWggaKHaatKWcBScSWa
accRVacacaaactaccScattRatatKVtactatatttHttaagtttSKtRtacaaagt
RDttcaaaaWgcacatWaDgtDKacgaacaattacaRNWaatHtttStgttattaaMtgt
tgDcgtMgcatBtgcttcgcgaDWgagctgcgaggggVtaaScNatttacttaatgacag
cccccacatYScaMgtaggtYaNgttctgaMaacNaMRaacaaacaKctacatagYWctg
ttWaaataaaataRattagHacacaagcgKatacBttRttaagtatttccgatctHSaat
actcNttMaagtattMtgRtgaMgcataatHcMtaBSaRattagttgatHtMttaaKagg
YtaaBataSaVatactWtataVWgKgttaaaacagtgcgRatatacatVtHRtVYataSa
KtWaStVcNKHKttactatccctcatgWHatWaRcttactaggatctataDtDHBttata
aaaHgtacVtagaYttYaKcctattcttcttaataNDaaggaaaDYgcggctaaWSctBa
aNtgctggMBaKctaMVKagBaactaWaDaMaccYVtNtaHtVWtKgRtcaaNtYaNacg
gtttNattgVtttctgtBaWgtaattcaagtcaVWtactNggattctttaYtaaagccgc
tcttagHVggaYtgtNcDaVagctctctKgacgtatagYcctRYHDtgBattDaaDgccK
tcHaaStttMcctagtattgcRgWBaVatHaaaataYtgtttagMDMRtaataaggatMt
ttctWgtNtgtgaaaaMaatatRtttMtDgHHtgtcattttcWattRSHcVagaagtacg
ggtaKVattKYagactNaatgtttgKMMgYNtcccgSKttctaStatatNVataYHgtNa
BKRgNacaactgatttcctttaNcgatttctctataScaHtataRagtcRVttacDSDtt
aRtSatacHgtSKacYagttMHtWataggatgactNtatSaNctataVtttRNKtgRacc
tttYtatgttactttttcctttaaacatacaHactMacacggtWataMtBVacRaSaatc
cgtaBVttccagccBcttaRKtgtgcctttttRtgtcagcRttKtaaacKtaaatctcac
aattgcaNtSBaaccgggttattaaBcKatDagttactcttcattVtttHaaggctKKga
tacatcBggScagtVcacattttgaHaDSgHatRMaHWggtatatRgccDttcgtatcga
aacaHtaagttaRatgaVacttagattVKtaaYttaaatcaNatccRttRRaMScNaaaD
gttVHWgtcHaaHgacVaWtgttScactaagSgttatcttagggDtaccagWattWtRtg
ttHWHacgattBtgVcaYatcggttgagKcWtKKcaVtgaYgWctgYggVctgtHgaNcV
taBtWaaYatcDRaaRtSctgaHaYRttagatMatgcatttNattaDttaattgttctaa
ccctcccctagaWBtttHtBccttagaVaatMcBHagaVcWcagBVttcBtaYMccagat
gaaaaHctctaacgttagNWRtcggattNatcRaNHttcagtKttttgWatWttcSaNgg
gaWtactKKMaacatKatacNattgctWtatctaVgagctatgtRaHtYcWcttagccaa
tYttWttaWSSttaHcaaaaagVacVgtaVaRMgattaVcDactttcHHggHRtgNcctt
tYatcatKgctcctctatVcaaaaKaaaagtatatctgMtWtaaaacaStttMtcgactt
taSatcgDataaactaaacaagtaaVctaggaSccaatMVtaaSKNVattttgHccatca
cBVctgcaVatVttRtactgtVcaattHgtaaattaaattttYtatattaaRSgYtgBag
aHSBDgtagcacRHtYcBgtcacttacactaYcgctWtattgSHtSatcataaatataHt
cgtYaaMNgBaatttaRgaMaatatttBtttaaaHHKaatctgatWatYaacttMctctt
ttVctagctDaaagtaVaKaKRtaacBgtatccaaccactHHaagaagaaggaNaaatBW
attccgStaMSaMatBttgcatgRSacgttVVtaaDMtcSgVatWcaSatcttttVatag
ttactttacgatcaccNtaDVgSRcgVcgtgaacgaNtaNatatagtHtMgtHcMtagaa
attBgtataRaaaacaYKgtRccYtatgaagtaataKgtaaMttgaaRVatgcagaKStc
tHNaaatctBBtcttaYaBWHgtVtgacagcaRcataWctcaBcYacYgatDgtDHccta
>THREE Homo sapiens frequency
aacacttcaccaggtatcgtgaaggctcaagattacccagagaacctttgcaatataaga
atatgtatgcagcattaccctaagtaattatattctttttctgactcaaagtgacaagcc
ctagtgtatattaaatcggtatatttgggaaattcctcaaactatcctaatcaggtagcc
atgaaagtgatcaaaaaagttcgtacttataccatacatgaattctggccaagtaaaaaa
tagattgcgcaaaattcgtaccttaagtctctcgccaagatattaggatcctattactca
tatcgtgtttttctttattgccgccatccccggagtatctcacccatccttctcttaaag
gcctaatattacctatgcaaataaacatatattgttgaaaattgagaacctgatcgtgat
tcttatgtgtaccatatgtatagtaatcacgcgactatatagtgctttagtatcgcccgt
gggtgagtgaatattctgggctagcgtgagatagtttcttgtcctaatatttttcagatc
gaatagcttctatttttgtgtttattgacatatgtcgaaactccttactcagtgaaagtc
atgaccagatccacgaacaatcttcggaatcagtctcgttttacggcggaatcttgagtc
taacttatatcccgtcgcttactttctaacaccccttatgtatttttaaaattacgttta
ttcgaacgtacttggcggaagcgttattttttgaagtaagttacattgggcagactcttg
acattttcgatacgactttctttcatccatcacaggactcgttcgtattgatatcagaag
ctcgtgatgattagttgtcttctttaccaatactttgaggcctattctgcgaaatttttg
ttgccctgcgaacttcacataccaaggaacacctcgcaacatgccttcatatccatcgtt
cattgtaattcttacacaatgaatcctaagtaattacatccctgcgtaaaagatggtagg
ggcactgaggatatattaccaagcatttagttatgagtaatcagcaatgtttcttgtatt
aagttctctaaaatagttacatcgtaatgttatctcgggttccgcgaataaacgagatag
attcattatatatggccctaagcaaaaacctcctcgtattctgttggtaattagaatcac
acaatacgggttgagatattaattatttgtagtacgaagagatataaaaagatgaacaat
tactcaagtcaagatgtatacgggatttataataaaaatcgggtagagatctgctttgca
attcagacgtgccactaaatcgtaatatgtcgcgttacatcagaaagggtaactattatt
aattaataaagggcttaatcactacatattagatcttatccgatagtcttatctattcgt
tgtatttttaagcggttctaattcagtcattatatcagtgctccgagttctttattattg
ttttaaggatgacaaaatgcctcttgttataacgctgggagaagcagactaagagtcgga
gcagttggtagaatgaggctgcaaaagacggtctcgacgaatggacagactttactaaac
caatgaaagacagaagtagagcaaagtctgaagtggtatcagcttaattatgacaaccct
taatacttccctttcgccgaatactggcgtggaaaggttttaaaagtcgaagtagttaga
ggcatctctcgctcataaataggtagactactcgcaatccaatgtgactatgtaatactg
ggaacatcagtccgcgatgcagcgtgtttatcaaccgtccccactcgcctggggagacat
gagaccacccccgtggggattattagtccgcagtaatcgactcttgacaatccttttcga
ttatgtcatagcaatttacgacagttcagcgaagtgactactcggcgaaatggtattact
aaagcattcgaacccacatgaatgtgattcttggcaatttctaatccactaaagcttttc
cgttgaatctggttgtagatatttatataagttcactaattaagatcacggtagtatatt
gatagtgatgtctttgcaagaggttggccgaggaatttacggattctctattgatacaat
ttgtctggcttataactcttaaggctgaaccaggcgtttttagacgacttgatcagctgt
tagaatggtttggactccctctttcatgtcagtaacatttcagccgttattgttacgata
tgcttgaacaatattgatctaccacacacccatagtatattttataggtcatgctgttac
ctacgagcatggtattccacttcccattcaatgagtattcaacatcactagcctcagaga
tgatgacccacctctaataacgtcacgttgcggccatgtgaaacctgaacttgagtagac
gatatcaagcgctttaaattgcatataacatttgagggtaaagctaagcggatgctttat
ataatcaatactcaataataagatttgattgcattttagagttatgacacgacatagttc
actaacgagttactattcccagatctagactgaagtactgatcgagacgatccttacgtc
gatgatcgttagttatcgacttaggtcgggtctctagcggtattggtacttaaccggaca
ctatactaataacccatgatcaaagcataacagaatacagacgataatttcgccaacata
tatgtacagaccccaagcatgagaagctcattgaaagctatcattgaagtcccgctcaca
atgtgtcttttccagacggtttaactggttcccgggagtcctggagtttcgacttacata
aatggaaacaatgtattttgctaatttatctatagcgtcatttggaccaatacagaatat
tatgttgcctagtaatccactataacccgcaagtgctgatagaaaatttttagacgattt
ataaatgccccaagtatccctcccgtgaatcctccgttatactaattagtattcgttcat
acgtataccgcgcatatatgaacatttggcgataaggcgcgtgaattgttacgtgacaga
gatagcagtttcttgtgatatggttaacagacgtacatgaagggaaactttatatctata
gtgatgcttccgtagaaataccgccactggtctgccaatgatgaagtatgtagctttagg
tttgtactatgaggctttcgtttgtttgcagagtataacagttgcgagtgaaaaaccgac
gaatttatactaatacgctttcactattggctacaaaatagggaagagtttcaatcatga
gagggagtatatggatgctttgtagctaaaggtagaacgtatgtatatgctgccgttcat
tcttgaaagatacataagcgataagttacgacaattataagcaacatccctaccttcgta
acgatttcactgttactgcgcttgaaatacactatggggctattggcggagagaagcaga
tcgcgccgagcatatacgagacctataatgttgatgatagagaaggcgtctgaattgata
catcgaagtacactttctttcgtagtatctctcgtcctctttctatctccggacacaaga
attaagttatatatatagagtcttaccaatcatgttgaatcctgattctcagagttcttt
ggcgggccttgtgatgactgagaaacaatgcaatattgctccaaatttcctaagcaaatt
ctcggttatgttatgttatcagcaaagcgttacgttatgttatttaaatctggaatgacg
gagcgaagttcttatgtcggtgtgggaataattcttttgaagacagcactccttaaataa
tatcgctccgtgtttgtatttatcgaatgggtctgtaaccttgcacaagcaaatcggtgg
tgtatatatcggataacaattaatacgatgttcatagtgacagtatactgatcgagtcct
ctaaagtcaattacctcacttaacaatctcattgatgttgtgtcattcccggtatcgccc
gtagtatgtgctctgattgaccgagtgtgaaccaaggaacatctactaatgcctttgtta
ggtaagatctctctgaattccttcgtgccaacttaaaacattatcaaaatttcttctact
tggattaactacttttacgagcatggcaaattcccctgtggaagacggttcattattatc
ggaaaccttatagaaattgcgtgttgactgaaattagatttttattgtaagagttgcatc
tttgcgattcctctggtctagcttccaatgaacagtcctcccttctattcgacatcgggt
ccttcgtacatgtctttgcgatgtaataattaggttcggagtgtggccttaatgggtgca
actaggaatacaacgcaaatttgctgacatgatagcaaatcggtatgccggcaccaaaac
gtgctccttgcttagcttgtgaatgagactcagtagttaaataaatccatatctgcaatc
gattccacaggtattgtccactatctttgaactactctaagagatacaagcttagctgag
accgaggtgtatatgactacgctgatatctgtaaggtaccaatgcaggcaaagtatgcga
gaagctaataccggctgtttccagctttataagattaaaatttggctgtcctggcggcct
cagaattgttctatcgtaatcagttggttcattaattagctaagtacgaggtacaactta
tctgtcccagaacagctccacaagtttttttacagccgaaacccctgtgtgaatcttaat
atccaagcgcgttatctgattagagtttacaactcagtattttatcagtacgttttgttt
ccaacattacccggtatgacaaaatgacgccacgtgtcgaataatggtctgaccaatgta
ggaagtgaaaagataaatat
INPUT568
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT568' && $CMP $stdout $ftemp2; then
>ONE Homo sapiens alu
CGGAGTCTCGCTCTGTCGCCCAGGCTGGAGTGCAGTGGCGCGATCTCGGCTCACTGCAAC
CTCCGCCTCCCGGGTTCAAGCGATTCTCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACA
GGCGCGCGCCACCACGCCCGGCTAATTTTTGTATTTTTAGTAGAGACGGGGTTTCACCAT
GTTGGCCAGGCTGGTCTCGAACTCCTGACCTCAGGTGATCCGCCCGCCTCGGCCTCCCAA
AGTGCTGGGATTACAGGCGTGAGCCACCGCGCCCGGCCTTTTTGAGACGGAGTCTCGCTC
TGTCGCCCAGGCTGGAGTGCAGTGGCGCGATCTCGGCTCACTGCAACCTCCGCCTCCCGG
GTTCAAGCGATTCTCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACAGGCGCGCGCCACC
ACGCCCGGCTAATTTTTGTATTTTTAGTAGAGACGGGGTTTCACCATGTTGGCCAGGCTG
GTCTCGAACTCCTGACCTCAGGTGATCCGCCCGCCTCGGCCTCCCAAAGTGCTGGGATTA
CAGGCGTGAGCCACCGCGCCCGGCCTTTTTGAGACGGAGTCTCGCTCTGTCGCCCAGGCT
GGAGTGCAGTGGCGCGATCTCGGCTCACTGCAACCTCCGCCTCCCGGGTTCAAGCGATTC
TCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACAGGCGCGCGCCACCACGCCCGGCTAAT
TTTTGTATTTTTAGTAGAGACGGGGTTTCACCATGTTGGCCAGGCTGGTCTCGAACTCCT
GACCTCAGGTGATCCGCCCGCCTCGGCCTCCCAAAGTGCTGGGATTACAGGCGTGAGCCA
CCGCGCCCGGCCTTTTTGAGACGGAGTCTCGCTCTGTCGCCCAGGCTGGAGTGCAGTGGC
GCGATCTCGGCTCACTGCAACCTCCGCCTCCCGGGTTCAAGCGATTCTCCTGCCTCAGCC
TCCCGAGTAGCTGGGATTACAGGCGCGCGCCACCACGCCCGGCTAATTTTTGTATTTTTA
GTAGAGACGGGGTTTCACCATGTTGGCCAGGCTGGTCTCGAACTCCTGACCTCAGGTGAT
CCGCCCGCCTCGGCCTCCCAAAGTGCTGGGATTACAGGCGTGAGCCACCGCGCCCGGCCT
TTTTGAGACGGAGTCTCGCTCTGTCGCCCAGGCTGGAGTGCAGTGGCGCGATCTCGGCTC
ACTGCAACCTCCGCCTCCCGGGTTCAAGCGATTCTCCTGCCTCAGCCTCCCGAGTAGCTG
GGATTACAGGCGCGCGCCACCACGCCCGGCTAATTTTTGTATTTTTAGTAGAGACGGGGT
TTCACCATGTTGGCCAGGCTGGTCTCGAACTCCTGACCTCAGGTGATCCGCCCGCCTCGG
CCTCCCAAAGTGCTGGGATTACAGGCGTGAGCCACCGCGCCCGGCCTTTTTGAGACGGAG
TCTCGCTCTGTCGCCCAGGCTGGAGTGCAGTGGCGCGATCTCGGCTCACTGCAACCTCCG
CCTCCCGGGTTCAAGCGATTCTCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACAGGCGC
GCGCCACCACGCCCGGCTAATTTTTGTATTTTTAGTAGAGACGGGGTTTCACCATGTTGG
CCAGGCTGGTCTCGAACTCCTGACCTCAGGTGATCCGCCCGCCTCGGCCTCCCAAAGTGC
TGGGATTACAGGCGTGAGCCACCGCGCCCGGCCTTTTTGAGACGGAGTCTCGCTCTGTCG
CCCAGGCTGGAGTGCAGTGGCGCGATCTCGGCTCACTGCAACCTCCGCCTCCCGGGTTCA
AGCGATTCTCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACAGGCGCGCGCCACCACGCC
CGGCTAATTTTTGTATTTTTAGTAGAGACGGGGTTTCACCATGTTGGCCAGGCTGGTCTC
GAACTCCTGACCTCAGGTGATCCGCCCGCCTCGGCCTCCCAAAGTGCTGGGATTACAGGC
GTGAGCCACCGCGCCCGGCC
>TWO IUB ambiguity codes
TAGGDHACHATCRGTRGVTGAGWTATGYTGCTGTCABACDWVTRTAAGAVVAGATTTNDA
GASMTCTGCATBYTTCAAKTTACMTATTACTTCATARGGYACMRTGTTTTYTATACVAAT
TTCTAKGDACKADACTATATNTANTCGTTCACGBCGYSCBHTANGGTGATCGTAAAGTAA
CTATBAAAAGATSTGWATBCSGAKHTTABBAACGTSYCATGCAAVATKTSKTASCGGAAT
WVATTTNTCCTTCTTCTTDDAGTGGTTGGATACVGTTAYMTMTBTACTTTHAGCTAGBAA
AAGAGKAAGTTRATWATCAGATTMDDTTTAAAVAAATATTKTCYTAAATTVCNKTTRACG
ADTATATTTATGATSADSCAATAWAGCGRTAGTGTAAGTGACVGRADYGTGCTACHVSDT
CTVCARCSYTTAATATARAAAATTTAATTTACDAATTGBACAGTAYAABATBTGCAGBVG
TGATGGDCAAAATBNMSTTABKATTGGSTCCTAGBTTACTTGTTTAGTTTATHCGATSTA
AAGTCGAKAAASTGTTTTAWAKCAGATATACTTTTMTTTTGBATAGAGGAGCMATGATRA
AAGGNCAYDCCDDGAAAGTHGBTAATCKYTBTACBGTBCTTTTTGDTAASSWTAAWAARA
TTGGCTAAGWGRADTYACATAGCTCBTAGATAWAGCAATNGTATMATGTTKMMAGTAWTC
CCNTSGAAWATWCAAAAMACTGAADNTYGATNAATCCGAYWNCTAACGTTAGAGDTTTTC
ATCTGGKRTAVGAABVCTGWGBTCTDVGKATTBTCTAAGGVADAAAVWTCTAGGGGAGGG
TTAGAACAATTAAHTAATNAAATGCATKATCTAAYRTDTCAGSAYTTYHGATRTTWAVTA
BGNTCDACAGBCCRCAGWCRTCABTGMMAWGMCTCAACCGATRTGBCAVAATCGTDWDAA
CAYAWAATWCTGGTAHCCCTAAGATAACSCTTAGTGSAACAWTBGTCDTTDGACWDBAAC
HTTTNGSKTYYAAYGGATNTGATTTAARTTAMBAATCTAAGTBTCATYTAACTTADTGTT
TCGATACGAAHGGCYATATACCWDTKYATDCSHTDTCAAAATGTGBACTGSCCVGATGTA
TCMMAGCCTTDAAABAATGAAGAGTAACTHATMGVTTAATAACCCGGTTVSANTGCAATT
GTGAGATTTAMGTTTAMAAYGCTGACAYAAAAAGGCACAMYTAAGVGGCTGGAABVTACG
GATTSTYGTBVAKTATWACCGTGTKAGTDTGTATGTTTAAAGGAAAAAGTAACATARAAA
GGTYCAMNYAAABTATAGNTSATANAGTCATCCTATWADKAACTRGTMSACDGTATSAYT
AAHSHGTAABYGACTYTATADTGSTATAGAGAAATCGNTAAAGGAAATCAGTTGTNCYMV
TNACDRTATBNATATASTAGAAMSCGGGANRCKKMCAAACATTNAGTCTRMAATBMTACC
CGTACTTCTBGDSYAATWGAAAATGACADDCHAKAAAYATATTKTTTTCACANACWAGAA
AKATCCTTATTAYKHKCTAAACARTATTTTDATBTVWCYGCAATACTAGGKAAASTTDGA
MGGCHTTHAATVCAHDRYAGGRCTATACGTCMAGAGAGCTBTHGNACARTCCBDCTAAGA
GCGGCTTTARTAAAGAATCCNAGTAWBTGACTTGAATTACWTVACAGAAABCAATNAAAC
CGTNTRANTTGAYCMAWBADTANABRGGTKTHTWTAGTTVCTMBKTAGMTVKCCAGCANT
TVAGSWTTAGCCGCRHTTTCCTTHNTATTAAGAAGAATAGGMTRAARTCTABGTACDTTT
TATAAVDHAHTATAGATCCTAGTAAGYTWATDWCATGAGGGATAGTAAMDMNGBASTWAM
TSTATRBAYDABATGTATATYCGCACTGTTTTAACMCWBTATAWAGTATBTSTATVTTAR
CCTMTTAAKADATCAACTAATYTSVTAKGDATTATGCKTCAYCAKAATACTTKAANGAGT
ATTSDAGATCGGAAATACTTAAYAAVGTATMCGCTTGTGTDCTAATYTATTTTATTTWAA
CAGWRCTATGTAGMTGTTTGTTYKTNGTTKTCAGAACNTRACCTACKTGSRATGTGGGGG
CTGTCATTAAGTAAATNGSTTABCCCCTCGCAGCTCWHTCGCGAAGCAVATGCKACGHCA
ACAKTTAATAACASAAADATTWNYTGTAATTGTTCGTMHACHTWATGTGCWTTTTGAAHY
ACTTTGTAYAMSAAACTTAADAAATATAGTABMATATYAATGSGGTAGTTTGTGTBYGGT
TWSGSVGWMATTDMTCCWWCABTCSVACAGBAATGTTKATBGTCAATAATCTTCTTAAAC
ARVAATHAGYBWCTRWCABGTWWAATCTAAGTCASTAAAKTAAGVKBAATTBGABACGTA
AGGTTAAATAAAAACTRMDTWBCTTTTTAATAAAAGATMGCCTACKAKNTBAGYRASTGT
ASSTCGTHCGAAKTTATTATATTYTTTGTAGAACATGTCAAAACTWTWTHGKTCCYAATA
AAGTGGAYTMCYTAARCSTAAATWAKTGAATTTRAGTCTSSATACGACWAKAASATDAAA
TGYYACTSAACAAHAKTSHYARGASTATTATTHAGGYGGASTTTBGAKGATSANAACACD
TRGSTTRAAAAAAAACAAGARTCVTAGTAAGATAWATGVHAAKATWGAAAAGTYAHVTAC
TCTGRTGTCAWGATRVAAKTCGCAAVCGASWGGTTRTCSAMCCTAACASGWKKAWDAATG
ACRCBACTATGTGTCTTCAAAHGSCTATATTTCGTVWAGAAGTAYCKGARAKSGKAGTAN
TTTCYACATWATGTCTAAAADMDTWCAATSTKDACAMAADADBSAAATAGGCTHAHAGTA
CGACVGAATTATAAAGAHCCVAYHGHTTTACATSTTTATGNCCMTAGCATATGATAVAAG
>THREE Homo sapiens frequency
ATATTTATCTTTTCACTTCCTACATTGGTCAGACCATTATTCGACACGTGGCGTCATTTT
GTCATACCGGGTAATGTTGGAAACAAAACGTACTGATAAAATACTGAGTTGTAAACTCTA
ATCAGATAACGCGCTTGGATATTAAGATTCACACAGGGGTTTCGGCTGTAAAAAAACTTG
TGGAGCTGTTCTGGGACAGATAAGTTGTACCTCGTACTTAGCTAATTAATGAACCAACTG
ATTACGATAGAACAATTCTGAGGCCGCCAGGACAGCCAAATTTTAATCTTATAAAGCTGG
AAACAGCCGGTATTAGCTTCTCGCATACTTTGCCTGCATTGGTACCTTACAGATATCAGC
GTAGTCATATACACCTCGGTCTCAGCTAAGCTTGTATCTCTTAGAGTAGTTCAAAGATAG
TGGACAATACCTGTGGAATCGATTGCAGATATGGATTTATTTAACTACTGAGTCTCATTC
ACAAGCTAAGCAAGGAGCACGTTTTGGTGCCGGCATACCGATTTGCTATCATGTCAGCAA
ATTTGCGTTGTATTCCTAGTTGCACCCATTAAGGCCACACTCCGAACCTAATTATTACAT
CGCAAAGACATGTACGAAGGACCCGATGTCGAATAGAAGGGAGGACTGTTCATTGGAAGC
TAGACCAGAGGAATCGCAAAGATGCAACTCTTACAATAAAAATCTAATTTCAGTCAACAC
GCAATTTCTATAAGGTTTCCGATAATAATGAACCGTCTTCCACAGGGGAATTTGCCATGC
TCGTAAAAGTAGTTAATCCAAGTAGAAGAAATTTTGATAATGTTTTAAGTTGGCACGAAG
GAATTCAGAGAGATCTTACCTAACAAAGGCATTAGTAGATGTTCCTTGGTTCACACTCGG
TCAATCAGAGCACATACTACGGGCGATACCGGGAATGACACAACATCAATGAGATTGTTA
AGTGAGGTAATTGACTTTAGAGGACTCGATCAGTATACTGTCACTATGAACATCGTATTA
ATTGTTATCCGATATATACACCACCGATTTGCTTGTGCAAGGTTACAGACCCATTCGATA
AATACAAACACGGAGCGATATTATTTAAGGAGTGCTGTCTTCAAAAGAATTATTCCCACA
CCGACATAAGAACTTCGCTCCGTCATTCCAGATTTAAATAACATAACGTAACGCTTTGCT
GATAACATAACATAACCGAGAATTTGCTTAGGAAATTTGGAGCAATATTGCATTGTTTCT
CAGTCATCACAAGGCCCGCCAAAGAACTCTGAGAATCAGGATTCAACATGATTGGTAAGA
CTCTATATATATAACTTAATTCTTGTGTCCGGAGATAGAAAGAGGACGAGAGATACTACG
AAAGAAAGTGTACTTCGATGTATCAATTCAGACGCCTTCTCTATCATCAACATTATAGGT
CTCGTATATGCTCGGCGCGATCTGCTTCTCTCCGCCAATAGCCCCATAGTGTATTTCAAG
CGCAGTAACAGTGAAATCGTTACGAAGGTAGGGATGTTGCTTATAATTGTCGTAACTTAT
CGCTTATGTATCTTTCAAGAATGAACGGCAGCATATACATACGTTCTACCTTTAGCTACA
AAGCATCCATATACTCCCTCTCATGATTGAAACTCTTCCCTATTTTGTAGCCAATAGTGA
AAGCGTATTAGTATAAATTCGTCGGTTTTTCACTCGCAACTGTTATACTCTGCAAACAAA
CGAAAGCCTCATAGTACAAACCTAAAGCTACATACTTCATCATTGGCAGACCAGTGGCGG
TATTTCTACGGAAGCATCACTATAGATATAAAGTTTCCCTTCATGTACGTCTGTTAACCA
TATCACAAGAAACTGCTATCTCTGTCACGTAACAATTCACGCGCCTTATCGCCAAATGTT
CATATATGCGCGGTATACGTATGAACGAATACTAATTAGTATAACGGAGGATTCACGGGA
GGGATACTTGGGGCATTTATAAATCGTCTAAAAATTTTCTATCAGCACTTGCGGGTTATA
GTGGATTACTAGGCAACATAATATTCTGTATTGGTCCAAATGACGCTATAGATAAATTAG
CAAAATACATTGTTTCCATTTATGTAAGTCGAAACTCCAGGACTCCCGGGAACCAGTTAA
ACCGTCTGGAAAAGACACATTGTGAGCGGGACTTCAATGATAGCTTTCAATGAGCTTCTC
ATGCTTGGGGTCTGTACATATATGTTGGCGAAATTATCGTCTGTATTCTGTTATGCTTTG
ATCATGGGTTATTAGTATAGTGTCCGGTTAAGTACCAATACCGCTAGAGACCCGACCTAA
GTCGATAACTAACGATCATCGACGTAAGGATCGTCTCGATCAGTACTTCAGTCTAGATCT
GGGAATAGTAACTCGTTAGTGAACTATGTCGTGTCATAACTCTAAAATGCAATCAAATCT
TATTATTGAGTATTGATTATATAAAGCATCCGCTTAGCTTTACCCTCAAATGTTATATGC
AATTTAAAGCGCTTGATATCGTCTACTCAAGTTCAGGTTTCACATGGCCGCAACGTGACG
TTATTAGAGGTGGGTCATCATCTCTGAGGCTAGTGATGTTGAATACTCATTGAATGGGAA
GTGGAATACCATGCTCGTAGGTAACAGCATGACCTATAAAATATACTATGGGTGTGTGGT
AGATCAATATTGTTCAAGCATATCGTAACAATAACGGCTGAAATGTTACTGACATGAAAG
AGGGAGTCCAAACCATTCTAACAGCTGATCAAGTCGTCTAAAAACGCCTGGTTCAGCCTT
AAGAGTTATAAGCCAGACAAATTGTATCAATAGAGAATCCGTAAATTCCTCGGCCAACCT
CTTGCAAAGACATCACTATCAATATACTACCGTGATCTTAATTAGTGAACTTATATAAAT
ATCTACAACCAGATTCAACGGAAAAGCTTTAGTGGATTAGAAATTGCCAAGAATCACATT
CATGTGGGTTCGAATGCTTTAGTAATACCATTTCGCCGAGTAGTCACTTCGCTGAACTGT
CGTAAATTGCTATGACATAATCGAAAAGGATTGTCAAGAGTCGATTACTGCGGACTAATA
ATCCCCACGGGGGTGGTCTCATGTCTCCCCAGGCGAGTGGGGACGGTTGATAAACACGCT
GCATCGCGGACTGATGTTCCCAGTATTACATAGTCACATTGGATTGCGAGTAGTCTACCT
ATTTATGAGCGAGAGATGCCTCTAACTACTTCGACTTTTAAAACCTTTCCACGCCAGTAT
TCGGCGAAAGGGAAGTATTAAGGGTTGTCATAATTAAGCTGATACCACTTCAGACTTTGC
TCTACTTCTGTCTTTCATTGGTTTAGTAAAGTCTGTCCATTCGTCGAGACCGTCTTTTGC
AGCCTCATTCTACCAACTGCTCCGACTCTTAGTCTGCTTCTCCCAGCGTTATAACAAGAG
GCATTTTGTCATCCTTAAAACAATAATAAAGAACTCGGAGCACTGATATAATGACTGAAT
TAGAACCGCTTAAAAATACAACGAATAGATAAGACTATCGGATAAGATCTAATATGTAGT
GATTAAGCCCTTTATTAATTAATAATAGTTACCCTTTCTGATGTAACGCGACATATTACG
ATTTAGTGGCACGTCTGAATTGCAAAGCAGATCTCTACCCGATTTTTATTATAAATCCCG
TATACATCTTGACTTGAGTAATTGTTCATCTTTTTATATCTCTTCGTACTACAAATAATT
AATATCTCAACCCGTATTGTGTGATTCTAATTACCAACAGAATACGAGGAGGTTTTTGCT
TAGGGCCATATATAATGAATCTATCTCGTTTATTCGCGGAACCCGAGATAACATTACGAT
GTAACTATTTTAGAGAACTTAATACAAGAAACATTGCTGATTACTCATAACTAAATGCTT
GGTAATATATCCTCAGTGCCCCTACCATCTTTTACGCAGGGATGTAATTACTTAGGATTC
ATTGTGTAAGAATTACAATGAACGATGGATATGAAGGCATGTTGCGAGGTGTTCCTTGGT
ATGTGAAGTTCGCAGGGCAACAAAAATTTCGCAGAATAGGCCTCAAAGTATTGGTAAAGA
AGACAACTAATCATCACGAGCTTCTGATATCAATACGAACGAGTCCTGTGATGGATGAAA
GAAAGTCGTATCGAAAATGTCAAGAGTCTGCCCAATGTAACTTACTTCAAAAAATAACGC
TTCCGCCAAGTACGTTCGAATAAACGTAATTTTAAAAATACATAAGGGGTGTTAGAAAGT
AAGCGACGGGATATAAGTTAGACTCAAGATTCCGCCGTAAAACGAGACTGATTCCGAAGA
TTGTTCGTGGATCTGGTCATGACTTTCACTGAGTAAGGAGTTTCGACATATGTCAATAAA
CACAAAAATAGAAGCTATTCGATCTGAAAAATATTAGGACAAGAAACTATCTCACGCTAG
CCCAGAATATTCACTCACCCACGGGCGATACTAAAGCACTATATAGTCGCGTGATTACTA
TACATATGGTACACATAAGAATCACGATCAGGTTCTCAATTTTCAACAATATATGTTTAT
TTGCATAGGTAATATTAGGCCTTTAAGAGAAGGATGGGTGAGATACTCCGGGGATGGCGG
CAATAAAGAAAAACACGATATGAGTAATAGGATCCTAATATCTTGGCGAGAGACTTAAGG
TACGAATTTTGCGCAATCTATTTTTTACTTGGCCAGAATTCATGTATGGTATAAGTACGA
ACTTTTTTGATCACTTTCATGGCTACCTGATTAGGATAGTTTGAGGAATTTCCCAAATAT
ACCGATTTAATATACACTAGGGCTTGTCACTTTGAGTCAGAAAAAGAATATAATTACTTA
GGGTAATGCTGCATACATATTCTTATATTGCAAAGGTTCTCTGGGTAATCTTGAGCCTTC
ACGATACCTGGTGAAGTGTT
OUTPUT568
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 569.
if test $result = ok -a $start_test_number -le 569; then
	echo test 569: Spectral Norm from Language Shootout
        cat >$test_file <<'TEST569'
func A (i, j) { return 1.0 / ((i + j) * (i + j + 1) / 2 + i + 1); }

func Av (n, v) {
   var i, j, Av = [n : 0.0];

   for (i = 0; i < n; i++)
      for (j = 0; j < n; j++) Av [i] += A (i, j) * v [j];
   return Av;
}

func Atv (n, v) {
   var i, j, Atv = [n : 0.0];

   for (i = 0; i < n; i++)
     for (j = 0; j < n; j++) Atv [i] += A (j, i) * v [j];
   return Atv;
}

func AtAv (n, v) {return Atv (n, Av (n, v));}

var n = int (#argv < 1 ? 100 : argv [0]);
var i, u = [n : 1.0], v = [n : 0.0], vBv = 0.0, vv = 0.0;

for (i = 0; i < 10; i++) { v = AtAv (n, u); u = AtAv (n, v); }
for (i = 0; i < n; i++) { vBv += u [i] * v [i]; vv += v [i] * v [i]; }

putf ("%0.9f\n", sqrt (vBv / vv));
TEST569
        echo '      ' $DINO $test_file 200 "2>$stderr"
        if $DINO $test_file 200 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT569' && $CMP $stdout $ftemp2; then
1.274223601
OUTPUT569
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 570.
if test $result = ok -a $start_test_number -le 570; then
	echo test 570: Sum file Language Shootout
        cat >$test_file <<'TEST570'
var sum = 0;
try {
  for (;;) sum += int (getln ());
} catch (invcalls.eof) {}

putln (sum);
TEST570
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file  <<'INPUT570' 2>$stderr >$stdout; then
276
498
-981
770
-401
702
966
950
-853
-53
-293
604
288
892
-697
204
96
408
880
-7
-817
422
-261
-485
-77
826
184
864
-751
626
812
-369
-353
-371
488
-83
-659
24
524
-21
840
-757
-17
-973
-843
260
858
-389
-521
-99
482
-561
-213
630
766
932
112
-419
-877
762
266
-837
170
834
746
764
922
-89
576
-63
90
684
316
506
-959
708
70
252
-747
342
-593
-895
-937
-707
350
588
-201
-683
-113
-511
-867
322
202
472
150
-9
-643
28
336
86
-925
836
-473
-451
-971
-805
-619
84
-67
806
270
366
334
-555
-557
-331
-409
-553
-145
-71
528
490
492
828
628
-961
536
-859
-271
974
-671
-749
414
-257
778
56
598
-437
-899
-785
-987
32
-999
132
-821
-209
402
-543
194
-967
294
-943
-285
-483
-97
660
-481
-829
-309
-597
-855
80
-355
192
-823
436
916
282
-629
612
-329
-535
780
-47
706
110
756
-857
-933
-345
-523
718
-31
902
678
540
698
456
-399
126
412
-563
-321
-487
-641
-195
-199
-955
772
INPUT570
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT570' && $CMP $stdout $ftemp2; then
-4818
OUTPUT570
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 571.
if test $result = ok -a $start_test_number -le 571; then
	echo test 571: Takfp Language Shootout
        cat >$test_file <<'TEST571'
func Tak (x, y, z) {
  if (y >= x) return z;
  return Tak (Tak (x - 1.0, y, z), Tak (y - 1.0, z, x), Tak (z -1.0, x, y));
}

var n = int (#argv < 1 ? 1 : argv [0]);
putf ("%.1f\n", Tak (n * 3.0, n * 2.0, n * 1.0));
TEST571
        echo '      ' $DINO $test_file 9 "2>$stderr"
        if $DINO $test_file 9 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT571' && $CMP $stdout $ftemp2; then
18.0
OUTPUT571
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 572.
if test $result = ok -a $start_test_number -le 572; then
	echo test 572: Swap statement implementation.
        cat >$test_file <<'TEST572'
var t, a = 1, b = 2;

putln (a, " ", b);
t = a; a = b; b = t;
putln (a, " ", b);

var ar = [1, 2, 3];
println (ar);
t = ar[0]; ar[0] = ar[2]; ar[2] = t;
println (ar);

class s (i) {}
var c1 = s (0), c2 = s (3);
putln (c1.i, ' ', c2.i);
t = c1.i; c1.i = c2.i; c2.i = t;
putln (c1.i, ' ', c2.i);

var tab = {"s" : 1, "t" : 2};
putln (tab{"s"}, ' ', tab{"t"});
t = tab{"s"}; tab{"s"} = tab{"t"}; tab{"t"} = t;
putln (tab{"s"}, ' ', tab{"t"});
TEST572
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT572' && $CMP $stdout $ftemp2; then
1 2
2 1
[1, 2, 3]
[3, 2, 1]
0 3
3 0
1 2
2 1
OUTPUT572
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 573.
if test $result = ok -a $start_test_number -le 573; then
	echo test 573: Health from Language Shootout.
        cat >$test_file <<'TEST573'
class queue {
  class node (item, next) {}
  var first = nil, last = nil;

  func Add (o) {
    var a = node (o, nil);

    if (first == nil) first = a; else last.next = a;
    last = a;
  }
  
  func Remove (o) {
    var c, p = nil;

    for (c = first; c != nil && c.item !== o; c = c.next) p = c;
    if (c == nil) return;
    if (p == nil) first = first.next; else p.next = c.next;
    if (last === c) last = p;
  }

  func Clear { first = nil; last = nil; }
}

class Patient (remainingTime = 0, hospitalTime = 0, hospitalVisits = 0) {}

val LEVELS = 5, DISTRICTS = 4;

class Hospital; class Totals;

class HealthcareRegion (level, s) {
  var districts = [DISTRICTS : nil];
  var localHospital = Hospital (level == LEVELS, level, s);

  func TransferPatients {
    var i, n;
    
    for (i = #districts - 1; i >= 0; i--)
      if (districts [i] != nil)
	for (n = districts [i].TransferPatients().first; n != nil; n = n.next)
	  localHospital.NewArrival(n.item);

    localHospital.TriageExaminationTreatment ();
    return localHospital.transfers;
  }

  func AccumulateTotals {
    var i, t = Totals ();

    for (i = #districts - 1; i >= 0; i--)
      if (districts [i] != nil)
	t.PlusTotal (districts [i].AccumulateTotals ());
    
    localHospital.AccumulateTotals (t);
    return t;
  }

  func TreatmentQueue { return localHospital.treatment; }
}

func CreateRegion (level, seed1, seed2) {
  var i, r = nil;
  
  if(level > 0) {
    r = HealthcareRegion (level, seed1 * seed2);
    for(i = #r.districts - 1; i >= 0; i--)
      r.districts [i] = CreateRegion (level - 1, seed1 * 4 + i + 1, seed2);
  }
  return r;
}

class Hospital (hasNoRegionalHospital, level, seed) {
  var availableStaff = 1 << (level - 1);
  var triage = queue (), examination = queue ();
  var treatment = queue (), transfers = queue ();
  var discharged = Totals ();

  func DischargePatients; func TreatOrTransferPatients; func TriagePatients;
  func genRandom; func NewArrival;

  func TriageExaminationTreatment {
    DischargePatients ();
    TreatOrTransferPatients ();
    TriagePatients ();
    
    if (genRandom (1.0) > 0.7) NewArrival (Patient ());
  }
  
  func AccumulateTotals (t) {
    var n;
    
    for (n = triage.first; n != nil; n = n.next) t.PlusPatient (n.item);
    for (n = examination.first; n != nil; n = n.next) t.PlusPatient (n.item);
    for (n = treatment.first; n != nil; n = n.next) t.PlusPatient (n.item);
    t.PlusTotal (discharged);
  }
  
  func NewArrival (p) {
    p.hospitalVisits++;
    if (availableStaff == 0) triage.Add (p);
    else {
      availableStaff--;
      p.remainingTime = 3;
      p.hospitalTime += 3;
      examination.Add (p);
    }
  }
  
  func DischargePatients {
    var n, p;
    
    for (n = treatment.first; n != nil; n = n.next) {
      p = n.item; p.remainingTime--;
      if (p.remainingTime == 0) {
	availableStaff++;
	treatment.Remove (p);
	discharged.PlusPatient (p);
      }
    }
  }

  func TreatOrTransferPatients {
    var p, n;

    transfers.Clear ();
    for (n = examination.first; n != nil; n = n.next) {
      p = n.item; p.remainingTime--;
      if (p.remainingTime == 0) { // no transfer
	if (genRandom (1.0) > 0.1 || hasNoRegionalHospital) {
	  treatment.Add(p);
	  p.remainingTime = 10;
	  p.hospitalTime += 10;
	} else { // transfer
	  availableStaff++;
	  transfers.Add (p);
	}
	examination.Remove(p);
      }
    }
  }

  func TriagePatients {
    var p, n;

    for (n = triage.first; n != nil; n = n.next) {
      p = n.item;
      if (availableStaff == 0) p.hospitalTime++;
      else {
	availableStaff--;
	p.remainingTime = 3;
	p.hospitalTime += 3;
	examination.Add (p);
	triage.Remove (p);
      }
    }
  }

  val IM = 139968, IA = 3877, IC = 29573;

  func genRandom (max) {
    seed = (seed * IA + IC) % IM;
    return max * seed / IM ;
  }
}

class Totals {
  var patients = 0, hospitalTime = 0, hospitalVisits = 0;

  func PlusTotal (t) {
    patients += t.patients;
    hospitalTime += t.hospitalTime;
    hospitalVisits += t.hospitalVisits;
  }

   func PlusPatient (p) {
     patients++;
     hospitalTime += p.hospitalTime;
     hospitalVisits += p.hospitalVisits;
   }
}

var N = int (#argv < 1 ? 100 : argv [0]);
var i, healthcareSystem = CreateRegion (LEVELS, 0, 42), t, n;

for (i = 0; i < N; i++)
  healthcareSystem.TransferPatients ();

t = healthcareSystem.AccumulateTotals ();

putln ("Patients: ", t.patients);
putln ("Time:     ", t.hospitalTime);
putln ("Visits:   ", t.hospitalVisits);

putln ("\nTreatment Queue - Remaining Treatment Time");
for (n = healthcareSystem.TreatmentQueue ().first; n != nil; n = n.next)
  putln (n.item.remainingTime, "\tanonymous patient");
TEST573
        echo '      ' $DINO $test_file 100 "2>$stderr"
        if $DINO $test_file 100 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT573' && $CMP $stdout $ftemp2; then
Patients: 10151
Time:     363815
Visits:   10526

Treatment Queue - Remaining Treatment Time
1	anonymous patient
3	anonymous patient
9	anonymous patient
10	anonymous patient
OUTPUT573
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 574.
if test $result = ok -a $start_test_number -le 574; then
	echo test 574: Sync-statement
        cat >$test_file <<'TEST574'
var f = 1;
thread t {
  wait (1) {
    var i;

    f = 0;
    for (i = 0; i < 1000000; i++)
      if (i % 100000 == 0) putln (i);
  }
}

t ();
wait (! f);
putln ("it should be the last message");
TEST574
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT574' && $CMP $stdout $ftemp2; then
0
100000
200000
300000
400000
500000
600000
700000
800000
900000
it should be the last message
OUTPUT574
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 575.
if test $result = ok -a $start_test_number -le 575; then
	echo test 575: Wait in sync-statement
        cat >$test_file <<'TEST575'
var flag = 0;

thread f {
  wait (1) {
    wait (flag);
    flag = 0;
  }
}

f ();
flag = 1;
wait (! flag);
putln ("it can not be printed");
TEST575
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT575' && $CMP $stderr $ftemp2; then
test.d:5:5: wait in sync-statement
OUTPUT575
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 576.
if test $result = ok -a $start_test_number -le 576; then
	echo test 576: Catching wait in sync-statement
        cat >$test_file <<'TEST576'
var flag = 0;

thread f {
  try {
    wait (1) wait (flag);
  } catch (errors.syncwait) {
    putln ("got the exception");
    flag = 0;
  }
}

f ();
flag = 1;
wait (! flag);
putln ("continue");
TEST576
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT576' && $CMP $stdout $ftemp2; then
got the exception
continue
OUTPUT576
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 577.
if test $result = ok -a $start_test_number -le 577; then
	echo test 577: Thread call in sync-statement
        cat >$test_file <<'TEST577'
var flag = 0;

thread f {
}

wait (1) f ();
putln ("it can not be printed");
TEST577
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT577' && $CMP $stderr $ftemp2; then
test.d:6:12: thread call in sync-statement
OUTPUT577
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 578.
if test $result = ok -a $start_test_number -le 578; then
	echo test 578: Catching thread call in sync-statement
        cat >$test_file <<'TEST578'
var flag = 0;

thread f {
}

try {
  wait (1) f ();
} catch (invcalls.syncthreadcall) {
  putln ("got the exception");
}

putln ("continue");
TEST578
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT578' && $CMP $stdout $ftemp2; then
got the exception
continue
OUTPUT578
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 579.
if test $result = ok -a $start_test_number -le 579; then
	echo test 579: gmp package
        cat >$test_file <<'TEST579'
include "gmp";

var gmp1 = mpzs.mpz(5);
var gmp2 = mpzs.mpz(10);
var gmp3 = mpzs.mpz(0);

putln (mpzs.get_i (gmp1));
putln (mpzs.get_f (gmp2));
mpzs.set_str(gmp1, "10000000000000000000000000000000000000000000000");
mpzs.set_str(gmp2, "5000000000000000000000000000000000000000000000");
putln (mpzs.get_str (mpzs.add (gmp1, gmp2), 10));
putln (mpzs.get_str (mpzs.sub (gmp1, gmp2), 10));
putln (mpzs.get_str (mpzs.neg (gmp1), 10));
putln (mpzs.get_str (mpzs.abs (mpzs.neg (gmp1)), 10));
putln (mpzs.get_str (mpzs.mul (gmp1, gmp2), 10));
putln (mpzs.get_str (mpzs.div (gmp1, gmp2), 10));
putln (mpzs.get_str (mpzs.mod (gmp1, gmp2), 10));
putln (mpzs.get_str (mpzs.mod (gmp2, gmp1), 10));
putln (mpzs.get_str (mpzs.pow_ui (gmp2, 2), 10));
putln (mpzs.get_str (mpzs.root (gmp1, 2), 10));
putln (mpzs.cmp (gmp1, gmp2));
putln (mpzs.cmp (gmp2, gmp1));
putln (mpzs.get_str (gmp1, 8));
putln (mpzs.get_str (gmp2, 8));
putln (mpzs.get_str (mpzs.ior (gmp1, gmp2), 8));
putln (mpzs.get_str (mpzs.xor (gmp1, gmp2), 8));
putln (mpzs.get_str (mpzs.and (gmp1, gmp2), 8));
putln (mpzs.get_str (mpzs.com (gmp1), 10));
// putln (mpzs.get_str (mpzs.rand (gmp1, 1), 10));
// putln (mpzs.get_str (mpzs.rand (gmp1, 0), 10));
// putln (mpzs.get_str (mpzs.rand (gmp1, 0), 10));

mpzs.set_bit (gmp1, 10);
putln (mpzs.get_str (gmp1, 10));
putln (mpzs.tst_bit (gmp1, 10));
mpzs.clr_bit (gmp1, 10);
putln (mpzs.get_str (gmp1, 10));
TEST579
        if uname | fgrep CYGWIN; then
            echo '      ' $DINO -L./d_gmp.dll -I@srcdir@ $test_file "2>$stderr"
	    if $DINO -Lgmp.dll -I@srcdir@ $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT579' && $CMP $stdout $ftemp2; then
5
10
15000000000000000000000000000000000000000000000
5000000000000000000000000000000000000000000000
-10000000000000000000000000000000000000000000000
10000000000000000000000000000000000000000000000
50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
2
0
5000000000000000000000000000000000000000000000
25000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
100000000000000000000000
1
-1
0700324573052063614067325026200675322000000000000000
0340152275425031706033552413100336551000000000000000
0740376777477073716077777437300777773000000000000000
0440276706477052112054677435300543673000000000000000
0300100071000021604023100002000234100000000000000000
-10000000000000000000000000000000000000000000001
10000000000000000000000000000000000000000001024
1
10000000000000000000000000000000000000000000000
OUTPUT579
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
            echo '      ' $DINO -L./d_gmp.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file "2>$stderr"
	    if $DINO -L./d_gmp.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT579' && $CMP $stdout $ftemp2; then
5
10
15000000000000000000000000000000000000000000000
5000000000000000000000000000000000000000000000
-10000000000000000000000000000000000000000000000
10000000000000000000000000000000000000000000000
50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
2
0
5000000000000000000000000000000000000000000000
25000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
100000000000000000000000
1
-1
0700324573052063614067325026200675322000000000000000
0340152275425031706033552413100336551000000000000000
0740376777477073716077777437300777773000000000000000
0440276706477052112054677435300543673000000000000000
0300100071000021604023100002000234100000000000000000
-10000000000000000000000000000000000000000000001
10000000000000000000000000000000000000000001024
1
10000000000000000000000000000000000000000000000
OUTPUT579
                        result=ok
                else
                        result=fail
                fi
	    elif fgrep 'run time error - can not find external function' $stderr >/dev/null;then
		echo GMP package is absent -- skip
                result=ok
	    else
                result=fail
	    fi
        fi
fi

# Test 580.
if test $result = ok -a $start_test_number -le 580; then
	echo test 580: exit tracing
        cat >$test_file <<'TEST580'
func a {
  exit (0);
}
func b {
  a ();
}
func c (i) {
  if (i == 0) b (); else c (i - 1);
}
class d {
  c (5);
}
d ();
TEST580
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT580' && $CMP $stderr $ftemp2; then
test.d:11:5:calling a
test.d:13:3:calling d
OUTPUT580
                        result=ok
                else
                        result=fail
                fi
	else
                result=fail
        fi
fi

# Test 581.
if test $result = ok -a $start_test_number -le 581; then
	echo test 581: exception tracing
        cat >$test_file <<'TEST581'
func a {
  throw except ();
}
func b {
  a ();
}
func c (i) {
  if (i == 0) b (); else c (i - 1);
}
class d {
  c (5);
}
d ();
TEST581
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT581' && $CMP $stderr $ftemp2; then
test.d:2:3: run time error - exception except has not been processed
test.d:11:5:calling a
test.d:13:3:calling d
OUTPUT581
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 582.
if test $result = ok -a $start_test_number -le 582; then
	echo test 582: catched exception tracing
        cat >$test_file <<'TEST582'
func a {
  var i = 0;
  i[10]=0;
}
func b {
  a ();
}
func c (i) {
  if (i == 0) b (); else c (i - 1);
}
class d {
  c (5);
}
var i;
for (i = 0; i < 10; i++) 
  try {
    d ();
  } catch (except().error) {
    putln ("got it: ", e.msg);
  }
TEST582
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT582' && $CMP $stdout $ftemp2; then
got it: run time error - index operation for non array
got it: run time error - index operation for non array
got it: run time error - index operation for non array
got it: run time error - index operation for non array
got it: run time error - index operation for non array
got it: run time error - index operation for non array
got it: run time error - index operation for non array
got it: run time error - index operation for non array
got it: run time error - index operation for non array
got it: run time error - index operation for non array
OUTPUT582
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 583.
if test $result = ok -a $start_test_number -le 583; then
	echo test 583: normal exit tracing
        cat >$test_file <<'TEST583'
var i;
for (i =0; i < 10; i++);
TEST583
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT583' && $CMP $stdout $ftemp2; then
OUTPUT583
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 584.
if test $result = ok -a $start_test_number -le 584; then
	echo test 584: Normal dump
        cat >$test_file <<'TEST584'
var SieveSize, i, prime, k, count, flags;
SieveSize = 8190;

flags = [SieveSize + 1 : 0];
count = 0;
for (i = 0; i <= SieveSize; i++)
  flags[i] = 1;
for (i = 0; i <= SieveSize; i++;)
  if (flags[i])
    {
      prime = i + i + 3;
      k = i + prime;
      for (;1;;)
        {
	      if (k > SieveSize)
            break;
          flags[k] = 0;
          k += prime;
        }
      count++;
    }

println (count);
TEST584
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT584' && $CMP $stdout $ftemp2; then
     0 block fn="<environment>" ln=1 pos=1 next=730 vars_num=33 tvars_num=3 // ident=(null)
       0 fdecl pos=7 ident=except ident_num=1 decl_scope=0 fblock=1
       1 fblock pos=17 next=410 fdecl=0 class_p=1 simple_p=1 pure_func_p=1 scope=0 vars_num=0 tvars_num=0 ext_life_p=1 // ident=except
         1 fdecl ln=2 pos=9 ident=error ident_num=2 decl_scope=1 public_p=1 fblock=2
         2 fblock pos=26 next=407 fdecl=1 class_p=1 pars_num=1 scope=1 vars_num=1 tvars_num=0 ext_life_p=1 // ident=error
           2 vdecl pos=16 ident=msg ident_num=3 decl_scope=2 public_p=1 var_num=0
           3 fdecl ln=3 pos=11 ident=signal ident_num=4 decl_scope=2 public_p=1 fblock=3
           3 fblock pos=30 next=28 fdecl=3 class_p=1 pars_num=1 scope=2 vars_num=1 tvars_num=0 ext_life_p=1 // ident=signal
             4 vdecl pos=19 ident=msg ident_num=3 decl_scope=3 public_p=1 var_num=0
             5 fdecl ln=4 pos=13 ident=sigint ident_num=5 decl_scope=3 public_p=1 fblock=4
             4 fblock pos=32 next=5 fdecl=5 class_p=1 pars_num=1 scope=3 vars_num=1 tvars_num=0 ext_life_p=1 // ident=sigint
               6 vdecl pos=21 ident=msg ident_num=3 decl_scope=4 public_p=1 var_num=0

               5 btdef pos=21 op1=0 pc=7 // goto 7 unless 0 is undefined
               6 ldnil pos=27 op1=0 // 0 <- nil
               7 bend pos=21 block=4
             7 fdecl ln=5 pos=13 ident=sigill ident_num=6 decl_scope=3 public_p=1 fblock=8
             8 fblock pos=32 next=9 fdecl=7 class_p=1 pars_num=1 scope=3 vars_num=1 tvars_num=0 ext_life_p=1 // ident=sigill
               8 vdecl pos=21 ident=msg ident_num=3 decl_scope=8 public_p=1 var_num=0

               9 btdef pos=21 op1=0 pc=11 // goto 11 unless 0 is undefined
              10 ldnil pos=27 op1=0 // 0 <- nil
              11 bend pos=21 block=8
             9 fdecl ln=6 pos=13 ident=sigabrt ident_num=7 decl_scope=3 public_p=1 fblock=12
            12 fblock pos=33 next=13 fdecl=9 class_p=1 pars_num=1 scope=3 vars_num=1 tvars_num=0 ext_life_p=1 // ident=sigabrt
              10 vdecl pos=22 ident=msg ident_num=3 decl_scope=12 public_p=1 var_num=0

              13 btdef pos=22 op1=0 pc=15 // goto 15 unless 0 is undefined
              14 ldnil pos=28 op1=0 // 0 <- nil
              15 bend pos=22 block=12
            11 fdecl ln=7 pos=13 ident=sigfpe ident_num=8 decl_scope=3 public_p=1 fblock=16
            16 fblock pos=32 next=17 fdecl=11 class_p=1 pars_num=1 scope=3 vars_num=1 tvars_num=0 ext_life_p=1 // ident=sigfpe
              12 vdecl pos=21 ident=msg ident_num=3 decl_scope=16 public_p=1 var_num=0

              17 btdef pos=21 op1=0 pc=19 // goto 19 unless 0 is undefined
              18 ldnil pos=27 op1=0 // 0 <- nil
              19 bend pos=21 block=16
            13 fdecl ln=8 pos=13 ident=sigterm ident_num=9 decl_scope=3 public_p=1 fblock=20
            20 fblock pos=33 next=21 fdecl=13 class_p=1 pars_num=1 scope=3 vars_num=1 tvars_num=0 ext_life_p=1 // ident=sigterm
              14 vdecl pos=22 ident=msg ident_num=3 decl_scope=20 public_p=1 var_num=0

              21 btdef pos=22 op1=0 pc=23 // goto 23 unless 0 is undefined
              22 ldnil pos=28 op1=0 // 0 <- nil
              23 bend pos=22 block=20
            15 fdecl ln=9 pos=13 ident=sigsegv ident_num=10 decl_scope=3 public_p=1 fblock=24
            24 fblock pos=33 next=25 fdecl=15 class_p=1 pars_num=1 scope=3 vars_num=1 tvars_num=0 ext_life_p=1 // ident=sigsegv
              16 vdecl pos=22 ident=msg ident_num=3 decl_scope=24 public_p=1 var_num=0

              25 btdef pos=22 op1=0 pc=27 // goto 27 unless 0 is undefined
              26 ldnil pos=28 op1=0 // 0 <- nil
              27 bend pos=22 block=24

            28 btdef ln=3 pos=19 op1=0 pc=30 // goto 30 unless 0 is undefined
            29 ldnil pos=25 op1=0 // 0 <- nil
            30 bend ln=9 pos=22 block=3
          17 fdecl ln=11 pos=11 ident=invenv ident_num=11 decl_scope=2 public_p=1 fblock=31
          31 fblock pos=30 next=32 fdecl=17 class_p=1 pars_num=1 scope=2 vars_num=1 tvars_num=0 ext_life_p=1 // ident=invenv
            18 vdecl pos=19 ident=msg ident_num=3 decl_scope=31 public_p=1 var_num=0

            32 btdef pos=19 op1=0 pc=34 // goto 34 unless 0 is undefined
            33 ldnil pos=25 op1=0 // 0 <- nil
            34 bend pos=19 block=31
          19 fdecl ln=12 pos=11 ident=invop ident_num=12 decl_scope=2 public_p=1 fblock=35
          35 fblock pos=29 next=44 fdecl=19 class_p=1 pars_num=1 scope=2 vars_num=1 tvars_num=0 ext_life_p=1 // ident=invop
            20 vdecl pos=18 ident=msg ident_num=3 decl_scope=35 public_p=1 var_num=0
            21 fdecl ln=13 pos=13 ident=optype ident_num=13 decl_scope=35 public_p=1 fblock=36
            36 fblock pos=32 next=37 fdecl=21 class_p=1 pars_num=1 scope=35 vars_num=1 tvars_num=0 ext_life_p=1 // ident=optype
              22 vdecl pos=21 ident=msg ident_num=3 decl_scope=36 public_p=1 var_num=0

              37 btdef pos=21 op1=0 pc=39 // goto 39 unless 0 is undefined
              38 ldnil pos=27 op1=0 // 0 <- nil
              39 bend pos=21 block=36
            23 fdecl ln=14 pos=13 ident=opvalue ident_num=14 decl_scope=35 public_p=1 fblock=40
            40 fblock pos=33 next=41 fdecl=23 class_p=1 pars_num=1 scope=35 vars_num=1 tvars_num=0 ext_life_p=1 // ident=opvalue
              24 vdecl pos=22 ident=msg ident_num=3 decl_scope=40 public_p=1 var_num=0

              41 btdef pos=22 op1=0 pc=43 // goto 43 unless 0 is undefined
              42 ldnil pos=28 op1=0 // 0 <- nil
              43 bend pos=22 block=40

            44 btdef ln=12 pos=18 op1=0 pc=46 // goto 46 unless 0 is undefined
            45 ldnil pos=24 op1=0 // 0 <- nil
            46 bend ln=14 pos=22 block=35
          25 fdecl ln=16 pos=11 ident=invindex ident_num=15 decl_scope=2 public_p=1 fblock=47
          47 fblock pos=32 next=60 fdecl=25 class_p=1 pars_num=1 scope=2 vars_num=1 tvars_num=0 ext_life_p=1 // ident=invindex
            26 vdecl pos=21 ident=msg ident_num=3 decl_scope=47 public_p=1 var_num=0
            27 fdecl ln=17 pos=13 ident=indextype ident_num=16 decl_scope=47 public_p=1 fblock=48
            48 fblock pos=35 next=49 fdecl=27 class_p=1 pars_num=1 scope=47 vars_num=1 tvars_num=0 ext_life_p=1 // ident=indextype
              28 vdecl pos=24 ident=msg ident_num=3 decl_scope=48 public_p=1 var_num=0

              49 btdef pos=24 op1=0 pc=51 // goto 51 unless 0 is undefined
              50 ldnil pos=30 op1=0 // 0 <- nil
              51 bend pos=24 block=48
            29 fdecl ln=18 pos=13 ident=indexvalue ident_num=17 decl_scope=47 public_p=1 fblock=52
            52 fblock pos=36 next=53 fdecl=29 class_p=1 pars_num=1 scope=47 vars_num=1 tvars_num=0 ext_life_p=1 // ident=indexvalue
              30 vdecl pos=25 ident=msg ident_num=3 decl_scope=52 public_p=1 var_num=0

              53 btdef pos=25 op1=0 pc=55 // goto 55 unless 0 is undefined
              54 ldnil pos=31 op1=0 // 0 <- nil
              55 bend pos=25 block=52
            31 fdecl ln=19 pos=13 ident=indexop ident_num=18 decl_scope=47 public_p=1 fblock=56
            56 fblock pos=33 next=57 fdecl=31 class_p=1 pars_num=1 scope=47 vars_num=1 tvars_num=0 ext_life_p=1 // ident=indexop
              32 vdecl pos=22 ident=msg ident_num=3 decl_scope=56 public_p=1 var_num=0

              57 btdef pos=22 op1=0 pc=59 // goto 59 unless 0 is undefined
              58 ldnil pos=28 op1=0 // 0 <- nil
              59 bend pos=22 block=56

            60 btdef ln=16 pos=21 op1=0 pc=62 // goto 62 unless 0 is undefined
            61 ldnil pos=27 op1=0 // 0 <- nil
            62 bend ln=19 pos=22 block=47
          33 fdecl ln=21 pos=11 ident=invslice ident_num=19 decl_scope=2 public_p=1 fblock=63
          63 fblock pos=32 next=72 fdecl=33 class_p=1 pars_num=1 scope=2 vars_num=1 tvars_num=0 ext_life_p=1 // ident=invslice
            34 vdecl pos=21 ident=msg ident_num=3 decl_scope=63 public_p=1 var_num=0
            35 fdecl ln=22 pos=13 ident=slicetype ident_num=20 decl_scope=63 public_p=1 fblock=64
            64 fblock pos=35 next=65 fdecl=35 class_p=1 pars_num=1 scope=63 vars_num=1 tvars_num=0 ext_life_p=1 // ident=slicetype
              36 vdecl pos=24 ident=msg ident_num=3 decl_scope=64 public_p=1 var_num=0

              65 btdef pos=24 op1=0 pc=67 // goto 67 unless 0 is undefined
              66 ldnil pos=30 op1=0 // 0 <- nil
              67 bend pos=24 block=64
            37 fdecl ln=23 pos=13 ident=sliceform ident_num=21 decl_scope=63 public_p=1 fblock=68
            68 fblock pos=35 next=69 fdecl=37 class_p=1 pars_num=1 scope=63 vars_num=1 tvars_num=0 ext_life_p=1 // ident=sliceform
              38 vdecl pos=24 ident=msg ident_num=3 decl_scope=68 public_p=1 var_num=0

              69 btdef pos=24 op1=0 pc=71 // goto 71 unless 0 is undefined
              70 ldnil pos=30 op1=0 // 0 <- nil
              71 bend pos=24 block=68

            72 btdef ln=21 pos=21 op1=0 pc=74 // goto 74 unless 0 is undefined
            73 ldnil pos=27 op1=0 // 0 <- nil
            74 bend ln=23 pos=24 block=63
          39 fdecl ln=25 pos=11 ident=invector ident_num=22 decl_scope=2 public_p=1 fblock=75
          75 fblock pos=32 next=88 fdecl=39 class_p=1 pars_num=1 scope=2 vars_num=1 tvars_num=0 ext_life_p=1 // ident=invector
            40 vdecl pos=21 ident=msg ident_num=3 decl_scope=75 public_p=1 var_num=0
            41 fdecl ln=26 pos=13 ident=veclen ident_num=23 decl_scope=75 public_p=1 fblock=76
            76 fblock pos=32 next=77 fdecl=41 class_p=1 pars_num=1 scope=75 vars_num=1 tvars_num=0 ext_life_p=1 // ident=veclen
              42 vdecl pos=21 ident=msg ident_num=3 decl_scope=76 public_p=1 var_num=0

              77 btdef pos=21 op1=0 pc=79 // goto 79 unless 0 is undefined
              78 ldnil pos=27 op1=0 // 0 <- nil
              79 bend pos=21 block=76
            43 fdecl ln=27 pos=13 ident=vecform ident_num=24 decl_scope=75 public_p=1 fblock=80
            80 fblock pos=33 next=81 fdecl=43 class_p=1 pars_num=1 scope=75 vars_num=1 tvars_num=0 ext_life_p=1 // ident=vecform
              44 vdecl pos=22 ident=msg ident_num=3 decl_scope=80 public_p=1 var_num=0

              81 btdef pos=22 op1=0 pc=83 // goto 83 unless 0 is undefined
              82 ldnil pos=28 op1=0 // 0 <- nil
              83 bend pos=22 block=80
            45 fdecl ln=28 pos=13 ident=matrixform ident_num=25 decl_scope=75 public_p=1 fblock=84
            84 fblock pos=36 next=85 fdecl=45 class_p=1 pars_num=1 scope=75 vars_num=1 tvars_num=0 ext_life_p=1 // ident=matrixform
              46 vdecl pos=25 ident=msg ident_num=3 decl_scope=84 public_p=1 var_num=0

              85 btdef pos=25 op1=0 pc=87 // goto 87 unless 0 is undefined
              86 ldnil pos=31 op1=0 // 0 <- nil
              87 bend pos=25 block=84

            88 btdef ln=25 pos=21 op1=0 pc=90 // goto 90 unless 0 is undefined
            89 ldnil pos=27 op1=0 // 0 <- nil
            90 bend ln=28 pos=25 block=75
          47 fdecl ln=30 pos=11 ident=invkey ident_num=26 decl_scope=2 public_p=1 fblock=91
          91 fblock pos=30 next=100 fdecl=47 class_p=1 pars_num=1 scope=2 vars_num=1 tvars_num=0 ext_life_p=1 // ident=invkey
            48 vdecl pos=19 ident=msg ident_num=3 decl_scope=91 public_p=1 var_num=0
            49 fdecl ln=31 pos=13 ident=keyvalue ident_num=27 decl_scope=91 public_p=1 fblock=92
            92 fblock pos=34 next=93 fdecl=49 class_p=1 pars_num=1 scope=91 vars_num=1 tvars_num=0 ext_life_p=1 // ident=keyvalue
              50 vdecl pos=23 ident=msg ident_num=3 decl_scope=92 public_p=1 var_num=0

              93 btdef pos=23 op1=0 pc=95 // goto 95 unless 0 is undefined
              94 ldnil pos=29 op1=0 // 0 <- nil
              95 bend pos=23 block=92
            51 fdecl ln=32 pos=13 ident=keyop ident_num=28 decl_scope=91 public_p=1 fblock=96
            96 fblock pos=31 next=97 fdecl=51 class_p=1 pars_num=1 scope=91 vars_num=1 tvars_num=0 ext_life_p=1 // ident=keyop
              52 vdecl pos=20 ident=msg ident_num=3 decl_scope=96 public_p=1 var_num=0

              97 btdef pos=20 op1=0 pc=99 // goto 99 unless 0 is undefined
              98 ldnil pos=26 op1=0 // 0 <- nil
              99 bend pos=20 block=96

           100 btdef ln=30 pos=19 op1=0 pc=102 // goto 102 unless 0 is undefined
           101 ldnil pos=25 op1=0 // 0 <- nil
           102 bend ln=32 pos=20 block=91
          53 fdecl ln=34 pos=11 ident=invcall ident_num=29 decl_scope=2 public_p=1 fblock=103
         103 fblock pos=31 next=380 fdecl=53 class_p=1 pars_num=1 scope=2 vars_num=1 tvars_num=0 ext_life_p=1 // ident=invcall
            54 vdecl pos=20 ident=msg ident_num=3 decl_scope=103 public_p=1 var_num=0
            55 fdecl ln=35 pos=13 ident=callop ident_num=30 decl_scope=103 public_p=1 fblock=104
           104 fblock pos=32 next=105 fdecl=55 class_p=1 pars_num=1 scope=103 vars_num=1 tvars_num=0 ext_life_p=1 // ident=callop
              56 vdecl pos=21 ident=msg ident_num=3 decl_scope=104 public_p=1 var_num=0

             105 btdef pos=21 op1=0 pc=107 // goto 107 unless 0 is undefined
             106 ldnil pos=27 op1=0 // 0 <- nil
             107 bend pos=21 block=104
            57 fdecl ln=36 pos=13 ident=partype ident_num=31 decl_scope=103 public_p=1 fblock=108
           108 fblock pos=33 next=109 fdecl=57 class_p=1 pars_num=1 scope=103 vars_num=1 tvars_num=0 ext_life_p=1 // ident=partype
              58 vdecl pos=22 ident=msg ident_num=3 decl_scope=108 public_p=1 var_num=0

             109 btdef pos=22 op1=0 pc=111 // goto 111 unless 0 is undefined
             110 ldnil pos=28 op1=0 // 0 <- nil
             111 bend pos=22 block=108
            59 fdecl ln=37 pos=13 ident=invresult ident_num=32 decl_scope=103 public_p=1 fblock=112
           112 fblock pos=35 next=113 fdecl=59 class_p=1 pars_num=1 scope=103 vars_num=1 tvars_num=0 ext_life_p=1 // ident=invresult
              60 vdecl pos=24 ident=msg ident_num=3 decl_scope=112 public_p=1 var_num=0

             113 btdef pos=24 op1=0 pc=115 // goto 115 unless 0 is undefined
             114 ldnil pos=30 op1=0 // 0 <- nil
             115 bend pos=24 block=112
            61 fdecl ln=38 pos=13 ident=invinput ident_num=33 decl_scope=103 public_p=1 fblock=116
           116 fblock pos=34 next=117 fdecl=61 class_p=1 pars_num=1 scope=103 vars_num=1 tvars_num=0 ext_life_p=1 // ident=invinput
              62 vdecl pos=23 ident=msg ident_num=3 decl_scope=116 public_p=1 var_num=0

             117 btdef pos=23 op1=0 pc=119 // goto 119 unless 0 is undefined
             118 ldnil pos=29 op1=0 // 0 <- nil
             119 bend pos=23 block=116
            63 fdecl ln=39 pos=13 ident=invfmt ident_num=34 decl_scope=103 public_p=1 fblock=120
           120 fblock pos=32 next=121 fdecl=63 class_p=1 pars_num=1 scope=103 vars_num=1 tvars_num=0 ext_life_p=1 // ident=invfmt
              64 vdecl pos=21 ident=msg ident_num=3 decl_scope=120 public_p=1 var_num=0

             121 btdef pos=21 op1=0 pc=123 // goto 123 unless 0 is undefined
             122 ldnil pos=27 op1=0 // 0 <- nil
             123 bend pos=21 block=120
            65 fdecl ln=40 pos=13 ident=eof ident_num=35 decl_scope=103 public_p=1 fblock=124
           124 fblock pos=29 next=125 fdecl=65 class_p=1 pars_num=1 scope=103 vars_num=1 tvars_num=0 ext_life_p=1 // ident=eof
              66 vdecl pos=18 ident=msg ident_num=3 decl_scope=124 public_p=1 var_num=0

             125 btdef pos=18 op1=0 pc=127 // goto 127 unless 0 is undefined
             126 ldnil pos=24 op1=0 // 0 <- nil
             127 bend pos=18 block=124
            67 fdecl ln=41 pos=13 ident=parnumber ident_num=36 decl_scope=103 public_p=1 fblock=128
           128 fblock pos=35 next=129 fdecl=67 class_p=1 pars_num=1 scope=103 vars_num=1 tvars_num=0 ext_life_p=1 // ident=parnumber
              68 vdecl pos=24 ident=msg ident_num=3 decl_scope=128 public_p=1 var_num=0

             129 btdef pos=24 op1=0 pc=131 // goto 131 unless 0 is undefined
             130 ldnil pos=30 op1=0 // 0 <- nil
             131 bend pos=24 block=128
            69 fdecl ln=42 pos=13 ident=syncthreadcall ident_num=37 decl_scope=103 public_p=1 fblock=132
           132 fblock pos=40 next=133 fdecl=69 class_p=1 pars_num=1 scope=103 vars_num=1 tvars_num=0 ext_life_p=1 // ident=syncthreadcall
              70 vdecl pos=29 ident=msg ident_num=3 decl_scope=132 public_p=1 var_num=0

             133 btdef pos=29 op1=0 pc=135 // goto 135 unless 0 is undefined
             134 ldnil pos=35 op1=0 // 0 <- nil
             135 bend pos=29 block=132
            71 fdecl ln=43 pos=13 ident=syserror ident_num=38 decl_scope=103 public_p=1 fblock=136
           136 fblock pos=34 next=281 fdecl=71 class_p=1 pars_num=1 scope=103 vars_num=1 tvars_num=0 ext_life_p=1 // ident=syserror
              72 vdecl pos=23 ident=msg ident_num=3 decl_scope=136 public_p=1 var_num=0
              73 fdecl ln=44 pos=15 ident=eaccess ident_num=39 decl_scope=136 public_p=1 fblock=137
             137 fblock pos=35 next=138 fdecl=73 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=eaccess
                74 vdecl pos=24 ident=msg ident_num=3 decl_scope=137 public_p=1 var_num=0

               138 btdef pos=24 op1=0 pc=140 // goto 140 unless 0 is undefined
               139 ldnil pos=30 op1=0 // 0 <- nil
               140 bend pos=24 block=137
              75 fdecl ln=45 pos=15 ident=eagain ident_num=40 decl_scope=136 public_p=1 fblock=141
             141 fblock pos=34 next=142 fdecl=75 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=eagain
                76 vdecl pos=23 ident=msg ident_num=3 decl_scope=141 public_p=1 var_num=0

               142 btdef pos=23 op1=0 pc=144 // goto 144 unless 0 is undefined
               143 ldnil pos=29 op1=0 // 0 <- nil
               144 bend pos=23 block=141
              77 fdecl ln=46 pos=15 ident=ebadf ident_num=41 decl_scope=136 public_p=1 fblock=145
             145 fblock pos=33 next=146 fdecl=77 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=ebadf
                78 vdecl pos=22 ident=msg ident_num=3 decl_scope=145 public_p=1 var_num=0

               146 btdef pos=22 op1=0 pc=148 // goto 148 unless 0 is undefined
               147 ldnil pos=28 op1=0 // 0 <- nil
               148 bend pos=22 block=145
              79 fdecl ln=47 pos=15 ident=ebusy ident_num=42 decl_scope=136 public_p=1 fblock=149
             149 fblock pos=33 next=150 fdecl=79 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=ebusy
                80 vdecl pos=22 ident=msg ident_num=3 decl_scope=149 public_p=1 var_num=0

               150 btdef pos=22 op1=0 pc=152 // goto 152 unless 0 is undefined
               151 ldnil pos=28 op1=0 // 0 <- nil
               152 bend pos=22 block=149
              81 fdecl ln=48 pos=15 ident=echild ident_num=43 decl_scope=136 public_p=1 fblock=153
             153 fblock pos=34 next=154 fdecl=81 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=echild
                82 vdecl pos=23 ident=msg ident_num=3 decl_scope=153 public_p=1 var_num=0

               154 btdef pos=23 op1=0 pc=156 // goto 156 unless 0 is undefined
               155 ldnil pos=29 op1=0 // 0 <- nil
               156 bend pos=23 block=153
              83 fdecl ln=49 pos=15 ident=edeadlk ident_num=44 decl_scope=136 public_p=1 fblock=157
             157 fblock pos=35 next=158 fdecl=83 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=edeadlk
                84 vdecl pos=24 ident=msg ident_num=3 decl_scope=157 public_p=1 var_num=0

               158 btdef pos=24 op1=0 pc=160 // goto 160 unless 0 is undefined
               159 ldnil pos=30 op1=0 // 0 <- nil
               160 bend pos=24 block=157
              85 fdecl ln=50 pos=15 ident=edom ident_num=45 decl_scope=136 public_p=1 fblock=161
             161 fblock pos=32 next=162 fdecl=85 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=edom
                86 vdecl pos=21 ident=msg ident_num=3 decl_scope=161 public_p=1 var_num=0

               162 btdef pos=21 op1=0 pc=164 // goto 164 unless 0 is undefined
               163 ldnil pos=27 op1=0 // 0 <- nil
               164 bend pos=21 block=161
              87 fdecl ln=51 pos=15 ident=eexist ident_num=46 decl_scope=136 public_p=1 fblock=165
             165 fblock pos=34 next=166 fdecl=87 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=eexist
                88 vdecl pos=23 ident=msg ident_num=3 decl_scope=165 public_p=1 var_num=0

               166 btdef pos=23 op1=0 pc=168 // goto 168 unless 0 is undefined
               167 ldnil pos=29 op1=0 // 0 <- nil
               168 bend pos=23 block=165
              89 fdecl ln=52 pos=15 ident=efault ident_num=47 decl_scope=136 public_p=1 fblock=169
             169 fblock pos=34 next=170 fdecl=89 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=efault
                90 vdecl pos=23 ident=msg ident_num=3 decl_scope=169 public_p=1 var_num=0

               170 btdef pos=23 op1=0 pc=172 // goto 172 unless 0 is undefined
               171 ldnil pos=29 op1=0 // 0 <- nil
               172 bend pos=23 block=169
              91 fdecl ln=53 pos=15 ident=efbig ident_num=48 decl_scope=136 public_p=1 fblock=173
             173 fblock pos=33 next=174 fdecl=91 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=efbig
                92 vdecl pos=22 ident=msg ident_num=3 decl_scope=173 public_p=1 var_num=0

               174 btdef pos=22 op1=0 pc=176 // goto 176 unless 0 is undefined
               175 ldnil pos=28 op1=0 // 0 <- nil
               176 bend pos=22 block=173
              93 fdecl ln=54 pos=15 ident=eintr ident_num=49 decl_scope=136 public_p=1 fblock=177
             177 fblock pos=33 next=178 fdecl=93 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=eintr
                94 vdecl pos=22 ident=msg ident_num=3 decl_scope=177 public_p=1 var_num=0

               178 btdef pos=22 op1=0 pc=180 // goto 180 unless 0 is undefined
               179 ldnil pos=28 op1=0 // 0 <- nil
               180 bend pos=22 block=177
              95 fdecl ln=55 pos=15 ident=einval ident_num=50 decl_scope=136 public_p=1 fblock=181
             181 fblock pos=34 next=182 fdecl=95 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=einval
                96 vdecl pos=23 ident=msg ident_num=3 decl_scope=181 public_p=1 var_num=0

               182 btdef pos=23 op1=0 pc=184 // goto 184 unless 0 is undefined
               183 ldnil pos=29 op1=0 // 0 <- nil
               184 bend pos=23 block=181
              97 fdecl ln=56 pos=15 ident=eio ident_num=51 decl_scope=136 public_p=1 fblock=185
             185 fblock pos=31 next=186 fdecl=97 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=eio
                98 vdecl pos=20 ident=msg ident_num=3 decl_scope=185 public_p=1 var_num=0

               186 btdef pos=20 op1=0 pc=188 // goto 188 unless 0 is undefined
               187 ldnil pos=26 op1=0 // 0 <- nil
               188 bend pos=20 block=185
              99 fdecl ln=57 pos=15 ident=eisdir ident_num=52 decl_scope=136 public_p=1 fblock=189
             189 fblock pos=34 next=190 fdecl=99 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=eisdir
               100 vdecl pos=23 ident=msg ident_num=3 decl_scope=189 public_p=1 var_num=0

               190 btdef pos=23 op1=0 pc=192 // goto 192 unless 0 is undefined
               191 ldnil pos=29 op1=0 // 0 <- nil
               192 bend pos=23 block=189
             101 fdecl ln=58 pos=15 ident=emfile ident_num=53 decl_scope=136 public_p=1 fblock=193
             193 fblock pos=34 next=194 fdecl=101 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=emfile
               102 vdecl pos=23 ident=msg ident_num=3 decl_scope=193 public_p=1 var_num=0

               194 btdef pos=23 op1=0 pc=196 // goto 196 unless 0 is undefined
               195 ldnil pos=29 op1=0 // 0 <- nil
               196 bend pos=23 block=193
             103 fdecl ln=59 pos=15 ident=emlink ident_num=54 decl_scope=136 public_p=1 fblock=197
             197 fblock pos=34 next=198 fdecl=103 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=emlink
               104 vdecl pos=23 ident=msg ident_num=3 decl_scope=197 public_p=1 var_num=0

               198 btdef pos=23 op1=0 pc=200 // goto 200 unless 0 is undefined
               199 ldnil pos=29 op1=0 // 0 <- nil
               200 bend pos=23 block=197
             105 fdecl ln=60 pos=15 ident=enametoolong ident_num=55 decl_scope=136 public_p=1 fblock=201
             201 fblock pos=40 next=202 fdecl=105 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=enametoolong
               106 vdecl pos=29 ident=msg ident_num=3 decl_scope=201 public_p=1 var_num=0

               202 btdef pos=29 op1=0 pc=204 // goto 204 unless 0 is undefined
               203 ldnil pos=35 op1=0 // 0 <- nil
               204 bend pos=29 block=201
             107 fdecl ln=61 pos=15 ident=enfile ident_num=56 decl_scope=136 public_p=1 fblock=205
             205 fblock pos=34 next=206 fdecl=107 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=enfile
               108 vdecl pos=23 ident=msg ident_num=3 decl_scope=205 public_p=1 var_num=0

               206 btdef pos=23 op1=0 pc=208 // goto 208 unless 0 is undefined
               207 ldnil pos=29 op1=0 // 0 <- nil
               208 bend pos=23 block=205
             109 fdecl ln=62 pos=15 ident=enodev ident_num=57 decl_scope=136 public_p=1 fblock=209
             209 fblock pos=34 next=210 fdecl=109 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=enodev
               110 vdecl pos=23 ident=msg ident_num=3 decl_scope=209 public_p=1 var_num=0

               210 btdef pos=23 op1=0 pc=212 // goto 212 unless 0 is undefined
               211 ldnil pos=29 op1=0 // 0 <- nil
               212 bend pos=23 block=209
             111 fdecl ln=63 pos=15 ident=enoent ident_num=58 decl_scope=136 public_p=1 fblock=213
             213 fblock pos=34 next=214 fdecl=111 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=enoent
               112 vdecl pos=23 ident=msg ident_num=3 decl_scope=213 public_p=1 var_num=0

               214 btdef pos=23 op1=0 pc=216 // goto 216 unless 0 is undefined
               215 ldnil pos=29 op1=0 // 0 <- nil
               216 bend pos=23 block=213
             113 fdecl ln=64 pos=15 ident=enoexec ident_num=59 decl_scope=136 public_p=1 fblock=217
             217 fblock pos=35 next=218 fdecl=113 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=enoexec
               114 vdecl pos=24 ident=msg ident_num=3 decl_scope=217 public_p=1 var_num=0

               218 btdef pos=24 op1=0 pc=220 // goto 220 unless 0 is undefined
               219 ldnil pos=30 op1=0 // 0 <- nil
               220 bend pos=24 block=217
             115 fdecl ln=65 pos=15 ident=enolck ident_num=60 decl_scope=136 public_p=1 fblock=221
             221 fblock pos=34 next=222 fdecl=115 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=enolck
               116 vdecl pos=23 ident=msg ident_num=3 decl_scope=221 public_p=1 var_num=0

               222 btdef pos=23 op1=0 pc=224 // goto 224 unless 0 is undefined
               223 ldnil pos=29 op1=0 // 0 <- nil
               224 bend pos=23 block=221
             117 fdecl ln=66 pos=15 ident=enomem ident_num=61 decl_scope=136 public_p=1 fblock=225
             225 fblock pos=34 next=226 fdecl=117 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=enomem
               118 vdecl pos=23 ident=msg ident_num=3 decl_scope=225 public_p=1 var_num=0

               226 btdef pos=23 op1=0 pc=228 // goto 228 unless 0 is undefined
               227 ldnil pos=29 op1=0 // 0 <- nil
               228 bend pos=23 block=225
             119 fdecl ln=67 pos=15 ident=enospc ident_num=62 decl_scope=136 public_p=1 fblock=229
             229 fblock pos=34 next=230 fdecl=119 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=enospc
               120 vdecl pos=23 ident=msg ident_num=3 decl_scope=229 public_p=1 var_num=0

               230 btdef pos=23 op1=0 pc=232 // goto 232 unless 0 is undefined
               231 ldnil pos=29 op1=0 // 0 <- nil
               232 bend pos=23 block=229
             121 fdecl ln=68 pos=15 ident=enosys ident_num=63 decl_scope=136 public_p=1 fblock=233
             233 fblock pos=34 next=234 fdecl=121 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=enosys
               122 vdecl pos=23 ident=msg ident_num=3 decl_scope=233 public_p=1 var_num=0

               234 btdef pos=23 op1=0 pc=236 // goto 236 unless 0 is undefined
               235 ldnil pos=29 op1=0 // 0 <- nil
               236 bend pos=23 block=233
             123 fdecl ln=69 pos=15 ident=enotdir ident_num=64 decl_scope=136 public_p=1 fblock=237
             237 fblock pos=35 next=238 fdecl=123 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=enotdir
               124 vdecl pos=24 ident=msg ident_num=3 decl_scope=237 public_p=1 var_num=0

               238 btdef pos=24 op1=0 pc=240 // goto 240 unless 0 is undefined
               239 ldnil pos=30 op1=0 // 0 <- nil
               240 bend pos=24 block=237
             125 fdecl ln=70 pos=15 ident=enotempty ident_num=65 decl_scope=136 public_p=1 fblock=241
             241 fblock pos=37 next=242 fdecl=125 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=enotempty
               126 vdecl pos=26 ident=msg ident_num=3 decl_scope=241 public_p=1 var_num=0

               242 btdef pos=26 op1=0 pc=244 // goto 244 unless 0 is undefined
               243 ldnil pos=32 op1=0 // 0 <- nil
               244 bend pos=26 block=241
             127 fdecl ln=71 pos=15 ident=enotty ident_num=66 decl_scope=136 public_p=1 fblock=245
             245 fblock pos=34 next=246 fdecl=127 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=enotty
               128 vdecl pos=23 ident=msg ident_num=3 decl_scope=245 public_p=1 var_num=0

               246 btdef pos=23 op1=0 pc=248 // goto 248 unless 0 is undefined
               247 ldnil pos=29 op1=0 // 0 <- nil
               248 bend pos=23 block=245
             129 fdecl ln=72 pos=15 ident=enxio ident_num=67 decl_scope=136 public_p=1 fblock=249
             249 fblock pos=33 next=250 fdecl=129 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=enxio
               130 vdecl pos=22 ident=msg ident_num=3 decl_scope=249 public_p=1 var_num=0

               250 btdef pos=22 op1=0 pc=252 // goto 252 unless 0 is undefined
               251 ldnil pos=28 op1=0 // 0 <- nil
               252 bend pos=22 block=249
             131 fdecl ln=73 pos=15 ident=eperm ident_num=68 decl_scope=136 public_p=1 fblock=253
             253 fblock pos=33 next=254 fdecl=131 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=eperm
               132 vdecl pos=22 ident=msg ident_num=3 decl_scope=253 public_p=1 var_num=0

               254 btdef pos=22 op1=0 pc=256 // goto 256 unless 0 is undefined
               255 ldnil pos=28 op1=0 // 0 <- nil
               256 bend pos=22 block=253
             133 fdecl ln=74 pos=15 ident=epipe ident_num=69 decl_scope=136 public_p=1 fblock=257
             257 fblock pos=33 next=258 fdecl=133 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=epipe
               134 vdecl pos=22 ident=msg ident_num=3 decl_scope=257 public_p=1 var_num=0

               258 btdef pos=22 op1=0 pc=260 // goto 260 unless 0 is undefined
               259 ldnil pos=28 op1=0 // 0 <- nil
               260 bend pos=22 block=257
             135 fdecl ln=75 pos=15 ident=erange ident_num=70 decl_scope=136 public_p=1 fblock=261
             261 fblock pos=34 next=262 fdecl=135 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=erange
               136 vdecl pos=23 ident=msg ident_num=3 decl_scope=261 public_p=1 var_num=0

               262 btdef pos=23 op1=0 pc=264 // goto 264 unless 0 is undefined
               263 ldnil pos=29 op1=0 // 0 <- nil
               264 bend pos=23 block=261
             137 fdecl ln=76 pos=15 ident=erofs ident_num=71 decl_scope=136 public_p=1 fblock=265
             265 fblock pos=33 next=266 fdecl=137 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=erofs
               138 vdecl pos=22 ident=msg ident_num=3 decl_scope=265 public_p=1 var_num=0

               266 btdef pos=22 op1=0 pc=268 // goto 268 unless 0 is undefined
               267 ldnil pos=28 op1=0 // 0 <- nil
               268 bend pos=22 block=265
             139 fdecl ln=77 pos=15 ident=espipe ident_num=72 decl_scope=136 public_p=1 fblock=269
             269 fblock pos=34 next=270 fdecl=139 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=espipe
               140 vdecl pos=23 ident=msg ident_num=3 decl_scope=269 public_p=1 var_num=0

               270 btdef pos=23 op1=0 pc=272 // goto 272 unless 0 is undefined
               271 ldnil pos=29 op1=0 // 0 <- nil
               272 bend pos=23 block=269
             141 fdecl ln=78 pos=15 ident=esrch ident_num=73 decl_scope=136 public_p=1 fblock=273
             273 fblock pos=33 next=274 fdecl=141 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=esrch
               142 vdecl pos=22 ident=msg ident_num=3 decl_scope=273 public_p=1 var_num=0

               274 btdef pos=22 op1=0 pc=276 // goto 276 unless 0 is undefined
               275 ldnil pos=28 op1=0 // 0 <- nil
               276 bend pos=22 block=273
             143 fdecl ln=79 pos=15 ident=exdev ident_num=74 decl_scope=136 public_p=1 fblock=277
             277 fblock pos=33 next=278 fdecl=143 class_p=1 pars_num=1 scope=136 vars_num=1 tvars_num=0 ext_life_p=1 // ident=exdev
               144 vdecl pos=22 ident=msg ident_num=3 decl_scope=277 public_p=1 var_num=0

               278 btdef pos=22 op1=0 pc=280 // goto 280 unless 0 is undefined
               279 ldnil pos=28 op1=0 // 0 <- nil
               280 bend pos=22 block=277

             281 btdef ln=43 pos=23 op1=0 pc=283 // goto 283 unless 0 is undefined
             282 ldnil pos=29 op1=0 // 0 <- nil
             283 bend ln=79 pos=22 block=136
           145 fdecl ln=81 pos=13 ident=systemcall ident_num=75 decl_scope=103 public_p=1 fblock=284
           284 fblock pos=36 next=293 fdecl=145 class_p=1 pars_num=1 scope=103 vars_num=1 tvars_num=0 ext_life_p=1 // ident=systemcall
             146 vdecl pos=25 ident=msg ident_num=3 decl_scope=284 public_p=1 var_num=0
             147 fdecl ln=82 pos=15 ident=noshell ident_num=76 decl_scope=284 public_p=1 fblock=285
             285 fblock pos=35 next=286 fdecl=147 class_p=1 pars_num=1 scope=284 vars_num=1 tvars_num=0 ext_life_p=1 // ident=noshell
               148 vdecl pos=24 ident=msg ident_num=3 decl_scope=285 public_p=1 var_num=0

               286 btdef pos=24 op1=0 pc=288 // goto 288 unless 0 is undefined
               287 ldnil pos=30 op1=0 // 0 <- nil
               288 bend pos=24 block=285
             149 fdecl ln=83 pos=15 ident=systemfail ident_num=77 decl_scope=284 public_p=1 fblock=289
             289 fblock pos=38 next=290 fdecl=149 class_p=1 pars_num=1 scope=284 vars_num=1 tvars_num=0 ext_life_p=1 // ident=systemfail
               150 vdecl pos=27 ident=msg ident_num=3 decl_scope=289 public_p=1 var_num=0

               290 btdef pos=27 op1=0 pc=292 // goto 292 unless 0 is undefined
               291 ldnil pos=33 op1=0 // 0 <- nil
               292 bend pos=27 block=289

             293 btdef ln=81 pos=25 op1=0 pc=295 // goto 295 unless 0 is undefined
             294 ldnil pos=31 op1=0 // 0 <- nil
             295 bend ln=83 pos=27 block=284
           151 fdecl ln=85 pos=13 ident=invregexp ident_num=78 decl_scope=103 public_p=1 fblock=296
           296 fblock pos=35 next=337 fdecl=151 class_p=1 pars_num=1 scope=103 vars_num=1 tvars_num=0 ext_life_p=1 // ident=invregexp
             152 vdecl pos=24 ident=msg ident_num=3 decl_scope=296 public_p=1 var_num=0
             153 fdecl ln=86 pos=15 ident=ebrack ident_num=79 decl_scope=296 public_p=1 fblock=297
             297 fblock pos=34 next=298 fdecl=153 class_p=1 pars_num=1 scope=296 vars_num=1 tvars_num=0 ext_life_p=1 // ident=ebrack
               154 vdecl pos=23 ident=msg ident_num=3 decl_scope=297 public_p=1 var_num=0

               298 btdef pos=23 op1=0 pc=300 // goto 300 unless 0 is undefined
               299 ldnil pos=29 op1=0 // 0 <- nil
               300 bend pos=23 block=297
             155 fdecl ln=87 pos=15 ident=erange ident_num=70 decl_scope=296 public_p=1 fblock=301
             301 fblock pos=34 next=302 fdecl=155 class_p=1 pars_num=1 scope=296 vars_num=1 tvars_num=0 ext_life_p=1 // ident=erange
               156 vdecl pos=23 ident=msg ident_num=3 decl_scope=301 public_p=1 var_num=0

               302 btdef pos=23 op1=0 pc=304 // goto 304 unless 0 is undefined
               303 ldnil pos=29 op1=0 // 0 <- nil
               304 bend pos=23 block=301
             157 fdecl ln=88 pos=15 ident=ectype ident_num=80 decl_scope=296 public_p=1 fblock=305
             305 fblock pos=34 next=306 fdecl=157 class_p=1 pars_num=1 scope=296 vars_num=1 tvars_num=0 ext_life_p=1 // ident=ectype
               158 vdecl pos=23 ident=msg ident_num=3 decl_scope=305 public_p=1 var_num=0

               306 btdef pos=23 op1=0 pc=308 // goto 308 unless 0 is undefined
               307 ldnil pos=29 op1=0 // 0 <- nil
               308 bend pos=23 block=305
             159 fdecl ln=89 pos=15 ident=eparen ident_num=81 decl_scope=296 public_p=1 fblock=309
             309 fblock pos=34 next=310 fdecl=159 class_p=1 pars_num=1 scope=296 vars_num=1 tvars_num=0 ext_life_p=1 // ident=eparen
               160 vdecl pos=23 ident=msg ident_num=3 decl_scope=309 public_p=1 var_num=0

               310 btdef pos=23 op1=0 pc=312 // goto 312 unless 0 is undefined
               311 ldnil pos=29 op1=0 // 0 <- nil
               312 bend pos=23 block=309
             161 fdecl ln=90 pos=15 ident=esubreg ident_num=82 decl_scope=296 public_p=1 fblock=313
             313 fblock pos=35 next=314 fdecl=161 class_p=1 pars_num=1 scope=296 vars_num=1 tvars_num=0 ext_life_p=1 // ident=esubreg
               162 vdecl pos=24 ident=msg ident_num=3 decl_scope=313 public_p=1 var_num=0

               314 btdef pos=24 op1=0 pc=316 // goto 316 unless 0 is undefined
               315 ldnil pos=30 op1=0 // 0 <- nil
               316 bend pos=24 block=313
             163 fdecl ln=91 pos=15 ident=eend ident_num=83 decl_scope=296 public_p=1 fblock=317
             317 fblock pos=32 next=318 fdecl=163 class_p=1 pars_num=1 scope=296 vars_num=1 tvars_num=0 ext_life_p=1 // ident=eend
               164 vdecl pos=21 ident=msg ident_num=3 decl_scope=317 public_p=1 var_num=0

               318 btdef pos=21 op1=0 pc=320 // goto 320 unless 0 is undefined
               319 ldnil pos=27 op1=0 // 0 <- nil
               320 bend pos=21 block=317
             165 fdecl ln=92 pos=15 ident=eescape ident_num=84 decl_scope=296 public_p=1 fblock=321
             321 fblock pos=35 next=322 fdecl=165 class_p=1 pars_num=1 scope=296 vars_num=1 tvars_num=0 ext_life_p=1 // ident=eescape
               166 vdecl pos=24 ident=msg ident_num=3 decl_scope=321 public_p=1 var_num=0

               322 btdef pos=24 op1=0 pc=324 // goto 324 unless 0 is undefined
               323 ldnil pos=30 op1=0 // 0 <- nil
               324 bend pos=24 block=321
             167 fdecl ln=93 pos=15 ident=badpat ident_num=85 decl_scope=296 public_p=1 fblock=325
             325 fblock pos=34 next=326 fdecl=167 class_p=1 pars_num=1 scope=296 vars_num=1 tvars_num=0 ext_life_p=1 // ident=badpat
               168 vdecl pos=23 ident=msg ident_num=3 decl_scope=325 public_p=1 var_num=0

               326 btdef pos=23 op1=0 pc=328 // goto 328 unless 0 is undefined
               327 ldnil pos=29 op1=0 // 0 <- nil
               328 bend pos=23 block=325
             169 fdecl ln=94 pos=15 ident=esize ident_num=86 decl_scope=296 public_p=1 fblock=329
             329 fblock pos=33 next=330 fdecl=169 class_p=1 pars_num=1 scope=296 vars_num=1 tvars_num=0 ext_life_p=1 // ident=esize
               170 vdecl pos=22 ident=msg ident_num=3 decl_scope=329 public_p=1 var_num=0

               330 btdef pos=22 op1=0 pc=332 // goto 332 unless 0 is undefined
               331 ldnil pos=28 op1=0 // 0 <- nil
               332 bend pos=22 block=329
             171 fdecl ln=95 pos=15 ident=espace ident_num=87 decl_scope=296 public_p=1 fblock=333
             333 fblock pos=34 next=334 fdecl=171 class_p=1 pars_num=1 scope=296 vars_num=1 tvars_num=0 ext_life_p=1 // ident=espace
               172 vdecl pos=23 ident=msg ident_num=3 decl_scope=333 public_p=1 var_num=0

               334 btdef pos=23 op1=0 pc=336 // goto 336 unless 0 is undefined
               335 ldnil pos=29 op1=0 // 0 <- nil
               336 bend pos=23 block=333

             337 btdef ln=85 pos=24 op1=0 pc=339 // goto 339 unless 0 is undefined
             338 ldnil pos=30 op1=0 // 0 <- nil
             339 bend ln=95 pos=23 block=296
           173 fdecl ln=97 pos=13 ident=invparser ident_num=88 decl_scope=103 public_p=1 fblock=340
           340 fblock pos=35 next=353 fdecl=173 class_p=1 pars_num=1 scope=103 vars_num=1 tvars_num=0 ext_life_p=1 // ident=invparser
             174 vdecl pos=24 ident=msg ident_num=3 decl_scope=340 public_p=1 var_num=0
             175 fdecl ln=98 pos=15 ident=invgrammar ident_num=89 decl_scope=340 public_p=1 fblock=341
             341 fblock pos=38 next=342 fdecl=175 class_p=1 pars_num=1 scope=340 vars_num=1 tvars_num=0 ext_life_p=1 // ident=invgrammar
               176 vdecl pos=27 ident=msg ident_num=3 decl_scope=341 public_p=1 var_num=0

               342 btdef pos=27 op1=0 pc=344 // goto 344 unless 0 is undefined
               343 ldnil pos=33 op1=0 // 0 <- nil
               344 bend pos=27 block=341
             177 fdecl ln=99 pos=15 ident=invtoken ident_num=90 decl_scope=340 public_p=1 fblock=345
             345 fblock pos=36 next=346 fdecl=177 class_p=1 pars_num=1 scope=340 vars_num=1 tvars_num=0 ext_life_p=1 // ident=invtoken
               178 vdecl pos=25 ident=msg ident_num=3 decl_scope=345 public_p=1 var_num=0

               346 btdef pos=25 op1=0 pc=348 // goto 348 unless 0 is undefined
               347 ldnil pos=31 op1=0 // 0 <- nil
               348 bend pos=25 block=345
             179 fdecl ln=100 pos=15 ident=pmemory ident_num=91 decl_scope=340 public_p=1 fblock=349
             349 fblock pos=35 next=350 fdecl=179 class_p=1 pars_num=1 scope=340 vars_num=1 tvars_num=0 ext_life_p=1 // ident=pmemory
               180 vdecl pos=24 ident=msg ident_num=3 decl_scope=349 public_p=1 var_num=0

               350 btdef pos=24 op1=0 pc=352 // goto 352 unless 0 is undefined
               351 ldnil pos=30 op1=0 // 0 <- nil
               352 bend pos=24 block=349

             353 btdef ln=97 pos=24 op1=0 pc=355 // goto 355 unless 0 is undefined
             354 ldnil pos=30 op1=0 // 0 <- nil
             355 bend ln=100 pos=24 block=340
           181 fdecl ln=102 pos=13 ident=invextern ident_num=92 decl_scope=103 public_p=1 fblock=356
           356 fblock pos=35 next=369 fdecl=181 class_p=1 pars_num=1 scope=103 vars_num=1 tvars_num=0 ext_life_p=1 // ident=invextern
             182 vdecl pos=24 ident=msg ident_num=3 decl_scope=356 public_p=1 var_num=0
             183 fdecl ln=103 pos=15 ident=noextern ident_num=93 decl_scope=356 public_p=1 fblock=357
             357 fblock pos=36 next=358 fdecl=183 class_p=1 pars_num=1 scope=356 vars_num=1 tvars_num=0 ext_life_p=1 // ident=noextern
               184 vdecl pos=25 ident=msg ident_num=3 decl_scope=357 public_p=1 var_num=0

               358 btdef pos=25 op1=0 pc=360 // goto 360 unless 0 is undefined
               359 ldnil pos=31 op1=0 // 0 <- nil
               360 bend pos=25 block=357
             185 fdecl ln=104 pos=15 ident=libclose ident_num=94 decl_scope=356 public_p=1 fblock=361
             361 fblock pos=36 next=362 fdecl=185 class_p=1 pars_num=1 scope=356 vars_num=1 tvars_num=0 ext_life_p=1 // ident=libclose
               186 vdecl pos=25 ident=msg ident_num=3 decl_scope=361 public_p=1 var_num=0

               362 btdef pos=25 op1=0 pc=364 // goto 364 unless 0 is undefined
               363 ldnil pos=31 op1=0 // 0 <- nil
               364 bend pos=25 block=361
             187 fdecl ln=105 pos=15 ident=noexternsupp ident_num=95 decl_scope=356 public_p=1 fblock=365
             365 fblock pos=40 next=366 fdecl=187 class_p=1 pars_num=1 scope=356 vars_num=1 tvars_num=0 ext_life_p=1 // ident=noexternsupp
               188 vdecl pos=29 ident=msg ident_num=3 decl_scope=365 public_p=1 var_num=0

               366 btdef pos=29 op1=0 pc=368 // goto 368 unless 0 is undefined
               367 ldnil pos=35 op1=0 // 0 <- nil
               368 bend pos=29 block=365

             369 btdef ln=102 pos=24 op1=0 pc=371 // goto 371 unless 0 is undefined
             370 ldnil pos=30 op1=0 // 0 <- nil
             371 bend ln=105 pos=29 block=356
           189 fdecl ln=107 pos=13 ident=invenvar ident_num=96 decl_scope=103 public_p=1 fblock=372
           372 fblock pos=34 next=373 fdecl=189 class_p=1 pars_num=1 scope=103 vars_num=1 tvars_num=0 ext_life_p=1 // ident=invenvar
             190 vdecl pos=23 ident=msg ident_num=3 decl_scope=372 public_p=1 var_num=0

             373 btdef pos=23 op1=0 pc=375 // goto 375 unless 0 is undefined
             374 ldnil pos=29 op1=0 // 0 <- nil
             375 bend pos=23 block=372
           191 fdecl ln=108 pos=13 ident=internal ident_num=97 decl_scope=103 public_p=1 fblock=376
           376 fblock pos=34 next=377 fdecl=191 class_p=1 pars_num=1 scope=103 vars_num=1 tvars_num=0 ext_life_p=1 // ident=internal
             192 vdecl pos=23 ident=msg ident_num=3 decl_scope=376 public_p=1 var_num=0

             377 btdef pos=23 op1=0 pc=379 // goto 379 unless 0 is undefined
             378 ldnil pos=29 op1=0 // 0 <- nil
             379 bend pos=23 block=376

           380 btdef ln=34 pos=20 op1=0 pc=382 // goto 382 unless 0 is undefined
           381 ldnil pos=26 op1=0 // 0 <- nil
           382 bend ln=108 pos=23 block=103
         193 fdecl ln=110 pos=11 ident=invaccess ident_num=98 decl_scope=2 public_p=1 fblock=383
         383 fblock pos=33 next=396 fdecl=193 class_p=1 pars_num=1 scope=2 vars_num=1 tvars_num=0 ext_life_p=1 // ident=invaccess
           194 vdecl pos=22 ident=msg ident_num=3 decl_scope=383 public_p=1 var_num=0
           195 fdecl ln=111 pos=13 ident=accessop ident_num=99 decl_scope=383 public_p=1 fblock=384
           384 fblock pos=34 next=385 fdecl=195 class_p=1 pars_num=1 scope=383 vars_num=1 tvars_num=0 ext_life_p=1 // ident=accessop
             196 vdecl pos=23 ident=msg ident_num=3 decl_scope=384 public_p=1 var_num=0

             385 btdef pos=23 op1=0 pc=387 // goto 387 unless 0 is undefined
             386 ldnil pos=29 op1=0 // 0 <- nil
             387 bend pos=23 block=384
           197 fdecl ln=112 pos=13 ident=accessvalue ident_num=100 decl_scope=383 public_p=1 fblock=388
           388 fblock pos=37 next=389 fdecl=197 class_p=1 pars_num=1 scope=383 vars_num=1 tvars_num=0 ext_life_p=1 // ident=accessvalue
             198 vdecl pos=26 ident=msg ident_num=3 decl_scope=388 public_p=1 var_num=0

             389 btdef pos=26 op1=0 pc=391 // goto 391 unless 0 is undefined
             390 ldnil pos=32 op1=0 // 0 <- nil
             391 bend pos=26 block=388
           199 fdecl ln=113 pos=13 ident=immutable ident_num=101 decl_scope=383 public_p=1 fblock=392
           392 fblock pos=35 next=393 fdecl=199 class_p=1 pars_num=1 scope=383 vars_num=1 tvars_num=0 ext_life_p=1 // ident=immutable
             200 vdecl pos=24 ident=msg ident_num=3 decl_scope=392 public_p=1 var_num=0

             393 btdef pos=24 op1=0 pc=395 // goto 395 unless 0 is undefined
             394 ldnil pos=30 op1=0 // 0 <- nil
             395 bend pos=24 block=392

           396 btdef ln=110 pos=22 op1=0 pc=398 // goto 398 unless 0 is undefined
           397 ldnil pos=28 op1=0 // 0 <- nil
           398 bend ln=113 pos=24 block=383
         201 fdecl ln=115 pos=11 ident=deadlock ident_num=102 decl_scope=2 public_p=1 fblock=399
         399 fblock pos=32 next=400 fdecl=201 class_p=1 pars_num=1 scope=2 vars_num=1 tvars_num=0 ext_life_p=1 // ident=deadlock
           202 vdecl pos=21 ident=msg ident_num=3 decl_scope=399 public_p=1 var_num=0

           400 btdef pos=21 op1=0 pc=402 // goto 402 unless 0 is undefined
           401 ldnil pos=27 op1=0 // 0 <- nil
           402 bend pos=21 block=399
         203 fdecl ln=116 pos=11 ident=syncwait ident_num=103 decl_scope=2 public_p=1 fblock=403
         403 fblock pos=32 next=404 fdecl=203 class_p=1 pars_num=1 scope=2 vars_num=1 tvars_num=0 ext_life_p=1 // ident=syncwait
           204 vdecl pos=21 ident=msg ident_num=3 decl_scope=403 public_p=1 var_num=0

           404 btdef pos=21 op1=0 pc=406 // goto 406 unless 0 is undefined
           405 ldnil pos=27 op1=0 // 0 <- nil
           406 bend pos=21 block=403

         407 btdef ln=2 pos=16 op1=0 pc=409 // goto 409 unless 0 is undefined
         408 ldnil pos=22 op1=0 // 0 <- nil
         409 bend ln=116 pos=21 block=2

       410 bend pos=21 block=1
     205 vdecl ln=119 pos=5 ident=excepts ident_num=104 decl_scope=0 var_num=0
     206 vdecl ln=120 pos=5 ident=errors ident_num=105 decl_scope=0 var_num=1
     207 vdecl ln=121 pos=5 ident=signals ident_num=106 decl_scope=0 var_num=2
     208 vdecl ln=122 pos=5 ident=invops ident_num=107 decl_scope=0 var_num=3
     209 vdecl ln=123 pos=5 ident=invindexes ident_num=108 decl_scope=0 var_num=4
     210 vdecl ln=124 pos=5 ident=invslices ident_num=109 decl_scope=0 var_num=5
     211 vdecl ln=125 pos=5 ident=invectors ident_num=110 decl_scope=0 var_num=6
     212 vdecl ln=126 pos=5 ident=invkeys ident_num=111 decl_scope=0 var_num=7
     213 vdecl ln=127 pos=5 ident=invcalls ident_num=112 decl_scope=0 var_num=8
     214 vdecl ln=128 pos=5 ident=syserrors ident_num=113 decl_scope=0 var_num=9
     215 vdecl ln=129 pos=5 ident=systemcalls ident_num=114 decl_scope=0 var_num=10
     216 vdecl ln=130 pos=5 ident=invregexps ident_num=115 decl_scope=0 var_num=11
     217 vdecl ln=131 pos=5 ident=invparsers ident_num=116 decl_scope=0 var_num=12
     218 vdecl ln=132 pos=5 ident=invexterns ident_num=117 decl_scope=0 var_num=13
     219 vdecl ln=133 pos=5 ident=invaccesses ident_num=118 decl_scope=0 var_num=14
     220 vdecl ln=134 pos=5 ident=argv ident_num=119 decl_scope=0 var_num=15
     221 vdecl pos=11 ident=env ident_num=120 decl_scope=0 var_num=16
     222 vdecl pos=20 ident=version ident_num=121 decl_scope=0 var_num=17
     223 vdecl pos=29 ident=main_thread ident_num=122 decl_scope=0 var_num=18
     224 vdecl pos=42 ident=curr_thread ident_num=123 decl_scope=0 var_num=19
     225 fdecl ln=135 pos=7 ident=anode ident_num=124 decl_scope=0 fblock=411
     411 fblock pos=28 next=412 fdecl=225 class_p=1 simple_p=1 pure_func_p=1 pars_num=2 min_pars_num=2 scope=0 vars_num=2 tvars_num=0 ext_life_p=1 // ident=anode
       226 vdecl pos=14 ident=name ident_num=125 decl_scope=411 public_p=1 var_num=0
       227 vdecl pos=20 ident=transl ident_num=126 decl_scope=411 public_p=1 var_num=1

       412 bend pos=20 block=411
     228 fdecl ln=136 pos=7 ident=token ident_num=127 decl_scope=0 fblock=413
     413 fblock pos=20 next=414 fdecl=228 class_p=1 simple_p=1 pure_func_p=1 pars_num=1 min_pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 // ident=token
       229 vdecl pos=14 ident=code ident_num=128 decl_scope=413 public_p=1 var_num=0

       414 bend pos=14 block=413
     230 vdecl ln=137 pos=5 ident=nil_anode ident_num=129 decl_scope=0 var_num=20
     231 vdecl ln=138 pos=5 ident=error_anode ident_num=130 decl_scope=0 var_num=21
     232 fdecl ln=139 pos=13 ident=parser ident_num=131 decl_scope=0 fblock=415
     415 fblock ln=140 pos=1 next=516 fdecl=232 class_p=1 scope=0 vars_num=2 tvars_num=1 ext_life_p=1 // ident=parser
       233 vdecl ln=141 pos=7 ident=ambiguous_p ident_num=132 decl_scope=415 public_p=1 var_num=0
       234 vdecl ln=142 pos=8 ident=grammar ident_num=133 decl_scope=415 var_num=1
       235 fdecl ln=144 pos=9 ident=int_earley_parse_grammar ident_num=134 decl_scope=415 fblock=416
       416 fblock pos=35 fdecl=235 func_p=1 scope=415 vars_num=0 tvars_num=0 // ident=int_earley_parse_grammar

         417 bend pos=35 block=416
       236 fdecl pos=44 ident=int_earley_set_debug_level ident_num=135 decl_scope=415 fblock=418
       418 fblock pos=72 fdecl=236 func_p=1 scope=415 vars_num=0 tvars_num=0 // ident=int_earley_set_debug_level

         419 bend pos=72 block=418
       237 fdecl ln=145 pos=9 ident=int_earley_set_one_parse_flag ident_num=136 decl_scope=415 fblock=420
       420 fblock pos=41 fdecl=237 func_p=1 scope=415 vars_num=0 tvars_num=0 // ident=int_earley_set_one_parse_flag

         421 bend pos=41 block=420
       238 fdecl ln=146 pos=9 ident=int_earley_set_lookahead_level ident_num=137 decl_scope=415 fblock=422
       422 fblock pos=42 fdecl=238 func_p=1 scope=415 vars_num=0 tvars_num=0 // ident=int_earley_set_lookahead_level

         423 bend pos=42 block=422
       239 fdecl ln=147 pos=9 ident=int_earley_set_cost_flag ident_num=138 decl_scope=415 fblock=424
       424 fblock pos=36 fdecl=239 func_p=1 scope=415 vars_num=0 tvars_num=0 // ident=int_earley_set_cost_flag

         425 bend pos=36 block=424
       240 fdecl ln=148 pos=9 ident=int_earley_set_error_recovery_flag ident_num=139 decl_scope=415 fblock=426
       426 fblock pos=47 fdecl=240 func_p=1 scope=415 vars_num=0 tvars_num=0 // ident=int_earley_set_error_recovery_flag

         427 bend pos=47 block=426
       241 fdecl ln=149 pos=9 ident=int_earley_set_recovery_match ident_num=140 decl_scope=415 fblock=428
       428 fblock pos=41 fdecl=241 func_p=1 scope=415 vars_num=0 tvars_num=0 // ident=int_earley_set_recovery_match

         429 bend pos=41 block=428
       242 fdecl pos=50 ident=int_earley_parse ident_num=141 decl_scope=415 fblock=430
       430 fblock pos=69 fdecl=242 func_p=1 scope=415 vars_num=0 tvars_num=0 // ident=int_earley_parse

         431 bend pos=69 block=430
       243 fdecl ln=150 pos=9 ident=int_earley_create_grammar ident_num=142 decl_scope=415 fblock=432
       432 fblock pos=37 fdecl=243 func_p=1 scope=415 vars_num=0 tvars_num=0 // ident=int_earley_create_grammar

         433 bend pos=37 block=432
       244 fdecl ln=152 pos=8 ident=set_grammar ident_num=143 decl_scope=415 public_p=1 fblock=434
       434 fblock pos=38 next=435 fdecl=244 func_p=1 pars_num=2 min_pars_num=2 scope=415 vars_num=2 tvars_num=4 // ident=set_grammar
         245 vdecl pos=21 ident=descr ident_num=144 decl_scope=434 var_num=0
         246 vdecl pos=28 ident=strict_p ident_num=145 decl_scope=434 var_num=1

         435 func ln=153 pos=5 op1=2 decl=235 // int_earley_parse_grammar
         436 var pos=31 op1=3 decl=234 // grammar
         437 move pos=40 op1=4 op2=1 rhs_decl=246 // 4 (strict_p) <- 1
         438 move pos=50 op1=5 op2=0 rhs_decl=245 // 5 (descr) <- 0
         439 pcall pos=30 op1=2 op2=3 // call (start=2) (npars=3)
         440 bend pos=50 block=434
       247 fdecl ln=155 pos=8 ident=set_debug ident_num=146 decl_scope=415 public_p=1 fblock=441
       441 fblock pos=26 next=442 fdecl=247 func_p=1 pars_num=1 min_pars_num=1 scope=415 vars_num=1 tvars_num=3 // ident=set_debug
         248 vdecl pos=19 ident=level ident_num=147 decl_scope=441 var_num=0

         442 func ln=156 pos=12 op1=1 decl=236 // int_earley_set_debug_level
         443 var pos=40 op1=2 decl=234 // grammar
         444 move pos=49 op1=3 op2=0 rhs_decl=248 // 3 (level) <- 0
         445 call pos=39 op1=1 op2=2 // call (start=1) (npars=2)
         446 ret pos=5 op1=1
         447 bend pos=49 block=441
       249 fdecl ln=158 pos=8 ident=set_one_parse ident_num=148 decl_scope=415 public_p=1 fblock=448
       448 fblock pos=29 next=449 fdecl=249 func_p=1 pars_num=1 min_pars_num=1 scope=415 vars_num=1 tvars_num=3 // ident=set_one_parse
         250 vdecl pos=23 ident=flag ident_num=149 decl_scope=448 var_num=0

         449 func ln=159 pos=12 op1=1 decl=237 // int_earley_set_one_parse_flag
         450 var pos=43 op1=2 decl=234 // grammar
         451 move pos=52 op1=3 op2=0 rhs_decl=250 // 3 (flag) <- 0
         452 call pos=42 op1=1 op2=2 // call (start=1) (npars=2)
         453 ret pos=5 op1=1
         454 bend pos=52 block=448
       251 fdecl ln=161 pos=8 ident=set_lookahead ident_num=150 decl_scope=415 public_p=1 fblock=455
       455 fblock pos=29 next=456 fdecl=251 func_p=1 pars_num=1 min_pars_num=1 scope=415 vars_num=1 tvars_num=3 // ident=set_lookahead
         252 vdecl pos=23 ident=flag ident_num=149 decl_scope=455 var_num=0

         456 func ln=162 pos=12 op1=1 decl=238 // int_earley_set_lookahead_level
         457 var pos=44 op1=2 decl=234 // grammar
         458 move pos=53 op1=3 op2=0 rhs_decl=252 // 3 (flag) <- 0
         459 call pos=43 op1=1 op2=2 // call (start=1) (npars=2)
         460 ret pos=5 op1=1
         461 bend pos=53 block=455
       253 fdecl ln=164 pos=8 ident=set_cost ident_num=151 decl_scope=415 public_p=1 fblock=462
       462 fblock pos=24 next=463 fdecl=253 func_p=1 pars_num=1 min_pars_num=1 scope=415 vars_num=1 tvars_num=3 // ident=set_cost
         254 vdecl pos=18 ident=flag ident_num=149 decl_scope=462 var_num=0

         463 func ln=165 pos=12 op1=1 decl=239 // int_earley_set_cost_flag
         464 var pos=38 op1=2 decl=234 // grammar
         465 move pos=47 op1=3 op2=0 rhs_decl=254 // 3 (flag) <- 0
         466 call pos=37 op1=1 op2=2 // call (start=1) (npars=2)
         467 ret pos=5 op1=1
         468 bend pos=47 block=462
       255 fdecl ln=167 pos=8 ident=set_recovery ident_num=152 decl_scope=415 public_p=1 fblock=469
       469 fblock pos=28 next=470 fdecl=255 func_p=1 pars_num=1 min_pars_num=1 scope=415 vars_num=1 tvars_num=3 // ident=set_recovery
         256 vdecl pos=22 ident=flag ident_num=149 decl_scope=469 var_num=0

         470 func ln=168 pos=12 op1=1 decl=240 // int_earley_set_error_recovery_flag
         471 var pos=48 op1=2 decl=234 // grammar
         472 move pos=57 op1=3 op2=0 rhs_decl=256 // 3 (flag) <- 0
         473 call pos=47 op1=1 op2=2 // call (start=1) (npars=2)
         474 ret pos=5 op1=1
         475 bend pos=57 block=469
       257 fdecl ln=170 pos=8 ident=set_recovery_match ident_num=153 decl_scope=415 public_p=1 fblock=476
       476 fblock pos=36 next=477 fdecl=257 func_p=1 pars_num=1 min_pars_num=1 scope=415 vars_num=1 tvars_num=3 // ident=set_recovery_match
         258 vdecl pos=28 ident=n_toks ident_num=154 decl_scope=476 var_num=0

         477 func ln=171 pos=12 op1=1 decl=241 // int_earley_set_recovery_match
         478 var pos=43 op1=2 decl=234 // grammar
         479 move pos=52 op1=3 op2=0 rhs_decl=258 // 3 (n_toks) <- 0
         480 call pos=42 op1=1 op2=2 // call (start=1) (npars=2)
         481 ret pos=5 op1=1
         482 bend pos=52 block=476
       259 fdecl ln=173 pos=8 ident=parse ident_num=155 decl_scope=415 public_p=1 fblock=483
       483 fblock pos=35 next=484 fdecl=259 func_p=1 pars_num=2 min_pars_num=2 scope=415 vars_num=3 tvars_num=13 // ident=parse
         260 vdecl pos=15 ident=tokens ident_num=156 decl_scope=483 var_num=0
         261 vdecl pos=23 ident=error_func ident_num=157 decl_scope=483 var_num=1
         262 vdecl ln=174 pos=9 ident=__i ident_num=158 decl_scope=483 var_num=2

         484 ldi ln=175 pos=11 op1=3 op2=1 // 3 <- i1
         485 ldi pos=15 op1=4 op2=2 // 4 <- i2
         486 ldi pos=20 op1=5 op2=3 // 5 <- i3
         487 ldi pos=24 op1=6 op2=4 // 6 <- i4
         488 ldi pos=29 op1=7 op2=5 // 7 <- i5
         489 ldi pos=33 op1=8 op2=6 // 8 <- i6
         490 ldi pos=38 op1=9 op2=7 // 9 <- i7
         491 ldi pos=42 op1=10 op2=8 // 10 <- i8
         492 ldi pos=47 op1=11 op2=9 // 11 <- i9
         493 ldi pos=51 op1=12 op2=10 // 12 <- i10
         494 ldi pos=57 op1=13 op2=11 // 13 <- i11
         495 ldi pos=62 op1=14 op2=12 // 14 <- i12
         496 ldi pos=67 op1=15 op2=13 // 15 <- i13
         497 and pos=65 pos2=62 pos3=67 op1=14 op2=14 op3=15 // 14 <- 14 op 15
         498 xor pos=60 pos2=57 pos3=65 op1=13 op2=13 op3=14 // 13 <- 13 op 14
         499 and pos=54 pos2=51 pos3=60 op1=12 op2=12 op3=13 // 12 <- 12 op 13
         500 xor pos=49 pos2=47 pos3=54 op1=11 op2=11 op3=12 // 11 <- 11 op 12
         501 and pos=44 pos2=42 pos3=49 op1=10 op2=10 op3=11 // 10 <- 10 op 11
         502 xor pos=40 pos2=38 pos3=44 op1=9 op2=9 op3=10 // 9 <- 9 op 10
         503 and pos=35 pos2=33 pos3=40 op1=8 op2=8 op3=9 // 8 <- 8 op 9
         504 xor pos=31 pos2=29 pos3=35 op1=7 op2=7 op3=8 // 7 <- 7 op 8
         505 and pos=26 pos2=24 pos3=31 op1=6 op2=6 op3=7 // 6 <- 6 op 7
         506 xor pos=22 pos2=20 pos3=26 op1=5 op2=5 op3=6 // 5 <- 5 op 6
         507 and pos=17 pos2=15 pos3=22 op1=4 op2=4 op3=5 // 4 <- 4 op 5
         508 xor pos=13 pos2=11 pos3=17 op1=2 op2=3 op3=4 // 2 <- 3 op 4
         509 func ln=176 pos=12 op1=3 decl=242 // int_earley_parse
         510 var pos=30 op1=4 decl=234 // grammar
         511 move pos=39 op1=5 op2=0 rhs_decl=260 // 5 (tokens) <- 0
         512 move pos=47 op1=6 op2=1 rhs_decl=261 // 6 (error_func) <- 1
         513 call pos=29 op1=3 op2=3 // call (start=3) (npars=3)
         514 ret pos=5 op1=3
         515 bend pos=47 block=483

       516 func ln=179 pos=13 op1=2 decl=243 // int_earley_create_grammar
       517 call pos=39 op1=2 op2=0 // call (start=2) (npars=0)
       518 move pos=11 op1=1 op2=2 rhs_decl=234 // 1 (grammar) <- 2
       519 bend pos=13 block=415
     263 fdecl ln=182 pos=13 ident=file ident_num=159 decl_scope=0 fblock=520
     520 fblock pos=20 next=521 fdecl=263 class_p=1 scope=0 vars_num=1 tvars_num=2 ext_life_p=1 // ident=file
       264 vdecl ln=183 pos=8 ident=file_ptr ident_num=160 decl_scope=520 var_num=0

       521 fld ln=184 pos=17 op1=1 op2=-9 op3=30 fldid=callop // 1 <- -9 . 30 (callop)
       522 lds ln=185 pos=6 op1=2 str="File can be created only by functions open or popen" // 2 <- string
       523 call pos=5 op1=1 op2=1 // call (start=1) (npars=1)
       524 throw ln=184 pos=3 op1=1
       525 bend ln=185 pos=59 block=520
     265 vdecl ln=186 pos=5 ident=stdin ident_num=161 decl_scope=0 var_num=22
     266 vdecl ln=187 pos=5 ident=stdout ident_num=162 decl_scope=0 var_num=23
     267 vdecl ln=188 pos=5 ident=stderr ident_num=163 decl_scope=0 var_num=24
     268 fdecl ln=189 pos=6 ident=max ident_num=164 decl_scope=0 fblock=526
     526 fblock pos=12 fdecl=268 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=max

       527 bend pos=12 block=526
     269 fdecl pos=20 ident=min ident_num=165 decl_scope=0 fblock=528
     528 fblock pos=26 fdecl=269 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=min

       529 bend pos=26 block=528
     270 fdecl ln=190 pos=6 ident=tolower ident_num=166 decl_scope=0 fblock=530
     530 fblock pos=16 fdecl=270 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=tolower

       531 bend pos=16 block=530
     271 fdecl pos=24 ident=toupper ident_num=167 decl_scope=0 fblock=532
     532 fblock pos=34 fdecl=271 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=toupper

       533 bend pos=34 block=532
     272 fdecl pos=42 ident=transliterate ident_num=168 decl_scope=0 fblock=534
     534 fblock pos=58 fdecl=272 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=transliterate

       535 bend pos=58 block=534
     273 fdecl ln=191 pos=6 ident=eltype ident_num=169 decl_scope=0 fblock=536
     536 fblock pos=15 fdecl=273 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=eltype

       537 bend pos=15 block=536
     274 fdecl ln=192 pos=6 ident=keys ident_num=170 decl_scope=0 fblock=538
     538 fblock pos=13 fdecl=274 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=keys

       539 bend pos=13 block=538
     275 fdecl ln=193 pos=6 ident=context ident_num=171 decl_scope=0 fblock=540
     540 fblock pos=16 fdecl=275 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=context

       541 bend pos=16 block=540
     276 fdecl pos=24 ident=inside ident_num=172 decl_scope=0 fblock=542
     542 fblock pos=33 fdecl=276 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=inside

       543 bend pos=33 block=542
     277 fdecl ln=194 pos=6 ident=subv ident_num=173 decl_scope=0 fblock=544
     544 fblock pos=12 fdecl=277 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=subv

       545 bend pos=12 block=544
     278 fdecl pos=20 ident=cmpv ident_num=174 decl_scope=0 fblock=546
     546 fblock pos=26 fdecl=278 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=cmpv

       547 bend pos=26 block=546
     279 fdecl pos=34 ident=del ident_num=175 decl_scope=0 fblock=548
     548 fblock pos=39 fdecl=279 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=del

       549 bend pos=39 block=548
     280 fdecl pos=47 ident=ins ident_num=176 decl_scope=0 fblock=550
     550 fblock pos=52 fdecl=280 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=ins

       551 bend pos=52 block=550
     281 fdecl pos=61 ident=insv ident_num=177 decl_scope=0 fblock=552
     552 fblock pos=67 fdecl=281 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=insv

       553 bend pos=67 block=552
     282 fdecl ln=195 pos=6 ident=rev ident_num=178 decl_scope=0 fblock=554
     554 fblock pos=11 fdecl=282 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=rev

       555 bend pos=11 block=554
     283 fdecl pos=19 ident=sort ident_num=179 decl_scope=0 fblock=556
     556 fblock pos=25 fdecl=283 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=sort

       557 bend pos=25 block=556
     284 fdecl ln=196 pos=6 ident=sqrt ident_num=180 decl_scope=0 fblock=558
     558 fblock pos=13 fdecl=284 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=sqrt

       559 bend pos=13 block=558
     285 fdecl pos=21 ident=exp ident_num=181 decl_scope=0 fblock=560
     560 fblock pos=27 fdecl=285 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=exp

       561 bend pos=27 block=560
     286 fdecl pos=35 ident=log ident_num=182 decl_scope=0 fblock=562
     562 fblock pos=41 fdecl=286 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=log

       563 bend pos=41 block=562
     287 fdecl pos=49 ident=log10 ident_num=183 decl_scope=0 fblock=564
     564 fblock pos=56 fdecl=287 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=log10

       565 bend pos=56 block=564
     288 fdecl pos=64 ident=pow ident_num=184 decl_scope=0 fblock=566
     566 fblock pos=69 fdecl=288 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=pow

       567 bend pos=69 block=566
     289 fdecl ln=197 pos=6 ident=sin ident_num=185 decl_scope=0 fblock=568
     568 fblock pos=11 fdecl=289 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=sin

       569 bend pos=11 block=568
     290 fdecl pos=19 ident=cos ident_num=186 decl_scope=0 fblock=570
     570 fblock pos=24 fdecl=290 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=cos

       571 bend pos=24 block=570
     291 fdecl pos=32 ident=atan2 ident_num=187 decl_scope=0 fblock=572
     572 fblock pos=39 fdecl=291 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=atan2

       573 bend pos=39 block=572
     292 fdecl ln=198 pos=6 ident=match ident_num=188 decl_scope=0 fblock=574
     574 fblock pos=13 fdecl=292 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=match

       575 bend pos=13 block=574
     293 fdecl pos=21 ident=gmatch ident_num=189 decl_scope=0 fblock=576
     576 fblock pos=29 fdecl=293 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=gmatch

       577 bend pos=29 block=576
     294 fdecl pos=37 ident=sub ident_num=190 decl_scope=0 fblock=578
     578 fblock pos=42 fdecl=294 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=sub

       579 bend pos=42 block=578
     295 fdecl pos=50 ident=gsub ident_num=191 decl_scope=0 fblock=580
     580 fblock pos=56 fdecl=295 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=gsub

       581 bend pos=56 block=580
     296 fdecl ln=199 pos=6 ident=split ident_num=192 decl_scope=0 fblock=582
     582 fblock pos=13 fdecl=296 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=split

       583 bend pos=13 block=582
     297 vdecl pos=20 ident=split_regex ident_num=193 decl_scope=0 var_num=25
     298 fdecl ln=200 pos=6 ident=srand ident_num=194 decl_scope=0 fblock=584
     584 fblock pos=13 fdecl=298 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=srand

       585 bend pos=13 block=584
     299 fdecl pos=21 ident=rand ident_num=195 decl_scope=0 fblock=586
     586 fblock pos=27 fdecl=299 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=rand

       587 bend pos=27 block=586
     300 fdecl ln=201 pos=6 ident=__process_errno__ ident_num=196 decl_scope=0 fblock=588
     588 fblock pos=26 fdecl=300 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=__process_errno__

       589 bend pos=26 block=588
     301 fdecl ln=202 pos=6 ident=readdir ident_num=197 decl_scope=0 fblock=590
     590 fblock pos=15 fdecl=301 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=readdir

       591 bend pos=15 block=590
     302 fdecl pos=23 ident=ftype ident_num=198 decl_scope=0 fblock=592
     592 fblock pos=32 fdecl=302 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=ftype

       593 bend pos=32 block=592
     303 fdecl ln=203 pos=6 ident=fun ident_num=199 decl_scope=0 fblock=594
     594 fblock pos=11 fdecl=303 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fun

       595 bend pos=11 block=594
     304 fdecl pos=19 ident=fgn ident_num=200 decl_scope=0 fblock=596
     596 fblock pos=26 fdecl=304 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fgn

       597 bend pos=26 block=596
     305 fdecl pos=34 ident=fsize ident_num=201 decl_scope=0 fblock=598
     598 fblock pos=41 fdecl=305 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fsize

       599 bend pos=41 block=598
     306 fdecl ln=204 pos=6 ident=fatime ident_num=202 decl_scope=0 fblock=600
     600 fblock pos=15 fdecl=306 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fatime

       601 bend pos=15 block=600
     307 fdecl pos=23 ident=fmtime ident_num=203 decl_scope=0 fblock=602
     602 fblock pos=31 fdecl=307 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fmtime

       603 bend pos=31 block=602
     308 fdecl pos=39 ident=fctime ident_num=204 decl_scope=0 fblock=604
     604 fblock pos=49 fdecl=308 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fctime

       605 bend pos=49 block=604
     309 fdecl ln=205 pos=6 ident=fumode ident_num=205 decl_scope=0 fblock=606
     606 fblock pos=15 fdecl=309 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fumode

       607 bend pos=15 block=606
     310 fdecl pos=23 ident=fgmode ident_num=206 decl_scope=0 fblock=608
     608 fblock pos=31 fdecl=310 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fgmode

       609 bend pos=31 block=608
     311 fdecl pos=39 ident=fomode ident_num=207 decl_scope=0 fblock=610
     610 fblock pos=49 fdecl=311 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fomode

       611 bend pos=49 block=610
     312 fdecl ln=206 pos=6 ident=time ident_num=208 decl_scope=0 fblock=612
     612 fblock pos=12 fdecl=312 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=time

       613 bend pos=12 block=612
     313 fdecl ln=207 pos=6 ident=strtime ident_num=209 decl_scope=0 fblock=614
     614 fblock pos=16 fdecl=313 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=strtime

       615 bend pos=16 block=614
     314 vdecl pos=23 ident=time_format ident_num=210 decl_scope=0 var_num=26
     315 fdecl ln=208 pos=6 ident=clock ident_num=211 decl_scope=0 fblock=616
     616 fblock pos=13 fdecl=315 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=clock

       617 bend pos=13 block=616
     316 fdecl ln=209 pos=6 ident=gc ident_num=212 decl_scope=0 fblock=618
     618 fblock pos=11 fdecl=316 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=gc

       619 bend pos=11 block=618
     317 fdecl ln=210 pos=6 ident=rename ident_num=213 decl_scope=0 fblock=620
     620 fblock pos=15 fdecl=317 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=rename

       621 bend pos=15 block=620
     318 fdecl pos=23 ident=remove ident_num=214 decl_scope=0 fblock=622
     622 fblock pos=31 fdecl=318 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=remove

       623 bend pos=31 block=622
     319 fdecl ln=211 pos=6 ident=mkdir ident_num=215 decl_scope=0 fblock=624
     624 fblock pos=14 fdecl=319 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=mkdir

       625 bend pos=14 block=624
     320 fdecl pos=22 ident=rmdir ident_num=216 decl_scope=0 fblock=626
     626 fblock pos=29 fdecl=320 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=rmdir

       627 bend pos=29 block=626
     321 fdecl ln=212 pos=6 ident=getcwd ident_num=217 decl_scope=0 fblock=628
     628 fblock pos=15 fdecl=321 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=getcwd

       629 bend pos=15 block=628
     322 fdecl pos=23 ident=chdir ident_num=218 decl_scope=0 fblock=630
     630 fblock pos=30 fdecl=322 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=chdir

       631 bend pos=30 block=630
     323 fdecl ln=213 pos=6 ident=chumod ident_num=219 decl_scope=0 fblock=632
     632 fblock pos=15 fdecl=323 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=chumod

       633 bend pos=15 block=632
     324 fdecl pos=23 ident=chgmod ident_num=220 decl_scope=0 fblock=634
     634 fblock pos=32 fdecl=324 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=chgmod

       635 bend pos=32 block=634
     325 fdecl pos=40 ident=chomod ident_num=221 decl_scope=0 fblock=636
     636 fblock pos=49 fdecl=325 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=chomod

       637 bend pos=49 block=636
     326 fdecl pos=57 ident=isatty ident_num=222 decl_scope=0 fblock=638
     638 fblock pos=65 fdecl=326 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=isatty

       639 bend pos=65 block=638
     327 fdecl ln=214 pos=6 ident=open ident_num=223 decl_scope=0 fblock=640
     640 fblock pos=13 fdecl=327 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=open

       641 bend pos=13 block=640
     328 fdecl pos=21 ident=close ident_num=224 decl_scope=0 fblock=642
     642 fblock pos=28 fdecl=328 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=close

       643 bend pos=28 block=642
     329 fdecl pos=36 ident=flush ident_num=225 decl_scope=0 fblock=644
     644 fblock pos=43 fdecl=329 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=flush

       645 bend pos=43 block=644
     330 fdecl ln=215 pos=6 ident=popen ident_num=226 decl_scope=0 fblock=646
     646 fblock pos=14 fdecl=330 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=popen

       647 bend pos=14 block=646
     331 fdecl pos=22 ident=pclose ident_num=227 decl_scope=0 fblock=648
     648 fblock pos=30 fdecl=331 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=pclose

       649 bend pos=30 block=648
     332 fdecl ln=216 pos=6 ident=tell ident_num=228 decl_scope=0 fblock=650
     650 fblock pos=13 fdecl=332 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=tell

       651 bend pos=13 block=650
     333 fdecl pos=21 ident=seek ident_num=229 decl_scope=0 fblock=652
     652 fblock pos=28 fdecl=333 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=seek

       653 bend pos=28 block=652
     334 fdecl ln=217 pos=6 ident=put ident_num=230 decl_scope=0 fblock=654
     654 fblock pos=11 fdecl=334 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=put

       655 bend pos=11 block=654
     335 fdecl pos=19 ident=putln ident_num=231 decl_scope=0 fblock=656
     656 fblock pos=26 fdecl=335 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=putln

       657 bend pos=26 block=656
     336 fdecl ln=218 pos=6 ident=fput ident_num=232 decl_scope=0 fblock=658
     658 fblock pos=12 fdecl=336 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fput

       659 bend pos=12 block=658
     337 fdecl pos=20 ident=fputln ident_num=233 decl_scope=0 fblock=660
     660 fblock pos=28 fdecl=337 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fputln

       661 bend pos=28 block=660
     338 fdecl pos=36 ident=sput ident_num=234 decl_scope=0 fblock=662
     662 fblock pos=42 fdecl=338 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=sput

       663 bend pos=42 block=662
     339 fdecl pos=50 ident=sputln ident_num=235 decl_scope=0 fblock=664
     664 fblock pos=58 fdecl=339 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=sputln

       665 bend pos=58 block=664
     340 fdecl ln=219 pos=6 ident=putf ident_num=236 decl_scope=0 fblock=666
     666 fblock pos=13 fdecl=340 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=putf

       667 bend pos=13 block=666
     341 fdecl pos=21 ident=fputf ident_num=237 decl_scope=0 fblock=668
     668 fblock pos=29 fdecl=341 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fputf

       669 bend pos=29 block=668
     342 fdecl pos=37 ident=sputf ident_num=238 decl_scope=0 fblock=670
     670 fblock pos=45 fdecl=342 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=sputf

       671 bend pos=45 block=670
     343 fdecl ln=220 pos=6 ident=print ident_num=239 decl_scope=0 fblock=672
     672 fblock pos=13 fdecl=343 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=print

       673 bend pos=13 block=672
     344 fdecl pos=21 ident=println ident_num=240 decl_scope=0 fblock=674
     674 fblock pos=30 fdecl=344 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=println

       675 bend pos=30 block=674
     345 fdecl ln=221 pos=6 ident=fprint ident_num=241 decl_scope=0 fblock=676
     676 fblock pos=14 fdecl=345 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fprint

       677 bend pos=14 block=676
     346 fdecl pos=22 ident=fprintln ident_num=242 decl_scope=0 fblock=678
     678 fblock pos=32 fdecl=346 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fprintln

       679 bend pos=32 block=678
     347 fdecl pos=40 ident=sprint ident_num=243 decl_scope=0 fblock=680
     680 fblock pos=48 fdecl=347 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=sprint

       681 bend pos=48 block=680
     348 fdecl pos=56 ident=sprintln ident_num=244 decl_scope=0 fblock=682
     682 fblock pos=66 fdecl=348 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=sprintln

       683 bend pos=66 block=682
     349 fdecl ln=222 pos=6 ident=get ident_num=245 decl_scope=0 fblock=684
     684 fblock pos=11 fdecl=349 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=get

       685 bend pos=11 block=684
     350 fdecl pos=19 ident=getln ident_num=246 decl_scope=0 fblock=686
     686 fblock pos=26 fdecl=350 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=getln

       687 bend pos=26 block=686
     351 fdecl pos=34 ident=getf ident_num=247 decl_scope=0 fblock=688
     688 fblock pos=40 fdecl=351 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=getf

       689 bend pos=40 block=688
     352 fdecl ln=223 pos=6 ident=fget ident_num=248 decl_scope=0 fblock=690
     690 fblock pos=12 fdecl=352 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fget

       691 bend pos=12 block=690
     353 fdecl pos=20 ident=fgetln ident_num=249 decl_scope=0 fblock=692
     692 fblock pos=28 fdecl=353 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fgetln

       693 bend pos=28 block=692
     354 fdecl pos=36 ident=fgetf ident_num=250 decl_scope=0 fblock=694
     694 fblock pos=43 fdecl=354 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fgetf

       695 bend pos=43 block=694
     355 fdecl ln=224 pos=6 ident=scan ident_num=251 decl_scope=0 fblock=696
     696 fblock pos=12 fdecl=355 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=scan

       697 bend pos=12 block=696
     356 fdecl pos=20 ident=scanln ident_num=252 decl_scope=0 fblock=698
     698 fblock pos=28 fdecl=356 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=scanln

       699 bend pos=28 block=698
     357 fdecl pos=36 ident=fscan ident_num=253 decl_scope=0 fblock=700
     700 fblock pos=43 fdecl=357 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fscan

       701 bend pos=43 block=700
     358 fdecl pos=51 ident=fscanln ident_num=254 decl_scope=0 fblock=702
     702 fblock pos=60 fdecl=358 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fscanln

       703 bend pos=60 block=702
     359 fdecl ln=225 pos=6 ident=getpid ident_num=255 decl_scope=0 fblock=704
     704 fblock pos=14 fdecl=359 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=getpid

       705 bend pos=14 block=704
     360 fdecl pos=22 ident=getun ident_num=256 decl_scope=0 fblock=706
     706 fblock pos=29 fdecl=360 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=getun

       707 bend pos=29 block=706
     361 fdecl pos=37 ident=geteun ident_num=257 decl_scope=0 fblock=708
     708 fblock pos=45 fdecl=361 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=geteun

       709 bend pos=45 block=708
     362 fdecl ln=226 pos=6 ident=getgn ident_num=258 decl_scope=0 fblock=710
     710 fblock pos=13 fdecl=362 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=getgn

       711 bend pos=13 block=710
     363 fdecl pos=21 ident=getegn ident_num=259 decl_scope=0 fblock=712
     712 fblock pos=29 fdecl=363 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=getegn

       713 bend pos=29 block=712
     364 fdecl pos=37 ident=getgroups ident_num=260 decl_scope=0 fblock=714
     714 fblock pos=48 fdecl=364 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=getgroups

       715 bend pos=48 block=714
     365 fdecl ln=227 pos=6 ident=system ident_num=261 decl_scope=0 fblock=716
     716 fblock pos=14 fdecl=365 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=system

       717 bend pos=14 block=716
     366 fdecl ln=228 pos=6 ident=exit ident_num=262 decl_scope=0 fblock=718
     718 fblock pos=12 fdecl=366 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=exit

       719 bend pos=12 block=718
     367 fdecl ln=229 pos=6 ident=fold ident_num=263 decl_scope=0 fblock=720
     720 fblock pos=12 fdecl=367 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fold

       721 bend pos=12 block=720
     368 fdecl pos=20 ident=filter ident_num=264 decl_scope=0 fblock=722
     722 fblock pos=28 fdecl=368 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=filter

       723 bend pos=28 block=722
     369 fdecl pos=36 ident=map ident_num=265 decl_scope=0 fblock=724
     724 fblock pos=41 fdecl=369 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=map

       725 bend pos=41 block=724
     370 fdecl ln=230 pos=6 ident=transpose ident_num=266 decl_scope=0 fblock=726
     726 fblock pos=17 fdecl=370 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=transpose

       727 bend pos=17 block=726
     371 fdecl ln=231 pos=6 ident=__init__ ident_num=267 decl_scope=0 fblock=728
     728 fblock pos=17 fdecl=371 func_p=1 scope=0 vars_num=0 tvars_num=0 // ident=__init__

       729 bend pos=17 block=728
//-----------------------test.d---------------------------
     372 vdecl fn="test.d" ln=1 pos=5 ident=SieveSize ident_num=268 decl_scope=0 var_num=27
     373 vdecl pos=16 ident=i ident_num=269 decl_scope=0 var_num=28
     374 vdecl pos=19 ident=prime ident_num=270 decl_scope=0 var_num=29
     375 vdecl pos=26 ident=k ident_num=271 decl_scope=0 var_num=30
     376 vdecl pos=29 ident=count ident_num=272 decl_scope=0 var_num=31
     377 vdecl pos=36 ident=flags ident_num=273 decl_scope=0 var_num=32

//-----------------------<environment>----------------------------
     730 class fn="<environment>" ln=119 pos=15 op1=33 decl=0 // except
     731 call pos=22 op1=33 op2=0 // call (start=33) (npars=0)
     732 move pos=13 op1=0 op2=33 rhs_decl=205 // 0 (excepts) <- 33
     733 fld ln=120 pos=21 op1=33 op2=0 op3=2 fldid=error // 33 <- 0 . 2 (error)
     734 call pos=28 op1=33 op2=0 // call (start=33) (npars=0)
     735 move pos=12 op1=1 op2=33 rhs_decl=206 // 1 (errors) <- 33
     736 fld ln=121 pos=21 op1=33 op2=1 op3=4 fldid=signal // 33 <- 1 . 4 (signal)
     737 call pos=29 op1=33 op2=0 // call (start=33) (npars=0)
     738 move pos=13 op1=2 op2=33 rhs_decl=207 // 2 (signals) <- 33
     739 fld ln=122 pos=20 op1=33 op2=1 op3=12 fldid=invop // 33 <- 1 . 12 (invop)
     740 call pos=27 op1=33 op2=0 // call (start=33) (npars=0)
     741 move pos=12 op1=3 op2=33 rhs_decl=208 // 3 (invops) <- 33
     742 fld ln=123 pos=24 op1=33 op2=1 op3=15 fldid=invindex // 33 <- 1 . 15 (invindex)
     743 call pos=34 op1=33 op2=0 // call (start=33) (npars=0)
     744 move pos=16 op1=4 op2=33 rhs_decl=209 // 4 (invindexes) <- 33
     745 fld ln=124 pos=23 op1=33 op2=1 op3=19 fldid=invslice // 33 <- 1 . 19 (invslice)
     746 call pos=33 op1=33 op2=0 // call (start=33) (npars=0)
     747 move pos=15 op1=5 op2=33 rhs_decl=210 // 5 (invslices) <- 33
     748 fld ln=125 pos=23 op1=33 op2=1 op3=22 fldid=invector // 33 <- 1 . 22 (invector)
     749 call pos=33 op1=33 op2=0 // call (start=33) (npars=0)
     750 move pos=15 op1=6 op2=33 rhs_decl=211 // 6 (invectors) <- 33
     751 fld ln=126 pos=21 op1=33 op2=1 op3=26 fldid=invkey // 33 <- 1 . 26 (invkey)
     752 call pos=29 op1=33 op2=0 // call (start=33) (npars=0)
     753 move pos=13 op1=7 op2=33 rhs_decl=212 // 7 (invkeys) <- 33
     754 fld ln=127 pos=22 op1=33 op2=1 op3=29 fldid=invcall // 33 <- 1 . 29 (invcall)
     755 call pos=31 op1=33 op2=0 // call (start=33) (npars=0)
     756 move pos=14 op1=8 op2=33 rhs_decl=213 // 8 (invcalls) <- 33
     757 fld ln=128 pos=25 op1=33 op2=8 op3=38 fldid=syserror // 33 <- 8 . 38 (syserror)
     758 call pos=35 op1=33 op2=0 // call (start=33) (npars=0)
     759 move pos=15 op1=9 op2=33 rhs_decl=214 // 9 (syserrors) <- 33
     760 fld ln=129 pos=27 op1=33 op2=8 op3=75 fldid=systemcall // 33 <- 8 . 75 (systemcall)
     761 call pos=39 op1=33 op2=0 // call (start=33) (npars=0)
     762 move pos=17 op1=10 op2=33 rhs_decl=215 // 10 (systemcalls) <- 33
     763 fld ln=130 pos=26 op1=33 op2=8 op3=78 fldid=invregexp // 33 <- 8 . 78 (invregexp)
     764 call pos=37 op1=33 op2=0 // call (start=33) (npars=0)
     765 move pos=16 op1=11 op2=33 rhs_decl=216 // 11 (invregexps) <- 33
     766 fld ln=131 pos=26 op1=33 op2=8 op3=88 fldid=invparser // 33 <- 8 . 88 (invparser)
     767 call pos=37 op1=33 op2=0 // call (start=33) (npars=0)
     768 move pos=16 op1=12 op2=33 rhs_decl=217 // 12 (invparsers) <- 33
     769 fld ln=132 pos=26 op1=33 op2=8 op3=92 fldid=invextern // 33 <- 8 . 92 (invextern)
     770 call pos=37 op1=33 op2=0 // call (start=33) (npars=0)
     771 move pos=16 op1=13 op2=33 rhs_decl=218 // 13 (invexterns) <- 33
     772 fld ln=133 pos=25 op1=33 op2=1 op3=98 fldid=invaccess // 33 <- 1 . 98 (invaccess)
     773 call pos=36 op1=33 op2=0 // call (start=33) (npars=0)
     774 move pos=17 op1=14 op2=33 rhs_decl=219 // 14 (invaccesses) <- 33
     775 class ln=137 pos=17 op1=33 decl=225 // anode
     776 lds pos=24 op1=34 str="$nil" // 34 <- string
     777 ldnil pos=32 op1=35 // 35 <- nil
     778 call pos=23 op1=33 op2=2 // call (start=33) (npars=2)
     779 move pos=15 op1=20 op2=33 rhs_decl=230 // 20 (nil_anode) <- 33
     780 class ln=138 pos=19 op1=33 decl=225 // anode
     781 lds pos=26 op1=34 str="$error" // 34 <- string
     782 ldnil pos=36 op1=35 // 35 <- nil
     783 call pos=25 op1=33 op2=2 // call (start=33) (npars=2)
     784 move pos=17 op1=21 op2=33 rhs_decl=231 // 21 (error_anode) <- 33
     785 lds ln=199 pos=34 op1=25 str="[ \t]+" // 25 <- string
     786 lds ln=207 pos=37 op1=26 str="%a %b %d %H:%M:%S %Z %Y" // 26 <- string
     787 ibpcall ln=231 pos=28 cfblock=728 op1=33 op2=0
//-----------------------test.d----------------------------
     788 ldi fn="test.d" ln=2 pos=13 op1=27 op2=8190 // 27 <- i8190
     789 addi ln=4 pos=20 pos2=10 pos3=22 op1=33 op2=27 op3=1 // 33 <- 27 + i1
     790 ldi pos=26 op1=34 op2=0 // 34 <- i0
     791 vec pos=9 op1=32 op2=33 op3=1 // 32 <- [els=33, nparts=1]
     792 ldi ln=5 pos=9 op1=31 op2=0 // 31 <- i0
     793 ldi ln=6 pos=10 next=797 op1=28 op2=0 // 28 <- i0
     794 ldi ln=7 pos=14 op1=33 op2=1 // 33 <- i1
     795 stv pos=12 pos2=8 op1=32 op2=28 op3=33
     796 btleinc ln=6 pos=15 next=798 op1=28 binc_inc=1 bcmp_op2=27 bcmp_res=33 pc=794 // goto 794 if 33 <- (28 += i1) cmp 27
     797 btle pos=15 op1=28 bcmp_op2=27 bcmp_res=33 pc=794 // goto 794 if 33 <- 28 cmp 27
     798 ldi ln=8 pos=10 next=814 op1=28 op2=0 // 28 <- i0
     799 ind ln=9 pos=12 op1=33 op2=32 op3=28 // 33 <- 32[28]
     800 lconv pos=12 op1=33 op2=33 // 33 <- 33
     801 bf pos=12 op1=33 pc=813 // goto 813 unless 33
     802 add ln=11 pos=17 pos2=15 pos3=19 op1=33 op2=28 op3=28 // 33 <- 28 op 28
     803 addi pos=21 pos2=17 pos3=23 op1=29 op2=33 op3=3 // 29 <- 33 + i3
     804 add ln=12 pos=13 pos2=11 pos3=15 next=810 op1=30 op2=28 op3=29 // 30 <- 28 op 29
     805 btle ln=15 pos=21 op1=30 bcmp_op2=27 bcmp_res=33 pc=807 // goto 807 if 33 <- 30 cmp 27
     806 out ln=16 pos=13 next=812 op1=0
     807 ldi ln=17 pos=22 op1=33 op2=0 // 33 <- i0
     808 stv pos=20 pos2=16 op1=32 op2=30 op3=33
     809 add ln=18 pos=13 pos2=11 op1=30 op2=30 op3=29 // 30 <- 30 op 29
     810 ldi ln=13 pos=13 op1=33 op2=1 // 33 <- i1
     811 bt pos=13 op1=33 pc=805 // goto 805 if 33
     812 addi ln=20 pos=12 pos2=7 op1=31 op2=31 op3=1 // 31 <- 31 + i1
     813 btleinc ln=8 pos=15 next=815 op1=28 binc_inc=1 bcmp_op2=27 bcmp_res=33 pc=799 // goto 799 if 33 <- (28 += i1) cmp 27
     814 btle pos=15 op1=28 bcmp_op2=27 bcmp_res=33 pc=799 // goto 799 if 33 <- 28 cmp 27
     815 move ln=23 pos=10 op1=33 op2=31 rhs_decl=376 // 33 (count) <- 31
     816 ibpcall pos=9 cfblock=674 op1=33 op2=1
     817 bend pos=10 block=0
OUTPUT584
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 585.
if test $result = ok -a $start_test_number -le 585; then
	echo test 585: Read/write dump
        cat >$test_file <<'TEST585'
class node (item, left, right) {}

func BottomUpTree (item, depth) {
  if (depth <= 0) return item;
  var i = item + item;

  depth--;
  return node (item, BottomUpTree (i - 1, depth), BottomUpTree (i, depth));
}

func ItemCheck (tree) {
  return (type (tree) != class ()
	  ? tree : tree.item + ItemCheck (tree.left) - ItemCheck (tree.right));
}

var N = int (#argv < 1 ? 0 : argv [0]);
var mindepth = 4, maxdepth = max (N, mindepth + 2);
var stretchdepth = maxdepth + 1, stretchtree = BottomUpTree (0, stretchdepth);

putf ("stretch tree of depth %d\t  check: %d\n", stretchdepth,
      ItemCheck (stretchtree));

var i, depth, longlivedtree = BottomUpTree (0, maxdepth);

for (depth = mindepth; depth <= maxdepth; depth += 2) {
  var iterations = 1 << (maxdepth - depth + mindepth), check = 0;

  for (i = 0; i < iterations; i++)
    check += (ItemCheck (BottomUpTree (1, depth))
	      + ItemCheck (BottomUpTree (-1, depth)));
  putf ("%d\t  trees of depth %d\t  check: %d\n", iterations*2, depth, check);
}

putf ("long lived tree of depth %d\t  check: %d\n",
      maxdepth, ItemCheck (longlivedtree));
TEST585
        echo '      ' $DINO -d $test_file ">$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
            echo '      ' $DINO -d -i "$stdout" ">$ftemp2"
            if $DINO -d -i "$stdout" > "$ftemp2" 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if $CMP $stdout $ftemp2; then
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
        else
                result=fail
        fi
fi

# Test 586.
if test $result = ok -a $start_test_number -le 586; then
	echo test 586: Different vector binary operations: 1
        cat >$test_file <<'TEST586'
var i, two = 2, three = 3, m = -32;
for (i = 0; i < 2; i++) {
  var v1 = [10:two], v2 = [10:three], v3 = [10:m], v4 = [5:{two}, 5:{three}], t={two};
  println ("+", v1[:] + v2[:]);
  println ("-", v1[:] - v2[:]);
  println ("*", v1[:] * v2[:]);
  println ("<<", v1[:] << v2[:]);
  println (">>", v3[:] >> v2[:]);
  println (">>>", v1[:] >>> v2[:]);
  println ("&", v1[:] & v2[:]);
  println ("^", v1[:] ^ v2[:]);
  println ("|", v1[:] | v2[:]);
  println ("@", v1[:] @ v2[:]);
  println ("in", v1[:] in v4[:]);
  println ("==", v1[:] == v2[:]);
  println ("!=", v1[:] != v2[:]);
  println ("===", v1[:] === v2[:]);
  println ("!==", v1[:] !== v2[:]);
  println ("<=", v1[:] <= v2[:]);
  println ("<", v1[:] < v2[:]);
  println (">=", v1[:] >= v2[:]);
  println (">", v1[:] > v2[:]);
  putln ("--------------------------------");
 
  println ("+", v1[:] + three);
  println ("-", v1[:] - three);
  println ("*", v1[:] * three);
  println ("<<", v1[:] << three);
  println (">>", v3[:] >> three);
  println (">>>", v1[:] >>> three);
  println ("&", v1[:] & three);
  println ("^", v1[:] ^ three);
  println ("|", v1[:] | three);
  println ("@", v1[:] @ three);
  println ("in", v1[:] in t);
  println ("==", v1[:] == three);
  println ("!=", v1[:] != three);
  println ("===", v1[:] === three);
  println ("!==", v1[:] !== three);
  println ("<=", v1[:] <= three);
  println ("<", v1[:] < three);
  println (">=", v1[:] >= three);
  println (">", v1[:] > three);
  putln ("--------------------------------");
  
  println ("+", two + v2[:]);
  println ("-", two - v2[:]);
  println ("*", two * v2[:]);
  println ("<<", two << v2[:]);
  println (">>", m >> v2[:]);
  println (">>>", two >>> v2[:]);
  println ("&", two & v2[:]);
  println ("^", two ^ v2[:]);
  println ("|", two | v2[:]);
  println ("@", two @ v2[:]);
  println ("in", two in v4[:]);
  println ("==", two == v2[:]);
  println ("!=", two != v2[:]);
  println ("===", two === v2[:]);
  println ("!==", two !== v2[:]);
  println ("<=", two <= v2[:]);
  println ("<", two < v2[:]);
  println (">=", two >= v2[:]);
  println (">", two > v2[:]);
  putln ("--------------------------------\n");
  two = 2.0; three = 3.0; m = -32.0;
}
TEST586
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT586' && $CMP $stdout $ftemp2; then
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

OUTPUT586
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 587.
if test $result = ok -a $start_test_number -le 587; then
	echo test 587: Different vector binary operations: 2
        cat >$test_file <<'TEST587'
var i, two = 2, three = 3, m = -32;
for (i = 0; i < 2; i++) {
  var v1 = [10:two, nil], v2 = [10:three], v3 = [10:m, nil];
  var v4 = [5:{two}, 5:{three}], t={two};

  println ("+", v1[0:10] + v2[:]);
  println ("-", v1[0:10] - v2[:]);
  println ("*", v1[0:10] * v2[:]);
  println ("<<", v1[0:10] << v2[:]);
  println (">>", v3[0:10] >> v2[:]);
  println (">>>", v1[0:10] >>> v2[:]);
  println ("&", v1[0:10] & v2[:]);
  println ("^", v1[0:10] ^ v2[:]);
  println ("|", v1[0:10] | v2[:]);
  println ("@", v1[0:10] @ v2[:]);
  println ("in", v1[0:10] in v4[:]);
  println ("==", v1[0:10] == v2[:]);
  println ("!=", v1[0:10] != v2[:]);
  println ("===", v1[0:10] === v2[:]);
  println ("!==", v1[0:10] !== v2[:]);
  println ("<", v1[0:10] < v2[:]);
  println (">", v1[0:10] > v2[:]);
  println ("<=", v1[0:10] <= v2[:]);
  println (">=", v1[0:10] >= v2[:]);
  putln ("--------------------------------");
  
  println ("+", v1[0:10] + 3);
  println ("-", v1[0:10] - 3);
  println ("*", v1[0:10] * 3);
  println ("<<", v1[0:10] << 3);
  println (">>", v3[0:10] >> 3);
  println (">>>", v1[0:10] >>> 3);
  println ("&", v1[0:10] & 3);
  println ("^", v1[0:10] ^ 3);
  println ("|", v1[0:10] | 3);
  println ("@", v1[0:10] @ 3);
  println ("in", v1[0:10] in t);
  println ("==", v1[0:10] == 3);
  println ("!=", v1[0:10] != 3);
  println ("===", v1[0:10] === 3);
  println ("!==", v1[0:10] !== 3);
  println ("<", v1[0:10] < 3);
  println (">", v1[0:10] > 3);
  println ("<=", v1[0:10] <= 3);
  println (">=", v1[0:10] >= 3);
  putln ("--------------------------------\n");
  two = 2.0; three = 3.0; m = -32.0;
}
TEST587
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT587' && $CMP $stdout $ftemp2; then
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

OUTPUT587
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 588.
if test $result = ok -a $start_test_number -le 588; then
	echo test 588: Different vector binary operations: 3
        cat >$test_file <<'TEST588'
var i, two = 2, three = 3, m = -32;
for (i = 0; i < 2; i++) {
  var v1 = [10:two, nil], v2 = [10:three], v3 = [10:m, nil];
  var v4 = [5:{two}, 5:{three}], t={two};

  println ("+", v1[0:10] + v2[:]);
  println ("-", v1[0:10] - v2[:]);
  println ("*", v1[0:10] * v2[:]);
  println ("<<", v1[0:10] << v2[:]);
  println (">>", v3[0:10] >> v2[:]);
  println (">>>", v1[0:10] >>> v2[:]);
  println ("&", v1[0:10] & v2[:]);
  println ("^", v1[0:10] ^ v2[:]);
  println ("|", v1[0:10] | v2[:]);
  println ("@", v1[0:10] @ v2[:]);
  println ("in", v1[0:10] in v4[:]);
  println ("==", v1[0:10] == v2[:]);
  println ("!=", v1[0:10] != v2[:]);
  println ("===", v1[0:10] === v2[:]);
  println ("!==", v1[0:10] !== v2[:]);
  println ("<", v1[0:10] < v2[:]);
  println (">", v1[0:10] > v2[:]);
  println ("<=", v1[0:10] <= v2[:]);
  println (">=", v1[0:10] >= v2[:]);
  putln ("--------------------------------");
  
  println ("+", v1[0:10] + three);
  println ("-", v1[0:10] - three);
  println ("*", v1[0:10] * three);
  println ("<<", v1[0:10] << three);
  println (">>", v3[0:10] >> three);
  println (">>>", v1[0:10] >>> three);
  println ("&", v1[0:10] & three);
  println ("^", v1[0:10] ^ three);
  println ("|", v1[0:10] | three);
  println ("@", v1[0:10] @ three);
  println ("in", v1[0:10] in t);
  println ("==", v1[0:10] == three);
  println ("!=", v1[0:10] != three);
  println ("===", v1[0:10] === three);
  println ("!==", v1[0:10] !== three);
  println ("<", v1[0:10] < three);
  println (">", v1[0:10] > three);
  println ("<=", v1[0:10] <= three);
  println (">=", v1[0:10] >= three);
  putln ("--------------------------------\n");
  two = 2.0; three = 3.0; m = -32.0;
}
TEST588
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT588' && $CMP $stdout $ftemp2; then
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

OUTPUT588
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 589.
if test $result = ok -a $start_test_number -le 589; then
	echo test 589: Different vector binary operations: 4
        cat >$test_file <<'TEST589'
var i, two = 2, three = 3, m = -32;
for (i = 0; i < 2; i++) {
  var v1 = [10:two, nil], v2 = [10:three, 0.5], v3 = [10:m, nil];
  var v4 = [5:{two}, 5:{three}], t={two};

  println ("+", v1[0:10] + v2[:10]);
  println ("-", v1[0:10] - v2[:10]);
  println ("*", v1[0:10] * v2[:10]);
  println ("<<", v1[0:10] << v2[:10]);
  println (">>", v3[0:10] >> v2[:10]);
  println (">>>", v1[0:10] >>> v2[:10]);
  println ("&", v1[0:10] & v2[:10]);
  println ("^", v1[0:10] ^ v2[:10]);
  println ("|", v1[0:10] | v2[:10]);
  println ("@", v1[0:10] @ v2[:10]);
  println ("in", v1[0:10] in v4[:10]);
  println ("==", v1[0:10] == v2[:10]);
  println ("!=", v1[0:10] != v2[:10]);
  println ("===", v1[0:10] === v2[:10]);
  println ("!==", v1[0:10] !== v2[:10]);
  println ("<", v1[0:10] < v2[:10]);
  println (">", v1[0:10] > v2[:10]);
  println ("<=", v1[0:10] <= v2[:10]);
  println (">=", v1[0:10] >= v2[:10]);
  putln ("--------------------------------");

  println ("+", two + v2[:10]);
  println ("-", two - v2[:10]);
  println ("*", two * v2[:10]);
  println ("<<", two << v2[:10]);
  println (">>", m >> v2[:10]);
  println (">>>", two >>> v2[:10]);
  println ("&", two & v2[:10]);
  println ("^", two ^ v2[:10]);
  println ("|", two | v2[:10]);
  println ("@", two @ v2[:10]);
  println ("in", three in v4[0:10]);
  println ("==", two == v2[:10]);
  println ("!=", two != v2[:10]);
  println ("===", two === v2[:10]);
  println ("!==", two !== v2[:10]);
  println ("<", two < v2[:10]);
  println (">", two > v2[:10]);
  println ("<=", two <= v2[:10]);
  println (">=", two >= v2[:10]);
  putln ("--------------------------------\n");
  two = 2.0; three = 3.0; m = -32.0;
}
TEST589
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT589' && $CMP $stdout $ftemp2; then
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[0, 0, 0, 0, 0, 1, 1, 1, 1, 1]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[0, 0, 0, 0, 0, 1, 1, 1, 1, 1]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

OUTPUT589
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 590.
if test $result = ok -a $start_test_number -le 590; then
	echo test 590: Different vector binary operations: 5
        cat >$test_file <<'TEST590'
var i, two = 2, four = 4;
for (i = 0; i < 2; i++) {
  var v1 = [10:two], v2 = [10:four];
  println ("/", v1[:] / v2[:]);
  println ("%", v1[:] % v2[:]);
  println ("/", v2[:] / v1[:]);
  println ("%", v2[:] % v1[:]);
  putln ("--------------------------------");
 
  println ("/", v1[:] / four);
  println ("%", v1[:] % four);
  println ("/", v2[:] / two);
  println ("%", v2[:] % two);
  putln ("--------------------------------");
  
  println ("/", two / v2[:]);
  println ("%", two % v2[:]);
  println ("/", four / v2[:]);
  println ("%", four % v2[:]);
  putln ("--------------------------------");

  v1 = [10:two, nil]; v2 = [10:four];
  println ("/", v1[0:10] / v2[:]);
  println ("%", v1[0:10] % v2[:]);
  println ("/", v2[:] / v1[0:10]);
  println ("%", v2[:] % v1[0:10]);
  putln ("--------------------------------");
  
  println ("/", v1[0:10] / 4);
  println ("%", v1[0:10] % 4);
  println ("/", 4 / v1[0:10]);
  println ("%", 4 % v1[0:10]);
  putln ("--------------------------------");

  v1 = [10:two, nil]; v2 = [10:four, 0.5];
  println ("/", v1[0:10] / v2[:10]);
  println ("%", v1[0:10] % v2[:10]);
  println ("/", four / v2[:10]);
  println ("%", four % v2[:10]);
  putln ("--------------------------------\n");

  two = 2.0; four = 4.0;
}
TEST590
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT590' && $CMP $stdout $ftemp2; then
"/"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

"/"[0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

OUTPUT590
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 591.
if test $result = ok -a $start_test_number -le 591; then
	echo test 591: Different vector fold operations
        cat >$test_file <<'TEST591'
var i, v1 = [10:2];
for (i = 0; i < 4; i++) {
  println (".+", .+v1[0:10]);
  println (".*", .*v1[0:10]);
  println (".&", .&v1[0:10]);
  println (".^", .^v1[0:10]);
  println (".|", .|v1[0:10]);
  putln ("--------------------------------");

  if (i == 0)
    v1 = [10:2, nil];
  else if (i == 1)
    v1 = [10:2.5, nil];
  else
    v1 = [5:2.0, 5:2, nil];
}

v1 = [];
println (".+", .+v1[:]);
println (".*", .*v1[:]);
println (".&", .&v1[:]);
println (".^", .^v1[:]);
println (".|", .|v1[:]);
TEST591
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT591' && $CMP $stdout $ftemp2; then
".+"20
".*"1024
".&"2
".^"0
".|"2
--------------------------------
".+"20
".*"1024
".&"2
".^"0
".|"2
--------------------------------
".+"25
".*"9536.74
".&"2
".^"0
".|"2
--------------------------------
".+"20
".*"1024
".&"2
".^"0
".|"2
--------------------------------
".+"0
".*"1
".&"-1
".^"0
".|"0
OUTPUT591
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 592.
if test $result = ok -a $start_test_number -le 592; then
	echo test 592: Different vector unary operations
        cat >$test_file <<'TEST592'
var i, two = 2;
for (i = 0; i < 2; i++) {
  var v1 = [10:two];
  println ("+", +v1[:]);
  println ("-", -v1[:]);
  println ("!", !v1[:]);
  println ("~", ~v1[:]);
  println ("#", #v1[:]);
  putln ("--------------------------------");
  two = 2.3;
}
TEST592
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT592' && $CMP $stdout $ftemp2; then
"+"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"-"[-2, -2, -2, -2, -2, -2, -2, -2, -2, -2]
"!"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"~"[-3, -3, -3, -3, -3, -3, -3, -3, -3, -3]
"#"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
--------------------------------
"+"[2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3]
"-"[-2.3, -2.3, -2.3, -2.3, -2.3, -2.3, -2.3, -2.3, -2.3, -2.3]
"!"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"~"[-3, -3, -3, -3, -3, -3, -3, -3, -3, -3]
"#"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
--------------------------------
OUTPUT592
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 593.
if test $result = ok -a $start_test_number -le 593; then
	echo test 593: Different vector unary operations 2
        cat >$test_file <<'TEST593'
var i, v = [4:[5:1]];
for (i = 1; i < #v; i++) put (v[i-1] === v[i]);
putln ();
v[:] = new v[:];
println (v);
for (i = 1; i < #v; i++) put (v[i-1] === v[i]);
putln ();
println (v);
TEST593
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT593' && $CMP $stdout $ftemp2; then
111
[[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]
000
[[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]
OUTPUT593
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 594.
if test $result = ok -a $start_test_number -le 594; then
	echo test 594: Different vector unary operations 3
        cat >$test_file <<'TEST594'
var i, two = 2;
for (i = 0; i < 2; i++) {
  var v1 = [10:two];
  println ("type()", type (v1[:]));
  println ("char()", char (v1[:]));
  println ("int()", int (v1[:]));
  println ("float()", float (v1[:]));
  putln ("--------------------------------");
  two = 2.3;
}
TEST594
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT594' && $CMP $stdout $ftemp2; then
"type()"[int, int, int, int, int, int, int, int, int, int]
"char()""\2\2\2\2\2\2\2\2\2\2"
"int()"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"float()"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
--------------------------------
"type()"[float, float, float, float, float, float, float, float, float, float]
"char()""\2\2\2\2\2\2\2\2\2\2"
"int()"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"float()"[2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3]
--------------------------------
OUTPUT594
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 595.
if test $result = ok -a $start_test_number -le 595; then
	echo test 595: Different vector unary operations 4
        cat >$test_file <<'TEST595'
var ct = nil;
thread t {ct = curr_thread;}
class c {}
func f {class fc {};return fc();}
func main {
  var i, one = 1, two = 2, three = 3;
  for (i = 0; i < 2; i++) {
    var v1 = [3:one, 3:two, 3:three];
    println ("func()", func (v1[:]));
    println ("thread()", thread (v1[:]));
    println ("class()", class (v1[:]));
    putln ("--------------------------------");
    one = context (f()); t (); wait (ct != nil); two = ct; three = c ();
  }
}
main ();
TEST595
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT595' && $CMP $stdout $ftemp2; then
"func()"[nil, nil, nil, nil, nil, nil, nil, nil, nil]
"thread()"[nil, nil, nil, nil, nil, nil, nil, nil, nil]
"class()"[nil, nil, nil, nil, nil, nil, nil, nil, nil]
--------------------------------
"func()"[func f, func f, func f, nil, nil, nil, nil, nil, nil]
"thread()"[nil, nil, nil, thread t, thread t, thread t, nil, nil, nil]
"class()"[nil, nil, nil, nil, nil, nil, class c, class c, class c]
--------------------------------
OUTPUT595
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 596
if test $result = ok -a $start_test_number -le 596; then
	echo test 596: Different vector unary operations 5
        cat >$test_file <<'TEST596'
var i, v = [4:[5:1]];
v[:] = final v[:];
println (v);
v[0][0] = 2;
println (v);
TEST596
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT596' && $CMP $stderr $ftemp2; then
test.d:4:5: run time error - attempt to modify immutable vector
OUTPUT596
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT596-2' && $CMP $stdout $ftemp2; then
[[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]
OUTPUT596-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 597.
if test $result = ok -a $start_test_number -le 597; then
	echo test 597: A bug with extended life block
        cat >$test_file <<'TEST597'
var o = nil;
thread t {class tc {}; o = tc ();}
func f {class fc {};return fc();}
func main {
  var one, two;
  one = context (f()); t (); wait (o != nil); two = context (o);
  println (one, two);
}
main ();
TEST597
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT597' && $CMP $ftemp $ftemp2; then
stack f()stack t()
OUTPUT597
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 598.
if test $result = ok -a $start_test_number -le 598; then
	echo test 598: Different vector unary operations 6
        cat >$test_file <<'TEST598'
var i, two = 2, v1 = [5:"ab"];
for (i = 0; i < 2; i++) {
  println ("vector()", vector (v1[:]));
  println ("table()", table (v1[:]));
  putln ("--------------------------------");
  v1 = [{1:2}, {3:4}, {5:6}];
}
TEST598
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT598' && $CMP $stdout $ftemp2; then
"vector()"["ab", "ab", "ab", "ab", "ab"]
"table()"[{0:'a', 1:'b'}, {0:'a', 1:'b'}, {0:'a', 1:'b'}, {0:'a', 1:'b'}, {0:'a', 1:'b'}]
--------------------------------
"vector()"[[1, 2], [3, 4], [5, 6]]
"table()"[{1:2}, {3:4}, {5:6}]
--------------------------------
OUTPUT598
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 599.
if test $result = ok -a $start_test_number -le 599; then
	echo test 599: Different format vector operations
        cat >$test_file <<'TEST599'
var v1=[1.2, 2.3, 3.4, 4.5], v2=["%.3e", "%.5e", "%g", "%+g"];
println (vector (v1[:], "%g"));
println (vector (4.5, v2[:]));
println (vector (v1[:], v2[:]));
TEST599
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT599' && $CMP $stdout $ftemp2; then
["1.2", "2.3", "3.4", "4.5"]
["4.500e+00", "4.50000e+00", "4.5", "+4.5"]
["1.200e+00", "2.30000e+00", "3.4", "+4.5"]
OUTPUT599
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 600.
if test $result = ok -a $start_test_number -le 600; then
	echo test 600: Different slice assignments
        cat >$test_file <<'TEST600'
var m = new [5:[7:1]];
m[::2][::3]=5;
println (m);
TEST600
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT600' && $CMP $stdout $ftemp2; then
[[5, 1, 1, 5, 1, 1, 5], [5, 1, 1, 5, 1, 1, 5], [5, 1, 1, 5, 1, 1, 5], [5, 1, 1, 5, 1, 1, 5], [5, 1, 1, 5, 1, 1, 5]]
OUTPUT600
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 601.
if test $result = ok -a $start_test_number -le 601; then
	echo test 601: Different slice assignments 2
        cat >$test_file <<'TEST601'
var i,v=[20:0], r=[30:0];
for (i = 0; i < #r; i++)r[i]=i;
v[5:15:2] = r[1:6];
println (v);
v=[20:0.5];
v[5:15:2] = r[1:6];
println (v);
TEST601
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT601' && $CMP $stdout $ftemp2; then
[0, 0, 0, 0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0]
[0.5, 0.5, 0.5, 0.5, 0.5, 1, 0.5, 2, 0.5, 3, 0.5, 4, 0.5, 5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
OUTPUT601
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 602.
if test $result = ok -a $start_test_number -le 602; then
	echo test 602: Different slice assignments 3
        cat >$test_file <<'TEST602'
var i, r=[30:0];
for (i = 0; i < #r; i++)r[i]=i;
r[:] = r[::-1];
println (r);
TEST602
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT602' && $CMP $stdout $ftemp2; then
[29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
OUTPUT602
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 603.
if test $result = ok -a $start_test_number -le 603; then
	echo test 603: Different slice assignments 4
        cat >$test_file <<'TEST603'
var r = 5, perm1=[10:0], i, t;
for (i = 0; i < 10; i++) perm1[i] = i;

println (r, perm1);
t = perm1[0]; perm1[0:r-1] = perm1[1:r]; perm1[r-1] = t;
println (perm1);
TEST603
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT603' && $CMP $stdout $ftemp2; then
5[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[1, 2, 3, 4, 0, 5, 6, 7, 8, 9]
OUTPUT603
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 604
if test $result = ok -a $start_test_number -le 604; then
	echo test 604: Wrong slice assignment
        cat >$test_file <<'TEST604'
var i, r=[30:0];
for (i = 0; i < #r; i++)r[i]=i;
r[1:5] = r[2:5];
println (r);
TEST604
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT604' && $CMP $stderr $ftemp2; then
test.d:3:2: run time error - different lengths of slices 4 vs 3 (dimension = 1)
OUTPUT604
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT604-2' && $CMP $stdout $ftemp2; then
OUTPUT604-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 605.
if test $result = ok -a $start_test_number -le 605; then
	echo test 605: Anonymous func/class/thread
        cat >$test_file <<'TEST605'
putln (afunc (a,b) {return a < b ? a : b;} (3, 5));
afunc (a,b) {putln (a > b ? a : b);} (3, 5);
var o = aclass (c) {};
putln (o (42).c);
athread {put ("Wait... "); wait (o==nil); putln ("Continue");} ();
o = nil;
TEST605
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT605' && $CMP $stdout $ftemp2; then
3
5
42
Wait... Continue
OUTPUT605
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 606.
if test $result = ok -a $start_test_number -le 606; then
	echo test 606: Fold function
        cat >$test_file <<'TEST606'
var v = [1,2,3,4];
println (fold (afunc (a, b) {return a + b;}, v[:], 0));
println (fold (afunc (a, b) {return a * b;}, v[:], 1));
var f = fold;
println (f (afunc (a, b) {return a * b;}, v[:], 1));
TEST606
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT606' && $CMP $stdout $ftemp2; then
10
24
24
OUTPUT606
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 607
if test $result = ok -a $start_test_number -le 607; then
	echo test 607: Wrong fold argument
        cat >$test_file <<'TEST607'
var v = [1,2,3,4];
println (fold (afunc (a, b) {return a + b;}, nil, 0));
TEST607
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT607' && $CMP $stderr $ftemp2; then
test.d:2:15: run time error - invalid parameter type of `fold'
OUTPUT607
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT607-2' && $CMP $stdout $ftemp2; then
OUTPUT607-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 608.
if test $result = ok -a $start_test_number -le 608; then
	echo test 608: Filter function
        cat >$test_file <<'TEST608'
var i, v = [0, 1, -2, 3, -4];
println (filter (afunc (a) {return a > 0;}, v));
v = [[0, 1, -2, 3, -4], [5, -6, 7, -8, 9]];
println (filter (afunc (a) {return a > 0;}, v, 2));
for (i = 0; i < 1000; i++) {
  v = [[0, 1.1, -2, 3, -4], [5, -6.1, 7, -8, 9]];
  v = filter (afunc (a) {if (i % 100) gc ();return a > 0;}, v, 2);
}
println (v);
TEST608
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT608' && $CMP $stdout $ftemp2; then
[1, 3]
[[1, 3], [5, 7, 9]]
[[1.1, 3], [5, 7, 9]]
OUTPUT608
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 609
if test $result = ok -a $start_test_number -le 609; then
	echo test 609: Wrong filter argument
        cat >$test_file <<'TEST609'
var v = [0, 1, -2, 3, -4];
println (filter (afunc (a) {return a > 0;}, nil));
TEST609
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT609' && $CMP $stderr $ftemp2; then
test.d:2:17: run time error - invalid parameter type of `filter'
OUTPUT609
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT609-2' && $CMP $stdout $ftemp2; then
OUTPUT609-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 610
if test $result = ok -a $start_test_number -le 610; then
	echo test 610: Another wrong filter argument
        cat >$test_file <<'TEST610'
var v = [[0, 1, -2, 3, -4], [5, -6, 7, -8, 9]];
println (filter (afunc (a) {return a > 0;}, v));
TEST610
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT610' && $CMP $stderr $ftemp2; then
test.d:2:38: run time error - invalid types of operands of operator ">"
OUTPUT610
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT610-2' && $CMP $stdout $ftemp2; then
OUTPUT610-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 611
if test $result = ok -a $start_test_number -le 611; then
	echo test 611: Wrong filter function result
        cat >$test_file <<'TEST611'
var v = [[0, 1, -2, 3, -4], [5, -6, 7, -8, 9]];
println (filter (afunc (a) {return nil;}, v, 2));
TEST611
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT611' && $CMP $stderr $ftemp2; then
test.d:2:17: run time error - invalid function result used by function `filter'
OUTPUT611
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT611-2' && $CMP $stdout $ftemp2; then
OUTPUT611-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 612.
if test $result = ok -a $start_test_number -le 612; then
	echo test 612: Map function
        cat >$test_file <<'TEST612'
var i, v = [[0, 1, -2, 3, -4], [5, -6, 7, -8, 9]];
println (map (afunc (a) {return a < 0 ? nil : a;}, v, 2));
for (i = 0; i < 1000; i++) {
  v = [[0, 1.1, -2, 3, -4], [5, -6.1, 7, -8, 9]];
  v = map (afunc (a) {if (i % 100) gc ();return a < 0 ? 0 : a;}, v, 2);
}
println (v);
TEST612
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT612' && $CMP $stdout $ftemp2; then
[[0, 1, nil, 3, nil], [5, nil, 7, nil, 9]]
[[0, 1.1, 0, 3, 0], [5, 0, 7, 0, 9]]
OUTPUT612
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 613
if test $result = ok -a $start_test_number -le 613; then
	echo test 613: Wrong map argument
        cat >$test_file <<'TEST613'
var v = [0, 1, -2, 3, -4];
println (map (afunc (a) {return a > 0;}, nil));
TEST613
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT613' && $CMP $stderr $ftemp2; then
test.d:2:14: run time error - invalid parameter type of `map'
OUTPUT613
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT613-2' && $CMP $stdout $ftemp2; then
OUTPUT613-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 614
if test $result = ok -a $start_test_number -le 614; then
	echo test 614: Another wrong map argument
        cat >$test_file <<'TEST614'
var v = [[0, 1, -2, 3, -4], [5, -6, 7, -8, 9]];
println (map (afunc (a) {return a > 0;}, v));
TEST614
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT614' && $CMP $stderr $ftemp2; then
test.d:2:35: run time error - invalid types of operands of operator ">"
OUTPUT614
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT614-2' && $CMP $stdout $ftemp2; then
OUTPUT614-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 615.
if test $result = ok -a $start_test_number -le 615; then
	echo test 615: addi generation
        cat >$test_file <<'TEST615'
for (var i = 0; i < 1000; i--);
TEST615
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep addi $stdout
                if fgrep addi $stdout > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 616.
if test $result = ok -a $start_test_number -le 616; then
	echo test 616: addi generation
        cat >$test_file <<'TEST616'
var i = 0;
i++;
i+=2;
i=i+3;
i=4+i;
TEST616
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' expr '`' fgrep addi $stdout '|wc -l`' = 4
                if expr `fgrep " addi" $stdout|wc -l` = 4 > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 617.
if test $result = ok -a $start_test_number -le 617; then
	echo test 617: btcmp generation
        cat >$test_file <<'TEST617'
var i = 0, k = 0;
for (;i!=k;);
for (;i==k;);
for (;i<=k;);
for (;i<k;);
for (;i>=k;);
for (;i>k;);
TEST617
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep btne $stdout '&&' fgrep bteq $stdout '&&' fgrep btle $stdout '&&' fgrep btlt $stdout '&&' fgrep btge $stdout '&&' fgrep btgt $stdout
                if (fgrep btne $stdout && fgrep bteq $stdout && fgrep btle $stdout && fgrep btlt $stdout && fgrep btge $stdout && fgrep btgt $stdout) > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 618.
if test $result = ok -a $start_test_number -le 618; then
	echo test 618: addi with neg. constant generation
        cat >$test_file <<'TEST618'
var i = 0;
i--;
i-=2;
i=i-3;
i=4-i;
TEST618
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' expr '`fgrep addi' $stdout '|wc -l`' = 3
                if expr `fgrep " addi" $stdout|wc -l` = 3 > /dev/null ; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 619.
if test $result = ok -a $start_test_number -le 619; then
	echo test 619: no addi generation for slices
        cat >$test_file <<'TEST619'
var i = [10:0];
i[:]++;
i[:]=i[:]+1;
TEST619
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep -v addi $stdout
                if fgrep -v addi $stdout > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 620.
if test $result = ok -a $start_test_number -le 620; then
	echo test 620: btcmpinc generation
        cat >$test_file <<'TEST620'
var i = 0, k = 10, n= 1;
for (;i!=k;i++)n++;
for (;i==k;i++)n++;
for (;i<=k;i++)n++;
for (;i<k;i++)n++;
for (;i>=k;i++)n++;
for (;i>k;i++)n++;
TEST620
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep btneinc $stdout '&&' fgrep bteqinc $stdout '&&' fgrep btleinc $stdout '&&' fgrep btltinc $stdout '&&' fgrep btgeinc $stdout '&&' fgrep btgtinc $stdout
                if (fgrep btneinc $stdout && fgrep bteqinc $stdout && fgrep btleinc $stdout && fgrep btltinc $stdout && fgrep btgeinc $stdout && fgrep btgtinc $stdout) > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 621.
if test $result = ok -a $start_test_number -le 621; then
	echo test 621: bfcmp generation
        cat >$test_file <<'TEST621'
var i=1, b=5, n=0;
if (i < b) n++;else n--;
TEST621
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep btge $stdout
                if fgrep btge $stdout > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 622.
if test $result = ok -a $start_test_number -le 622; then
	echo test 622: Call tail optimization
        cat >$test_file <<'TEST622'
func even;
func odd (n) {
  if (n == 0) return 0;
  return even (n - 1);
}

func even (n) {
  if (n == 0) return 1;
  return odd (n - 1);
}

putln ("odd  (10000000) = ", odd (10000000));
putln ("even (10000000) = ", even (10000000));
TEST622
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT622' && $CMP $stdout $ftemp2; then
odd  (10000000) = 0
even (10000000) = 1
OUTPUT622
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 623.
if test $result = ok -a $start_test_number -le 623; then
	echo test 623: Immediate call generation
        cat >$test_file <<'TEST623'
func f {
  func h {
  }
  func g {
     h ();
  }
  g ();
}
f();
TEST623
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep  $stdout itpcall '&&' fgrep citpcall $stdout '&&' fgrep titpcall $stdout
                if (fgrep itpcall $stdout && fgrep citpcall $stdout && fgrep titpcall $stdout) > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 624.
if test $result = ok -a $start_test_number -le 624; then
	echo test 624: Branch and compare with immediate generation
        cat >$test_file <<'TEST624'
var i = 0;
if (i < 1) i++;
if (i > 1) i++;
if (i <= 1) i++;
if (i >= 1) i++;
if (i == 1) i++;
if (i != 1) i++;
if (2 < i) i++;
if (2 > i) i++;
if (2 <= i) i++;
if (2 >= i) i++;
if (2 == i) i++;
if (2 != i) i++;
TEST624
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' expr '`' egrep "'btgei|btlei|btgti|btlti|btnei|bteqi'" $stdout '| wc -l`' = 12
                if expr `egrep 'btgei|btlei|btgti|btlti|btnei|bteqi' $stdout | wc -l` = 12 > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 625.
if test $result = ok -a $start_test_number -le 625; then
	echo test 625: Compare with immediate generation
        cat >$test_file <<'TEST625'
var i = 0;
i = i < 1;
i = i > 1;
i = i <= 1;
i = i >= 1;
i = i == 1;
i = i != 1;
i = 2 < i;
i = 2 > i;
i = 2 <= i;
i = 2 >= i;
i = 2 == i;
i = 2 != i;
TEST625
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' expr '`' egrep "'gei|lei|gti|lti|nei|eqi'" $stdout '| wc -l`' = 12
                if expr `egrep 'gei|lei|gti|lti|nei|eqi' $stdout | wc -l` = 12 > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 626
if test $result = ok -a $start_test_number -le 626; then
	echo test 626: Too few actuals
        cat >$test_file <<'TEST626'
func f (a, b) {
}

f(1);
TEST626
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT626' && $CMP $stderr $ftemp2; then
test.d:4:2: run time error - too few actual parameters for `f'
OUTPUT626
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT626-2' && $CMP $stdout $ftemp2; then
OUTPUT626-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 627
if test $result = ok -a $start_test_number -le 627; then
	echo test 627: Too many actuals
        cat >$test_file <<'TEST627'
func f {
}

f(1);
TEST627
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT627' && $CMP $stderr $ftemp2; then
test.d:4:2: run time error - too many actual parameters for `f'
OUTPUT627
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT627-2' && $CMP $stdout $ftemp2; then
OUTPUT627-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 628
if test $result = ok -a $start_test_number -le 628; then
	echo test 628: Too few actuals when ... is present
        cat >$test_file <<'TEST628'
func f (a, ...) {
}

f ();
TEST628
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT628' && $CMP $stderr $ftemp2; then
test.d:4:3: run time error - too few actual parameters for `f'
OUTPUT628
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT628-2' && $CMP $stdout $ftemp2; then
OUTPUT628-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 629
if test $result = ok -a $start_test_number -le 629; then
	echo test 629: Undefined comparison values
        cat >$test_file <<'TEST629'
var i;
println (i == 10);
TEST629
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT629' && $CMP $stderr $ftemp2; then
test.d:2:12: run time error - invalid types of operands of operator "==" or "!="
OUTPUT629
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT629-2' && $CMP $stdout $ftemp2; then
OUTPUT629-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 630
if test $result = ok -a $start_test_number -le 630; then
	echo test 630: Undefined identity values
        cat >$test_file <<'TEST630'
var i;
println (i !== 10);
TEST630
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT630' && $CMP $stderr $ftemp2; then
test.d:2:12: run time error - invalid types of operands of operator "===" or "!=="
OUTPUT630
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT630-2' && $CMP $stdout $ftemp2; then
OUTPUT630-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 631
if test $result = ok -a $start_test_number -le 631; then
	echo test 631: Undefined local values
        cat >$test_file <<'TEST631'
var i, j = i;
TEST631
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT631' && $CMP $stderr $ftemp2; then
test.d:1:10: run time error - undefined `i' value access
OUTPUT631
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT631-2' && $CMP $stdout $ftemp2; then
OUTPUT631-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 632
if test $result = ok -a $start_test_number -le 632; then
	echo test 632: Undefined object values
        cat >$test_file <<'TEST632'
class c { var i;}
println (c().i);
TEST632
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT632' && $CMP $stderr $ftemp2; then
test.d:2:13: run time error - undefined `i' value access
OUTPUT632
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT632-2' && $CMP $stdout $ftemp2; then
OUTPUT632-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 633
if test $result = ok -a $start_test_number -le 633; then
	echo test 633: Undefined global values
        cat >$test_file <<'TEST633'
var i;
func f {
  return i;
}

f();
TEST633
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT633' && $CMP $stderr $ftemp2; then
test.d:3:9: run time error - undefined `i' value access
OUTPUT633
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT633-2' && $CMP $stdout $ftemp2; then
OUTPUT633-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 634
if test $result = ok -a $start_test_number -le 634; then
	echo test 634: This not in func/block/ext
        cat >$test_file <<'TEST634'
var i = this;
TEST634
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT634' && $CMP $stderr $ftemp2; then
test.d:1:9: this is not in function, class, or extension
OUTPUT634
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT634-2' && $CMP $stdout $ftemp2; then
OUTPUT634-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 635.
if test $result = ok -a $start_test_number -le 635; then
	echo test 635: This in func/class/extension
        cat >$test_file <<'TEST635'
var i; func f {i = this;}
class c {i = this;}
thread t {i = this;}
TEST635
        echo '      ' $DINO $test_file "2>$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT635' && $CMP $stdout $ftemp2; then
OUTPUT635
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 636.
if test $result = ok -a $start_test_number -le 636; then
	echo test 636: Correct this value in func/class/extension
        cat >$test_file <<'TEST636'
var i; func f {i = this;} f (); putln (inside (i, f));
class c {i = this;} c (); putln (inside (i, c));
var s = 0; func t {i = this; s = 1;} t (); wait (s == 1); putln (inside (i, t));
class c1 {} ext c1 {i=this;} c1 (); putln (inside (i, c1));
TEST636
        echo '      ' $DINO $test_file "2>$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT636' && $CMP $stdout $ftemp2; then
1
1
1
1
OUTPUT636
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 637.
if test $result = ok -a $start_test_number -le 637; then
	echo test 637: Condition generation of if or for statements
        cat >$test_file <<'TEST637'
val i = 1, j = 2, k = 3;
if (i < j && j < k) putln();
if (i < j || j < k) putln();
if (! (i < j)) putln ();

for (;i < j && j < k;) putln();
for (;i < j || j < k;) putln();
for (;! (i < j);) putln ();

if (1) putln ();
if (!1) putln ();
TEST637
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep -v lconv $stdout '&&' fgrep -v brfs $stdout '&&' fgrep -v brts $stdout
                if (fgrep -v lconv $stdout && fgrep -v brfs $stdout && fgrep -v brts $stdout) > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 638.
if test $result = ok -a $start_test_number -le 638; then
	echo test 638: Condition generation result
        cat >$test_file <<'TEST638'
var i = 1, j = 2, k = 3;
i = i < j && j < k;
i = i < j || j < k;
i = ! (i < j);
TEST638
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep lconv $stdout '&&' fgrep brfs $stdout '&&' fgrep brts $stdout '&&' fgrep not $stdout
                if (fgrep lconv $stdout && fgrep brfs $stdout && fgrep brts $stdout && fgrep not $stdout) > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 639.
if test $result = ok -a $start_test_number -le 639; then
	echo test 639: Transpose function: expected results
        cat >$test_file <<'TEST639'
var m=[[1]];
println (transpose(m));
m=[[1,2],[3,4]];
println (transpose(m));
m=[[1,2,3],[4,5,6]];
println (transpose(m));
m=[[1,2]];
println (transpose(m));
m=[[1],[2]];
println (transpose(m));
m=[[1],['a']];
println (transpose(m));
TEST639
        echo '      ' $DINO $test_file "2>$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT639' && $CMP $stdout $ftemp2; then
[[1]]
[[1, 3], [2, 4]]
[[1, 4], [2, 5], [3, 6]]
[[1], [2]]
[[1, 2]]
[[1, 'a']]
OUTPUT639
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 640
if test $result = ok -a $start_test_number -le 640; then
	echo test 640: Transpose function: not vector
        cat >$test_file <<'TEST640'
var m=1;
println (transpose(m));
TEST640
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT640' && $CMP $stderr $ftemp2; then
test.d:2:19: run time error - invalid parameter type of `transpose'
OUTPUT640
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT640-2' && $CMP $stdout $ftemp2; then
OUTPUT640-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 641
if test $result = ok -a $start_test_number -le 641; then
	echo test 641: Transpose function: empty vector
        cat >$test_file <<'TEST641'
val m=[];
println (transpose(m));
TEST641
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT641' && $CMP $stderr $ftemp2; then
test.d:2:19: run time error - wrong matrix form for matrix operation `transpose'
OUTPUT641
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT641-2' && $CMP $stdout $ftemp2; then
OUTPUT641-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 642
if test $result = ok -a $start_test_number -le 642; then
	echo test 642: Transpose function: different row lengths
        cat >$test_file <<'TEST642'
val m=[[1],[2,3]];
println (transpose(m));
TEST642
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT642' && $CMP $stderr $ftemp2; then
test.d:2:19: run time error - wrong matrix form for matrix operation `transpose'
OUTPUT642
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT642-2' && $CMP $stdout $ftemp2; then
OUTPUT642-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 643
if test $result = ok -a $start_test_number -le 643; then
	echo test 643: Transpose function: empty row
        cat >$test_file <<'TEST643'
val m=[[]];
println (transpose(m));
TEST643
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT643' && $CMP $stderr $ftemp2; then
test.d:2:19: run time error - wrong matrix form for matrix operation `transpose'
OUTPUT643
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT643-2' && $CMP $stdout $ftemp2; then
OUTPUT643-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 644.
if test $result = ok -a $start_test_number -le 644; then
	echo test 644: REPL correct program
        cat >$test_file <<'TEST644'
func fact (x)
{
  if (x <= 1)
    return 1;
  return x * fact (x-1);
}

var i, x, n = 3;

for (i = 0; i < n; i++)
  x = fact (12);

putln (x);
TEST644
        echo '      ' $DINO "<" $test_file "2>&1 | fgrep -v version >$stdout"
        if $DINO < $test_file 2>&1 | fgrep -v version >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT644' && $CMP $stdout $ftemp2; then
Use "exit(<int>);" or Ctrl-D to exit
dino>     |     |     |     |     | dino> dino> dino> dino>     | dino> dino> 479001600
dino> 
OUTPUT644
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 645.
if test $result = ok -a $start_test_number -le 645; then
	echo test 645: REPL syntax error
        cat >$test_file <<'TEST645'
val ;
putln ("Right");
val ;
putln ("Right again");
TEST645
        echo '      ' $DINO "<" $test_file "2>&1 | fgrep -v version >$stdout"
        if $DINO < $test_file 2>&1 | fgrep -v version >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT645' && $CMP $stdout $ftemp2; then
Use "exit(<int>);" or Ctrl-D to exit
dino>       val ;
          ^
      syntax error
dino> Right
dino>       val ;
          ^
      syntax error
dino> Right again
dino> 
OUTPUT645
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 646.
if test $result = ok -a $start_test_number -le 646; then
	echo test 646: REPL context error
        cat >$test_file <<'TEST646'
final func f;
func f{}
putln ("Right");
final func f;
func f{}
putln ("Right again");
throw 1;
putln ("One more: right");
TEST646
        echo '      ' $DINO "<" $test_file "2>&1 | fgrep -v version >$stdout"
        if $DINO < $test_file 2>&1 | fgrep -v version >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT646' && $CMP $stdout $ftemp2; then
Use "exit(<int>);" or Ctrl-D to exit
dino> dino>       func f{}
           ^
      forward and matched decls of `f' have different access/final attributes
      final func f;
                 ^
      (previous declaration of identifier `f')
dino> Right
dino> dino>       func f{}
           ^
      forward and matched decls of `f' have different access/final attributes
      final func f;
                 ^
      (previous declaration of identifier `f')
dino> Right again
dino>       throw 1;
      ^
      invalid type of throw-expr
dino> One more: right
dino> 
OUTPUT646
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 647.
if test $result = ok -a $start_test_number -le 647; then
	echo test 647: REPL eval error
        cat >$test_file <<'TEST647'
val i = 5/0;
putln ("Right");
val i = 5/0;
putln ("Right again");
val i = 5/0;
putln ("One more: right");
TEST647
        echo '      ' $DINO "<" $test_file "2>&1 | fgrep -v version >$stdout"
        if $DINO < $test_file 2>&1 | fgrep -v version >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT647' && $CMP $stdout $ftemp2; then
Use "exit(<int>);" or Ctrl-D to exit
dino>       val i = 5/0;
               ^
      floating point exception
dino> Right
dino>       val i = 5/0;
               ^
      floating point exception
dino> Right again
dino>       val i = 5/0;
               ^
      floating point exception
dino> One more: right
dino> 
OUTPUT647
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Final message

if test $result = ok; then
        echo $script_file: it is all ok
        rm -f $test_file $test_file_1 $stderr a.out $stdout $ftemp $ftemp2
	rm -rf $tempdir
        exit 0
else
        echo '***' $script_file:test is failed
        echo '   '  see files $test_file, $stdout, $test_file_1, $stderr, $ftemp, $ftemp2, $tempdir
        exit 1
fi
