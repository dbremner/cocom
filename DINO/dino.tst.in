#!/bin/sh

#
# Script to test of DINO.
#
# Copyright (C) 1997-2013 Vladimir Makarov.
# 
# Written by Vladimir Makarov <vmakarov@users.sourceforge.net>
# 
# This file is part of interpreter of DINO.
# 
# This is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
# 
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with GNU CC; see the file COPYING.  If not, write to the Free
# Software Foundation, 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.
#
#
# Usage: dino.tst [start_test_number [build by MSVC]] 
#
# The script outputs self-explanatory messages and returns zero exit code if 
# it is all ok.
#

DINO=./dino
script_file=$0
test_file=test.d
test_file_1=test1.d
stderr=_stderr.out
stdout=_stdout.out
ftemp=_temp.out
ftemp2=_temp2.out
tempdir=__tempdir
result=ok

if uname | fgrep CYGWIN; then
   CMP="eval sh -c 'tr -d \\\\r <\$0 >__tmp && mv __tmp \$0 && tr -d \\\\r <\$1 >__tmp && mv __tmp \$1 && cmp \$0 \$1'"
   SCMP="eval sh -c 'tr -d \\\\r <\$0 >__tmp && mv __tmp \$0 && cmp \$0 \$1'"
else
   CMP=cmp
   SCMP=cmp
fi

if test x$1 = x
then
    start_test_number=1
else
    if expr $1 + 0 >/dev/null
    then
        start_test_number=`expr $1 + 0`
    else
        echo $script_file:invalid argument $1 2>&1
        exit 1
    fi
fi

if test x$2 = x
then
    msvc=
else
    msvc=yes
fi

# Test 1.
if test $result = ok -a $start_test_number -le 1; then
	echo test 1
        cat >$test_file <<'TEST1'
var i;
i = 0;
i++;
TEST1
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        else
                result=fail
        fi
fi


# Test 2.
if test $result = ok -a $start_test_number -le 2; then
	echo test 2
        cat >$test_file <<'TEST2'
var i;
for (i = 0; i < 100000; i++);
TEST2
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        else
                result=fail
        fi
fi

# Test 3.
if test $result = ok -a $start_test_number -le 3; then
	echo test 3
        cat >$test_file <<'TEST3'
fun f {}
var i;
for (i = 0; i < 100000;i++)
 f ();
TEST3
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        else
                result=fail
        fi
fi

# Test 4.
if test $result = ok -a $start_test_number -le 4; then
	echo test 4
        cat >$test_file <<'TEST4'
fun f {
  {
    return 10;
  }
}

var i;
i = f ();
println (i);
TEST4
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT4' && $CMP $stdout $ftemp2; then
10
OUTPUT4
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 5.
if test $result = ok -a $start_test_number -le 5; then
	echo test 5
        cat >$test_file <<'TEST5'
fun f {}
class c {}

putln ("0:", "abc" === "abc");
putln ("1:", 'c' === 'c');
putln ("1:", 10 === 10);
putln ("1:", 10.5 === 10.5);
	   
putln ("1:", f === f);
putln ("0:", f === c);
putln ("1:", c === c);
putln ("0:", c() === c());
	   
putln ("0:", 10 === "10");
putln ("0:", 10.5 === "10.5");
putln ("0:", 'c' === "c");

var op;
op = "abc";
putln ("0:", op === "abc");
op = 'c';
putln ("1:", op === 'c');
op = 10;
putln ("1:", op === 10);
op = 10.5;
putln ("1:", op === 10.5);

op = f;
putln ("1:", op === f);
putln ("0:", f === c);
op = c();
putln ("0:", op === c());
putln ("1:", op === op);

op = 10;
putln ("0:", op === "10");
op = 10.5;
putln ("0:", op === "10.5");
op = 'c';
putln ("0:", op === "c");
op = "abc";
putln ("0:", op === "abc");
TEST5
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT5' && $CMP $stdout $ftemp2; then
0:0
1:1
1:1
1:1
1:1
0:0
1:1
0:0
0:0
0:0
0:0
0:0
1:1
1:1
1:1
1:1
0:0
0:0
1:1
0:0
0:0
0:0
0:0
OUTPUT5
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 6.
if test $result = ok -a $start_test_number -le 6; then
	echo test 6
        cat >$test_file <<'TEST6'
fun f {}
putln ("0:", f === 10);
TEST6
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT6' && $CMP $stdout $ftemp2; then
0:0
OUTPUT6
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 7.
if test $result = ok -a $start_test_number -le 7; then
	echo test 7
        cat >$test_file <<'TEST7'
class c {}
putln ("0:", c === 10);
TEST7
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT7' && $CMP $stdout $ftemp2; then
0:0
OUTPUT7
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 8.
if test $result = ok -a $start_test_number -le 8; then
	echo test 8
        cat >$test_file <<'TEST8'
class c {}
putln ("0:", c () === 10);
TEST8
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT8' && $CMP $stdout $ftemp2; then
0:0
OUTPUT8
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 9.
if test $result = ok -a $start_test_number -le 9; then
	echo test 9
        cat >$test_file <<'TEST9'
var i = nil;
putln ("1:", i == nil);
putln ("0:", i != nil);
putln ("1:", i === nil);
putln ("0:", i !== nil);
fun f {}
try {putln ("1:", f () == nil);}
catch (optype) {putln ("1:1");}
fun g {return;}
try {putln ("1:", f () == nil);}
catch (optype) {putln ("1:1");}
var t;
t = tab ["e"];
putln ("1:", t["e"] == nil);
TEST9
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT9' && $CMP $stdout $ftemp2; then
1:1
0:0
1:1
0:0
1:1
1:1
1:1
OUTPUT9
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 10.
if test $result = ok -a $start_test_number -le 10; then
	echo test 10
        cat >$test_file <<'TEST10'
var i;
i = 10 + "aaa";
i = 10 @ "aaa";
i = 10 == "aaa";
TEST10
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST10-1'; then
test.d:2:8: run time error - invalid types of operands of operator "+"
TEST10-1
                result=ok
        else
                result=fail
        fi
fi

# Test 11.
if test $result = ok -a $start_test_number -le 11; then
	echo test 11
        cat >$test_file <<'TEST11'
fun f {putln ("eval false");return 0;}
fun t {putln ("eval true");return 1;}

var i;
putln ("++test false and true");
i = f() && t ();
putln ("++test true and true");
i = t() && t ();
putln ("++test true or true");
i = t() || t ();
putln ("++test false or true");
i = f() || t ();
putln ("++conditional: f ? t : f");
i = f() ? t () : f ();
putln ("++conditional: t ? t : f");
i = t() ? t () : f ();
TEST11
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT11' && $CMP $stdout $ftemp2; then
++test false and true
eval false
++test true and true
eval true
eval true
++test true or true
eval true
++test false or true
eval false
eval true
++conditional: f ? t : f
eval false
eval false
++conditional: t ? t : f
eval true
eval true
OUTPUT11
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 12.
if test $result = ok -a $start_test_number -le 12; then
	echo test 12
        cat >$test_file <<'TEST12'
fun fact (x)
{
  if (x <= 1)
    return 1;
  return x * fact (x-1);
}

var i, x;

for (i = 0; i < 1000; i++)
  x = fact (12);

putln (x);
TEST12
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT12' && $CMP $stdout $ftemp2; then
479001600
OUTPUT12
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 13.
if test $result = ok -a $start_test_number -le 13; then
	echo test 13
        cat >$test_file <<'TEST13'
putln ("length of abcd - ", #"abcd");
TEST13
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT13' && $CMP $stdout $ftemp2; then
length of abcd - 4
OUTPUT13
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 14.
if test $result = ok -a $start_test_number -le 14; then
	echo test 14
        cat >$test_file <<'TEST14'
var s, ns, t;
s = "aaaa";
ns = new s;
ns[1] = "b";
println (s,ns);

s = tab ["a"];
ns = new s;
ns["a"] = "b";
println (s,ns);

s = ['a'];
t = tab [s:"a"];
ns = new s;
ns[0] = 'b';
println (s, ns);

class c()
{
  var i = nil;
}
var o, no;
o = final c ();
no = new o;
no.i = 10;
println (o.i, no.i);

s = "10" @ new "10";
s[0] = 'c';
TEST14
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT14' && $CMP $stdout $ftemp2; then
"aaaa"['a', "b", 'a', 'a']
tab ["a":nil]tab ["a":"b"]
"a""b"
nil10
OUTPUT14
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 15.
if test $result = ok -a $start_test_number -le 15; then
	echo test 15
        cat >$test_file <<'TEST15'
var i;
for (i = 0.0; i < 100000.0; i = i + 1.0);
TEST15
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT15' && $CMP $stdout $ftemp2; then
OUTPUT15
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 16.
if test $result = ok -a $start_test_number -le 16; then
	echo test 16
        cat >$test_file <<'TEST16'
fun tak (x, y, z)
  {
    if (y >= x)
        return z;
    else
        return tak (tak (x-1, y, z), tak (y-1, z, x), tak (z-1, x, y));
  }
putln (tak(18, 12, 6));
TEST16
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT16' && $CMP $stdout $ftemp2; then
7
OUTPUT16
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 17.
if test $result = ok -a $start_test_number -le 17; then
	echo test 17
        cat >$test_file <<'TEST17'
var i, t;
t = tab ["e":10, 10:11];
putln (t["e"]);
putln (t[10]);
putln ("e in t - 1:", "e" in t);
putln ("10 in t - 1:", 10 in t);
putln ("11 in t - 0:", 11 in t);
t = tab ["e":10, "f":11, "g":12, "h":13];
for (i: t) putln (i);
t = tab ["e", "f", "g", "h"];
for (i: t) putln (i);
TEST17
        echo '      ' $DINO $test_file "2>$stderr" ">$ftemp2" '&&' sort $ftemp2 ">$stdout"
        if $DINO $test_file 2>$stderr >$ftemp2 && sort $ftemp2 >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT17' && $CMP $stdout $ftemp2; then
10
10 in t - 1:1
11
11 in t - 0:0
e
e
e in t - 1:1
f
f
g
g
h
h
OUTPUT17
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 18.
if test $result = ok -a $start_test_number -le 18; then
	echo test 18
        cat >$test_file <<'TEST18'
var t;
t = tab [];
t["e"] = 10;
t[10] = 11;
putln (t["e"]);
putln (t[10]);
TEST18
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT18' && $CMP $stdout $ftemp2; then
10
11
OUTPUT18
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 19.
if test $result = ok -a $start_test_number -le 19; then
	echo test 19
        cat >$test_file <<'TEST19'
var i, v, pv;

v = [100:0, 100:'c'];
for (i = 0; i < 1000;i++)
{
  v = [100:10.0];
  v[50] = 'c';
  v[50] = 10.0;
  pv = v;
}
TEST19
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT19' && $CMP $stdout $ftemp2; then
OUTPUT19
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 20.
if test $result = ok -a $start_test_number -le 20; then
	echo test 20
        cat >$test_file <<'TEST20'
class c(p) {
  var i;
  i = 1;
  fun f {putln ("i=", i);}
  fun g {putln ("p=", p);}
  fun f1 (i) {putln ("i=", i);}
  fun g1 (p) {putln ("p=", p);}
}
var i;
i = c(10);
i.f();
i.g();
i.f1(100);
i.g1(1000);
TEST20
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT20' && $CMP $stdout $ftemp2; then
i=1
p=10
i=100
p=1000
OUTPUT20
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 21.
if test $result = ok -a $start_test_number -le 21; then
	echo test 21
        cat >$test_file <<'TEST21'
class c(p) {
  var i;
  class cc(p) {
    fun f {putln (p);}
  }
  i = 10;
}
var j,k;
j = c(10);
k = j.cc(100);
k.f();


TEST21
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT21' && $CMP $stdout $ftemp2; then
100
OUTPUT21
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 22.
if test $result = ok -a $start_test_number -le 22; then
	echo test 22
        cat >$test_file <<'TEST22'
var a, i;
for (i = 0; i < 10; i++)
  a = [5:2];
TEST22
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT22' && $CMP $stdout $ftemp2; then
OUTPUT22
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 23.
if test $result = ok -a $start_test_number -le 23; then
	echo test 23
        cat >$test_file <<'TEST23'
var v;
var i;
i = 3;
v = [5 : 7, i:8];
for (i = 0; i< #v; i = i + 1)
  putln (v[i]);
TEST23
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT23' && $CMP $stdout $ftemp2; then
7
7
7
7
7
8
8
8
OUTPUT23
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 24.
if test $result = ok -a $start_test_number -le 24; then
	echo test 24
        cat >$test_file <<'TEST24'
putln ("0:", '\n' === 10.0);
putln ("0:", 10 === 10.0);
putln ("0:", "10" === 10.0);
putln ("0:", "10.0" === 10.0);
putln ("0:", "aaaaa" === [5:'a', '\0']);
TEST24
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT24' && $CMP $stdout $ftemp2; then
0:0
0:0
0:0
0:0
0:0
OUTPUT24
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 25.
if test $result = ok -a $start_test_number -le 25; then
	echo test 25
        cat >$test_file <<'TEST25'
fun f (args)
{
}

fun g (a)
{
  var args;
}

fun t (a, ...)
{
  var i;

  putln ("****");
  if (a !== nil)
    putln ("a = ", a);
  for (i = 0; i<#args;i++)
    putln ("args[", i, "]=", args[i]);
}

t (10);
t (10, 1);
t (10, 1, 2);
t (10, 1, 2, 3);
TEST25
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT25' && $CMP $stdout $ftemp2; then
****
a = 10
****
a = 10
args[0]=1
****
a = 10
args[0]=1
args[1]=2
****
a = 10
args[0]=1
args[1]=2
args[2]=3
OUTPUT25
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 26.
if test $result = ok -a $start_test_number -le 26; then
	echo test 26
        cat >$test_file <<'TEST26'
fun f {}
class c {}

putln ("1:", "10" == "10");
putln ("1:", 10 == 10);
putln ("1:", 10.5 == 10.5);
putln ("1:", 'c' == 'c');
	  
putln ("1:", 10 == 10.0);
putln ("1:", 99 == 'c');
putln ("1:", 99.0 == 'c');
	  
putln ("1:", 10 == "10");
putln ("1:", 10.5 == "10.5");
putln ("1:", 'c' == "c");
	  
putln ("1:", f == f);
putln ("1:", c == c);
putln ("1:", c() == c());

var op;
op = 10;
putln ("1:", op == "10");
op = 10.5;
putln ("1:", op == "10.5");
op = 'c';
putln ("1:", op == "c");
TEST26
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT26' && $CMP $stdout $ftemp2; then
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
OUTPUT26
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 27.
if test $result = ok -a $start_test_number -le 27; then
	echo test 27
        cat >$test_file <<'TEST27'
fun f {}
var r;
r = f == 10;
putln ("0:", r);
TEST27
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT27' && $CMP $stdout $ftemp2; then
0:0
OUTPUT27
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 28.
if test $result = ok -a $start_test_number -le 28; then
	echo test 28
        cat >$test_file <<'TEST28'
class c {}
var r;
r = c == 10;
putln ("0:", r);
TEST28
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT28' && $CMP $stdout $ftemp2; then
0:0
OUTPUT28
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 29.
if test $result = ok -a $start_test_number -le 29; then
	echo test 29
        cat >$test_file <<'TEST29'
class c {}
var r;
r = c () == 10;
putln ("0:", r);
TEST29
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT29' && $CMP $stdout $ftemp2; then
0:0
OUTPUT29
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 30.
if test $result = ok -a $start_test_number -le 30; then
	echo test 30
        cat >$test_file <<'TEST30'
class c (p) {
  putln ("p = ", p);
};

c(10);
TEST30
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT30' && $CMP $stdout $ftemp2; then
p = 10
OUTPUT30
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 31.
if test $result = ok -a $start_test_number -le 31; then
	echo test 31
        cat >$test_file <<'TEST31'
class c (p, ...)
{
  var i;
  putln ("p = ", p);
  for (i = 0; i < #args; i++)
    putln (args[i]);
}

c (10, 11, 12, 13);
TEST31
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT31' && $CMP $stdout $ftemp2; then
p = 10
11
12
13
OUTPUT31
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 32.
if test $result = ok -a $start_test_number -le 32; then
	echo test 32
        cat >$test_file_1 <<'TEST32'
var i;
i = 8;
TEST32
        cat >$test_file <<'TEST32-1'
include "test1";
putln (i);
TEST32-1
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT32' && $CMP $stdout $ftemp2; then
8
OUTPUT32
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 33.
if test $result = ok -a $start_test_number -le 33; then
	echo test 33
        cat >$test_file <<'TEST33'
// vector
var v;
// pack
v = [1, 2, 3, 5, 6]; ins (v, 4, 3); println (v);
v = [2, 3, 4, 5, 6]; ins (v, 1); println (v);
v = [1, 2, 3, 4, 5]; ins (v, 6, -1); println (v);
v = [2, 3, 4, 5, 6]; ins (v, 1, 0); println (v);
// unpack
v = [1.0, 2, 3, 5, 6]; ins (v, 4, 3); println (v);
v = [2.0, 3, 4, 5, 6]; ins (v, 1); println (v);
v = [1.0, 2, 3, 4, 5]; ins (v, 6, -1); println (v);
v = [2.0, 3, 4, 5, 6]; ins (v, 1, 0); println (v);
// empty
v = []; ins (v, nil); println (v);
v = []; ins (v, nil, -1); println (v);
v = []; ins (v, nil, 0); println (v);
v = []; ins (v, nil, 10); println (v);
// string
v = new "123456"; ins (v, 2); println (v);
v = new "123456"; ins (v, "+++"); println (v);
v = new "123456"; ins (v, "+++", -1); println (v);
v = new "123456"; ins (v, "+++", 100); println (v);
//
var i, iter;
for (iter = 0; iter < 10000; iter++)
  { 
    v = [];
    for (i = 0; i < 100; i++)
      ins (v, 1);
    for (i = 0; i < 100; i++)
      del (v, 0);
  }
println (v);
TEST33
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT33' && $CMP $stdout $ftemp2; then
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[nil]
[nil]
[nil]
[nil]
[2, '1', '2', '3', '4', '5', '6']
["+++", '1', '2', '3', '4', '5', '6']
['1', '2', '3', '4', '5', '6', "+++"]
['1', '2', '3', '4', '5', '6', "+++"]
[]
OUTPUT33
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 34.
if test $result = ok -a $start_test_number -le 34; then
	echo test 34
        cat >$test_file <<'TEST34'
// vector
var v;
// pack & pack
v = [1, 2, 3, 5, 6]; insv (v, [4], 3); println (v);
v = [2, 3, 4, 5, 6]; insv (v, [1]); println (v);
v = [1, 2, 3, 4, 5]; insv (v, [6], -1); println (v);
v = [2, 3, 4, 5, 6]; insv (v, [1], 0); println (v);
// unpack & pack
v = [1.0, 2, 3, 5, 6]; insv (v, [4], 3); println (v);
v = [2.0, 3, 4, 5, 6]; insv (v, [1]); println (v);
v = [1.0, 2, 3, 4, 5]; insv (v, [6], -1); println (v);
v = [2.0, 3, 4, 5, 6]; insv (v, [1], 0); println (v);
// unpack & unpack
v = [1.0, 2, 3, 6]; insv (v, [4, 5.0], 3); println (v);
v = [3.0, 4, 5, 6]; insv (v, [1.0, 2]); println (v);
v = [1.0, 2, 3, 4, 5]; insv (v, [6, 7.0], -1); println (v);
v = [3, 4, 5, 6]; insv (v, [1, 2.0], 0); println (v);
// empty
v = []; insv (v, [10]); println (v);
v = []; insv (v, [10], -1); println (v);
v = []; insv (v, [10], 0); println (v);
v = []; insv (v, [10], 10); println (v);
v = [10]; insv (v, []); println (v);
v = [10]; insv (v, [], -1); println (v);
v = [10]; insv (v, [], 0); println (v);
v = [10]; insv (v, [], 10); println (v);
// string
v = new "123456"; insv (v, "+++"); putln (v);
v = new "123456"; insv (v, "+++", -1); putln (v);
v = new "123456"; insv (v, "+++", 100); putln (v);
//
var i, iter;
for (iter = 0; iter < 10000; iter++)
  { 
    v = [];
    for (i = 0; i < 100; i++)
      insv (v, [1]);
    for (i = 0; i < 100; i++)
      del (v, 0);
  }
println (v);
TEST34
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT34' && $CMP $stdout $ftemp2; then
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6, 7]
[1, 2, 3, 4, 5, 6]
[10]
[10]
[10]
[10]
[10]
[10]
[10]
[10]
+++123456
123456+++
123456+++
[]
OUTPUT34
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 35.
if test $result = ok -a $start_test_number -le 35; then
	echo test 35
        cat >$test_file <<'TEST35'
print (nil);put (" ");
print (10);put (" ");
print (10.2e10);put (" ");
print ('c');put (" ");
println ("ssss");
println (["aaa", "bbb", "ccc"]);
println (["v1", tab ["key":"val", tab ["key1":"val1"]]]);
fun f {}
println (f);
class c {}
println (c);
println (c ());
var stop;
stop = 0;
thread t {wait (stop);}
println (t());
wait (1) stop = 1;

TEST35
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT35' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+11 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", tab ["key":"val", tab ["key1":"val1"]:nil]]
fun f
class c
instance c()
thread 1 t()
OUTPUT35
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT35-1' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+011 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", tab ["key":"val", tab ["key1":"val1"]:nil]]
fun f
class c
instance c()
thread 1 t()
OUTPUT35-1
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT35-2' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+11 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", tab [tab ["key1":"val1"]:nil, "key":"val"]]
fun f
class c
instance c()
thread 1 t()
OUTPUT35-2
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT35-3' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+011 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", tab [tab ["key1":"val1"]:nil, "key":"val"]]
fun f
class c
instance c()
thread 1 t()
OUTPUT35-3
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 36.
if test $result = ok -a $start_test_number -le 36; then
	echo test 36
        cat >$test_file <<'TEST36'
var s, t;
s = new "aaaa";
s[1] = "b";
TEST36
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT36' && $CMP $stdout $ftemp2; then
OUTPUT36
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 37.
if test $result = ok -a $start_test_number -le 37; then
	echo test 37
        cat >$test_file <<'TEST37'
thread t1 {
  var i;
  for (i = 0; i < 1000; i++)
     if (i % 100 == 0)
       putln ("thread 1 ", i);
}

thread t2 {
  var i;
  for (i = 0; i < 1000; i++)
     if (i % 100 == 0)
       putln ("thread 2 ", i);
}

t1 ();
putln ("after t1()");
t2 ();
putln ("after t2()");
TEST37
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT37' && $CMP $stdout $ftemp2; then
after t1()
after t2()
thread 1 0
thread 1 100
thread 1 200
thread 1 300
thread 2 0
thread 2 100
thread 2 200
thread 2 300
thread 1 400
thread 1 500
thread 1 600
thread 2 400
thread 2 500
thread 2 600
thread 1 700
thread 1 800
thread 1 900
thread 2 700
thread 2 800
thread 2 900
OUTPUT37
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 38.
if test $result = ok -a $start_test_number -le 38; then
	echo test 38
        cat >$test_file <<'TEST38'
class c(){
thread f (start, iter) {var i;
  for (; iter >= 0; iter--){
    println (start);
    start++;
  }
}
}
var o;
o = c();
o.f (0, 5);
o.f (10, 5);
TEST38
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT38' && $CMP $stdout $ftemp2; then
0
1
2
3
4
5
10
11
12
13
14
15
OUTPUT38
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 39.
if test $result = ok -a $start_test_number -le 39; then
	echo test 39
        cat >$test_file <<'TEST39'
wait (1);
TEST39
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT39' && $CMP $stdout $ftemp2; then
OUTPUT39
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 40.
if test $result = ok -a $start_test_number -le 40; then
	echo test 40
        cat >$test_file <<'TEST40'
var i;
for (i = 0; i < #argv; i++)
  putln (argv[i]);
TEST40
        echo '      ' $DINO $test_file "2>$stderr -- aaaa bbbb"
        if $DINO $test_file 2>$stderr >$stdout -- aaaa bbbb; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT40' && $CMP $stdout $ftemp2; then
aaaa
bbbb
OUTPUT40
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 41.
if test $result = ok -a $start_test_number -le 41; then
	echo test 41
        cat >$test_file <<'TEST41'
// vector
var v;
// pack
v = [1, 2, 3, 4, 5, 6]; del (v, 2); println (v);
v = [1, 2, 3, 4, 5, 6]; del (v, -2, 2); println (v);
v = [1, 2, 3, 4, 5, 6]; del (v, 2, 2); println (v);
v = [1, 2, 3, 4, 5, 6]; del (v, 2, -1); println (v);
v = [1, 2, 3, 4, 5, 6]; del (v, 2, 0); println (v);
// unpack
v = [1, 2.0, 3.0, 4, 5, 6]; del (v, 2); println (v);
v = [1.0, 2, 3, 4, 5, 6]; del (v, -2, 2); println (v);
v = [1.0, 2, 3, 4, 5, 6]; del (v, 2, 2); println (v);
v = [1.0, 2, 3, 4, 5, 6]; del (v, 2, -1); println (v);
v = [1.0, 2, 3, 4, 5, 6]; del (v, 2, 0); println (v);
// empty
v = []; del (v, 0); println (v);
v = []; del (v, -2, 1); println (v);
v = []; del (v, 0, 1); println (v);
v = []; del (v, 1, 0); println (v);
v = []; del (v, 0, -1); println (v);
// string
v = new "123456"; del (v, 2, 2); putln (v);
v = new "123456"; del (v, -2, 2); putln (v);
// table
var t;
t = tab [1:1, 2:2, 3:3, 4:4, 5:5, 6:6]; del (t, 2); println (t);
//
var i, iter;
for (iter = 0; iter < 1000; iter++)
  { 
    v = [1000:1];
    for (i = 0; i < 1000; i++)
      del (v, 0);
  }
println (v);
TEST41
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT41' && $CMP $stdout $ftemp2; then
[1, 2, 4, 5, 6]
[3, 4, 5, 6]
[1, 2, 5, 6]
[1, 2]
[1, 2, 3, 4, 5, 6]
[1, 2, 4, 5, 6]
[3, 4, 5, 6]
[1, 2, 5, 6]
[1, 2]
[1, 2, 3, 4, 5, 6]
[]
[]
[]
[]
[]
1256
3456
tab [1:1, 3:3, 4:4, 5:5, 6:6]
[]
OUTPUT41
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 42.
if test $result = ok -a $start_test_number -le 42; then
	echo test 42
        cat >$test_file <<'TEST42'
println (system ("echo test"));
TEST42
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT42' && $CMP $stdout $ftemp2; then
test
0
OUTPUT42
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 43.
if test $result = ok -a $start_test_number -le 43; then
	echo test 43
        cat >$test_file <<'TEST43'
var i,j;
j = 0;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
TEST43
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT43' && $CMP $stdout $ftemp2; then
OUTPUT43
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 44.
if test $result = ok -a $start_test_number -le 44; then
	echo test 44
        cat >$test_file <<'TEST44'
println (cos (3.14));
println (cos ("3.14"));
println (cos (3));
println (cos ('\3'));
TEST44
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT44' && $CMP $stdout $ftemp2; then
-0.999999
-0.999999
-0.989992
-0.989992
OUTPUT44
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 45.
if test $result = ok -a $start_test_number -le 45; then
	echo test 45
        cat >$test_file <<'TEST45'
println (sin (3.14));
println (sin ("3.14"));
println (sin (3));
println (sin ('\3'));
TEST45
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT45' && $CMP $stdout $ftemp2; then
0.00159265
0.00159265
0.14112
0.14112
OUTPUT45
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 46.
if test $result = ok -a $start_test_number -le 46; then
	echo test 46
        cat >$test_file <<'TEST46'
println (atan2 (3.14, 0));
println (atan2 ("3.14", 0));
println (atan2 (3, 0));
println (atan2 ('\3', 0));
//
println (atan2 (1.0, 0));
println (atan2 ("1.0", 0));
println (atan2 (1, 0));
println (atan2 ('\1', 0));
TEST46
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT46' && $CMP $stdout $ftemp2; then
1.5708
1.5708
1.5708
1.5708
1.5708
1.5708
1.5708
1.5708
OUTPUT46
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 47.
if test $result = ok -a $start_test_number -le 47; then
	echo test 47
        cat >$test_file <<'TEST47'
var SieveSize, i, prime, k, count, iter, flags;
SieveSize = 8190;

for (iter = 0; iter < 10; iter++;)
  {
    flags = [SieveSize + 1 : 0];
    count = 0;
    for (i = 0; i <= SieveSize; i++)
      flags[i] = 1;
    for (i = 0; i <= SieveSize; i++;)
      if (flags[i])
        {
          prime = i + i + 3;
          k = i + prime;
          for (;1;;)
            {
	      if (k > SieveSize)
                break;
              flags[k] = 0;
              k += prime;
            }
          count++;
        }
  }
println (count);
TEST47
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT47' && $CMP $stdout $ftemp2; then
1899
OUTPUT47
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 48.
if test $result = ok -a $start_test_number -le 48; then
	echo test 48
        cat >$test_file <<'TEST48'
var SieveSize, i, prime, k, count, iter, flags;
SieveSize = 8190;

for (iter = 0; iter < 10; iter++;)
  {
    flags = tab [];
    count = 0;
    for (i = 0; i <= SieveSize; i++)
      flags[i] = 1;
    for (i = 0; i <= SieveSize; i++;)
      if (flags[i])
        {
          prime = i + i + 3;
          k = i + prime;
          for (;1;;)
            {
	      if (k > SieveSize)
                break;
              flags[k] = 0;
              k += prime;
            }
          count++;
        }
  }
println (count);
TEST48
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT48' && $CMP $stdout $ftemp2; then
1899
OUTPUT48
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 49.
if test $result = ok -a $start_test_number -le 49; then
	echo test 49
        cat >$test_file <<'TEST49'
var m1, m2;

fun mmult (m1, m2)
{
  var i, j, k, m1rows, m1cols, m2rows, m2cols, result;

  m1rows = #m1; m2rows = #m2;
  m1cols = #m1[0]; m2cols = #m2[0];
  if (m2cols != m2rows)
    {
       println ("matrices don't match");
       return;
    }
  result = [m1rows:[m2cols:0]];
  for (i=0; i < m1rows; i++)
    for (j=0; j < m2cols; j++)
      for (k=0; k < m1cols; k++)
        result[i][j] += m1[i][k]*m2[k][j];
  return result;
}

m1 = [100:[100:1]];
m2 = [100:[100:1]];
mmult (m1, m2);
TEST49
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT49' && $CMP $stdout $ftemp2; then
OUTPUT49
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 50.
if test $result = ok -a $start_test_number -le 50; then
	echo test 50
        cat >$test_file <<'TEST50'
var m1, m2;

fun mmult (m1, m2)
{
  var i, j, k, m1rows, m1cols, m2rows, m2cols, result;

  m1rows = #m1; m2rows = #m2;
  m1cols = #m1[0]; m2cols = #m2[0];
  if (m2cols != m2rows)
    {
       println ("matrices don't match");
       return;
    }
  result = tab [];
  for (i=0; i < m1rows; i++) {
    result[i] = tab [];
    for (j=0; j < m2cols; j++) {
      result[i][j] = 0;
      for (k=0; k < m1cols; k++)
        result[i][j] += m1[i][k]*m2[k][j];
    }
  }
  return result;
}

var i, j;

m1 = tab [];
for (i = 0;i < 100; i++) {
  m1[i] = tab [];
  for (j = 0;j < 100; j++)
    m1[i][j] = 2;
}
m2 = m1;
mmult (m1, m2);
TEST50
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT50' && $CMP $stdout $ftemp2; then
OUTPUT50
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 51.
if test $result = ok -a $start_test_number -le 51; then
	echo test 51
        cat >$test_file <<'TEST51'
var i;
i = 0;
fun f
{
   var i;

   fun g {i = 20; return i;}
   i = 10;
   return g;
}
println (f ()());
TEST51
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT51' && $CMP $stdout $ftemp2; then
20
OUTPUT51
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 52.
if test $result = ok -a $start_test_number -le 52; then
	echo test 52
        cat >$test_file <<'TEST52'
var i;
i = 0;
class c ()
{
   var i;

   class sc ()
   {
     class scc ()
     {
       println (i);
     }
     i = 30;
   }
   i = 10;
}
var ssc, ssci;
ssc = c().sc().scc;
ssci = ssc ();
TEST52
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT52' && $CMP $stdout $ftemp2; then
30
OUTPUT52
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 53.
if test $result = ok -a $start_test_number -le 53; then
	echo test 53
        cat >$test_file <<'TEST53'
class c {
  class sc {
     class ssc {
     }
  }
}
fun f {
  class sc {
    fun g {}
  }
  return sc ();
}
println (c().sc().ssc);
println (f().g);
TEST53
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT53' && $CMP $ftemp $ftemp2; then
class c().sc().ssc
fun f().sc().g
OUTPUT53
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 54.
if test $result = ok -a $start_test_number -le 54; then
	echo test 54
        cat >$test_file <<'TEST54'
// Recursive function to compute Fibonacci numbers
fun fibonacci (n)
  {
     if (n <= 1) return 1;
     return (fibonacci(n-1) + fibonacci(n-2));
  }

var i, fibnum;

fibnum = 0;
for (i = 0; i <= 24; i++) 
  {
    fibnum = fibonacci(i);
    putln (i @ " " @ fibnum); 
  }
TEST54
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT54' && $CMP $stdout $ftemp2; then
0 1
1 1
2 2
3 3
4 5
5 8
6 13
7 21
8 34
9 55
10 89
11 144
12 233
13 377
14 610
15 987
16 1597
17 2584
18 4181
19 6765
20 10946
21 17711
22 28657
23 46368
24 75025
OUTPUT54
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 55.
if test $result = ok -a $start_test_number -le 55; then
	echo test 55: Use with before
        cat >$test_file <<'TEST55'
//----------------------- before -----------------
class c {
  fun me {putln ("c");}
  fun pr {me ();}
};

class sc {
   fun me {putln ("sc");}
   use c former me;
};

var co = c (), sco = sc ();
co.pr ();
sco.pr ();
TEST55
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT55' && $CMP $stdout $ftemp2; then
c
sc
OUTPUT55
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 56.
if test $result = ok -a $start_test_number -le 56; then
	echo test 56: Nested uses
        cat >$test_file <<'TEST56'
//----------------nested uses ------------
class c {
  fun me;
  fun pr {me ();}
  fun me {putln ("c");}
};

class sc {
  use c later me;
  fun me {putln ("sc");}
};

class ssc {
  use sc later me;
  fun me {putln ("ssc");}
};

var ssco = ssc ();
ssco.pr ();
//----------------nested uses ------------
class c {
  fun me;
  fun me {putln ("c");}
  fun pr {me ();}
};

class sc {
  use c later me;
  fun me;
  fun me {putln ("sc");}
};

class ssc {
  use sc later me;
  fun me;
  fun me {putln ("ssc");}
};

var ssco = ssc ();
ssco.pr ();
TEST56
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT56' && $CMP $stdout $ftemp2; then
ssc
ssc
OUTPUT56
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 57.
if test $result = ok -a $start_test_number -le 57; then
	echo test 57: Two uses
        cat >$test_file <<'TEST57'
//---------- two uses ----------------------
class c {
  fun me;
  fun me {putln ("c");}
  fun pr {me ();}
};

class sc {
  use c later me;
  use c former pr;
};

var sco = sc ();
sco.pr ();
TEST57
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT57' && $CMP $stdout $ftemp2; then
c
OUTPUT57
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 58.
if test $result = ok -a $start_test_number -le 58; then
	echo test 58: Use with later
        cat >$test_file <<'TEST58'
//--------------------- later --------------
class c {
  fun me {putln ("c");}
  fun pr {me ();}
};

class sc {
  use c later me;
  fun me {putln ("sc");}
};

var co = c (), sco = sc ();
co.pr ();
sco.pr ();
TEST58
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT58' && $CMP $stdout $ftemp2; then
c
sc
OUTPUT58
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 59.
if test $result = ok -a $start_test_number -le 59; then
	echo test 59
        cat >$test_file <<'TEST59'
var ff;
{
  var i;
  i = 10;
  fun f {return i;}
  ff = f;
}
println (ff ());
TEST59
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT59' && $CMP $stdout $ftemp2; then
10
OUTPUT59
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 60.
if test $result = ok -a $start_test_number -le 60; then
	echo test 60
        cat >$test_file <<'TEST60'
println (type (nil));
println (type ('a'));
println (type (10));
println (type (10.0));
println (type ([]));
println (type (tab []));
fun f ()
{
}
println (type (f));
var flag;
thread t ()
{
  wait (flag != nil);
}
println (type (t));
class c ()
{
}
println (type (c));
var i;
i = c ();
println (type (i));
println (type (t ()));
try {wait (1) flag = 1;}
println (type (context (i)));
println (type (type (1)));
TEST60
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT60' && $CMP $stdout $ftemp2; then
type (nil)
char
int
float
vector
table
fun
thread
class
obj
process
obj
type
OUTPUT60
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 61.
if test $result = ok -a $start_test_number -le 61; then
	echo test 61
        cat >$test_file <<'TEST61'
println (closure ('c'));
println (closure (10));
println (closure (10l));
println (closure (10.));
println (closure ([]));
println (closure (tab []));
fun f {}
println (closure (f));
thread t {}
println (closure (t));
class c {}
println (closure (c ()));
TEST61
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT61' && $CMP $stdout $ftemp2; then
nil
nil
nil
nil
nil
nil
nil
nil
class c
OUTPUT61
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 63.
if test $result = ok -a $start_test_number -le 63; then
	echo test 63: closure params number
        cat >$test_file <<'TEST63'
closure ();
TEST63
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT63' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of actual parameters for `closure'
OUTPUT63
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 63.
if test $result = ok -a $start_test_number -le 63; then
	echo test 63: closure params number
        cat >$test_file <<'TEST63'
closure (1, 2);
TEST63
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT63' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of actual parameters for `closure'
OUTPUT63
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 64.
if test $result = ok -a $start_test_number -le 64; then
	echo test 64
        cat >$test_file <<'TEST64'
println (main_thread);
TEST64
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT64' && $CMP $ftemp $ftemp2; then
main thread
OUTPUT64
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 65.
if test $result = ok -a $start_test_number -le 65; then
	echo test 65
        cat >$test_file <<'TEST65'
{
  var i;
  fun f {
     class c (){
       class c (){
       }
     }

     i = c ().c();
  }
  f ();
  println (context (i));
  println (context (context (i)));
  println (context (context (context (i))));
  println (context (context (context (context (i)))));
  println (context (context (context (context (context (i))))));
}
TEST65
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT65' && $CMP $ftemp $ftemp2; then
instance {}.f().c()
stack {}.f()
stack {}
stack 
nil
OUTPUT65
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 66.
if test $result = ok -a $start_test_number -le 66; then
	echo test 66
        cat >$test_file <<'TEST66'
var i;

{
  pub var l;
  class c {};
  i = c();
  l = 10;
}

println (context (i).l);

fun f ()
{
  pub var l;
  class c {};
  i = c();
  l = 20;
}

f ();
println (context (i).l);

fun fp (pub l)
{
  class c {};
  i = c();
}

fp (30);
println (context (i).l);

class c ()
{
  var l;
  class cc {};
  i = cc();
  l = 40;
}

c ();
println (context (i).l);

class cp (l)
{
  class cc {};
  i = cc();
}

cp (50);
println (context (i).l);

{
  pub var l;
  fun f {};
  i = f;
  l = 60;
}

println (context (i).l);

{
  pub var l;
  class c {};
  i = c;
  l = 70;
}

println (context (i).l);

{
  pub var l;
  thread t { wait (l);};
  i = t ();
  try {wait (1) l = 0;}
}

println (context (i).l);
context (i).l = 1;
TEST66
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT66' && $CMP $ftemp $ftemp2; then
10
20
30
40
50
60
70
0
OUTPUT66
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 67.
if test $result = ok -a $start_test_number -le 67; then
	echo test 67
        cat >$test_file <<'TEST67'
var ci;
{
  pub var i;
  class c {
  }
  ci = c ();
  i = 0;
}

println (context(ci).i);
context(ci).i = 1;
println (context(ci).i);
TEST67
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT67' && $CMP $stdout $ftemp2; then
0
1
OUTPUT67
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 68.
if test $result = ok -a $start_test_number -le 68; then
	echo test 68
        cat >$test_file <<'TEST68'
var i = 10, j = i, k;
i = 0;
k = 5;
putln (i, " ", j, " ", k);
TEST68
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT68' && $CMP $stdout $ftemp2; then
0 10 5
OUTPUT68
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 69.
if test $result = ok -a $start_test_number -le 69; then
	echo test 69
        cat >$test_file <<'TEST69'
fun e {putln ("e");return 100;}
fun f (i, p = e ()) {
  putln (p, " ", i);
}

var i;
for (i = 0; i < 10; i++) {
  f (20, i);
  f (20);
}
TEST69
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT69' && $CMP $stdout $ftemp2; then
0 20
e
100 20
1 20
e
100 20
2 20
e
100 20
3 20
e
100 20
4 20
e
100 20
5 20
e
100 20
6 20
e
100 20
7 20
e
100 20
8 20
e
100 20
9 20
e
100 20
OUTPUT69
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 70.
if test $result = ok -a $start_test_number -le 70; then
	echo test 70
        cat >$test_file <<'TEST70'
fun e {putln ("e");return 100;}
class c (i, p = e ()) {
  putln (p, " ", i);
}

var i;
for (i = 0; i < 10; i++) {
  c (20, i);
  c (20);
}
TEST70
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT70' && $CMP $stdout $ftemp2; then
0 20
e
100 20
1 20
e
100 20
2 20
e
100 20
3 20
e
100 20
4 20
e
100 20
5 20
e
100 20
6 20
e
100 20
7 20
e
100 20
8 20
e
100 20
9 20
e
100 20
OUTPUT70
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 71.
if test $result = ok -a $start_test_number -le 71; then
	echo test 71
        cat >$test_file <<'TEST71'
var fp, c;
{
  class cc {
    class c1 {
    }
    fun f {
    }
    {
      fun f {}
      fp = f;
    }
  }
  c = cc;
}
println (inside (c(), c, 1));
println (inside (c().c1, c, 1));
println (inside (c().c1(), c, 1));
println (inside (c().f, c, 1));
println (inside (fp, c, 1));
println (inside (context (fp), c, 1));
println (inside (c().c1 (), c().c1, 1));
println (inside (fp, c().c1, 1));
println (inside (c(), c().c1, 1));
println (inside (c().c1, c().c1, 1));
//
putln ();
println (inside (c(), c, "1"));
println (inside (c().c1, c, '1'));
println (inside (c().c1(), c, "1.0"));
println (inside (c().f, c, 1.0));
println (inside (fp, c, "1"));
println (inside (context (fp), c, "1"));
println (inside (c().c1 (), c().c1, "1"));
println (inside (fp, c().c1, "1"));
println (inside (c(), c().c1, "1"));
println (inside (c().c1, c().c1, "1"));
//
putln ();
println (inside (c(), c, 0));
println (inside (c().c1, c, 0));
println (inside (c().c1(), c, 0));
println (inside (c().f, c, 0));
println (inside (fp, c, 0));
println (inside (context (fp), c, 0));
println (inside (c().c1 (), c().c1, 0));
println (inside (fp, c().c1, 0));
println (inside (c(), c().c1, 0));
println (inside (c().c1, c().c1, 0));
//
putln ();
println (inside (c(), c, "0"));
println (inside (c().c1, c, '0'));
println (inside (c().c1(), c, 0.5));
println (inside (c().f, c, "0"));
println (inside (fp, c, "0"));
println (inside (context (fp), c, "0"));
println (inside (c().c1 (), c().c1, "0"));
println (inside (fp, c().c1, "0"));
println (inside (c(), c().c1, "0"));
println (inside (c().c1, c().c1, "0"));
//
putln ();
println (inside (c(), c));
println (inside (c().c1, c));
println (inside (c().c1(), c));
println (inside (c().f, c));
println (inside (fp, c));
println (inside (context (fp), c));
println (inside (c().c1 (), c().c1));
println (inside (fp, c().c1));
println (inside (c(), c().c1));
println (inside (c().c1, c().c1));
TEST71
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT71' && $CMP $stdout $ftemp2; then
1
1
1
1
1
1
0
0
0
0

1
1
1
1
1
1
0
0
0
0

1
1
1
1
1
1
1
0
0
1

1
1
1
1
1
1
1
0
0
1

1
1
1
1
1
1
1
0
0
1
OUTPUT71
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 72.
if test $result = ok -a $start_test_number -le 72; then
	echo test 72
        cat >$test_file <<'TEST72'
println (match ("aaa", "baaab"));
println (match ("(a)(a)(a)", "baaab"));
println (match ("aba", "baaab"));                 // no matching
println (match ("ab.", "baaab\n"));               // matching with NL
println (match ("[:alpha:]", "p"));
println (match ("^.aa", "baaab"));
println (match ("1", 10));
println (match ("1", 0));
println (match ("1", '1'));
println (match ("()aaa", "baaab"));
TEST72
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT72' && $CMP $stdout $ftemp2; then
[1, 4]
[1, 4, 1, 2, 2, 3, 3, 4]
nil
[3, 6]
[0, 1]
[0, 3]
[0, 1]
nil
[0, 1]
[1, 4, 1, 1]
OUTPUT72
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 73.
if test $result = ok -a $start_test_number -le 73; then
	echo test 73
        cat >$test_file <<'TEST73'
println (split ("aaa bbb ccc	ddd"));
println (split ("aaa bbb ccc	ddd", split_regex));
println (split ("aaa   bbb   ccc	  ddd"));
println (split ("  aaa   bbb   ccc	  ddd  "));
println (split ("abcdef", ""));
println (split ("  aaa   bbb   ccc ddd  ", " "));
println (split ("aaabbbcccddd"));
println (split (""));
println (split ("", ""));
println (split (10));
println (split ('c'));
println (split (10.0));
TEST73
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT73' && $CMP $stdout $ftemp2; then
["aaa", "bbb", "ccc", "ddd"]
["aaa", "bbb", "ccc", "ddd"]
["aaa", "bbb", "ccc", "ddd"]
["aaa", "bbb", "ccc", "ddd"]
["a", "b", "c", "d", "e", "f"]
["aaa", "bbb", "ccc", "ddd"]
["aaabbbcccddd"]
[""]
[""]
["10"]
["c"]
["10"]
OUTPUT73
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 74.
if test $result = ok -a $start_test_number -le 74; then
	echo test 74
        cat >$test_file <<'TEST74'
putln (sub ("aa", "abaabbaaaa", "11"));
putln (gsub ("aa", "abaabbaaaa", "11"), "\n");

putln (sub ("aa", "abaabbaaaa", "d&d"));
putln (gsub ("aa", "abaabbaaaa", "d&d"), "\n");

putln (sub ("(a)a", "abaabbaaaa", "d\\1d"));
putln (gsub ("(a)a", "abaabbaaaa", "d\\1d"), "\n");

putln (sub ("aa", "abaabbaaaa", "d\\2d"));
putln (gsub ("aa", "abaabbaaaa", "d\\2d"), "\n");

putln (sub ("aa", "abaabbaaaa", "d\\&d"));
putln (gsub ("aa", "abaabbaaaa", "d\\&d"), "\n");

putln (sub ("aa", "abaabbaaaa", "d\\\\d"));
putln (gsub ("aa", "abaabbaaaa", "d\\\\d"), "\n");

putln (sub ("", "abc", "d"));
putln (gsub ("", "abc", "d"), "\n");

putln (sub ("", "", "d"));
putln (gsub ("", "", "d"), "\n");

putln (sub ("a", "a", 10));
putln (sub ("a", "a", 'c'));
putln (sub ("a", "a", 10.0));
putln (sub ("8", 8, 10));
TEST74
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT74' && $CMP $stdout $ftemp2; then
ab11bbaaaa
ab11bb1111

abdaadbbaaaa
abdaadbbdaaddaad

abdadbbaaaa
abdadbbdaddad

abddbbaaaa
abddbbdddd

abd&dbbaaaa
abd&dbbd&dd&d

abd\dbbaaaa
abd\dbbd\dd\d

dabc
dadbdc

d
d

10
c
10
10
OUTPUT74
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 75.
if test $result = ok -a $start_test_number -le 75; then
	echo test 75
        cat >$test_file <<TEST75
println (sort (readdir ("__tempdir"), cmpv));

try {
println (readdir ("abracadabra"));
} catch (enoent) {
  putln ("abracadabra: no such directory");
}

try {
println (readdir (1000022));
} catch (enoent) {
  putln ("1000022: no such directory");
}
TEST75
        rm -rf $tempdir
        mkdir $tempdir
        echo > $tempdir/a
        echo > $tempdir/b
        echo > $tempdir/c
        echo > $tempdir/d
        echo > $tempdir/e
        echo > $tempdir/f
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT75' && $CMP $stdout $ftemp2; then
[".", "..", "a", "b", "c", "d", "e", "f"]
abracadabra: no such directory
1000022: no such directory
OUTPUT75
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 76.
if test $result = ok -a $start_test_number -le 76; then
	echo test 76
        cat >$test_file <<'TEST76'
var i = 0;
i[10]=0;
TEST76
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT76' && $CMP $stderr $ftemp2; then
test.d:2:2: run time error - index operation for non vector or table
OUTPUT76
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 77.
if test $result = ok -a $start_test_number -le 77; then
	echo test 77
        cat >$test_file <<'TEST77'
try {
  var i = 0;
  i[10]=0;
} catch (error) {
  putln ("got it: ", e.msg);
}
TEST77
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT77' && $CMP $stdout $ftemp2; then
got it: run time error - index operation for non vector or table
OUTPUT77
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 78.
if test $result = ok -a $start_test_number -le 78; then
	echo test 78
	cat >$test_file <<'TEST78'
var i = 0 / 0;
TEST78
	echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
	    if test `uname` = AIX && $CMP - $stderr <<'OUTPUT78'; then
OUTPUT78
		    result=ok
	    elif uname -a|fgrep Linux|fgrep ppc && $CMP - $stderr <<'OUTPUT78a'; then
OUTPUT78a
		    result=ok
	    elif uname -a|fgrep Linux|fgrep ia64 && $CMP - $stderr <<'OUTPUT78b'; then
OUTPUT78b
		    result=ok
	    else
		    result=fail
	    fi
	else
	    echo '      ' $CMP - $stderr
	    if cat >$ftemp2 <<'OUTPUT78-1' && $CMP $stderr $ftemp2; then
test.d:1:11: floating point exception
OUTPUT78-1
		    result=ok
	    else
                    result=fail
	    fi
        fi
fi

# Test 79.
if test $result = ok -a $start_test_number -le 79; then
	echo test 79
        if uname | fgrep CYGWIN; then
	    echo skip the test
	    result=ok
        else
	    cat >$test_file <<'TEST79'
for (var i = 0; i < 10; i++)
try {
  var i = 0 / 0;
} catch (error) {
  putln ("got it: ", e.msg);
}
TEST79
	    echo '      ' $DINO $test_file "2>$stderr"
	    if $DINO $test_file 2>$stderr >$stdout; then
		    echo '      ' $CMP $stdout $ftemp2
		    if cat >$ftemp2 <<'OUTPUT79' && $CMP $stdout $ftemp2; then
OUTPUT79
			result=ok
		    elif cat >$ftemp2 <<'OUTPUT79-1' && $CMP $stdout $ftemp2; then
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
OUTPUT79-1
			    result=ok
		    else
			    result=fail
		    fi
	    else
		    result=fail
	    fi
        fi
fi

# Test 80.
if test $result = ok -a $start_test_number -le 80; then
	echo test 80: Forward and matched declarations
	cat >$test_file <<'TEST80'
fun f;
class f () {}
TEST80
	echo '      ' $DINO $test_file "2>$stderr"
	if $DINO $test_file 2>$stderr >$stdout; then
	    result=fail
	else
	    echo '      ' $CMP - $stderr
	    if cat >$ftemp2 <<'OUTPUT80' && $CMP $stderr $ftemp2; then
test.d:2:7: forward and matched declarations of `f' are different entities
test.d:1:5: (previous declaration of identifier `f')
OUTPUT80
		    result=ok
	    else
		    result=fail
	    fi
        fi
fi

# Test 81.
if test $result = ok -a $start_test_number -le 81; then
	echo test 81
        if uname | fgrep CYGWIN; then
	    echo skip the test
	    result=ok
        else
	    cat >$test_file <<'TEST81'
for (var i = 0; i < 10; i++)
try {
  var i = 0 / 0;
} catch (sigfpe) {
  putln ("got it: ", e.msg);
}
TEST81
	    echo '      ' $DINO $test_file "2>$stderr"
	    if $DINO $test_file 2>$stderr >$stdout; then
		    echo '      ' $CMP $stdout $ftemp2
		    if cat >$ftemp2 <<'OUTPUT81' && $CMP $stdout $ftemp2; then
OUTPUT81
			result=ok
		    elif cat >$ftemp2 <<'OUTPUT81-1' && $CMP $stdout $ftemp2; then
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
OUTPUT81-1
			    result=ok
		    else
			    result=fail
		    fi
	    else
		    result=fail
	    fi
        fi
fi

# Test 82.
if test $result = ok -a $start_test_number -le 82; then
	echo test 82
        cat >$test_file <<'TEST82'
match ("[a", "");
TEST82
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT82' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unmatched bracket list operators in regexp
OUTPUT82
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 83.
if test $result = ok -a $start_test_number -le 83; then
	echo test 83
        cat >$test_file <<'TEST83'
match ("[z-a]", "");
TEST83
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT83' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid use of the range operator in regexp
OUTPUT83
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 84.
if test $result = ok -a $start_test_number -le 84; then
	echo test 84
        cat >$test_file <<'TEST84'
match ("[[:foo:]]", "");
TEST84
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT84' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unknown character class name in regexp
OUTPUT84
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 85.
if test $result = ok -a $start_test_number -le 85; then
	echo test 85
        cat >$test_file <<'TEST85'
match ("(a", "");
TEST85
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT85' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - unmatched parenthesis group operators in regexp
OUTPUT85
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 86.
if test $result = ok -a $start_test_number -le 86; then
	echo test 86
        cat >$test_file <<'TEST86'
match ("(a)\\2", "");
TEST86
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT86' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid back reference to a subexpr. in regexp
OUTPUT86
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 87.
if test $result = ok -a $start_test_number -le 87; then
	echo test 87
        cat >$test_file <<'TEST87'
match ("a\\", "");
TEST87
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT87' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid escape sequence in regexp
OUTPUT87
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 88.
if test $result = ok -a $start_test_number -le 88; then
	echo test 88
        cat >$test_file <<'TEST88'
val i;
i = 10;
putln(i);
TEST88
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT88' && $CMP $stderr $ftemp2; then
test.d:2:1: constant `i' in assignment statement
OUTPUT88
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 89.
if test $result = ok -a $start_test_number -le 89; then
	echo test 89
        cat >$test_file <<'TEST89'
fun f (val i)
{
  i = 10;
  putln(i);
}
f (1);
TEST89
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT89' && $CMP $stderr $ftemp2; then
test.d:3:3: constant `i' in assignment statement
OUTPUT89
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 90.
if test $result = ok -a $start_test_number -le 90; then
	echo test 90
        cat >$test_file <<'TEST90'
val i = 10; putln(i);
fun f (val i = 10)
{
  putln(i);
}
f (1);
f ();
class c (val i = 100)
{
  putln(i);
}
c (1);
c ();
TEST90
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT90' && $CMP $stdout $ftemp2; then
10
1
10
1
100
OUTPUT90
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 91.
if test $result = ok -a $start_test_number -le 91; then
	echo test 91
        cat >$test_file <<'TEST91'
final fun f {putln ("hello, world # 0");}
f();
TEST91
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT91' && $CMP $stdout $ftemp2; then
hello, world # 0
OUTPUT91
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 92.
if test $result = ok -a $start_test_number -le 92; then
	echo test 92
        cat >$test_file <<'TEST92'
final class c (p)
{
  var i;
  i = 10;
  putln (i);
}

c (20);
TEST92
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT92' && $CMP $stdout $ftemp2; then
10
OUTPUT92
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 93.
if test $result = ok -a $start_test_number -le 93; then
	echo test 93: use with later and forward
        cat >$test_file <<'TEST93'
//--------------------- later with forward --------------
class c {
  fun me;
  fun pr {me ();}
  fun me {putln ("c");}
};

class sc {
  use c later me;
  fun me {putln ("sc");}
};

var co = c (), sco = sc ();
co.pr ();
sco.pr ();
TEST93
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT93' && $CMP $stdout $ftemp2; then
c
sc
OUTPUT93
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 94.
if test $result = ok -a $start_test_number -le 94; then
	echo test 94
        cat >$test_file <<'TEST94'
class c {
  use c;
}
TEST94
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT94' && $CMP $stderr $ftemp2; then
test.d:2:7: use of fun/class `c' inside the fun/class
OUTPUT94
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 95.
if test $result = ok -a $start_test_number -le 95; then
	echo test 95
        cat >$test_file <<'TEST95'
class sc {
  use c;
}

class c {
}
TEST95
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT95' && $CMP $stderr $ftemp2; then
test.d:2:7: use `c' before defined fun or class
OUTPUT95
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 96.
if test $result = ok -a $start_test_number -le 96; then
	echo test 96
        cat >$test_file <<'TEST96'
class c;

class sc {
  use c;
}

class c {
}
TEST96
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT96' && $CMP $stderr $ftemp2; then
test.d:4:7: use of forward declaration of fun/class `c'
OUTPUT96
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 97.
if test $result = ok -a $start_test_number -le 97; then
	echo test 97
        cat >$test_file <<'TEST97'
var i;

class sc {
  use i;
}
TEST97
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT97' && $CMP $stderr $ftemp2; then
test.d:4:7: use of non fun/class `i'
OUTPUT97
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 98.
if test $result = ok -a $start_test_number -le 98; then
	echo test 98
        cat >$test_file <<'TEST98'
final class c {}

class sc {
  use c;
}
TEST98
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT98' && $CMP $stderr $ftemp2; then
test.d:4:7: use of final fun/class `c'
OUTPUT98
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 99.
if test $result = ok -a $start_test_number -le 99; then
	echo test 99
        cat >$test_file <<'TEST99'
seek (stdout, 10, 10);
TEST99
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT99' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `seek'
OUTPUT99
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 100.
if test $result = ok -a $start_test_number -le 100; then
	echo test 100
        if uname | fgrep Linux || uname | fgrep linux; then
	    cat >$test_file <<'TEST100'
seek (stdout, 10000, 'C');
TEST100
	    echo '      ' $DINO $test_file "2>$stderr"
	    if $DINO $test_file 2>$stderr; then
		    result=fail
	    else
		    echo '      ' $CMP - $stderr
		    if cat >$ftemp2 <<'OUTPUT100' && $CMP $stderr $ftemp2; then
test.d:1:6: system error - invalid seek: `seek'
OUTPUT100
			    result=ok
		    else
			    result=fail
		    fi
	    fi
        else
	    echo skip the test
	    result=ok
        fi
fi

# Test 101.
if test $result = ok -a $start_test_number -le 101; then
	echo test 101
        if uname | fgrep Linux || uname | fgrep linux; then
	    cat >$test_file <<'TEST101'
seek (stdout, 10, "c");
TEST101
	    echo '      ' $DINO $test_file "2>$stderr"
	    if $DINO $test_file 2>$stderr; then
		    result=fail
	    else
		    echo '      ' $CMP - $stderr
		    if cat >$ftemp2 <<'OUTPUT101' && $CMP $stderr $ftemp2; then
test.d:1:6: system error - invalid seek: `seek'
OUTPUT101
			    result=ok
		    else
			    result=fail
		    fi
	    fi
        else
	    echo skip the test
	    result=ok
        fi
fi

# Test 102.
if test $result = ok -a $start_test_number -le 102; then
	echo test 102
        cat >$test_file <<'TEST102'
seek (stdout, 10, "t");
TEST102
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT102' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `seek'
OUTPUT102
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 103.
if test $result = ok -a $start_test_number -le 103; then
	echo test 103
        cat >$test_file <<'TEST103'
seek (stdout, "aaa", 's');
TEST103
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT103' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `seek'
OUTPUT103
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT103' && $CMP $stderr $ftemp2; then
test.d:1:6: system error - invalid argument: `string-to-float conversion'
OUTPUT103
                        result=ok

                else
                        result=fail
                fi
        fi
fi

# Test 104.
if test $result = ok -a $start_test_number -le 104; then
	echo test 104
        cat >$test_file <<'TEST104'
seek (10, 10, 'e');
TEST104
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT104' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `seek'
OUTPUT104
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 105.
if test $result = ok -a $start_test_number -le 105; then
	echo test 105
        cat >$test_file <<'TEST105'
var f = open ("test.d", "r");
putln (tell (f));
seek (f, 10, 's');
putln (tell (f));
seek (f, -10, 'c');
putln (tell (f));
seek (f, 0, 'e');
putln (tell (f));
TEST105
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT105'\
		   && wc -c $test_file|awk '{print $1}' >>$ftemp2\
		   && $CMP $stdout $ftemp2; then
0
10
0
OUTPUT105
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 106.
if test $result = ok -a $start_test_number -le 106; then
	echo test 106
        cat >$test_file <<'TEST106'
putln (time ());
TEST106
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^[0-9][0-9][0-9][0-9][0-9]*$' $stdout
                if egrep '^[0-9][0-9][0-9][0-9][0-9]*$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 107.
if test $result = ok -a $start_test_number -le 107; then
	echo test 107
        cat >$test_file <<'TEST107'
time (10);
TEST107
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT107' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `time'
OUTPUT107
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 108.
if test $result = ok -a $start_test_number -le 108; then
	echo test 108
        cat >$test_file <<'TEST108'
strtime (10, nil, nil);
TEST108
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT108' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of actual parameters for `strtime'
OUTPUT108
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 109.
if test $result = ok -a $start_test_number -le 109; then
	echo test 109
        cat >$test_file <<'TEST109'
strtime (nil);
TEST109
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT109' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `strtime'
OUTPUT109
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 110.
if test $result = ok -a $start_test_number -le 110; then
	echo test 110
        cat >$test_file <<'TEST110'
strtime (10, nil);
TEST110
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT110' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `strtime'
OUTPUT110
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 111.
if test $result = ok -a $start_test_number -le 111; then
	echo test 111
        cat >$test_file <<'TEST111'
time_format = nil;
strtime ();
TEST111
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT111' && $CMP $stderr $ftemp2; then
test.d:2:9: run time error - bad value of environment variable `time_format'
OUTPUT111
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 112.
if test $result = ok -a $start_test_number -le 112; then
	echo test 112
        cat >$test_file <<'TEST112'
put (strtime ("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa "));
put (strtime ("%Y ", time()));
put (strtime (time_format, time()));
put (strtime (" %d "));
put (strtime ());
putln (strtime (" aa"));
TEST112
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa [0-9][0-9][0-9][0-9] [A-Za-z][A-Za-z]* [A-Za-z][A-Za-z]* [0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9] [A-Z]* [0-9][0-9][0-9][0-9] [0-3][0-9] [A-Za-z][A-Za-z]* [A-Za-z][A-Za-z]* [0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9] [A-Z]* [0-9][0-9][0-9][0-9] aa$' $stdout
                if egrep '^aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa [0-9][0-9][0-9][0-9] [A-Za-z][A-Za-z]* [A-Za-z][A-Za-z]* [0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9] [A-Z]* [0-9][0-9][0-9][0-9] [0-3][0-9] [A-Za-z][A-Za-z]* [A-Za-z][A-Za-z]* [0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9] [A-Z]* [0-9][0-9][0-9][0-9] aa$' $stdout; then
                        result=ok
                elif egrep '^aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa [0-9][0-9][0-9][0-9] [A-Za-z][A-Za-z]* [A-Za-z][A-Za-z]* [0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9] [A-Za-z]* [A-Za-z]* [A-Za-z]* [0-9][0-9][0-9][0-9] [0-3][0-9] [A-Za-z][A-Za-z]* [A-Za-z][A-Za-z]* [0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9] [A-Za-z]* [A-Za-z]* [A-Za-z]* [0-9][0-9][0-9][0-9] aa$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 113.
if test $result = ok -a $start_test_number -le 113; then
	echo test 113
        cat >$test_file <<'TEST113'
clock (nil);
TEST113
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT113' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `clock'
OUTPUT113
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 114.
if test $result = ok -a $start_test_number -le 114; then
	echo test 114
        cat >$test_file <<'TEST114'
putln (clock ());
TEST114
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^[0-1]\.?[0-9]*$' $stdout
                if egrep '^[0-1]\.?[0-9]*$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 115.
if test $result = ok -a $start_test_number -le 115; then
	echo test 115
        cat >$test_file <<'TEST115'
split_regex = nil;
println (split ("aaa bbb ccc	ddd"));
TEST115
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT115' && $CMP $stderr $ftemp2; then
test.d:2:16: run time error - bad value of environment variable `split_regex'
OUTPUT115
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 116.
if test $result = ok -a $start_test_number -le 116; then
	echo test 116
        cat >$test_file <<'TEST116'
throw except ();
TEST116
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT116' && $CMP $stderr $ftemp2; then
test.d:1:1: run time error - exception except has not been processed
OUTPUT116
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 117.
if test $result = ok -a $start_test_number -le 117; then
	echo test 117
        cat >$test_file <<'TEST117'
throw  error ("Error111");
TEST117
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT117' && $CMP $stderr $ftemp2; then
test.d:1:1: Error111
OUTPUT117
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 118.
if test $result = ok -a $start_test_number -le 118; then
	echo test 118
        cat >$test_file <<'TEST118'
for (var i = 0; i < 50;i++)
{
  try {
    putln ("in try");
    throw except ();
    putln ("after throw");
  } catch (except) {
    putln ("in catch");
  } 
  putln ("finish");
}
TEST118
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT118' && $CMP $stdout $ftemp2; then
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
OUTPUT118
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 119.
if test $result = ok -a $start_test_number -le 119; then
	echo test 119
        cat >$test_file <<'TEST119'
try {
  put ("Good");
} catch (except) {
}
putln (" and good");
TEST119
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT119' && $CMP $stdout $ftemp2; then
Good and good
OUTPUT119
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 120.
if test $result = ok -a $start_test_number -le 120; then
	echo test 120
        cat >$test_file <<'TEST120'
var f = open ("test.d", "r"), f1;
f1 = f;
println (f == f1);
println (type (f));
println (type (hide));
println (hide);
println (type (hideblock));
println (hideblock);
TEST120
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT120' && $CMP $stdout $ftemp2; then
1
obj
type
hide
type
hideblock
OUTPUT120
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 121.
if test $result = ok -a $start_test_number -le 121; then
	echo test 121
        cat >$test_file <<'TEST121'
var v = [4, 2, 1, 3]; println (sort (v)); println (v);
v = [4.0, 2.0, 1.0, 3.0]; println (sort (v)); println (v);
v = ['4', '2', '1', '3']; println (sort (v)); println (v);
v = "5132"; println (sort (v)); println (v);

fun c(i,j) {
  if (i < j)
    return -1;
  else if (i == j)
    return 0;
  else
    return 1;
}
v = [4, 2, 1, 3.5];
println (sort (v, c)); println (v);
TEST121
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT121' && $CMP $stdout $ftemp2; then
[1, 2, 3, 4]
[4, 2, 1, 3]
[1, 2, 3, 4]
[4, 2, 1, 3]
"1234"
"4213"
"1235"
"5132"
[1, 2, 3.5, 4]
[4, 2, 1, 3.5]
OUTPUT121
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 122.
if test $result = ok -a $start_test_number -le 122; then
	echo test 122
        cat >$test_file <<'TEST122'
var v = "5132"; println (sort ());
TEST122
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT122' && $CMP $stderr $ftemp2; then
test.d:1:31: run time error - invalid number of actual parameters for `sort'
OUTPUT122
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 123.
if test $result = ok -a $start_test_number -le 123; then
	echo test 123
        cat >$test_file <<'TEST123'
var v = "5132"; println (sort (nil, nil, nil));
TEST123
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT123' && $CMP $stderr $ftemp2; then
test.d:1:31: run time error - invalid number of actual parameters for `sort'
OUTPUT123
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 124.
if test $result = ok -a $start_test_number -le 124; then
	echo test 124
        cat >$test_file <<'TEST124'
println (sort (nil));
TEST124
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT124' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid parameter type of `sort'
OUTPUT124
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 125.
if test $result = ok -a $start_test_number -le 125; then
	echo test 125
        cat >$test_file <<'TEST125'
var v = [4.0, 2.0, 1.0, 3]; println (sort (v));
TEST125
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT125' && $CMP $stderr $ftemp2; then
test.d:1:43: run time error - invalid parameter type of `sort'
OUTPUT125
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 126.
if test $result = ok -a $start_test_number -le 126; then
	echo test 126
        cat >$test_file <<'TEST126'
var v = [nil, nil]; println (sort (v));
TEST126
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT126' && $CMP $stderr $ftemp2; then
test.d:1:35: run time error - invalid parameter type of `sort'
OUTPUT126
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 127.
if test $result = ok -a $start_test_number -le 127; then
	echo test 127
        cat >$test_file <<'TEST127'
var v = [2, 1]; println (sort (v, v));
TEST127
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT127' && $CMP $stderr $ftemp2; then
test.d:1:31: run time error - invalid parameter type of `sort'
OUTPUT127
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 128.
if test $result = ok -a $start_test_number -le 128; then
	echo test 128
        cat >$test_file <<'TEST128'
fun c (i, j) {return nil;}
var v = [2, 1]; println (sort (v, c));
TEST128
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT128' && $CMP $stderr $ftemp2; then
test.d:2:31: run time error - invalid function result used by function `sort'
OUTPUT128
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 129.
if test $result = ok -a $start_test_number -le 129; then
	echo test 129
        cat >$test_file <<'TEST129'
putln (getpid (), " ", getun (), " ", geteun (), " ", getgn (), " ", getegn ());
TEST129
        echo '      ' $DINO $test_file "2>$stderr"
        if uname | fgrep CYGWIN; then
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^-?[0-9][0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]*$' $stdout
                if egrep '^-?[0-9][0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]*$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^[0-9][0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]*$' $stdout
                if egrep '^[0-9][0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]*$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	fi
fi

# Test 130.
if test $result = ok -a $start_test_number -le 130; then
	echo test 130
        cat >$test_file <<'TEST130'
getpid (1);
TEST130
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT130' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `getpid'
OUTPUT130
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 131.
if test $result = ok -a $start_test_number -le 130; then
	echo test 131
        cat >$test_file <<'TEST131'
getppid (1);
TEST131
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT131' && $CMP $stderr $ftemp2; then
test.d:1:1: undeclared identifier `getppid'
OUTPUT131
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 132.
if test $result = ok -a $start_test_number -le 132; then
	echo test 132
        cat >$test_file <<'TEST132'
getun (1);
TEST132
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT132' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `getun'
OUTPUT132
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 133.
if test $result = ok -a $start_test_number -le 133; then
	echo test 133
        cat >$test_file <<'TEST133'
geteun (1);
TEST133
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT133' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `geteun'
OUTPUT133
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 134.
if test $result = ok -a $start_test_number -le 134; then
	echo test 134
        cat >$test_file <<'TEST134'
getgn (1);
TEST134
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT134' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `getgn'
OUTPUT134
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 135.
if test $result = ok -a $start_test_number -le 135; then
	echo test 135
        cat >$test_file <<'TEST135'
getegn (1);
TEST135
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT135' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `getegn'
OUTPUT135
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 136.
if test $result = ok -a $start_test_number -le 136; then
	echo test 136
        cat >$test_file <<'TEST136'
putln (ftype ("test.d"));
putln (ftype ("."));
putln (ftype (stdin));
putln (ftype (stdout));
TEST136
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT136' && $CMP $stdout $ftemp2; then
f
d
c
f
OUTPUT136
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 137.
if test $result = ok -a $start_test_number -le 137; then
	echo test 137
        cat >$test_file <<'TEST137'
ftype ();
TEST137
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT137' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `ftype'
OUTPUT137
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 138.
if test $result = ok -a $start_test_number -le 138; then
	echo test 138
        cat >$test_file <<'TEST138'
ftype (nil, nil);
TEST138
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT138' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `ftype'
OUTPUT138
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 139.
if test $result = ok -a $start_test_number -le 139; then
	echo test 139
        cat >$test_file <<'TEST139'
ftype (nil);
TEST139
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT139' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `ftype'
OUTPUT139
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 140.
if test $result = ok -a $start_test_number -le 140; then
	echo test 140
        cat >$test_file <<'TEST140'
println (getgroups ());
TEST140
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                regex="^\[(\"[-_a-zA-Z0-9][-_a-zA-Z0-9]*\"(, \"[-_a-zA-Z0-9][-_a-zA-Z0-9]*\")*)?\]$"
                echo '      ' egrep \'$regex\' $stdout
                if egrep "$regex" $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 141.
if test $result = ok -a $start_test_number -le 141; then
	echo test 141
        cat >$test_file <<'TEST141'
getgroups (nil);
TEST141
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT141' && $CMP $stderr $ftemp2; then
test.d:1:11: run time error - invalid number of actual parameters for `getgroups'
OUTPUT141
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 142.
if test $result = ok -a $start_test_number -le 142; then
	echo test 142
        cat >$test_file <<'TEST142'
var i, j;
for (i=0;i<10000;i++)
  {
    j=0;
  }
putln (gc());
TEST142
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^[0-9][0-9][0-9][0-9][0-9][0-9]*$' $stdout
                if egrep '^[0-9][0-9][0-9][0-9][0-9][0-9]*$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 143.
if test $result = ok -a $start_test_number -le 143; then
	echo test 143
        cat >$test_file <<'TEST143'
gc (nil);
TEST143
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT143' && $CMP $stderr $ftemp2; then
test.d:1:4: run time error - invalid number of actual parameters for `gc'
OUTPUT143
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 144.
if test $result = ok -a $start_test_number -le 144; then
	echo test 144
        cat >$test_file <<'TEST144'
put (fuidn ("test.d"));
put (" ", fgrpn ("test.d"));
putln (" ", fsize ("test.d"));
TEST144
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		regex="^[a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* "
		regex=$regex`wc -c $test_file|awk '{print $1}'`\$
                echo '      \'$regex\' $stdout
                if egrep "$regex" $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 145.
if test $result = ok -a $start_test_number -le 145; then
	echo test 145
        cat >$test_file <<'TEST145'
put (fatime ("test.d"));
put (" ", fmtime ("test.d"));
putln (" ", fctime ("test.d"));
TEST145
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*( [0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*)*$' $stdout
                if egrep '^[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*( [0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*)*$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 146.
if test $result = ok -a $start_test_number -le 146; then
	echo test 146
        cat >$test_file <<'TEST146'
put (fumode ("test.d"));
put (" ", fgmode ("test.d"));
putln (" ", fomode ("test.d"));
TEST146
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^s?r?w?x? r?w?x? r?w?x?$' $stdout
                if egrep '^s?r?w?x? r?w?x? r?w?x?$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 147.
if test $result = ok -a $start_test_number -le 147; then
	echo test 147
        cat >$test_file <<'TEST147'
fatime ();
TEST147
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT147' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `fatime'
OUTPUT147
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 148.
if test $result = ok -a $start_test_number -le 148; then
	echo test 148
        cat >$test_file <<'TEST148'
fatime (nil);
TEST148
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT148' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `fatime'
OUTPUT148
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 149.
if test $result = ok -a $start_test_number -le 149; then
	echo test 149
        cat >$test_file <<'TEST149'
var i,t;
t = tab [];
for (i = 0; i < 10000; i++)
  t [i] = -i;
TEST149
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT149' && $CMP $stdout $ftemp2; then
OUTPUT149
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 150.
if test $result = ok -a $start_test_number -le 150; then
	echo test 150
        cat >$test_file <<'TEST150'
var c, i;
for (i = 0; i < 5; i++)
{
  c = get ();
  putln (c);
}
TEST150
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT150' && $CMP $stdout $ftemp2; then
a
b
c
d


OUTPUT150
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 151.
if test $result = ok -a $start_test_number -le 151; then
	echo test 151
        cat >$test_file <<'TEST151'
var c;
for (;1;)
{
  try {c = get ();} catch (eof) {break;}
  putln (c);
}
TEST151
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT151' && $CMP $stdout $ftemp2; then
a
b
c
d


OUTPUT151
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 152.
if test $result = ok -a $start_test_number -le 152; then
	echo test 152
        cat >$test_file <<'TEST152'
var c, f = open ("test.d", "r");
for (;1;)
{
  try {c = fget (f);} catch (eof) {break;}
  put (c);
}
TEST152
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT152' && $CMP $stdout $ftemp2; then
var c, f = open ("test.d", "r");
for (;1;)
{
  try {c = fget (f);} catch (eof) {break;}
  put (c);
}
OUTPUT152
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 153.
if test $result = ok -a $start_test_number -le 153; then
	echo test 153
        cat >$test_file <<'TEST153'
var c;
for (;1;)
{
  c = get ();
  putln (c);
}
TEST153
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT153' && $CMP $stderr $ftemp2; then
test.d:4:11: run time error - EOF occured in `get'
OUTPUT153
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 154.
if test $result = ok -a $start_test_number -le 154; then
	echo test 154
        cat >$test_file <<'TEST154'
var c, f=open ("test.d", "r");
for (;1;)
{
  c = fget (f);
  put (c);
}
TEST154
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT154' && $CMP $stderr $ftemp2; then
test.d:4:12: run time error - EOF occured in `fget'
OUTPUT154
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 155.
if test $result = ok -a $start_test_number -le 155; then
	echo test 155
        cat >$test_file <<'TEST155'
var c = get (nil);
TEST155
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT155' && $CMP $stderr $ftemp2; then
test.d:1:13: run time error - invalid number of actual parameters for `get'
OUTPUT155
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 156.
if test $result = ok -a $start_test_number -le 156; then
	echo test 156
        cat >$test_file <<'TEST156'
var c = fget ();
TEST156
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT156' && $CMP $stderr $ftemp2; then
test.d:1:14: run time error - invalid number of actual parameters for `fget'
OUTPUT156
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 157.
if test $result = ok -a $start_test_number -le 157; then
	echo test 157
        cat >$test_file <<'TEST157'
var c = fget (nil);
TEST157
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT157' && $CMP $stderr $ftemp2; then
test.d:1:14: run time error - invalid parameter type of `fget'
OUTPUT157
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 158.
if test $result = ok -a $start_test_number -le 158; then
	echo test 158
        cat >$test_file <<'TEST158'
putln (getln());
TEST158
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT158' && $CMP $stdout $ftemp2; then
abcd
OUTPUT158
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 159.
if test $result = ok -a $start_test_number -le 159; then
	echo test 159
        cat >$test_file <<'TEST159'
var c, f = open ("test.d", "r");
for (;1;)
{
  try {putln (fgetln (f));} catch (eof) {break;}
}
TEST159
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT159' && $CMP $stdout $ftemp2; then
var c, f = open ("test.d", "r");
for (;1;)
{
  try {putln (fgetln (f));} catch (eof) {break;}
}
OUTPUT159
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 160.
if test $result = ok -a $start_test_number -le 160; then
	echo test 160
        cat >$test_file <<'TEST160'
putln (getln ());
putln (getln ());
TEST160
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT160' && $CMP $stderr $ftemp2; then
test.d:2:14: run time error - EOF occured in `getln'
OUTPUT160
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 161.
if test $result = ok -a $start_test_number -le 161; then
	echo test 161
        cat >$test_file <<'TEST161'
var c, f=open ("test.d", "r");
for (;1;)
  putln (fgetln (f));
TEST161
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT161' && $CMP $stderr $ftemp2; then
test.d:3:17: run time error - EOF occured in `fgetln'
OUTPUT161
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 162.
if test $result = ok -a $start_test_number -le 162; then
	echo test 162
        cat >$test_file <<'TEST162'
var c = getln (nil);
TEST162
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT162' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid number of actual parameters for `getln'
OUTPUT162
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 163.
if test $result = ok -a $start_test_number -le 163; then
	echo test 163
        cat >$test_file <<'TEST163'
var c = fgetln ();
TEST163
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT163' && $CMP $stderr $ftemp2; then
test.d:1:16: run time error - invalid number of actual parameters for `fgetln'
OUTPUT163
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 164.
if test $result = ok -a $start_test_number -le 164; then
	echo test 164
        cat >$test_file <<'TEST164'
var c = fgetln (nil);
TEST164
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT164' && $CMP $stderr $ftemp2; then
test.d:1:16: run time error - invalid parameter type of `fgetln'
OUTPUT164
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 165.
if test $result = ok -a $start_test_number -le 165; then
	echo test 165
        cat >$test_file <<'TEST165'
putln (nil);
TEST165
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT165' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `putln'
OUTPUT165
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 166.
if test $result = ok -a $start_test_number -le 166; then
	echo test 166
        cat >$test_file <<'TEST166'
put ([10]);
TEST166
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT166' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `put'
OUTPUT166
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 167.
if test $result = ok -a $start_test_number -le 167; then
	echo test 167
        cat >$test_file <<'TEST167'
fputln (nil);
TEST167
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT167' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `fputln'
OUTPUT167
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 168.
if test $result = ok -a $start_test_number -le 168; then
	echo test 168
        cat >$test_file <<'TEST168'
fput ([10]);
TEST168
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT168' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `fput'
OUTPUT168
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 169.
if test $result = ok -a $start_test_number -le 169; then
	echo test 169
        cat >$test_file <<'TEST169'
for (;1;)
{
  try {
    println (scanln ());
  } catch (eof) {putln ("eof"); break;}
    catch (invinput) {putln ("catch invalid input");}
}
TEST169
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout <<'INPUT169' ; then
'c'
"aaaaa"
1000
-1000
10e+10
-10e+10
[]
[2]
[2:2]
[2:[2]]
[2,2.2, 2:[10, 'c', "aaa", 10.7]]
tab []
tab [10, 2:"10"]
tab [[2,5]:tab [1:5, 5], 10:[10, 'c']]
[2,3] [3,2]
[2, a
[3,3]
INPUT169
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT169' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
-1000
1e+11
-1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab []
tab [2:"10", 10:10]
tab [10:[10, 'c'], [2, 5]:tab [1:5, 5:5]]
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT169
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT169-2' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
-1000
1e+011
-1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab []
tab [2:"10", 10:10]
tab [10:[10, 'c'], [2, 5]:tab [1:5, 5:5]]
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT169-2
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT169-3' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
-1000
1e+11
-1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab []
tab [2:"10", 10:10]
tab [[2, 5]:tab [1:5, 5:5], 10:[10, 'c']]
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT169-3
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT169-4' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
-1000
1e+011
-1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab []
tab [2:"10", 10:10]
tab [[2, 5]:tab [1:5, 5:5], 10:[10, 'c']]
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT169-4
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 170.
if test $result = ok -a $start_test_number -le 170; then
	echo test 170
        cat >$test_file <<'TEST170'
scan (nil);
TEST170
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT170' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `scan'
OUTPUT170
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 171.
if test $result = ok -a $start_test_number -le 171; then
	echo test 171
        cat >$test_file <<'TEST171'
scanln (nil);
TEST171
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT171' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `scanln'
OUTPUT171
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 172.
if test $result = ok -a $start_test_number -le 172; then
	echo test 172
        cat >$test_file <<'TEST172'
fscan ();
TEST172
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT172' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `fscan'
OUTPUT172
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 173.
if test $result = ok -a $start_test_number -le 173; then
	echo test 173
        cat >$test_file <<'TEST173'
fscanln ();
TEST173
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT173' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of actual parameters for `fscanln'
OUTPUT173
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 174.
if test $result = ok -a $start_test_number -le 174; then
	echo test 174
        cat >$test_file <<'TEST174'
fscan ([10]);
TEST174
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT174' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `fscan'
OUTPUT174
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 175.
if test $result = ok -a $start_test_number -le 175; then
	echo test 175
        cat >$test_file <<'TEST175'
fscanln ([10]);
TEST175
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT175' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `fscanln'
OUTPUT175
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 176.
if test $result = ok -a $start_test_number -le 176; then
	echo test 176
        cat >$test_file <<'TEST176'
for (;1;)
{
  try {
    println (scan ());
  } catch (eof) {putln ("eof"); break;}
}
TEST176
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout <<'INPUT176' ; then
'c'"aaaaa"1000 10e+10[][2][2:2][2:[2]][2,2.2, 2:[10, 'c', "aaa", 10.7]]
tab [10, 2:"10"]tab [[2,5]:tab [1:5, 5], 10:[10, 'c']][2,3] [3,2] [3,3]
INPUT176
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT176' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab [2:"10", 10:10]
tab [10:[10, 'c'], [2, 5]:tab [1:5, 5:5]]
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT176
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT176-2' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab [2:"10", 10:10]
tab [10:[10, 'c'], [2, 5]:tab [1:5, 5:5]]
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT176-2
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT176-3' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab [2:"10", 10:10]
tab [[2, 5]:tab [1:5, 5:5], 10:[10, 'c']]
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT176-3
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT176-4' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab [2:"10", 10:10]
tab [[2, 5]:tab [1:5, 5:5], 10:[10, 'c']]
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT176-4
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 177.
if test $result = ok -a $start_test_number -le 177; then
	echo test 177
        cat >$test_file <<'TEST177'
var f = open ("_temp.out", "r");
for (;1;)
{
  try {
    println (fscanln (f));
  } catch (eof) {putln ("eof"); break;}
    catch (invinput) {putln ("catch invalid input");}
}
TEST177
        echo '      ' "$DINO $test_file 2>$stderr"
	cat >$ftemp  <<'INPUT177'
'c'
"aaaaa"
1000
10e+10
[]
[2]
[2:2]
[2:[2]]
[2,2.2, 2:[10, 'c', "aaa", 10.7]]
tab [10, 2:"10"]
tab [[2,5]:tab [1:5, 5], 10:[10, 'c']]
[2,3] [3,2]
[2, a
[3,3]
INPUT177
        if $DINO $test_file 2>$stderr >$stdout ; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT177' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab [2:"10", 10:10]
tab [10:[10, 'c'], [2, 5]:tab [1:5, 5:5]]
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT177
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT177-2' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab [2:"10", 10:10]
tab [10:[10, 'c'], [2, 5]:tab [1:5, 5:5]]
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT177-2
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT177-3' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab [2:"10", 10:10]
tab [[2, 5]:tab [1:5, 5:5], 10:[10, 'c']]
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT177-3
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT177-4' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab [2:"10", 10:10]
tab [[2, 5]:tab [1:5, 5:5], 10:[10, 'c']]
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT177-4
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 178.
if test $result = ok -a $start_test_number -le 178; then
	echo test 178
        cat >$test_file <<'TEST178'
var f = open ("_temp.out", "r");
for (;1;)
{
  try {
    println (fscan (f));
  } catch (eof) {putln ("eof"); break;}
    catch (invinput) {putln ("catch invalid input");}
}
TEST178
        echo '      ' "$DINO $test_file 2>$stderr"
	cat >$ftemp  <<'INPUT178'
'c'"aaaaa"1000 10e+10[][2][2:2][2:[2]][2,2.2, 2:[10, 'c', "aaa", 10.7]]
tab [10, 2:"10"]tab [[2,5]:tab [1:5, 5], 10:[10, 'c']][2,3] [3,2] [3,3]
INPUT178
        if $DINO $test_file 2>$stderr >$stdout ; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT178' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab [2:"10", 10:10]
tab [10:[10, 'c'], [2, 5]:tab [1:5, 5:5]]
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT178
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT178-2' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab [2:"10", 10:10]
tab [10:[10, 'c'], [2, 5]:tab [1:5, 5:5]]
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT178-2
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT178-3' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab [2:"10", 10:10]
tab [[2, 5]:tab [1:5, 5:5], 10:[10, 'c']]
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT178-3
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT178-4' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
tab [2:"10", 10:10]
tab [[2, 5]:tab [1:5, 5:5], 10:[10, 'c']]
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT178-4
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 179.
if test $result = ok -a $start_test_number -le 179; then
	echo test 179
        cat >$test_file <<'TEST179'
println (scanln ());
TEST179
        echo '      ' "echo 1000000000000|$DINO $test_file 2>$stderr"
        if echo 1000000000000|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT179' && $CMP $stderr $ftemp2; then
test.d:1:17: system error - result too big (small): `string-to-int conversion'
OUTPUT179
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 180.
if test $result = ok -a $start_test_number -le 180; then
	echo test 180
        cat >$test_file <<'TEST180'
println (scanln ());
TEST180
        echo '      ' "echo 1000000000000e1000|$DINO $test_file 2>$stderr"
        if echo 1000000000000e1000|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT180' && $CMP $stderr $ftemp2; then
test.d:1:17: system error - result too big (small): `string-to-float conversion'
OUTPUT180
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 181.
if test $result = ok -a $start_test_number -le 181; then
	echo test 181
        cat >$test_file <<'TEST181'
println (scanln ());
TEST181
        echo '      ' "echo 1000000000000e-1000|$DINO $test_file 2>$stderr"
        if echo 1000000000000e-1000|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT181' && $CMP $stderr $ftemp2; then
test.d:1:17: system error - result too big (small): `string-to-float conversion'
OUTPUT181
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 182.
if test $result = ok -a $start_test_number -le 182; then
	echo test 182
        cat >$test_file <<'TEST182'
var i=100000000000;
TEST182
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT182' && $CMP $stderr $ftemp2; then
test.d:1:7: too big integer value
OUTPUT182
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 183.
if test $result = ok -a $start_test_number -le 183; then
	echo test 183
        cat >$test_file <<'TEST183'
var i=-100000000000;
TEST183
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT183' && $CMP $stderr $ftemp2; then
test.d:1:8: too big integer value
OUTPUT183
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 184.
if test $result = ok -a $start_test_number -le 184; then
	echo test 184
        cat >$test_file <<'TEST184'
var f=1000000000000e1000;
TEST184
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT184' && $CMP $stderr $ftemp2; then
test.d:1:7: too big or too small floating point value
OUTPUT184
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 185.
if test $result = ok -a $start_test_number -le 185; then
	echo test 185
        cat >$test_file <<'TEST185'
var f=1000000000000e-1000;
TEST185
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT185' && $CMP $stderr $ftemp2; then
test.d:1:7: too big or too small floating point value
OUTPUT185
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 186.
if test $result = ok -a $start_test_number -le 186; then
	echo test 186
        cat >$test_file <<'TEST186'
var f=-1000000000000e1000;
TEST186
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT186' && $CMP $stderr $ftemp2; then
test.d:1:8: too big or too small floating point value
OUTPUT186
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 187.
if test $result = ok -a $start_test_number -le 187; then
	echo test 187
        cat >$test_file <<'TEST187'
var i="1000000000000" + 0;
TEST187
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT187' && $CMP $stderr $ftemp2; then
test.d:1:23: system error - result too big (small): `string-to-int conversion'
OUTPUT187
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 188.
if test $result = ok -a $start_test_number -le 188; then
	echo test 188
        cat >$test_file <<'TEST188'
var f="1000000000000e1000" + 0.0;
TEST188
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT188' && $CMP $stderr $ftemp2; then
test.d:1:28: system error - result too big (small): `string-to-float conversion'
OUTPUT188
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 189.
if test $result = ok -a $start_test_number -le 189; then
	echo test 189
        cat >$test_file <<'TEST189'
thread t1 {
  put ("thread 1: ");print (curr_thread); put (" "); println (main_thread);
}

thread t2 {
  put ("thread 2: ");print (curr_thread); put (" "); println (main_thread);
}

put ("thread 2: ");print (curr_thread); put (" "); println (main_thread);

t1 ();
t2 ();
TEST189
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT189' && $CMP $ftemp $ftemp2; then
thread 2: main thread main thread
thread 1: thread 1 t1() main thread
thread 2: thread 2 t2() main thread
OUTPUT189
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 190.
if test $result = ok -a $start_test_number -le 190; then
	echo test 190
        cat >$test_file <<'TEST190'
var i;
for(i=0;;i++) {
  if (i == 10)
    break;
  putln (i);
}
TEST190
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout ; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT190' && $CMP $stdout $ftemp2; then
0
1
2
3
4
5
6
7
8
9
OUTPUT190
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 191.
if test $result = ok -a $start_test_number -le 191; then
	echo test 191
        cat >$test_file <<'TEST191'
var f = open ("1000000000000e1000", "r");
TEST191
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT191' && $CMP $stderr $ftemp2; then
test.d:1:14: system error - no such file or directory: `open'
OUTPUT191
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 192.
if test $result = ok -a $start_test_number -le 192; then
	echo test 192
        cat >$test_file <<'TEST192'
var f;
try {
 f = open ("1000000000000e1000", "r");
} catch (invcall) {}
close (f);
TEST192
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT192' && $CMP $stderr $ftemp2; then
test.d:5:8: run time error - undefined `f' value access
OUTPUT192
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 193.
if test $result = ok -a $start_test_number -le 193; then
	echo test 193
        cat >$test_file <<'TEST193'
var f = open ("1000000000000e1000");
TEST193
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT193' && $CMP $stderr $ftemp2; then
test.d:1:14: run time error - invalid number of actual parameters for `open'
OUTPUT193
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 194.
if test $result = ok -a $start_test_number -le 194; then
	echo test 194
        cat >$test_file <<'TEST194'
var f = open ("1000000000000e1000", "k");
TEST194
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT194' && $CMP $stderr $ftemp2; then
test.d:1:14: system error - invalid argument: `open'
OUTPUT194
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 195.
if test $result = ok -a $start_test_number -le 195; then
	echo test 195
        cat >$test_file <<'TEST195'
var f = open ("1000000000000e1000", nil);
TEST195
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT195' && $CMP $stderr $ftemp2; then
test.d:1:14: run time error - invalid parameter type of `open'
OUTPUT195
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 196.
if test $result = ok -a $start_test_number -le 196; then
	echo test 196
        cat >$test_file <<'TEST196'
close ();
TEST196
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT196' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `close'
OUTPUT196
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 197.
if test $result = ok -a $start_test_number -le 197; then
	echo test 197
        cat >$test_file <<'TEST197'
close (nil);
TEST197
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT197' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `close'
OUTPUT197
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 198.
if test $result = ok -a $start_test_number -le 198; then
	echo test 198
        cat >$test_file <<'TEST198'
flush ();
TEST198
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT198' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `flush'
OUTPUT198
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 199.
if test $result = ok -a $start_test_number -le 199; then
	echo test 199
        cat >$test_file <<'TEST199'
flush (nil);
TEST199
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT199' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `flush'
OUTPUT199
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 200.
if test $result = ok -a $start_test_number -le 200; then
	echo test 200
        cat >$test_file <<'TEST200'
put ("aaaaaa");
fputln (stderr, "end of output");
flush (stdout);
fputln (stderr, "end of output");
TEST200
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT200' && $CMP $stdout $ftemp2; then
end of output
aaaaaaend of output
OUTPUT200
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT200-2' && $CMP $stdout $ftemp2; then
aaaaaaend of output
end of output
OUTPUT200-2
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 201.
if test $result = ok -a $start_test_number -le 201; then
	echo test 201
        cat >$test_file <<'TEST201'
var f = popen ("1000000000000e1000");
TEST201
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT201' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid number of actual parameters for `popen'
OUTPUT201
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 202.
if test $result = ok -a $start_test_number -le 202; then
	echo test 202
        cat >$test_file <<'TEST202'
var f=popen("cat test.d", "r"), l;
for (;;)
{
  try {l = fgetln (f);} catch (eof) {break;}
  putln (l);
}
pclose (f);
TEST202
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT202' && $CMP $stdout $ftemp2; then
var f=popen("cat test.d", "r"), l;
for (;;)
{
  try {l = fgetln (f);} catch (eof) {break;}
  putln (l);
}
pclose (f);
OUTPUT202
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 203.
if test $result = ok -a $start_test_number -le 203; then
	echo test 203
        cat >$test_file <<'TEST203'
var f=popen("cat >_temp.out", "w"), l;
fputln (f, "tests ");
fputln (f, "tests #1");
pclose (f);
TEST203
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT203' && $CMP $ftemp $ftemp2; then
tests 
tests #1
OUTPUT203
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 204.
if test $result = ok -a $start_test_number -le 204; then
	echo test 204
        cat >$test_file <<'TEST204'
var f = popen ("cat test.d", "rw");
TEST204
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT204' && $CMP $stderr $ftemp2; then
test.d:1:15: system error - invalid argument: `popen'
OUTPUT204
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 205.
if test $result = ok -a $start_test_number -le 205; then
	echo test 205
        cat >$test_file <<'TEST205'
var f = popen ("1000000000000e1000", nil);
TEST205
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT205' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid parameter type of `popen'
OUTPUT205
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 206.
if test $result = ok -a $start_test_number -le 206; then
	echo test 206
        cat >$test_file <<'TEST206'
pclose ();
TEST206
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT206' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `pclose'
OUTPUT206
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 207.
if test $result = ok -a $start_test_number -le 207; then
	echo test 207
        cat >$test_file <<'TEST207'
pclose (nil);
TEST207
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT207' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `pclose'
OUTPUT207
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 208.
if test $result = ok -a $start_test_number -le 208; then
	echo test 208
        cat >$test_file <<'TEST208'
println (eltype ([1,2,3]));
println (eltype ([1.0,2,'c']));
println (eltype ([]));
TEST208
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT208' && $CMP $stdout $ftemp2; then
int
nil
type (nil)
OUTPUT208
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 209.
if test $result = ok -a $start_test_number -le 209; then
	echo test 209
        cat >$test_file <<'TEST209'
eltype ();
TEST209
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT209' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `eltype'
OUTPUT209
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 210.
if test $result = ok -a $start_test_number -le 210; then
	echo test 210
        cat >$test_file <<'TEST210'
eltype (1);
TEST210
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT210' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `eltype'
OUTPUT210
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 211.
if false; then
# Removed deprecated operations.
	echo test 211
        cat >$test_file <<'TEST211'
class c {
var i = 10;
}
var i=c();
putln (("i")->i);
("i")->i = 20;
putln (("i")->i);
("i")->i = 30;
putln (("i")->i);
("i")->i = 40;
putln (("i")->i);
("i")->i = 50;
putln (("i")->i);
TEST211
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT211' && $CMP $stdout $ftemp2; then
10
20
30
40
50
OUTPUT211
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 212.
if false; then
# Removed deprecated operations.
	echo test 212
        cat >$test_file <<'TEST212'
class c {
var i = 10;
}
var i=c();
putln ((10)->i);
TEST212
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT212' && $CMP $stderr $ftemp2; then
test.d:5:13: left operand of arrow must be of string type
OUTPUT212
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 213.
if false; then
# Removed deprecated operations.
	echo test 213
        cat >$test_file <<'TEST213'
class c {
var i = 10;
}
var i=c();
var j=[];
putln ((j)->i);
TEST213
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT213' && $CMP $stderr $ftemp2; then
test.d:6:12: run time error - decl name is not string (operation "->" or "*")
OUTPUT213
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 214.
if false; then
# Removed deprecated operations.
	echo test 214
        cat >$test_file <<'TEST214'
class c {
var i = 10;
}
var i=c();
var j=10;
putln (("i")->k);
TEST214
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT214' && $CMP $stderr $ftemp2; then
test.d:6:14: there is no such declaration in a block
OUTPUT214
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 215.
if false; then
# Removed deprecated operations.
	echo test 215
        cat >$test_file <<'TEST215'
class c {
var i = 10;
}
var i=c();
var j=10;
putln (("i")->j);
TEST215
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT215' && $CMP $stderr $ftemp2; then
test.d:6:14: run time error - there is no such declaration in given class
OUTPUT215
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 216.
if test $result = ok -a $start_test_number -le 216; then
	echo test 216
        cat >$test_file <<'TEST216'
var f=open ("_temp2.out", "w");
close(f);
putln (ftype ("_temp2.out"));
remove ("_temp2.out");
TEST216
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT216' && $CMP $stdout $ftemp2; then
f
OUTPUT216
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 217.
if test $result = ok -a $start_test_number -le 217; then
	echo test 217
        cat >$test_file <<'TEST217'
remove ();
TEST217
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT217' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `remove'
OUTPUT217
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 218.
if test $result = ok -a $start_test_number -le 218; then
	echo test 218
        cat >$test_file <<'TEST218'
remove (nil);
TEST218
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT218' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `remove'
OUTPUT218
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 219.
if test $result = ok -a $start_test_number -le 219; then
	echo test 219
        cat >$test_file <<'TEST219'
var f=open ("_temp.out", "w");
close(f);
putln (ftype ("_temp.out"));
rename ("_temp.out", "_temp2.out");
putln (ftype ("_temp2.out"));
remove ("_temp2.out");
TEST219
	rm -f $ftemp2
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT219' && $CMP $stdout $ftemp2; then
f
f
OUTPUT219
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 220.
if test $result = ok -a $start_test_number -le 220; then
	echo test 220
        cat >$test_file <<'TEST220'
rename (nil);
TEST220
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT220' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `rename'
OUTPUT220
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 221.
if test $result = ok -a $start_test_number -le 221; then
	echo test 221
        cat >$test_file <<'TEST221'
rename ("aaa", nil);
TEST221
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT221' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `rename'
OUTPUT221
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 222.
if test $result = ok -a $start_test_number -le 222; then
	echo test 222
        cat >$test_file <<TEST222
mkdir ("__tempdir");
putln (ftype ("__tempdir"));
TEST222
        rm -rf $tempdir
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT222' && $CMP $stdout $ftemp2; then
d
OUTPUT222
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 223.
if test $result = ok -a $start_test_number -le 223; then
	echo test 223
        cat >$test_file <<'TEST223'
mkdir ();
TEST223
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT223' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `mkdir'
OUTPUT223
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 224.
if test $result = ok -a $start_test_number -le 224; then
	echo test 224
        cat >$test_file <<'TEST224'
mkdir (nil);
TEST224
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT224' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `mkdir'
OUTPUT224
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 225.
if test $result = ok -a $start_test_number -le 225; then
	echo test 225
        cat >$test_file <<TEST225
mkdir ("__tempdir");
putln (ftype ("__tempdir"));
rmdir ("__tempdir");
TEST225
        rm -rf $tempdir
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT225' && $CMP $stdout $ftemp2 && test ! -d $tempdir; then
d
OUTPUT225
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 226.
if test $result = ok -a $start_test_number -le 226; then
	echo test 226
        cat >$test_file <<'TEST226'
rmdir ();
TEST226
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT226' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `rmdir'
OUTPUT226
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 227.
if test $result = ok -a $start_test_number -le 227; then
	echo test 227
        cat >$test_file <<'TEST227'
rmdir (nil);
TEST227
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT227' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `rmdir'
OUTPUT227
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 228.
if test $result = ok -a $start_test_number -le 228; then
	echo test 228
        cat >$test_file <<TEST228
putln (getcwd ());
TEST228
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/^[A-Za-z]://' $stdout|sed 's,\\,/,g' >$ftemp
                echo '      ' egrep "$ftemp2" $ftemp
                if uname | fgrep CYGWIN && test x$msvc != x;then
                   echo `pwd`| sed 's%/cygdrive/[a-z]%%' >$ftemp2
                else
                   echo `pwd` >$ftemp2
                fi
                echo '      ' $CMP $ftemp2 $ftemp
                if $CMP $ftemp $ftemp2; then
                        result=ok
                else
                        result=ok
			echo difference in the expected and result:
                        diff -c $ftemp2 $ftemp
                fi
        else
                result=fail
        fi
fi

# Test 229.
if test $result = ok -a $start_test_number -le 229; then
	echo test 229
        cat >$test_file <<'TEST229'
getcwd (1);
TEST229
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT229' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `getcwd'
OUTPUT229
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 230.
if test $result = ok -a $start_test_number -le 230; then
	echo test 230
        cat >$test_file <<TEST230
chdir ("__tempdir");
putln (getcwd ());
TEST230
        rm -rf $tempdir
        mkdir $tempdir
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/^[A-Za-z]://' $stdout|sed 's,\\,/,g' >$ftemp
                if uname | fgrep CYGWIN && test x$msvc != x;then
                   echo `pwd`/$tempdir| sed 's%/cygdrive/[a-z]%%' >$ftemp2
                else
                   echo `pwd`/$tempdir >$ftemp2
                fi
                echo '      ' $CMP $ftemp $ftemp2
                if  $CMP $ftemp $ftemp2; then
                        result=ok
                else
                        result=ok
			echo difference in the expected and result:
                        diff -c $ftemp2 $ftemp
                fi
        else
                result=fail
        fi
fi

# Test 231.
if test $result = ok -a $start_test_number -le 231; then
	echo test 231
        cat >$test_file <<'TEST231'
chdir ();
TEST231
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT231' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `chdir'
OUTPUT231
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 232.
if test $result = ok -a $start_test_number -le 232; then
	echo test 232
        cat >$test_file <<'TEST232'
chdir (nil);
TEST232
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT232' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `chdir'
OUTPUT232
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 233.
if test $result = ok -a $start_test_number -le 233; then
	echo test 233
        cat >$test_file <<'TEST233'
chdir ("abracadabra");
TEST233
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT233' && $CMP $stderr $ftemp2; then
test.d:1:7: system error - no such file or directory: `chdir'
OUTPUT233
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 234.
if test $result = ok -a $start_test_number -le 234; then
	echo test 234
        cat >$test_file <<'TEST234'
rmdir ("abracadabra");
TEST234
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT234' && $CMP $stderr $ftemp2; then
test.d:1:7: system error - no such file or directory: `rmdir'
OUTPUT234
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 235.
if test $result = ok -a $start_test_number -le 235; then
	echo test 235
        cat >$test_file <<'TEST235'
mkdir ("abracadabra/abaraca");
TEST235
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT235' && $CMP $stderr $ftemp2; then
test.d:1:7: system error - no such file or directory: `mkdir'
OUTPUT235
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 236.
if test $result = ok -a $start_test_number -le 236; then
	echo test 236
        cat >$test_file <<TEST236
putln (isatty (open ("test.d", "r")));
TEST236
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT236' && $CMP $stdout $ftemp2; then
0
OUTPUT236
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 237.
if test $result = ok -a $start_test_number -le 237; then
	echo test 237
        cat >$test_file <<'TEST237'
isatty ();
TEST237
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT237' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `isatty'
OUTPUT237
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 238.
if test $result = ok -a $start_test_number -le 238; then
	echo test 238
        cat >$test_file <<'TEST238'
isatty (nil);
TEST238
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT238' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `isatty'
OUTPUT238
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 239.
if test $result = ok -a $start_test_number -le 239; then
	echo test 239
        cat >$test_file <<TEST239
chumod ("test.d", "rwx");
putln (fumode ("test.d"));
TEST239
        if uname | fgrep CYGWIN; then
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT239' && $CMP $stdout $ftemp2; then
rwx
OUTPUT239
                        result=ok
                elif  cat >$ftemp2 <<'OUTPUT239-1' && $CMP $stdout $ftemp2; then
rw
OUTPUT239-1
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT239-2' && $CMP $stdout $ftemp2; then
rwx
OUTPUT239-2
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	fi
fi

# Test 240.
if test $result = ok -a $start_test_number -le 240; then
	echo test 240
        cat >$test_file <<'TEST240'
chumod (nil);
TEST240
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT240' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `chumod'
OUTPUT240
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 241.
if test $result = ok -a $start_test_number -le 241; then
	echo test 241
        cat >$test_file <<'TEST241'
chumod (nil, "aaa");
TEST241
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT241' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `chumod'
OUTPUT241
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 242.
if test $result = ok -a $start_test_number -le 242; then
	echo test 242
        cat >$test_file <<'TEST242'
chumod ("abracadabra", "r");
TEST242
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT242' && $CMP $stderr $ftemp2; then
test.d:1:8: system error - no such file or directory: `chumod'
OUTPUT242
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 243.
if test $result = ok -a $start_test_number -le 243; then
	echo test 243
        cat >$test_file <<TEST243
chgmod ("test.d", "rwx");
putln (fgmode ("test.d"));
TEST243
        if uname | fgrep CYGWIN; then
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT243' && $CMP $stdout $ftemp2; then

OUTPUT243
                        result=ok
		elif cat >$ftemp2 <<'OUTPUT243-1' && $CMP $stdout $ftemp2; then
r
OUTPUT243-1
                        result=ok
		elif cat >$ftemp2 <<'OUTPUT243-11' && $CMP $stdout $ftemp2; then
rw
OUTPUT243-11
                        result=ok
		elif cat >$ftemp2 <<'OUTPUT243-12' && $CMP $stdout $ftemp2; then
rwx
OUTPUT243-12
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT243-2' && $CMP $stdout $ftemp2; then
rwx
OUTPUT243-2
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	fi
fi

# Test 244.
if test $result = ok -a $start_test_number -le 244; then
	echo test 244
        cat >$test_file <<'TEST244'
chgmod (nil);
TEST244
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT244' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `chgmod'
OUTPUT244
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 241.
if test $result = ok -a $start_test_number -le 245; then
	echo test 245
        cat >$test_file <<'TEST245'
chgmod (nil, "aaa");
TEST245
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT245' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `chgmod'
OUTPUT245
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 246.
if test $result = ok -a $start_test_number -le 246; then
	echo test 246
        cat >$test_file <<'TEST246'
chgmod ("abracadabra", "r");
TEST246
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT246' && $CMP $stderr $ftemp2; then
test.d:1:8: system error - no such file or directory: `chgmod'
OUTPUT246
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 247.
if test $result = ok -a $start_test_number -le 247; then
	echo test 247
        cat >$test_file <<TEST247
chomod ("test.d", "rwx");
putln (fomode ("test.d"));
TEST247
        if uname | fgrep CYGWIN; then
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT247' && $CMP $stdout $ftemp2; then

OUTPUT247
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT247-1' && $CMP $stdout $ftemp2; then
r
OUTPUT247-1
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT247-11' && $CMP $stdout $ftemp2; then
rw
OUTPUT247-11
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT247-12' && $CMP $stdout $ftemp2; then
rwx
OUTPUT247-12
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT247-2' && $CMP $stdout $ftemp2; then
rwx
OUTPUT247-2
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	fi
fi

# Test 248.
if test $result = ok -a $start_test_number -le 248; then
	echo test 248
        cat >$test_file <<'TEST248'
chomod (nil);
TEST248
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT248' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `chomod'
OUTPUT248
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 241.
if test $result = ok -a $start_test_number -le 249; then
	echo test 249
        cat >$test_file <<'TEST249'
chomod (nil, "aaa");
TEST249
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT249' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `chomod'
OUTPUT249
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 250.
if test $result = ok -a $start_test_number -le 250; then
	echo test 250
        cat >$test_file <<'TEST250'
chomod ("abracadabra", "r");
TEST250
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT250' && $CMP $stderr $ftemp2; then
test.d:1:8: system error - no such file or directory: `chomod'
OUTPUT250
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 251.
if false; then
# Removed deprecated operations.
	echo test 251
        cat >$test_file <<'TEST251'
fun f ()
{
  putln ("call f");
}
class c ()
{
  putln ("call c");
}
var i = 10;
putln (*("i"));
*("i") = 20;
putln (*("i"));
*("i") = 30;
putln (*("i"));
*("i") = 40;
putln (*("i"));
*("i") = 50;
putln (*("i"));
*("f") ();
*("c") ();
TEST251
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT251' && $CMP $stdout $ftemp2; then
10
20
30
40
50
call f
call c
OUTPUT251
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 252.
if false; then
# Removed deprecated operations.
	echo test 252
        cat >$test_file <<'TEST252'
var i=10;
putln (*(10));
TEST252
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT252' && $CMP $stderr $ftemp2; then
test.d:2:8: operand of unary `*' must be of string type
OUTPUT252
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 253.
if false; then
# Removed deprecated operations.
	echo test 253
        cat >$test_file <<'TEST253'
var i=10;
var j={};
putln (*(j));
TEST253
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT253' && $CMP $stderr $ftemp2; then
test.d:3:8: run time error - decl name is not string (operation "->" or "*")
OUTPUT253
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 254.
if false; then
# Removed deprecated operations.
	echo test 254
        cat >$test_file <<'TEST254'
fun f {}
*("f") = 10;
TEST254
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT254' && $CMP $stderr $ftemp2; then
test.d:2:1: run time error - usage function as variable
OUTPUT254
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 255.
if false; then
# Removed deprecated operations.
	echo test 255
        cat >$test_file <<'TEST255'
class c {}
*("c") = 10;
TEST255
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT255' && $CMP $stderr $ftemp2; then
test.d:2:1: run time error - usage class as variable
OUTPUT255
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 256.
if false; then
# Removed deprecated operations.
	echo test 256
        cat >$test_file <<'TEST256'
class c()
{
    fun f {}
}
var i = c();
("i")->f = 10;
TEST256
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT256' && $CMP $stderr $ftemp2; then
test.d:6:7: run time error - usage function as variable
OUTPUT256
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 257.
if false; then
# Removed deprecated operations.
	echo test 257
        cat >$test_file <<'TEST257'
class c()
{
    class c {}
}
var i = c();
("i")->c = 10;
TEST257
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT257' && $CMP $stderr $ftemp2; then
test.d:6:7: run time error - usage class as variable
OUTPUT257
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 258.
if test $result = ok -a $start_test_number -le 258; then
	echo test 258: mpi package
        cat >$test_file <<'TEST258'
include "mpi";

var mpi1 = mpis.from_string(1, "10");
var mpi2 = mpis.from_string(1, "5");
putln (mpis.to_string (mpis.add (mpi1, mpi2)));
putln (mpis.to_string (mpis.subtract (mpi1, mpi2)));
putln (mpis.to_string (mpis.subtract (mpi2, mpi1)));
putln (mpis.to_string (mpis.multiply (mpi1, mpi2)));
putln (mpis.to_string (mpis.divide (mpi1, mpi2)));
putln (mpis.to_string (mpis.remainder (mpi1, mpi2)));
putln (mpis.eq (mpi1, mpi2));
putln (mpis.ne (mpi1, mpi2));
putln (mpis.lt (mpi1, mpi2));
putln (mpis.le (mpi1, mpi2));
putln (mpis.gt (mpi1, mpi2));
putln (mpis.ge (mpi1, mpi2));

try {
  mpis.multiply (mpis.multiply (mpi1, mpi2), mpis.multiply (mpi1, mpi2));
} catch (mpi_overflow_except) {
  putln ("got overflow 1");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.to_string (mpis.multiply (mpis.multiply (mpi1, mpi2), mpis.multiply (mpi1, mpi2))));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
mpi2 = mpis.from_string(2, "300");
try {
  mpis.change_size (mpi2, 1);
} catch (mpi_overflow_except) {
  putln ("got overflow 2");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.to_string (mpis.change_size (mpi2, 1)));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;

mpi1 = mpis.unsigned_from_string(1, "10");
mpi2 = mpis.unsigned_from_string(1, "5");
putln (mpis.unsigned_to_string (mpis.unsigned_add (mpi1, mpi2)));
putln (mpis.unsigned_to_string (mpis.unsigned_subtract (mpi1, mpi2)));
try {
  putln (mpis.unsigned_to_string (mpis.unsigned_subtract (mpi2, mpi1)));
} catch (mpi_overflow_except) {
  putln ("got overflow 3");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.unsigned_to_string (mpis.unsigned_subtract (mpi2, mpi1)));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
putln (mpis.unsigned_to_string (mpis.unsigned_multiply (mpi1, mpi2)));
putln (mpis.unsigned_to_string (mpis.unsigned_divide (mpi1, mpi2)));
putln (mpis.unsigned_to_string (mpis.unsigned_remainder (mpi1, mpi2)));
putln (mpis.unsigned_eq (mpi1, mpi2));
putln (mpis.unsigned_ne (mpi1, mpi2));
putln (mpis.unsigned_lt (mpi1, mpi2));
putln (mpis.unsigned_le (mpi1, mpi2));
putln (mpis.unsigned_gt (mpi1, mpi2));
putln (mpis.unsigned_ge (mpi1, mpi2));

try {
  mpis.unsigned_multiply (mpis.unsigned_multiply (mpi1, mpi2), mpis.unsigned_multiply (mpi1, mpi2));
} catch (mpi_overflow_except) {
  putln ("got overflow 4");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.unsigned_to_string (mpis.unsigned_multiply (mpis.unsigned_multiply (mpi1, mpi2), mpis.unsigned_multiply (mpi1, mpi2))));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
mpi2 = mpis.unsigned_from_string(2, "300");
try {
  mpis.unsigned_change_size (mpi2, 1);
} catch (mpi_overflow_except) {
  putln ("got overflow 5");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.unsigned_to_string (mpis.unsigned_change_size (mpi2, 1)));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;

mpi1 = mpis.from_string(50, "10000000000000000000000000000000000000000000000");
mpi2 = mpis.from_string(50, "5000000000000000000000000000000000000000000000");
putln (mpis.to_string (mpis.add (mpi1, mpi2)));
putln (mpis.to_string (mpis.subtract (mpi1, mpi2)));
putln (mpis.to_string (mpis.subtract (mpi2, mpi1)));
putln (mpis.to_string (mpis.multiply (mpi1, mpi2)));
putln (mpis.to_string (mpis.divide (mpi1, mpi2)));
putln (mpis.to_string (mpis.remainder (mpi1, mpi2)));
putln (mpis.eq (mpi1, mpi2));
putln (mpis.ne (mpi1, mpi2));
putln (mpis.lt (mpi1, mpi2));
putln (mpis.le (mpi1, mpi2));
putln (mpis.gt (mpi1, mpi2));
putln (mpis.ge (mpi1, mpi2));
try {
  mpis.multiply (mpis.multiply (mpi1, mpi2), mpis.multiply (mpi1, mpi2));
} catch (mpi_overflow_except) {
  putln ("got overflow 6");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.to_string (mpis.multiply (mpis.multiply (mpi1, mpi2), mpis.multiply (mpi1, mpi2))));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
try {
  mpis.change_size (mpi2, 2);
} catch (mpi_overflow_except) {
  putln ("got overflow 7");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.to_string (mpis.change_size (mpi2, 2)));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;

mpi1 = mpis.unsigned_from_string(50, "10000000000000000000000000000000000000000000000");
mpi2 = mpis.unsigned_from_string(50, "5000000000000000000000000000000000000000000000");
putln (mpis.unsigned_to_string (mpis.unsigned_add (mpi1, mpi2)));
putln (mpis.unsigned_to_string (mpis.unsigned_subtract (mpi1, mpi2)));
try {
  putln (mpis.unsigned_to_string (mpis.unsigned_subtract (mpi2, mpi1)));
} catch (mpi_overflow_except) {
  putln ("got overflow 8");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.unsigned_to_string (mpis.unsigned_subtract (mpi2, mpi1)));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
putln (mpis.unsigned_to_string (mpis.unsigned_multiply (mpi1, mpi2)));
putln (mpis.unsigned_to_string (mpis.unsigned_divide (mpi1, mpi2)));
putln (mpis.unsigned_to_string (mpis.unsigned_remainder (mpi1, mpi2)));
putln (mpis.unsigned_eq (mpi1, mpi2));
putln (mpis.unsigned_ne (mpi1, mpi2));
putln (mpis.unsigned_lt (mpi1, mpi2));
putln (mpis.unsigned_le (mpi1, mpi2));
putln (mpis.unsigned_gt (mpi1, mpi2));
putln (mpis.unsigned_ge (mpi1, mpi2));
try {
  mpis.unsigned_multiply (mpis.unsigned_multiply (mpi1, mpi2), mpis.unsigned_multiply (mpi1, mpi2));
} catch (mpi_overflow_except) {
  putln ("got overflow 9");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.unsigned_to_string (mpis.unsigned_multiply (mpis.unsigned_multiply (mpi1, mpi2), mpis.unsigned_multiply (mpi1, mpi2))));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
try {
  mpis.unsigned_change_size (mpi2, 2);
} catch (mpi_overflow_except) {
  putln ("got overflow 10");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.unsigned_to_string (mpis.unsigned_change_size (mpi2, 2)));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
TEST258
        if uname | fgrep CYGWIN; then
            echo '      ' $DINO -L./d_mpi.dll -I@srcdir@ $test_file "2>$stderr"
	    if $DINO -Lmpi.dll -I@srcdir@ $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT258' && $CMP $stdout $ftemp2; then
15
5
-5
50
2
0
0
1
0
0
1
1
got overflow 1
-60
ovfw=1
got overflow 2
44
ovfw=1
15
5
got overflow 3
251
ovfw=1
50
2
0
0
1
0
0
1
1
got overflow 4
196
ovfw=1
got overflow 5
44
ovfw=1
15000000000000000000000000000000000000000000000
5000000000000000000000000000000000000000000000
-5000000000000000000000000000000000000000000000
50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
2
0
0
1
0
0
1
1
got overflow 6
867904737743324110893126166364363704770614348168184133037106651590308130409865771824596108187979317115712568128322928640
ovfw=1
got overflow 7
0
ovfw=1
15000000000000000000000000000000000000000000000
5000000000000000000000000000000000000000000000
got overflow 8
2582249878086908589655919172003011874329705792829223512830659356540647622011841194629645353280137831435903171972747493376
ovfw=1
50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
2
0
0
1
0
0
1
1
got overflow 9
867904737743324110893126166364363704770614348168184133037106651590308130409865771824596108187979317115712568128322928640
ovfw=1
got overflow 10
0
ovfw=1
OUTPUT258
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
            echo '      ' $DINO -L./d_mpi.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file "2>$stderr"
	    if $DINO -L./d_mpi.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT258' && $CMP $stdout $ftemp2; then
15
5
-5
50
2
0
0
1
0
0
1
1
got overflow 1
-60
ovfw=1
got overflow 2
44
ovfw=1
15
5
got overflow 3
251
ovfw=1
50
2
0
0
1
0
0
1
1
got overflow 4
196
ovfw=1
got overflow 5
44
ovfw=1
15000000000000000000000000000000000000000000000
5000000000000000000000000000000000000000000000
-5000000000000000000000000000000000000000000000
50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
2
0
0
1
0
0
1
1
got overflow 6
867904737743324110893126166364363704770614348168184133037106651590308130409865771824596108187979317115712568128322928640
ovfw=1
got overflow 7
0
ovfw=1
15000000000000000000000000000000000000000000000
5000000000000000000000000000000000000000000000
got overflow 8
2582249878086908589655919172003011874329705792829223512830659356540647622011841194629645353280137831435903171972747493376
ovfw=1
50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
2
0
0
1
0
0
1
1
got overflow 9
867904737743324110893126166364363704770614348168184133037106651590308130409865771824596108187979317115712568128322928640
ovfw=1
got overflow 10
0
ovfw=1
OUTPUT258
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
        fi
fi

# Test 259.
if test $result = ok -a $start_test_number -le 259; then
	echo test 259: Redefinitions
        cat >$test_file <<'TEST259'
val i = 10;
fun f { return i;}
val i = 20;
putln (f ());
fun f { return i;}
putln (f ());
TEST259
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT259' && $CMP $stdout $ftemp2; then
10
20
OUTPUT259
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 260.
if test $result = ok -a $start_test_number -le 260; then
	echo test 260: Redefinitions
        cat >$test_file <<'TEST260'
val i = 10;
fun f { return 10;}
val i = 20;
fun f2 { return i + f ();}
putln (f2 ());
TEST260
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT260' && $CMP $stdout $ftemp2; then
30
OUTPUT260
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 261.
if test $result = ok -a $start_test_number -le 261; then
	echo test 261
        cat >$test_file <<'TEST261'
class c {
  priv var i;
  i = 0;
}

var i;
i = c ();
i.i = 1;
TEST261
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT261' && $CMP $stderr $ftemp2; then
test.d:8:2: run time error - access to private decl `i' from outside
OUTPUT261
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 262.
if test $result = ok -a $start_test_number -le 262; then
	echo test 262
        cat >$test_file <<'TEST262'
var ci;
{
  var i;
  class c {
  }
  ci = c ();
  i = 0;
}

context(ci).i = 1;
TEST262
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT262' && $CMP $stderr $ftemp2; then
test.d:10:12: run time error - access to private decl `i' from outside
OUTPUT262
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 263.
if test $result = ok -a $start_test_number -le 263; then
	echo test 263: Forward and matched decl access
        cat >$test_file <<'TEST263'
fun f;
pub fun f () {}
TEST263
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT263' && $CMP $stderr $ftemp2; then
test.d:2:9: forward and matched decls of `f' have different access/final attributes
test.d:1:5: (previous declaration of identifier `f')
OUTPUT263
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 264.
if test $result = ok -a $start_test_number -le 264; then
	echo test 264: Forward and matched decl final
        cat >$test_file <<'TEST264'
final class c;
class c () {}
TEST264
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT264' && $CMP $stderr $ftemp2; then
test.d:2:7: forward and matched decls of `c' have different access/final attributes
test.d:1:13: (previous declaration of identifier `c')
OUTPUT264
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 265.
if test $result = ok -a $start_test_number -le 265; then
	echo test 265
        cat >$test_file <<'TEST265'
fun f;
pub fun f;
fun f() {}
TEST265
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT265' && $CMP $stderr $ftemp2; then
test.d:2:9: forward and matched decls of `f' have different access/final attributes
test.d:1:5: (previous declaration of identifier `f')
OUTPUT265
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 266.
if test $result = ok -a $start_test_number -le 266; then
	echo test 266
        cat >$test_file <<'TEST266'
argv[0] = 1;
TEST266
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT266' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - attempt to modify immutable vector
OUTPUT266
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 267.
if test $result = ok -a $start_test_number -le 267; then
	echo test 267
        cat >$test_file <<'TEST267'
atan2 (10);
TEST267
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT267' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `atan2'
OUTPUT267
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 268.
if test $result = ok -a $start_test_number -le 268; then
	echo test 268
        cat >$test_file <<'TEST268'
atan2 (tab [], 10);
TEST268
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT268' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `atan2'
OUTPUT268
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 269.
if test $result = ok -a $start_test_number -le 269; then
	echo test 269
        cat >$test_file <<'TEST269'
atan2 (10, 10, 10);
TEST269
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT269' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `atan2'
OUTPUT269
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 270.
if test $result = ok -a $start_test_number -le 270; then
	echo test 270
        cat >$test_file <<'TEST270'
atan2 ();
TEST270
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT270' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `atan2'
OUTPUT270
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 271.
if test $result = ok -a $start_test_number -le 271; then
	echo test 271
        cat >$test_file <<'TEST271'
class c () {
  return 10;
}

var i;

i = c ();
TEST271
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT271' && $CMP $stderr $ftemp2; then
test.d:2:3: statement return with result is in class
OUTPUT271
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 272.
if test $result = ok -a $start_test_number -le 272; then
	echo test 272
        cat >$test_file <<'TEST272'
class c {
  {
    return 10;
  }
}

var i;

i = c ();
TEST272
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT272' && $CMP $stderr $ftemp2; then
test.d:3:5: statement return with result is in class
OUTPUT272
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 273.
if test $result = ok -a $start_test_number -le 273; then
	echo test 273
        cat >$test_file <<'TEST273'
cos ();
TEST273
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT273' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `cos'
OUTPUT273
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 274.
if test $result = ok -a $start_test_number -le 274; then
	echo test 274
        cat >$test_file <<'TEST274'
cos (tab []);
TEST274
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT274' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `cos'
OUTPUT274
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 275.
if test $result = ok -a $start_test_number -le 275; then
	echo test 275
        cat >$test_file <<'TEST275'
del ();
TEST275
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT275' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `del'
OUTPUT275
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 276.
if test $result = ok -a $start_test_number -le 276; then
	echo test 276
        cat >$test_file <<'TEST276'
var v;
v = "123456"; del (v, 1);
TEST276
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT276' && $CMP $stderr $ftemp2; then
test.d:2:19: run time error - attempt to modify immutable vector
OUTPUT276
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 277.
if test $result = ok -a $start_test_number -le 277; then
	echo test 277
        cat >$test_file <<'TEST277'
var t;
t = final tab [1, 2, 3, 4, 5, 6]; del (t, 1);
TEST277
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT277' && $CMP $stderr $ftemp2; then
test.d:2:39: run time error - attempt to modify immutable table
OUTPUT277
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 278.
if test $result = ok -a $start_test_number -le 278; then
	echo test 278
        cat >$test_file <<'TEST278'
del (10);
TEST278
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT278' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `del'
OUTPUT278
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 279.
if test $result = ok -a $start_test_number -le 279; then
	echo test 279
        cat >$test_file <<'TEST279'
del (10, 10);
TEST279
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT279' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `del'
OUTPUT279
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 280.
if test $result = ok -a $start_test_number -le 280; then
	echo test 280
        cat >$test_file <<'TEST280'
del (10,10,10,10);
TEST280
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT280' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `del'
OUTPUT280
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 281.
if test $result = ok -a $start_test_number -le 281; then
	echo test 281
        cat >$test_file <<'TEST281'
var t;
t = tab [10]; del (t, 10, 10);
TEST281
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT281' && $CMP $stderr $ftemp2; then
test.d:2:19: run time error - invalid number of actual parameters for `del'
OUTPUT281
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 282.
if test $result = ok -a $start_test_number -le 282; then
	echo test 282
        cat >$test_file <<'TEST282'
var v;
v = []; del (v, tab []);
TEST282
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT282' && $CMP $stderr $ftemp2; then
test.d:2:13: run time error - invalid parameter type of `del'
OUTPUT282
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 283.
if test $result = ok -a $start_test_number -le 283; then
	echo test 283
        cat >$test_file <<'TEST283'
var v;
v = []; del (v, 0, tab []);
TEST283
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT283' && $CMP $stderr $ftemp2; then
test.d:2:13: run time error - invalid parameter type of `del'
OUTPUT283
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 284.
if test $result = ok -a $start_test_number -le 284; then
	echo test 284: Repeated idents in use
        cat >$test_file <<'TEST284'
class c {
  val i;
}

class sc {
  val i;
  use c former i later i;
}
TEST284
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT284' && $CMP $stderr $ftemp2; then
test.d:7:7: used decl redefines previous `i' and is not mentioned in former item
test.d:6:7: (previous declaration of identifier `i')
test.d:7:16: repeated occurrence of identifier `i' in use items
test.d:7:24: (previous occurrence of identifier `i')
test.d:7:24: `i' mentioned in later item is not declared after the use-clause
OUTPUT284
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 285.
if test $result = ok -a $start_test_number -le 285; then
	echo test 285
        cat >$test_file <<'TEST285'
env ["PATH"] = "abracadabra";
TEST285
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT285' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - attempt to modify immutable table
OUTPUT285
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 286.
if test $result = ok -a $start_test_number -le 286; then
	echo test 286
        cat >$test_file <<'TEST286'
ins ();
TEST286
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT286' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `ins'
OUTPUT286
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 287.
if test $result = ok -a $start_test_number -le 287; then
	echo test 287
        cat >$test_file <<'TEST287'
var v;
v = "123456"; ins (v, 1);
TEST287
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT287' && $CMP $stderr $ftemp2; then
test.d:2:19: run time error - attempt to modify immutable vector
OUTPUT287
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 288.
if test $result = ok -a $start_test_number -le 288; then
	echo test 288
        cat >$test_file <<'TEST288'
ins (10);
TEST288
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT288' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `ins'
OUTPUT288
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 289.
if test $result = ok -a $start_test_number -le 289; then
	echo test 289
        cat >$test_file <<'TEST289'
ins (10, 10);
TEST289
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT289' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `ins'
OUTPUT289
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 290.
if test $result = ok -a $start_test_number -le 290; then
	echo test 290
        cat >$test_file <<'TEST290'
ins (10,10,10,10);
TEST290
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT290' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `ins'
OUTPUT290
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 291.
if test $result = ok -a $start_test_number -le 291; then
	echo test 291
        cat >$test_file <<'TEST291'
var v;
v = []; ins (v, 1, tab []);
TEST291
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT291' && $CMP $stderr $ftemp2; then
test.d:2:13: run time error - invalid parameter type of `ins'
OUTPUT291
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 292.
if test $result = ok -a $start_test_number -le 292; then
	echo test 292
        cat >$test_file <<'TEST292'
insv ();
TEST292
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT292' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `insv'
OUTPUT292
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 293.
if test $result = ok -a $start_test_number -le 293; then
	echo test 293
        cat >$test_file <<'TEST293'
var v;
v = "123456"; insv (v, [1]);
TEST293
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT293' && $CMP $stderr $ftemp2; then
test.d:2:20: run time error - attempt to modify immutable vector
OUTPUT293
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 294.
if test $result = ok -a $start_test_number -le 294; then
	echo test 294
        cat >$test_file <<'TEST294'
insv (10);
TEST294
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT294' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `insv'
OUTPUT294
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 295.
if test $result = ok -a $start_test_number -le 295; then
	echo test 295
        cat >$test_file <<'TEST295'
insv (10, 10);
TEST295
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT295' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `insv'
OUTPUT295
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 296.
if test $result = ok -a $start_test_number -le 296; then
	echo test 296
        cat >$test_file <<'TEST296'
insv (10,10,10,10);
TEST296
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT296' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `insv'
OUTPUT296
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 297.
if test $result = ok -a $start_test_number -le 297; then
	echo test 297
        cat >$test_file <<'TEST297'
var v;
v = []; insv (v, [1], tab []);
TEST297
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT297' && $CMP $stderr $ftemp2; then
test.d:2:14: run time error - invalid parameter type of `insv'
OUTPUT297
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 298.
if test $result = ok -a $start_test_number -le 298; then
	echo test 298
        cat >$test_file <<'TEST298'
var v;
v = []; insv (v, 1);
TEST298
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT298' && $CMP $stderr $ftemp2; then
test.d:2:14: run time error - invalid parameter type of `insv'
OUTPUT298
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 299.
if test $result = ok -a $start_test_number -le 299; then
	echo test 299
        cat >$test_file <<'TEST299'
class c {
  val i;
}

class sc {
  use c former i;
}
TEST299
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT299' && $CMP $stderr $ftemp2; then
test.d:6:16: `i' mentioned in former item is not declared before the use-clause
OUTPUT299
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 300.
if test $result = ok -a $start_test_number -le 300; then
	echo test 300
        cat >$test_file <<'TEST300'
fput ();
TEST300
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT300' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `fput'
OUTPUT300
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 301.
if test $result = ok -a $start_test_number -le 301; then
	echo test 301
        cat >$test_file <<'TEST301'
fput ("AAAA");
TEST301
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT301' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `fput'
OUTPUT301
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 302.
if test $result = ok -a $start_test_number -le 302; then
	echo test 302: More one used
        cat >$test_file <<'TEST302'
class c {
  fun me {putln ("c1");}
  fun me {putln ("c2");}
  fun pr {me ();}
};

class sc {
   fun me {putln ("sc");}
   use c former me;
};

var co = c (), sco = sc ();
co.pr ();
sco.pr ();
TEST302
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT302' && $CMP $stdout $ftemp2; then
c2
sc
OUTPUT302
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 303.
if test $result = ok -a $start_test_number -le 303; then
	echo test 303: More one use with later
        cat >$test_file <<'TEST303'
class c {
  fun me {putln ("c1");}
  fun me {putln ("c2");}
  fun pr {me ();}
};

class sc {
   use c later me;
   fun me {putln ("sc");}
};

var co = c (), sco = sc ();
co.pr ();
sco.pr ();
TEST303
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT303' && $CMP $stdout $ftemp2; then
c2
sc
OUTPUT303
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 304.
if test $result = ok -a $start_test_number -le 304; then
	echo test 304: Forward declaration for recursion
        cat >$test_file <<'TEST304'
fun even;
fun odd (i) { if (i == 0) return 0; return even (i - 1);}
fun even (i) { if (i == 0) return 1; return odd (i - 1);}
putln (odd (10));
TEST304
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT304' && $CMP $stdout $ftemp2; then
0
OUTPUT304
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 305.
if test $result = ok -a $start_test_number -le 305; then
	echo test 305
        cat >$test_file <<'TEST305'
inside ("");
TEST305
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT305' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `inside'
OUTPUT305
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 306.
if test $result = ok -a $start_test_number -le 306; then
	echo test 306
        cat >$test_file <<'TEST306'
class c {}
inside ("", c);
TEST306
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT306' && $CMP $stderr $ftemp2; then
test.d:2:8: run time error - invalid parameter type of `inside'
OUTPUT306
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 307.
if test $result = ok -a $start_test_number -le 307; then
	echo test 307
        cat >$test_file <<'TEST307'
class c {}
inside (c,"");
TEST307
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT307' && $CMP $stderr $ftemp2; then
test.d:2:8: run time error - invalid parameter type of `inside'
OUTPUT307
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 308.
if test $result = ok -a $start_test_number -le 308; then
	echo test 308
        cat >$test_file <<'TEST308'
match ("");
TEST308
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT308' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `match'
OUTPUT308
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 309.
if test $result = ok -a $start_test_number -le 309; then
	echo test 309
        cat >$test_file <<'TEST309'
match (nil, 10);
TEST309
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT309' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `match'
OUTPUT309
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 310.
if test $result = ok -a $start_test_number -le 310; then
	echo test 310
        cat >$test_file <<'TEST310'
match ("", nil);
TEST310
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT310' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `match'
OUTPUT310
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 311.
if test $result = ok -a $start_test_number -le 311; then
	echo test 311
        cat >$test_file <<'TEST311'
var s;
s = "aaaa";
s[1] = "b";
TEST311
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT311' && $CMP $stderr $ftemp2; then
test.d:3:2: run time error - attempt to modify immutable vector
OUTPUT311
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 312.
if test $result = ok -a $start_test_number -le 312; then
	echo test 312
        cat >$test_file <<'TEST312'
var s;
s = final tab["a"];
s["a"] = "b";
TEST312
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT312' && $CMP $stderr $ftemp2; then
test.d:3:2: run time error - attempt to modify immutable table
OUTPUT312
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 313.
if test $result = ok -a $start_test_number -le 313; then
	echo test 313
        cat >$test_file <<'TEST313'
var s, t;
s = ['a'];
t = tab [s:"a"];
s[0] = 'b';
TEST313
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT313' && $CMP $stderr $ftemp2; then
test.d:4:2: run time error - attempt to modify immutable vector
OUTPUT313
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 314.
if test $result = ok -a $start_test_number -le 314; then
	echo test 314
        cat >$test_file <<'TEST314'
class c()
{
  var i;
}
var o;
o = final c ();
o.i = 10;
TEST314
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT314' && $CMP $stderr $ftemp2; then
test.d:7:2: run time error - attempt to modify immutable instance
OUTPUT314
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 315.
if test $result = ok -a $start_test_number -le 315; then
	echo test 315
        cat >$test_file <<'TEST315'
var i;
i = nil;
i++;
TEST315
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT315' && $CMP $stderr $ftemp2; then
test.d:3:2: run time error - invalid types of operands of operator "+"
OUTPUT315
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 316.
if test $result = ok -a $start_test_number -le 316; then
	echo test 316
        cat >$test_file <<'TEST316'
rand (10);
TEST316
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT316' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `rand'
OUTPUT316
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 317.
if test $result = ok -a $start_test_number -le 317; then
	echo test 317
        cat >$test_file <<'TEST317'
rand (10, 10);
TEST317
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT317' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `rand'
OUTPUT317
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 318.
if test $result = ok -a $start_test_number -le 318; then
	echo test 318
        cat >$test_file <<'TEST318'
readdir ();
TEST318
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT318' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of actual parameters for `readdir'
OUTPUT318
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 319.
if test $result = ok -a $start_test_number -le 319; then
	echo test 319
        cat >$test_file <<'TEST319'
readdir ("1", "");
TEST319
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT319' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of actual parameters for `readdir'
OUTPUT319
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 320.
if test $result = ok -a $start_test_number -le 320; then
	echo test 320
        cat >$test_file <<'TEST320'
readdir (nil);
TEST320
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT320' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `readdir'
OUTPUT320
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 321.
if test $result = ok -a $start_test_number -le 321; then
	echo test 321
        cat >$test_file <<'TEST321'
fun f {putln ("aa";return 1;}
fun g {putln ("aa";return 1;}
TEST321
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT321' && $CMP $stderr $ftemp2; then
test.d:1:19: syntax error
test.d:2:19: syntax error
OUTPUT321
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 322.
if test $result = ok -a $start_test_number -le 322; then
	echo test 322
        cat >$test_file <<'TEST322'
fun f {}
f = 1;
TEST322
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT322' && $CMP $stderr $ftemp2; then
test.d:2:1: non variable in assignment statement
OUTPUT322
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 323.
if test $result = ok -a $start_test_number -le 323; then
	echo test 323
        cat >$test_file <<'TEST323'
fun f {}
var t;
t = tab [];
for (f: t);
TEST323
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT323' && $CMP $stderr $ftemp2; then
test.d:4:6: non variable in foreach-stmt index designator
OUTPUT323
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 324.
if test $result = ok -a $start_test_number -le 324; then
	echo test 324
        cat >$test_file <<'TEST324'
class c {
  fun f {}
}
var o;
o = c();
o.f = 1;
TEST324
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT324' && $CMP $stderr $ftemp2; then
test.d:6:2: run time error - usage function as variable
OUTPUT324
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 325.
if test $result = ok -a $start_test_number -le 325; then
	echo test 325
        cat >$test_file <<'TEST325'
class c {
  fun f {}
}
var o, t;
o = c();
t = tab [];
for (o.f: t);
TEST325
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT325' && $CMP $stderr $ftemp2; then
test.d:7:7: run time error - usage function as variable
OUTPUT325
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 326.
if test $result = ok -a $start_test_number -le 326; then
	echo test 326
        cat >$test_file <<'TEST326'
class c {
  class f {}
}
var o;
o = c();
o.f = 1;
TEST326
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT326' && $CMP $stderr $ftemp2; then
test.d:6:2: run time error - usage class as variable
OUTPUT326
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 327.
if test $result = ok -a $start_test_number -le 327; then
	echo test 327
        cat >$test_file <<'TEST327'
class c {
  class f {}
}
var o, t;
o = c();
t = tab [];
for (o.f: t);
TEST327
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT327' && $CMP $stderr $ftemp2; then
test.d:7:7: run time error - usage class as variable
OUTPUT327
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 328.
if test $result = ok -a $start_test_number -le 328; then
	echo test 328
        cat >$test_file <<'TEST328'
sin ();
TEST328
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT328' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `sin'
OUTPUT328
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 329.
if test $result = ok -a $start_test_number -le 329; then
	echo test 329
        cat >$test_file <<'TEST329'
sin (tab []);
TEST329
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT329' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `sin'
OUTPUT329
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 330.
if test $result = ok -a $start_test_number -le 330; then
	echo test 330
        cat >$test_file <<'TEST330'
split ("a", "A", "A");
TEST330
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT330' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `split'
OUTPUT330
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 331.
if test $result = ok -a $start_test_number -le 331; then
	echo test 331
        cat >$test_file <<'TEST331'
split ();
TEST331
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT331' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `split'
OUTPUT331
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 332.
if test $result = ok -a $start_test_number -le 332; then
	echo test 332
        cat >$test_file <<'TEST332'
split ("aaa", nil);
TEST332
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT332' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `split'
OUTPUT332
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 333.
if test $result = ok -a $start_test_number -le 333; then
	echo test 333
        cat >$test_file <<'TEST333'
split (nil);
TEST333
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT333' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `split'
OUTPUT333
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 334.
if test $result = ok -a $start_test_number -le 334; then
	echo test 334
        cat >$test_file <<'TEST334'
srand (10, 10);
TEST334
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT334' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of actual parameters for `srand'
OUTPUT334
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 335.
if test $result = ok -a $start_test_number -le 335; then
	echo test 335
        cat >$test_file <<'TEST335'
srand (tab []);
TEST335
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT335' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `srand'
OUTPUT335
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 336.
if test $result = ok -a $start_test_number -le 336; then
	echo test 336
        cat >$test_file <<'TEST336'
sub ();
TEST336
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT336' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `sub'
OUTPUT336
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 337.
if test $result = ok -a $start_test_number -le 337; then
	echo test 337
        cat >$test_file <<'TEST337'
sub ("", "", "", "");
TEST337
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT337' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `sub'
OUTPUT337
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 338.
if test $result = ok -a $start_test_number -le 338; then
	echo test 338
        cat >$test_file <<'TEST338'
sub (nil, "", "");
TEST338
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT338' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `sub'
OUTPUT338
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 339.
if test $result = ok -a $start_test_number -le 339; then
	echo test 339
        cat >$test_file <<'TEST339'
sub (nil, "", "");
TEST339
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT339' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `sub'
OUTPUT339
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 340.
if test $result = ok -a $start_test_number -le 340; then
	echo test 340
        cat >$test_file <<'TEST340'
putln (system (10));
TEST340
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT340' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid parameter type of `system'
OUTPUT340
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 341.
if test $result = ok -a $start_test_number -le 341; then
	echo test 341
        cat >$test_file <<'TEST341'
putln (system ());
TEST341
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT341' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid number of actual parameters for `system'
OUTPUT341
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 342.
if test $result = ok -a $start_test_number -le 342; then
	echo test 342
        cat >$test_file <<'TEST342'
var t;
t = tab [];
putln (t[10]);
TEST342
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT342' && $CMP $stderr $ftemp2; then
test.d:3:9: run time error - no such key in table
OUTPUT342
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 343.
if test $result = ok -a $start_test_number -le 343; then
	echo test 343
        cat >$test_file <<'TEST343'
var t;
t = 10;
putln (10 in t);
TEST343
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT343' && $CMP $stderr $ftemp2; then
test.d:3:11: run time error - non table right to `:'
OUTPUT343
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 344.
if test $result = ok -a $start_test_number -le 344; then
	echo test 344
        cat >$test_file <<'TEST344'
var t;
t = [];
putln (t[10]);
TEST344
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT344' && $CMP $stderr $ftemp2; then
test.d:3:9: run time error - index is greater than array bound
OUTPUT344
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 345.
if test $result = ok -a $start_test_number -le 345; then
	echo test 345
        cat >$test_file <<'TEST345'
var i,t;
t = [];
for (i: t) putln ("wrong");
TEST345
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT345' && $CMP $stderr $ftemp2; then
test.d:3:1: run time error - non table right to `:'
OUTPUT345
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 346.
if test $result = ok -a $start_test_number -le 346; then
	echo test 346
        cat >$test_file <<'TEST346'
thread f {
  return 10;
}

var t;

t = f ();
TEST346
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT346' && $CMP $stderr $ftemp2; then
test.d:2:3: statement return with result is in thread
OUTPUT346
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 347.
if test $result = ok -a $start_test_number -le 347; then
	echo test 347
        cat >$test_file <<'TEST347'
thread f {
  {
    return 10;
  }
}

var t;

t = f ();
TEST347
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT347' && $CMP $stderr $ftemp2; then
test.d:3:5: statement return with result is in thread
OUTPUT347
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 348.
if test $result = ok -a $start_test_number -le 348; then
	echo test 348
        cat >$test_file <<'TEST348'
wait (0);
TEST348
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT348' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - process deadlock
OUTPUT348
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 349.
if test $result = ok -a $start_test_number -le 349; then
	echo test 349
        cat >$test_file <<'TEST349'
thread t { wait (0);}
var p;
p = t ();
wait (0);
TEST349
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT349' && $CMP $stderr $ftemp2; then
test.d:4:7: run time error - process deadlock
OUTPUT349
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 350.
if test $result = ok -a $start_test_number -le 350; then
	echo test 350
        cat >$test_file <<'TEST350'
thread t { wait (0);}
var p;
p = t ();
TEST350
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT350' && $CMP $stderr $ftemp2; then
test.d:1:18: run time error - process deadlock
OUTPUT350
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 351.
if test $result = ok -a $start_test_number -le 351; then
	echo test 351
        cat >$test_file <<'TEST351'
fun f() {return 1;}
wait (f());
TEST351
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT351' && $CMP $stderr $ftemp2; then
test.d:2:7: function call is present in wait statement
OUTPUT351
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 352.
if test $result = ok -a $start_test_number -le 352; then
	echo test 352
        cat >$test_file <<'TEST352'
class c(){}
if (tab []) {}
var i;
for (i=0;c;i++) {}
wait (c);
for (i: 10) {}
try {
  throw 1;
}
catch 10 {
}
TEST352
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT352' && $CMP $stderr $ftemp2; then
test.d:2:5: invalid type of operand in logical operation
test.d:4:10: invalid type of operand in logical operation
test.d:5:7: invalid type of wait-expr
test.d:6:9: invalid type of foreach-table
test.d:8:3: invalid type of throw-expr
test.d:10:7: syntax error
OUTPUT352
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 353.
if test $result = ok -a $start_test_number -le 353; then
	echo test 353
        cat >$test_file <<'TEST353'
i := 10;
TEST353
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT353' && $CMP $stderr $ftemp2; then
test.d:1:3: syntax error
OUTPUT353
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 354.
if test $result = ok -a $start_test_number -le 354; then
	echo test 354
        cat >$test_file <<'TEST354'
var i;
for (i:=0; i<1000000; i:=i+1;)
 ;
TEST354
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT354' && $CMP $stderr $ftemp2; then
test.d:2:8: syntax error
test.d:2:23: syntax error
OUTPUT354
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 355.
if test $result = ok -a $start_test_number -le 355; then
	echo test 355
        cat >$test_file <<'TEST355'
var ctime;
ctime = 0.0;

fun waitfor (n, t){
  var cont;
  wait (1) cont = 1;
  putln (n, " waitfor ", t, " ctime ", ctime);
  for (; cont;)
    try {
      wait (ctime == t) cont = 0;
    } catch (deadlock) {
      wait (1) ctime++;
      putln ("tick ", ctime); 
    }
}

thread output {
  waitfor ("output", 2.0);
  putln ("output 1");
  waitfor ("output", 4.0);
  putln ("output 2");
}

thread move {
   waitfor ("move", 1.0);
   putln ("move 1");
   waitfor ("move", 3.0);
   putln ("move 2");
}

move ();
output ();
TEST355
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT355' && $CMP $stdout $ftemp2; then
move waitfor 1 ctime 0
output waitfor 2 ctime 0
tick 1
move 1
move waitfor 3 ctime 1
tick 2
output 1
output waitfor 4 ctime 2
tick 3
move 2
tick 4
output 2
OUTPUT355
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 356.
if test $result = ok -a $start_test_number -le 356; then
	echo test 356
        cat >$test_file <<'TEST356'
var ctime;
ctime = 0.0;
var X,Y,Z;
X = [1.0,0.0,0.0];
Y = [0.0,1.0,0.0];
Z = [0.0,0.0,1.0];
fun fulfill (){ putln ("FULFILL");}
fun publish (){ putln ("PUBLISH");}
fun rotate (what, axis, angle){
  putln ("ROTATE ", what, " ",
         axis [0], " ", axis [1], " ", axis [2], " ", angle);
}

fun waitfor (n, t){
  var cont;
  wait (1) cont = 1;
  putln ("waitfor ", n, " ", t, " ctime ", ctime);
  for (; cont;)
    try {
      wait (ctime == t) cont = 0;
    } catch (deadlock) {
      wait (1) ctime++;
      putln ("tick ", ctime); 
    }
}

class back_leg(side){
  var angle;
  angle = 1.0;

  fun step {
    var start;
    putln ("step ", ctime);
    start = ctime;
    rotate (side @ "_back_hoof", Z, -angle);
    waitfor (side, start+1);
    rotate (side @ "_back_hoof", Z, -angle);
    waitfor (side, start+2);
    rotate (side @ "_back_hoof", Z, angle);
    waitfor (side, start+3);
    rotate (side @ "_back_hoof", Z, angle);
  }

  thread move (start_ctime, steps_number) {
    waitfor (side, start_ctime);
    var i;
    for (i=0; i<steps_number; i = i+1)
	step ();
  }
}     

thread output(interval) {
  var i, cont;
  for (i=0; i<interval; i=i+1) {
    waitfor ("output", i + 0.0);
    fulfill ();
    publish ();
  }
}

var left_back_leg, right_back_leg;

left_back_leg = back_leg("left");
right_back_leg = back_leg("right");

left_back_leg.move (ctime, 10.0);
right_back_leg.move (ctime+1.0, 10.0);
output (32);
TEST356
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT356' && $CMP $stdout $ftemp2; then
waitfor left 0 ctime 0
step 0
ROTATE left_back_hoof 0 0 1 -1
waitfor left 1 ctime 0
waitfor right 1 ctime 0
waitfor output 0 ctime 0
FULFILL
PUBLISH
waitfor output 1 ctime 0
tick 1
ROTATE left_back_hoof 0 0 1 -1
waitfor left 2 ctime 1
step 1
ROTATE right_back_hoof 0 0 1 -1
waitfor right 2 ctime 1
FULFILL
PUBLISH
waitfor output 2 ctime 1
tick 2
ROTATE left_back_hoof 0 0 1 1
waitfor left 3 ctime 2
ROTATE right_back_hoof 0 0 1 -1
waitfor right 3 ctime 2
FULFILL
PUBLISH
waitfor output 3 ctime 2
tick 3
ROTATE left_back_hoof 0 0 1 1
ROTATE right_back_hoof 0 0 1 1
waitfor right 4 ctime 3
FULFILL
PUBLISH
waitfor output 4 ctime 3
tick 4
ROTATE right_back_hoof 0 0 1 1
FULFILL
PUBLISH
waitfor output 5 ctime 4
tick 5
FULFILL
PUBLISH
waitfor output 6 ctime 5
tick 6
FULFILL
PUBLISH
waitfor output 7 ctime 6
tick 7
FULFILL
PUBLISH
waitfor output 8 ctime 7
tick 8
FULFILL
PUBLISH
waitfor output 9 ctime 8
tick 9
FULFILL
PUBLISH
waitfor output 10 ctime 9
tick 10
FULFILL
PUBLISH
waitfor output 11 ctime 10
tick 11
FULFILL
PUBLISH
waitfor output 12 ctime 11
tick 12
FULFILL
PUBLISH
waitfor output 13 ctime 12
tick 13
FULFILL
PUBLISH
waitfor output 14 ctime 13
tick 14
FULFILL
PUBLISH
waitfor output 15 ctime 14
tick 15
FULFILL
PUBLISH
waitfor output 16 ctime 15
tick 16
FULFILL
PUBLISH
waitfor output 17 ctime 16
tick 17
FULFILL
PUBLISH
waitfor output 18 ctime 17
tick 18
FULFILL
PUBLISH
waitfor output 19 ctime 18
tick 19
FULFILL
PUBLISH
waitfor output 20 ctime 19
tick 20
FULFILL
PUBLISH
waitfor output 21 ctime 20
tick 21
FULFILL
PUBLISH
waitfor output 22 ctime 21
tick 22
FULFILL
PUBLISH
waitfor output 23 ctime 22
tick 23
FULFILL
PUBLISH
waitfor output 24 ctime 23
tick 24
FULFILL
PUBLISH
waitfor output 25 ctime 24
tick 25
FULFILL
PUBLISH
waitfor output 26 ctime 25
tick 26
FULFILL
PUBLISH
waitfor output 27 ctime 26
tick 27
FULFILL
PUBLISH
waitfor output 28 ctime 27
tick 28
FULFILL
PUBLISH
waitfor output 29 ctime 28
tick 29
FULFILL
PUBLISH
waitfor output 30 ctime 29
tick 30
FULFILL
PUBLISH
waitfor output 31 ctime 30
tick 31
FULFILL
PUBLISH
OUTPUT356
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 357.
if test $result = ok -a $start_test_number -le 357; then
	echo test 357
        cat >$test_file <<'TEST357'
var k;
//putln ("#env=", #env);
for (k: env)
  putln (k, "=", env [k]);
TEST357
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sort $stdout | awk '/^(HOSTNAME|USER|MACHTYPE|TERMCAP|LANG|DISPLAY|LOGNAME|COLUMNS|TERM|OSTYPE)/ && length != 0' >$ftemp
		sh -c 'env' | sort | awk '/^(HOSTNAME|USER|MACHTYPE|TERMCAP|LANG|DISPLAY|LOGNAME|COLUMNS|TERM|OSTYPE)/ && length != 0' >$ftemp2
                echo '      ' $CMP $ftemp $ftemp2
                if $CMP $ftemp $ftemp2; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 358.
if test $result = ok -a $start_test_number -le 358; then
	echo test 358
        cat >$test_file <<'TEST358'
putln (log (-1.0));
TEST358
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT358' && $CMP $stderr $ftemp2; then
test.d:1:12: system error - domain error: `log'
OUTPUT358
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 359.
if test $result = ok -a $start_test_number -le 359; then
	echo test 359
        cat >$test_file <<'TEST359'
putln (pow (-10, 1000));
TEST359
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT359' && $CMP $stderr $ftemp2; then
test.d:1:12: system error - result too big (small): `pow'
OUTPUT359
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 360.
if test $result = ok -a $start_test_number -le 360; then
	echo test 360
        cat >$test_file <<'TEST360'
putln (sqrt (-10.0));
TEST360
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT360' && $CMP $stderr $ftemp2; then
test.d:1:13: system error - domain error: `sqrt'
OUTPUT360
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 361.
if test $result = ok -a $start_test_number -le 361; then
	echo test 361
        cat >$test_file <<'TEST361'
putln (rand ());
putln (rand ());
srand ();
putln (rand ());
putln (rand ());
srand ();
putln (rand ());
putln (rand ());
srand (10);
putln (rand ());
putln (rand ());
srand (10.0);
putln (rand ());
putln (rand ());
srand ("10.0");
putln (rand ());
putln (rand ());
TEST361
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		awk '!/^0\.[0-9]+$/' $stdout >$ftemp
                echo '      ' $CMP $ftemp $ftemp2
                if cat >$ftemp2 <<'OUTPUT361' && $CMP $ftemp $ftemp2; then
OUTPUT361
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 362.
if test $result = ok -a $start_test_number -le 362; then
	echo test 362
        cat >$test_file <<'TEST362'
println (tab ([]));
println (tab ([5:10]));
println (tab (101));
println (tab ('c'));
println (tab (10.1));
println (tab ([5:10, "c"]));
println (tab (tab []));
println (tab (tab ["a":10.0, 10:5]));
println (vec (tab []));
println (vec (tab ["e":5, "g": 6]));
println (vec (101));
println (vec ('c'));
println (vec (10.1));
println (vec ([]));
println (vec ("abcd"));
println (vec ([3:3]));
TEST362
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT362' && $CMP $stdout $ftemp2; then
tab []
tab [0:10, 1:10, 2:10, 3:10, 4:10]
tab [0:'1', 1:'0', 2:'1']
tab [0:'c']
tab [0:'1', 1:'0', 2:'.', 3:'1']
tab [0:10, 1:10, 2:10, 3:10, 4:10, 5:"c"]
tab []
tab [10:5, "a":10]
[]
["e", 5, "g", 6]
"101"
"c"
"10.1"
[]
"abcd"
[3, 3, 3]
OUTPUT362
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 363.
if test $result = ok -a $start_test_number -le 363; then
	echo test 363
        cat >$test_file <<'TEST363'
fun f {}
var v = tab (f);
TEST363
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT363' && $CMP $stderr $ftemp2; then
test.d:2:14: invalid operand type tab (...)
OUTPUT363
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 364.
if test $result = ok -a $start_test_number -le 364; then
	echo test 364
        cat >$test_file <<'TEST364'
var v = tab (nil);
TEST364
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT364' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid type of operand of tab (...)
OUTPUT364
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 365.
if test $result = ok -a $start_test_number -le 365; then
	echo test 365
        cat >$test_file <<'TEST365'
fun f {}
var v = vec (f);
TEST365
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT365' && $CMP $stderr $ftemp2; then
test.d:2:14: invalid operand type vec (...)
OUTPUT365
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 366.
if test $result = ok -a $start_test_number -le 366; then
	echo test 366
        cat >$test_file <<'TEST366'
var v = vec (nil);
TEST366
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT366' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid type of operand of vec (...)
OUTPUT366
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 367.
if test $result = ok -a $start_test_number -le 367; then
	echo test 367
        cat >$test_file <<'TEST367'
println (keys (tab []));
println (keys (tab [8:5, 7:7]));
println (keys (tab ["a":5, "ha":7]));
TEST367
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT367' && $CMP $stdout $ftemp2; then
[]
[7, 8]
["a", "ha"]
OUTPUT367
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 368.
if test $result = ok -a $start_test_number -le 368; then
	echo test 368
        cat >$test_file <<'TEST368'
var v = keys ([]);
TEST368
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT368' && $CMP $stderr $ftemp2; then
test.d:1:14: run time error - invalid parameter type of `keys'
OUTPUT368
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 369.
if test $result = ok -a $start_test_number -le 369; then
	echo test 369
        cat >$test_file <<'TEST369'
var v = keys ();
TEST369
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT369' && $CMP $stderr $ftemp2; then
test.d:1:14: run time error - invalid number of actual parameters for `keys'
OUTPUT369
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 370.
if test $result = ok -a $start_test_number -le 370; then
	echo test 370
        cat >$test_file <<'TEST370'
println (cmpv ("var", "if"));
println (cmpv ([10, 12], [10, 11, nil]));
println (cmpv ([10.0, 12.0], [10.0]));
println (cmpv ([10.0, 12], [10.0, 11, 13.0]));
println (cmpv ([10.0, 12.0], [10.0, 12.0]));
println (cmpv (10, 'c'));
println (cmpv ([], []));
println (cmpv ([], [10]));
TEST370
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT370' && $CMP $stdout $ftemp2; then
1
1
1
1
0
-1
0
-1
OUTPUT370
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 371.
if test $result = ok -a $start_test_number -le 371; then
	echo test 371
        cat >$test_file <<'TEST371'
cmpv ();
TEST371
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT371' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `cmpv'
OUTPUT371
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 372.
if test $result = ok -a $start_test_number -le 372; then
	echo test 372
        cat >$test_file <<'TEST372'
cmpv ([], nil);
TEST372
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT372' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `cmpv'
OUTPUT372
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 373.
if test $result = ok -a $start_test_number -le 373; then
	echo test 373
        cat >$test_file <<'TEST373'
cmpv ([10, 11], [10, 'c']);
TEST373
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT373' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `cmpv'
OUTPUT373
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 374.
if test $result = ok -a $start_test_number -le 374; then
	echo test 374
        cat >$test_file <<'TEST374'
var i, key, voc = tab [];
for (;;)
  try {
    var ln, a;

    ln = getln ();
    if (ln == "")
      continue;
    a = split (ln, "[^[:alnum:]]");
    for (i = 0; i < #a; i++)
      voc [a[i]] = (a[i] in voc ? voc [a[i]] + 1 : 1);
  } catch (eof) {
    break;
  }
key = sort (keys (voc), cmpv);
for (i = 0; i < #key; i++)
  putln (key[i], " : ", voc[key[i]]);
TEST374
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout <<'INPUT374' ; then

var i, prime, k, count, iter, flags;
val SieveSize = 8190;

flags = [SieveSize + 1 : 0];
for (iter = 0; iter < 10; iter++;)
  {
    count = 0;
    for (i = 0; i <= SieveSize; i++)
      flags[i] = 1;
    for (i = 0; i <= SieveSize; i++;)
      if (flags[i])
        {
          prime = i + i + 3;
          k = i + prime;
          for (;1;;)
            {
	      if (k > SieveSize)
                break;
              flags[k] = 0;
              k += prime;
            }
          count++;
        }
  }
putln (count);
INPUT374
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT374' && $CMP $stdout $ftemp2; then
0 : 6
1 : 3
10 : 1
3 : 1
8190 : 1
SieveSize : 5
break : 1
count : 4
flags : 5
for : 4
i : 12
if : 2
iter : 4
k : 5
prime : 4
putln : 1
val : 1
var : 1
OUTPUT374
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 375.
if test $result = ok -a $start_test_number -le 375; then
	echo test 375
        cat >$test_file <<'TEST375'
putln (tolower ("abcd"));
putln (tolower ("ABCD"));
putln (tolower (10));
putln (tolower (10e10));
putln (tolower ('c'));
putln (tolower ('C'));
//
putln (toupper ("abcd"));
putln (toupper ("ABCD"));
putln (toupper (10));
putln (toupper (10e10));
putln (toupper ('c'));
putln (toupper ('C'));
TEST375
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout ; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT375' && $CMP $stdout $ftemp2; then
abcd
abcd
10
1e+11
c
c
ABCD
ABCD
10
1E+11
C
C
OUTPUT375
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT375-1' && $CMP $stdout $ftemp2; then
abcd
abcd
10
1e+011
c
c
ABCD
ABCD
10
1E+011
C
C
OUTPUT375-1
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 376.
if test $result = ok -a $start_test_number -le 376; then
	echo test 376
        cat >$test_file <<'TEST376'
tolower ();
TEST376
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT376' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of actual parameters for `tolower'
OUTPUT376
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 377.
if test $result = ok -a $start_test_number -le 377; then
	echo test 377
        cat >$test_file <<'TEST377'
tolower (nil);
TEST377
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT377' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `tolower'
OUTPUT377
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 378.
if test $result = ok -a $start_test_number -le 378; then
	echo test 378
        cat >$test_file <<'TEST378'
tolower ();
TEST378
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT378' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of actual parameters for `tolower'
OUTPUT378
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 379.
if test $result = ok -a $start_test_number -le 379; then
	echo test 379
        cat >$test_file <<'TEST379'
tolower (nil);
TEST379
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT379' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `tolower'
OUTPUT379
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 380.
if test $result = ok -a $start_test_number -le 380; then
	echo test 380
        cat >$test_file <<'TEST380'
a
TEST380
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT380' && $CMP $stderr $ftemp2; then
test.d:2:1: syntax error
OUTPUT380
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 381.
if test $result = ok -a $start_test_number -le 381; then
	echo test 381
        cat >$test_file <<'TEST381'
// vector
var v;
// pack
v = [1, 2, 3, 4, 5, 6]; v = subv (v, 2); println (v);
v = [1, 2, 3, 4, 5, 6]; v = subv (v, -2, 2); println (v);
v = [1, 2, 3, 4, 5, 6]; v = subv (v, 2, 2); println (v);
v = [1, 2, 3, 4, 5, 6]; v = subv (v, 2, -1); println (v);
v = [1, 2, 3, 4, 5, 6]; v = subv (v, 2, 0); println (v);
// unpack
v = [1, 2.0, 3.0, 4, 5, 6]; v = subv (v, 2); println (v);
v = [1.0, 2, 3, 4, 5, 6]; v = subv (v, -2, 2); println (v);
v = [1.0, 2, 3, 4, 5, 6]; v = subv (v, 2, 2); println (v);
v = [1.0, 2, 3, 4, 5, 6]; v = subv (v, 2, -1); println (v);
v = [1.0, 2, 3, 4, 5, 6]; v = subv (v, 2, 0); println (v);
// empty
v = []; v = subv (v, 0); println (v);
v = []; v = subv (v, -2, 1); println (v);
v = []; v = subv (v, 0, 1); println (v);
v = []; v = subv (v, 1, 0); println (v);
v = []; v = subv (v, 0, -1); println (v);
// string
v = new "123456"; v = subv (v, 2, 2); putln (v);
v = new "123456"; v = subv (v, -2, 2); putln (v);
v = new "123456"; v = subv (v, 2, 0); println (v);
var i, iter, t;
for (iter = 0; iter < 1000; iter++)
  { 
    v = [1000:1];
    for (i = 0; i < 1000; i++)
      t = subv (v, 2, 2);
  }
println (t);
TEST381
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT381' && $CMP $stdout $ftemp2; then
[3, 4, 5, 6]
[1, 2]
[3, 4]
[3, 4, 5, 6]
[]
[3, 4, 5, 6]
[1, 2]
[3, 4]
[3, 4, 5, 6]
[]
[]
[]
[]
[]
[]
34
12
""
[1, 1]
OUTPUT381
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 382.
if test $result = ok -a $start_test_number -le 382; then
	echo test 382
        cat >$test_file <<'TEST382'
subv ();
TEST382
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT382' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `subv'
OUTPUT382
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 383.
if test $result = ok -a $start_test_number -le 383; then
	echo test 383
        cat >$test_file <<'TEST383'
subv (10);
TEST383
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT383' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `subv'
OUTPUT383
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 384.
if test $result = ok -a $start_test_number -le 384; then
	echo test 384
        cat >$test_file <<'TEST384'
subv (nil, 10);
TEST384
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT384' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `subv'
OUTPUT384
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 385.
if test $result = ok -a $start_test_number -le 385; then
	echo test 385
        cat >$test_file <<'TEST385'
subv (10,10,10,10);
TEST385
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT385' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `subv'
OUTPUT385
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 386.
if test $result = ok -a $start_test_number -le 386; then
	echo test 386
        cat >$test_file <<'TEST386'
var t;
t = tab [10]; subv (t, 10, 10);
TEST386
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT386' && $CMP $stderr $ftemp2; then
test.d:2:20: run time error - invalid parameter type of `subv'
OUTPUT386
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 387.
if test $result = ok -a $start_test_number -le 387; then
	echo test 387
        cat >$test_file <<'TEST387'
var v;
v = []; subv (v, tab []);
TEST387
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT387' && $CMP $stderr $ftemp2; then
test.d:2:14: run time error - invalid parameter type of `subv'
OUTPUT387
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 388.
if test $result = ok -a $start_test_number -le 388; then
	echo test 388
        cat >$test_file <<'TEST388'
var v;
v = []; subv (v, 0, tab []);
TEST388
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT388' && $CMP $stderr $ftemp2; then
test.d:2:14: run time error - invalid parameter type of `subv'
OUTPUT388
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 389.
if test $result = ok -a $start_test_number -le 389; then
	echo test 389
        cat >$test_file <<'TEST389'
exit (1);
putln (stderr, "ahaha");
TEST389
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT389' && $CMP $stderr $ftemp2; then
OUTPUT389
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 390.
if test $result = ok -a $start_test_number -le 390; then
	echo test 390
        cat >$test_file <<'TEST390'
exit (0);
putln ("ahaha");
TEST390
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT390' && $CMP $stdout $ftemp2; then
OUTPUT390
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 391.
if test $result = ok -a $start_test_number -le 391; then
	echo test 391
        cat >$test_file <<'TEST391'
exit ();
TEST391
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT391' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `exit'
OUTPUT391
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 392.
if test $result = ok -a $start_test_number -le 392; then
	echo test 392
        cat >$test_file <<'TEST392'
exit (1, 1);
TEST392
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT392' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of actual parameters for `exit'
OUTPUT392
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 393.
if test $result = ok -a $start_test_number -le 393; then
	echo test 393
        cat >$test_file <<'TEST393'
exit (nil);
TEST393
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT393' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `exit'
OUTPUT393
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 394.
if test $result = ok -a $start_test_number -le 394; then
	echo test 394
        cat >$test_file <<'TEST394'
putln (max (1.5, 2));
putln (min (1.5, 2));
putln (max (1.5, 2, "3.0"));
putln (min (1.5, 2, "3.0"));
putln (min (1.5, 2, 'a'));
putln (max (1.5, 2, 'a'));
putln (min (1.5, 2, 'a'));
TEST394
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT394' && $CMP $stdout $ftemp2; then
2
1.5
3
1.5
1.5
97
1.5
OUTPUT394
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 395.
if test $result = ok -a $start_test_number -le 395; then
	echo test 395
        cat >$test_file <<'TEST395'
max (1);
TEST395
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT395' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `max'
OUTPUT395
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 396.
if test $result = ok -a $start_test_number -le 396; then
	echo test 396
        cat >$test_file <<'TEST396'
min (1);
TEST396
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT396' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `min'
OUTPUT396
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 397.
if test $result = ok -a $start_test_number -le 397; then
	echo test 397
        cat >$test_file <<'TEST397'
max ();
TEST397
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT397' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `max'
OUTPUT397
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 398.
if test $result = ok -a $start_test_number -le 398; then
	echo test 398
        cat >$test_file <<'TEST398'
min ();
TEST398
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT398' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `min'
OUTPUT398
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 399.
if test $result = ok -a $start_test_number -le 399; then
	echo test 399
        cat >$test_file <<'TEST399'
max (nil, nil);
TEST399
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT399' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `max'
OUTPUT399
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 400.
if test $result = ok -a $start_test_number -le 400; then
	echo test 400
        cat >$test_file <<'TEST400'
min (nil, nil);
TEST400
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT400' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid parameter type of `min'
OUTPUT400
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 401.
if test $result = ok -a $start_test_number -le 401; then
	echo test 401
        cat >$test_file <<'TEST401'
class c (par) {
  class sc (i) {
  }
}

var i=c(10).sc(20);
putln (i.par, " ", i.i);
i.par = 15;
putln (i.par, " ", i.i);
TEST401
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT401' && $CMP $stdout $ftemp2; then
10 20
15 20
OUTPUT401
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 402.
if test $result = ok -a $start_test_number -le 402; then
	echo test 402
        cat >$test_file <<'TEST402'
fun f (par) {
  class sc (i) {
  }
  return sc;
}

var i=f(10)(20);
putln (i.par);
TEST402
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT402' && $CMP $stderr $ftemp2; then
test.d:8:9: run time error - there is no such declaration in given class
OUTPUT402
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 403.
if test $result = ok -a $start_test_number -le 403; then
	echo test 403
        cat >$test_file <<'TEST403'
var c;
{
  class sc (i) {
  }
  c = sc;
}

var i=c(20);
putln (i.par);
TEST403
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT403' && $CMP $stderr $ftemp2; then
test.d:9:8: there is no such declaration in a block
OUTPUT403
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 404.
if test $result = ok -a $start_test_number -le 404; then
	echo test 404
        cat >$test_file <<'TEST404'
var i = 0;
include "../DINO/../DINO/test1";
i = 1;
include +"../DINO/..//////DINO/test1";
i = 2;
{
  include "../DINO/../DINO/test1";
  i = 3;
  include "../DINO/..//////DINO/test1";
  i = 4;
  include +"../DINO/../DINO/test1";
}
i = 5;
include "../DINO/../DINO/test1";
i = 6;
include +"../DINO/..//////DINO/test1";
TEST404
        cat >$test_file_1 <<'TEST404-1'
putln (i);
TEST404-1
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT404' && $CMP $stdout $ftemp2; then
0
1
2
4
6
OUTPUT404
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 406.
if test $result = ok -a $start_test_number -le 406; then
	echo test 406
        cat >$test_file <<'TEST406'
inside (nil);
TEST406
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT406' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `inside'
OUTPUT406
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 407.
if test $result = ok -a $start_test_number -le 407; then
	echo test 407
        cat >$test_file <<'TEST407'
inside (nil, nil, nil, nil);
TEST407
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT407' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of actual parameters for `inside'
OUTPUT407
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 408.
if test $result = ok -a $start_test_number -le 408; then
	echo test 408
        cat >$test_file <<'TEST408'
class c {}
inside (c, c, nil);
TEST408
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT408' && $CMP $stderr $ftemp2; then
test.d:2:8: run time error - invalid parameter type of `inside'
OUTPUT408
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 409.
if test $result = ok -a $start_test_number -le 409; then
	echo test 409
        cat >$test_file <<'TEST409'
class c {}
inside (c, c());
TEST409
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT409' && $CMP $stderr $ftemp2; then
test.d:2:8: run time error - invalid parameter type of `inside'
OUTPUT409
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 410.
if test $result = ok -a $start_test_number -le 410; then
	echo test 410: Parsing expression
        cat >$test_file <<'TEST410'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(a+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (p.ambiguous_p);
TEST410
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT410' && $CMP $stdout $ftemp2; then
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      $term(97, 5)
      mult(
        $term(97, 7)
        $term(97, 9)
      )
    )
  )
)
OUTPUT410
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 411.
if test $result = ok -a $start_test_number -le 411; then
	echo test 411: Undefined grammar
        cat >$test_file <<'TEST411'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST411
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT411' && $CMP $stderr $ftemp2; then
test.d:32:20: run time error (parse) -- undefined or bad grammar
OUTPUT411
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 412.
if test $result = ok -a $start_test_number -le 412; then
	echo test 412: Already defined grammar.
        cat >$test_file <<'TEST412'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);
p.set_grammar (g, 1);

var str = "a+a*(a+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST412
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT412' && $CMP $stdout $ftemp2; then
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      $term(97, 5)
      mult(
        $term(97, 7)
        $term(97, 9)
      )
    )
  )
)
OUTPUT412
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 413.
if test $result = ok -a $start_test_number -le 413; then
	echo test 413: Description syntax error.
        cat >$test_file <<'TEST413'
var g = "TERM 1\n\
         E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST413
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT413' && $CMP $stderr $ftemp2; then
test.d:16:15: run time error (set_grammar) -- description syntax error on ln 1
OUTPUT413
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 414.
if test $result = ok -a $start_test_number -le 414; then
	echo test 414: error in the left side of the rule.
        cat >$test_file <<'TEST414'
var g = "TERM;\n\
         error : T         # 0\n\
         E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST414
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT414' && $CMP $stderr $ftemp2; then
test.d:17:15: run time error (set_grammar) -- term `error' in the left hand side of rule
OUTPUT414
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 415.
if test $result = ok -a $start_test_number -le 415; then
	echo test 415: The same code for terminals.
        cat >$test_file <<'TEST415'
var g = "TERM ident=10 i=10;\n\
         E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST415
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT415' && $CMP $stderr $ftemp2; then
test.d:16:15: run time error (set_grammar) -- repeated code 10 in term `i'
OUTPUT415
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 416.
if test $result = ok -a $start_test_number -le 416; then
	echo test 416: No rules.
        cat >$test_file <<'TEST416'
var g = "TERM ident=10;\n";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST416
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT416' && $CMP $stderr $ftemp2; then
test.d:9:15: run time error (set_grammar) -- grammar does not contains rules
OUTPUT416
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 417.
if test $result = ok -a $start_test_number -le 417; then
	echo test 417: Term in the left hand side of rule.
        cat >$test_file <<'TEST417'
var g = "TERM ident=10;\n\
         ident : 'a'\n\
         E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST417
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT417' && $CMP $stderr $ftemp2; then
test.d:17:15: run time error (set_grammar) -- term `ident' in the left hand side of rule
OUTPUT417
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 418.
if test $result = ok -a $start_test_number -le 418; then
	echo test 418: Incorrect translation number.
        cat >$test_file <<'TEST418'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 1\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST418
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT418' && $CMP $stderr $ftemp2; then
test.d:15:15: run time error (set_grammar) -- translation symbol number 1 in rule for `E' is out of range
OUTPUT418
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 419.
if test $result = ok -a $start_test_number -le 419; then
	echo test 419: Repeated translation symbol number.
        cat >$test_file <<'TEST419'
var g = "E : E '+' T # plus (0 0)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST419
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT419' && $CMP $stderr $ftemp2; then
test.d:15:15: run time error (set_grammar) -- repeated translation symbol number 0 in rule for `E'
OUTPUT419
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 420.
if test $result = ok -a $start_test_number -le 420; then
	echo test 420: No derivations.
        cat >$test_file <<'TEST420'
var g = "E : 'a' E\n\
           | E '+'";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST420
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT420' && $CMP $stderr $ftemp2; then
test.d:10:15: run time error (set_grammar) -- nonterm `E' does not derive any term string
OUTPUT420
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 421.
if test $result = ok -a $start_test_number -le 421; then
	echo test 421: Grammar loops.
        cat >$test_file <<'TEST421'
var g = "E : A O O\n\
           | E 'a'\n\
           | 'b'\n\
           |\n\
         A : O O N\n\
         N : O E E O\n\
         O :\n";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST421
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT421' && $CMP $stderr $ftemp2; then
test.d:15:15: run time error (set_grammar) -- nonterm `E' can derive only itself (grammar with loops)
OUTPUT421
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 422.
if test $result = ok -a $start_test_number -le 422; then
	echo test 422: Invalid token code.
        cat >$test_file <<'TEST422'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*b)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST422
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT422' && $CMP $stderr $ftemp2; then
test.d:33:20: run time error (parse) -- invalid token code 98
OUTPUT422
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 423.
if test $result = ok -a $start_test_number -le 423; then
	echo test 423: Unaccessible nonterm.
        cat >$test_file <<'TEST423'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         G : 'a'       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*b)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST423
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT423' && $CMP $stderr $ftemp2; then
test.d:16:15: run time error (set_grammar) -- nonterm `G' is not accessible from axiom
OUTPUT423
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 424.
if test $result = ok -a $start_test_number -le 424; then
	echo test 424: Fixed name error.
        cat >$test_file <<'TEST424'
var g = "TERM error=10;\n\
         E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*b)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST424
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT424' && $CMP $stderr $ftemp2; then
test.d:16:15: run time error (set_grammar) -- do not use fixed name `error'
OUTPUT424
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 425.
if test $result = ok -a $start_test_number -le 425; then
	echo test 425: Error recovery.
        cat >$test_file <<'TEST425'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(a*+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST425
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT425' && $CMP $stdout $ftemp2; then
syntax error on token #7 (43) -- ignore 10 tokens starting with token #0
$nil
OUTPUT425
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 426.
if test $result = ok -a $start_test_number -le 426; then
	echo test 426: More error recovery.
        cat >$test_file <<'TEST426'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(a*+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST426
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT426' && $CMP $stdout $ftemp2; then
syntax error on token #7 (43) -- ignore 4 tokens starting with token #5
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    $error
  )
)
OUTPUT426
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 427.
if test $result = ok -a $start_test_number -le 427; then
	echo test 427: More error recovery.
        cat >$test_file <<'TEST427'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST427
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT427' && $CMP $stdout $ftemp2; then
syntax error on token #5 (42) -- ignore 4 tokens starting with token #5
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    $error
  )
)
OUTPUT427
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 428.
if test $result = ok -a $start_test_number -le 428; then
	echo test 428: Ambiguous grammar.
        cat >$test_file <<'TEST428'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | '(' E ')' # 1\n";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (1);
p.set_grammar (g, 1);

var str = "a+a*(a*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (!p.ambiguous_p);
TEST428
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT428' && $CMP $stdout $ftemp2; then
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      mult(
        $term(97, 5)
        $term(97, 7)
      )
      $term(97, 9)
    )
  )
)
OUTPUT428
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 429.
if test $result = ok -a $start_test_number -le 429; then
	echo test 429: More ambiguous grammar.
        cat >$test_file <<'TEST429'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | '(' E ')' # 1\n";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(a*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST429
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT429' && $CMP $stdout $ftemp2; then
$alt(
  mult(
    plus(
      $term(97, 0)
      $term(97, 2)
    )
    $alt(
      mult(
        $term(97, 5)
        plus(
          $term(97, 7)
          $term(97, 9)
        )
      )
      plus(
        mult(
          $term(97, 5)
          $term(97, 7)
        )
        $term(97, 9)
      )
    )
  )
  plus(
    $term(97, 0)
    mult(
      $term(97, 2)
      $alt(
        mult(
          $term(97, 5)
          plus(
            $term(97, 7)
            $term(97, 9)
          )
        )
        plus(
          mult(
            $term(97, 5)
            $term(97, 7)
          )
          $term(97, 9)
        )
      )
    )
  )
)
OUTPUT429
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 430.
if test $result = ok -a $start_test_number -le 430; then
	echo test 430: Ambiguous grammar with error recovery
        cat >$test_file <<'TEST430'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | '(' E ')' # 1\n";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (1);
p.set_grammar (g, 1);

var str = "a+a*(*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST430
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT430' && $CMP $stdout $ftemp2; then
syntax error on token #5 (42) -- ignore 10 tokens starting with token #0
$nil
OUTPUT430
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 431.
if test $result = ok -a $start_test_number -le 431; then
	echo test 431: More ambiguous grammar with error recovery
        cat >$test_file <<'TEST431'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1\n";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (1);
p.set_grammar (g, 1);

var str = "a+a*(*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST431
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT431' && $CMP $stdout $ftemp2; then
syntax error on token #5 (42) -- ignore 4 tokens starting with token #5
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    $error
  )
)
OUTPUT431
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 432.
if test $result = ok -a $start_test_number -le 432; then
	echo test 432: More ambiguous grammar with error recovery
        cat >$test_file <<'TEST432'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1\n";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST432
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT432' && $CMP $stdout $ftemp2; then
syntax error on token #5 (42) -- ignore 4 tokens starting with token #5
$alt(
  mult(
    plus(
      $term(97, 0)
      $term(97, 2)
    )
    $error
  )
  plus(
    $term(97, 0)
    mult(
      $term(97, 2)
      $error
    )
  )
)
OUTPUT432
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 433.
if test $result = ok -a $start_test_number -le 433; then
	echo test 433: Error recovery with 2 
        cat >$test_file <<'TEST433'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(a*)+(*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST433
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT433' && $CMP $stdout $ftemp2; then
syntax error on token #7 (41) -- ignore 2 tokens starting with token #5
syntax error on token #10 (42) -- ignore 2 tokens starting with token #10
plus(
  plus(
    $term(97, 0)
    mult(
      $term(97, 2)
      $error
    )
  )
  $error
)
OUTPUT433
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 434.
if test $result = ok -a $start_test_number -le 434; then
	echo test 434: More error recovery with 2 
        cat >$test_file <<'TEST434'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_recovery_match (4);
p.set_grammar (g, 1);

var str = "a+a*(a*)+(*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (p.ambiguous_p);
TEST434
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT434' && $CMP $stdout $ftemp2; then
syntax error on token #7 (41) -- ignore 4 tokens starting with token #5
plus(
  plus(
    $term(97, 0)
    mult(
      $term(97, 2)
      $error
    )
  )
  $error
)
OUTPUT434
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 435.
if test $result = ok -a $start_test_number -le 435; then
	echo test 435: More ambiguous grammar.
        cat >$test_file <<'TEST435'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | 'b' # 0\n\
           | 'c' # 0\n\
           | 'd' # 0\n\
           | '(' E ')' # 1\n";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+b*c+d";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST435
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT435' && $CMP $stdout $ftemp2; then
$alt(
  plus(
    $alt(
      mult(
        plus(
          $term(97, 0)
          $term(98, 2)
        )
        $term(99, 4)
      )
      plus(
        $term(97, 0)
        mult(
          $term(98, 2)
          $term(99, 4)
        )
      )
    )
    $term(100, 6)
  )
  mult(
    plus(
      $term(97, 0)
      $term(98, 2)
    )
    plus(
      $term(99, 4)
      $term(100, 6)
    )
  )
  plus(
    $term(97, 0)
    $alt(
      mult(
        $term(98, 2)
        plus(
          $term(99, 4)
          $term(100, 6)
        )
      )
      plus(
        mult(
          $term(98, 2)
          $term(99, 4)
        )
        $term(100, 6)
      )
    )
  )
)
OUTPUT435
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 436.
if test $result = ok -a $start_test_number -le 436; then
	echo test 436: More ambiguous grammar and GC.
        cat >$test_file <<'TEST436'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | 'b' # 0\n\
           | 'c' # 0\n\
           | 'd' # 0\n\
           | '(' E ')' # 1\n";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+b*c+a";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);

var v, iter;

for (iter = 0; iter < 1000; iter++) { 
  v = [];
  for (i = 0; i < 100; i++)
    insv (v, [1]);
  for (i = 0; i < 100; i++)
    del (v, 0);
}

println (v);

pr (root, 0);

exit (!p.ambiguous_p);
TEST436
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT436' && $CMP $stdout $ftemp2; then
$alt(
  plus(
    $term(97, 0)
    $alt(
      mult(
        $term(98, 2)
        plus(
          $term(99, 4)
          $term(97, 6)
        )
      )
      plus(
        mult(
          $term(98, 2)
          $term(99, 4)
        )
        $term(97, 6)
      )
    )
  )
  mult(
    plus(
      $term(97, 0)
      $term(98, 2)
    )
    plus(
      $term(99, 4)
      $term(97, 6)
    )
  )
  plus(
    $alt(
      mult(
        plus(
          $term(97, 0)
          $term(98, 2)
        )
        $term(99, 4)
      )
      plus(
        $term(97, 0)
        mult(
          $term(98, 2)
          $term(99, 4)
        )
      )
    )
    $term(97, 6)
  )
)
[]
$alt(
  plus(
    $term(97, 0)
    $alt(
      mult(
        $term(98, 2)
        plus(
          $term(99, 4)
          $term(97, 6)
        )
      )
      plus(
        mult(
          $term(98, 2)
          $term(99, 4)
        )
        $term(97, 6)
      )
    )
  )
  mult(
    plus(
      $term(97, 0)
      $term(98, 2)
    )
    plus(
      $term(99, 4)
      $term(97, 6)
    )
  )
  plus(
    $alt(
      mult(
        plus(
          $term(97, 0)
          $term(98, 2)
        )
        $term(99, 4)
      )
      plus(
        $term(97, 0)
        mult(
          $term(98, 2)
          $term(99, 4)
        )
      )
    )
    $term(97, 6)
  )
)
OUTPUT436
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 437.
if test $result = ok -a $start_test_number -le 437; then
	echo test 437: Debugging information.
        cat >$test_file <<'TEST437'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (1);
p.set_one_parse (0);
p.set_recovery_match (4);
p.set_grammar (g, 1);

var str = "a+a*(a*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (p.ambiguous_p);
TEST437
        echo '      ' "$DINO $test_file >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT437' && $CMP $stdout $ftemp2; then
Grammar: #terms = 7, #nonterms = 4, #rules = 8, rules size = 24
Input: #tokens = 12, #unique situations = 22
       #terminal sets = 30, their size = 240
       #unique set cores = 10, #their start situations = 25
       #parent indexes for some non start situations = 0
       #unique set dist. vects = 13, their length = 30
       #pairs(set core, symb) = 38, their trans+reduce vects length = 43
       #unique transition vectors = 12, their length = 16
       #unique reduce vectors = 4, their length = 4
       #term nodes = 5, #abstract nodes = 4
       #alternative nodes = 0, #all nodes = 9
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      mult(
        $term(97, 5)
        $term(97, 7)
      )
      $term(97, 9)
    )
  )
)
OUTPUT437
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT437' && $CMP $stdout $ftemp2; then
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      mult(
        $term(97, 5)
        $term(97, 7)
      )
      $term(97, 9)
    )
  )
)
Grammar: #terms = 7, #nonterms = 4, #rules = 8, rules size = 24
Input: #tokens = 12, #unique situations = 22
       #terminal sets = 30, their size = 240
       #unique set cores = 10, #their start situations = 25
       #parent indexes for some non start situations = 0
       #unique set dist. vects = 13, their length = 30
       #pairs(set core, symb) = 38, their trans+reduce vects length = 43
       #unique transition vectors = 12, their length = 16
       #unique reduce vectors = 4, their length = 4
       #term nodes = 5, #abstract nodes = 4
       #alternative nodes = 0, #all nodes = 9
OUTPUT437
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 438.
if test $result = ok -a $start_test_number -le 438; then
	echo test 438: Debugging information.
        cat >$test_file <<'TEST438'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (2);
p.set_one_parse (0);
p.set_recovery_match (4);
p.set_grammar (g, 1);

var str = "a+a*(a*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (p.ambiguous_p);
TEST438
        echo '      ' "$DINO $test_file >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT438' && $CMP $stdout $ftemp2; then
Translation:
      0: ABSTRACT: plus ( 1 2 )
      1: TERMINAL: code=97, repr='a'
      2: ABSTRACT: mult ( 3 4 )
      3: TERMINAL: code=97, repr='a'
      4: ABSTRACT: plus ( 5 6 )
      5: ABSTRACT: mult ( 7 8 )
      7: TERMINAL: code=97, repr='a'
      8: TERMINAL: code=97, repr='a'
      6: TERMINAL: code=97, repr='a'

Grammar: #terms = 7, #nonterms = 4, #rules = 8, rules size = 24
Input: #tokens = 12, #unique situations = 22
       #terminal sets = 30, their size = 240
       #unique set cores = 10, #their start situations = 25
       #parent indexes for some non start situations = 0
       #unique set dist. vects = 13, their length = 30
       #pairs(set core, symb) = 38, their trans+reduce vects length = 43
       #unique transition vectors = 12, their length = 16
       #unique reduce vectors = 4, their length = 4
       #term nodes = 5, #abstract nodes = 4
       #alternative nodes = 0, #all nodes = 9
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      mult(
        $term(97, 5)
        $term(97, 7)
      )
      $term(97, 9)
    )
  )
)
OUTPUT438
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT438' && $CMP $stdout $ftemp2; then
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      mult(
        $term(97, 5)
        $term(97, 7)
      )
      $term(97, 9)
    )
  )
)
Translation:
      0: ABSTRACT: plus ( 1 2 )
      1: TERMINAL: code=97, repr='a'
      2: ABSTRACT: mult ( 3 4 )
      3: TERMINAL: code=97, repr='a'
      4: ABSTRACT: plus ( 5 6 )
      5: ABSTRACT: mult ( 7 8 )
      7: TERMINAL: code=97, repr='a'
      8: TERMINAL: code=97, repr='a'
      6: TERMINAL: code=97, repr='a'

Grammar: #terms = 7, #nonterms = 4, #rules = 8, rules size = 24
Input: #tokens = 12, #unique situations = 22
       #terminal sets = 30, their size = 240
       #unique set cores = 10, #their start situations = 25
       #parent indexes for some non start situations = 0
       #unique set dist. vects = 13, their length = 30
       #pairs(set core, symb) = 38, their trans+reduce vects length = 43
       #unique transition vectors = 12, their length = 16
       #unique reduce vectors = 4, their length = 4
       #term nodes = 5, #abstract nodes = 4
       #alternative nodes = 0, #all nodes = 9
OUTPUT438
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 439.
if test $result = ok -a $start_test_number -le 439; then
	echo test 439: Parameter exception.
        cat >$test_file <<'TEST439'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (nil);
p.set_one_parse ("0");

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST439
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT439' && $CMP $stderr $ftemp2; then
test.d:12:13: run time error - invalid parameter type of `set_debug'
OUTPUT439
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 440.
if test $result = ok -a $start_test_number -le 440; then
	echo test 440: More parameter exception.
        cat >$test_file <<'TEST440'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug ("0");
p.set_one_parse (nil);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST440
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT440' && $CMP $stderr $ftemp2; then
test.d:13:17: run time error - invalid parameter type of `set_one_parse'
OUTPUT440
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 441.
if test $result = ok -a $start_test_number -le 441; then
	echo test 441: More parameter exception.
        cat >$test_file <<'TEST441'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery (nil);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST441
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT441' && $CMP $stderr $ftemp2; then
test.d:14:16: run time error - invalid parameter type of `set_recovery'
OUTPUT441
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 442.
if test $result = ok -a $start_test_number -le 442; then
	echo test 442: More parameter exception.
        cat >$test_file <<'TEST442'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match (nil);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST442
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT442' && $CMP $stderr $ftemp2; then
test.d:15:22: run time error - invalid parameter type of `set_recovery_match'
OUTPUT442
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 443.
if test $result = ok -a $start_test_number -le 443; then
	echo test 443: More parameter exception.
        cat >$test_file <<'TEST443'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (['T', 'E', 'R', 'M'], nil);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST443
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT443' && $CMP $stderr $ftemp2; then
test.d:17:15: run time error - invalid parameter type of `set_grammar'
OUTPUT443
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 444.
if test $result = ok -a $start_test_number -le 444; then
	echo test 444: More parameter exception.
        cat >$test_file <<'TEST444'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (nil, 0);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST444
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT444' && $CMP $stderr $ftemp2; then
test.d:17:15: run time error - invalid parameter type of `set_grammar'
OUTPUT444
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 445.
if test $result = ok -a $start_test_number -le 445; then
	echo test 445: More parameter exception.
        cat >$test_file <<'TEST445'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (0, 0);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST445
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT445' && $CMP $stderr $ftemp2; then
test.d:17:15: run time error - invalid parameter type of `set_grammar'
OUTPUT445
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 446.
if test $result = ok -a $start_test_number -le 446; then
	echo test 446: More parameter exception.
        cat >$test_file <<'TEST446'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, 0);
exit (0);
TEST446
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT446' && $CMP $stderr $ftemp2; then
test.d:35:20: run time error - invalid parameter type of `parse'
OUTPUT446
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 447.
if test $result = ok -a $start_test_number -le 447; then
	echo test 447: More parameter exception.
        cat >$test_file <<'TEST447'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (nil, error);
exit (0);
TEST447
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT447' && $CMP $stderr $ftemp2; then
test.d:35:20: run time error - invalid parameter type of `parse'
OUTPUT447
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 447.
if test $result = ok -a $start_test_number -le 447; then
	echo test 447: More parameter exception.
        cat >$test_file <<'TEST447'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (['a', 'b'], error);
exit (0);
TEST447
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT447' && $CMP $stderr $ftemp2; then
test.d:35:20: run time error - invalid parameter type of `parse'
OUTPUT447
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 448.
if test $result = ok -a $start_test_number -le 448; then
	echo test 448: More parameter exception.
        cat >$test_file <<'TEST448'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

{
 class token (c) {}
 var root = p.parse ([token ('a'), token ('b')], error);
}
exit (0);
TEST448
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT448' && $CMP $stderr $ftemp2; then
test.d:37:21: run time error (parse) -- invalid token #0
OUTPUT448
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 449.
if test $result = ok -a $start_test_number -le 449; then
	echo test 449: More parameter exception.
        cat >$test_file <<'TEST449'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (g, 0);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse ([tok ('a'), tok ('b')], error);
exit (0);
TEST449
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT449' && $CMP $stderr $ftemp2; then
test.d:35:20: run time error (parse) -- invalid code of token #0
OUTPUT449
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 450.
if test $result = ok -a $start_test_number -le 450; then
	echo test 450: More parameter exception.
        cat >$test_file <<'TEST450'
class c1 {friend g; priv var a;}
TEST450
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT450' && $CMP $stderr $ftemp2; then
test.d:1:18: there is no declaration for identifier `g' in friend list
OUTPUT450
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 451.
if test $result = ok -a $start_test_number -le 451; then
	echo test 451: More parameter exception.
        cat >$test_file <<'TEST451'
var g;
class c1 {friend g; priv var a;}
TEST451
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT451' && $CMP $stderr $ftemp2; then
test.d:2:18: friend identifier `g' is neither function nor class
OUTPUT451
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 452.
if test $result = ok -a $start_test_number -le 452; then
	echo test 452
        cat >$test_file <<'TEST452'
class c2;
class c1 {friend c2; priv var a = 10;}
var i1 = c1 ();
class c2 {var a; a = i1.a;}
var i2 = c2 ();
putln (i2.a);
TEST452
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT452' && $CMP $stdout $ftemp2; then
10
OUTPUT452
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 453.
if test $result = ok -a $start_test_number -le 453; then
	echo test 453: IEEE package
        cat >$test_file <<'TEST453'
// There is no goal to test IEEE package we simply testing all
// functions of ieee.d

include "ieee";

var s1 = ieees.single(), s2 = ieees.single();
putln ("*******IEEE singles:**********");

putln ("pzero s1 (2, 4, 8, 16)=", s1.to_binary_string (2), ", ",
       s1.to_binary_string (4), ", ", s1.to_binary_string (8), ", ",
       s1.to_binary_string (16));
putln ("pzero s1=", s1.to_string ());
putln ("pzero s2 (2, 4, 8, 16)=", s2.to_binary_string (2), ", ",
       s2.to_binary_string (4), ", ", s2.to_binary_string (8), ", ",
       s2.to_binary_string (16));
putln ("pzero s2=", s2.to_string ());

s1 = ieees.single("0");
s2 = ieees.single("0");

s1.nzero();
putln ("-zero s1=", s1.to_string (), " s1 is -zero = ", s1.is_nzero ());
s1.nan();
putln ("nan s1=", s1.to_string (), " s1 is nan = ", s1.is_nan ());
s1.trap_nan();
putln ("trap nan s1=", s1.to_string (),
       " s1 is trap nan = ", s1.is_trap_nan ());
s1.pinfinity();
putln ("+infinity s1=", s1.to_string (),
       " s1 is +infinity = ", s1.is_pinfinity ());
s1.ninfinity();
putln ("-infinity s1=", s1.to_string (),
       " s1 is -infinity = ", s1.is_ninfinity ());
s1.pmax();
putln ("+max s1 (10, 16)=", s1.to_string (), ", ", s1.to_binary_string (16),
       " s1 is norm = ", s1.is_normalized ());
s1.nmax();
putln ("-max s1 (10, 16)=", s1.to_string (), ", ", s1.to_binary_string (16),
       " s1 is norm = ", s1.is_normalized ());
s1.pmin();
putln ("+min s1 (10, 16)=", s1.to_string (), ", ", s1.to_binary_string (16),
       " s1 is denorm = ", s1.is_denormalized ());
s1.nmin();
putln ("-min s1 (10,16)=", s1.to_string (), ", ", s1.to_binary_string (16),
       " s1 is denorm = ", s1.is_denormalized ());

s1.from_float(5.0);
s2.from_float(10.0);
putln ("s1 (10,2,4,8,16)= ", s1.to_string (), ", ", s1.to_binary_string (2),
       ", ", s1.to_binary_string (4), ", ", s1.to_binary_string (8),
       ", ", s1.to_binary_string (16));
putln ("s2 = ", s2.to_string ());

s1.from_string("5.0");
s2.from_string("10.0");
putln ("s1 = ", s1.to_string ());
putln ("s2 = ", s2.to_string ());

s1.from_binary_string("5.0", 16);
s2.from_binary_string("2.8p2", 16);
putln ("s1 = ", s1.to_string ());
putln ("s2 = ", s2.to_string ());

putln ("s1 + s2 = ", s1.add (s2).to_string ());
putln ("s1 - s2 = ", s1.subtract (s2).to_string ());
putln ("s2 - s1 = ", s2.subtract (s1).to_string ());
putln ("s1 * s2 = ", s1.multiply (s2).to_string ());
putln ("s1 / s2 = ", s1.divide (s2).to_string ());
putln ("s1 == s2 = ", s1.eq (s2));
putln ("s1 != s2 = ", s1.ne (s2));
putln ("s1 < s2 = ", s1.lt (s2));
putln ("s1 <= s2 = ", s1.le (s2));
putln ("s1 > s2 = ", s1.gt (s2));
putln ("s1 >= s2 = ", s1.ge (s2));

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

try {
  var s3 = ieees.single ();
  put (s1.to_string (), " / ", s3.to_string (), " ...");
  s1.divide (s3);
} catch (ieee_zero_division_except) {
  putln ("  got zero_division");
}

{
  var s3 = ieees.single (), st, res;
  ieees.ignore_excepts = 1;
  put (s1.to_string (), " / ", s3.to_string (), " = ");
  res = s1.divide (s3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.dz);
  ieees.ignore_excepts = 0;
}

try {
  var s3 = ieees.single ("3");
  put (s1.to_string (), " / ", s3.to_string (), " ...");
  s1.divide (s3);
} catch (ieee_imprecise_result_except) {
  putln ("  got imprecise result");
}

{
  var s3 = ieees.single ("3"), st, res;
  ieees.ignore_excepts = 1;
  put (s1.to_string (), " / ", s3.to_string (), " = ");
  res = s1.divide (s3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.imp);
  ieees.ignore_excepts = 0;
}

try {
  var s3 = ieees.single ();
  s3.pmax ();
  put (s3.to_string (), " + ", s3.to_string (), " ...");
  s3.add (s3);
} catch (ieee_overflow_except) {
  putln ("  got overflow");
}

{
  var s3 = ieees.single (), st, res;
  ieees.ignore_excepts = 1;
  s3.pmax ();
  put (s3.to_string (), " + ", s3.to_string (), " = ");
  res = s3.add (s3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ofl);
  ieees.ignore_excepts = 0;
}

try {
  var s3 = ieees.single ();
  s3.pmin ();
  put (s3.to_string (), " / 10 ...");
  s3.divide (ieees.single ("10"));
} catch (ieee_underflow_except) {
  putln ("  got underflow");
}

{
  var s3 = ieees.single (), st, res;
  s3.pmin ();
  ieees.ignore_excepts = 1;
  put (s3.to_string (), " / 10 = ");
  res = s3.divide (ieees.single ("10"));
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ufl);
  ieees.ignore_excepts = 0;
}

try {
  var s3 = ieees.single ("SNaN");
  put (s3.to_string (), " + ", s3.to_string (), " ...");
  s3.add (s3);
} catch (ieee_invalid_operation_except) {
  putln ("  got invalid operation");
}

{
  var s3 = ieees.single ("SNaN"), st, res;
  ieees.ignore_excepts = 1;
  put (s3.to_string (), " + ", s3.to_string (), " = ");
  res = s3.add (s3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.inv);
  ieees.ignore_excepts = 0;
}

try {
  var s3 = ieees.single ("QNaN");
  put (s3.to_string (), " + ", s3.to_string (), " ...");
  s3.add (s3);
} catch (ieee_reserved_operand_except) {
  putln ("  got reserved operand");
}

{
  var s3 = ieees.single ("QNaN"), st, res;
  ieees.ignore_excepts = 1;
  put (s3.to_string (), " + ", s3.to_string (), " = ");
  res = s3.add (s3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ro);
  ieees.ignore_excepts = 0;
}

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

putln ("trap mask = ", ieees.get_trap_mask ());

ieees.set_trap_mask (ieees.inv|ieees.ro|ieees.ofl
		     |ieees.ufl|ieees.imp|ieees.dz);
putln ("trap mask = ", ieees.get_trap_mask ());

var s3 = ieees.single ();
put (s1.to_string (), " / ", s3.to_string (), " = ");
putln (s1.divide (s3).to_string ());

s3 = ieees.single ("3");
put (s1.to_string (), " / ", s3.to_string (), " = ");
putln (s1.divide (s3).to_string ());

s3 = ieees.single ();
s3.pmax ();
put (s3.to_string (), " + ", s3.to_string (), " = ");
putln (s3.add (s3).to_string ());

s3 = ieees.single ();
s3.pmin ();
put (s3.to_string (), " / 10 = ");
putln (s3.divide (ieees.single ("10")).to_string ());

s3 = ieees.single ("SNaN");
put (s3.to_string (), " + ", s3.to_string (), " = ");
putln (s3.add (s3).to_string ());

s3 = ieees.single ("QNaN");
put (s3.to_string (), " + ", s3.to_string (), " = ");
putln (s3.add (s3).to_string ());

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

putln ("round = ", ieees.get_round ());

s3 = ieees.single ("1.23456788");
s1 = ieees.single ("0.00000001");
putln (s3.to_string (), " + ", s1.to_string (), " = ",
       s3.add (s1).to_string ());

ieees.set_round (ieees.rni);
putln ("round = ", ieees.get_round ());

s3 = ieees.single ("1.23456788");
s1 = ieees.single ("0.00000001");
putln (s3.to_string (), " + ", s1.to_string (), " = ",
       s3.add (s1).to_string ());

ieees.set_round (ieees.rpi);
putln ("round = ", ieees.get_round ());

s3 = ieees.single ("1.23456788");
s1 = ieees.single ("0.00000001");
putln (s3.to_string (), " + ", s1.to_string (), " = ",
       s3.add (s1).to_string ());

ieees.set_round (ieees.rz);
putln ("round = ", ieees.get_round ());

s3 = ieees.single ("1.23456788");
s1 = ieees.single ("0.00000001");
putln (s3.to_string (), " + ", s1.to_string (), " = ",
       s3.add (s1).to_string ());

try {
  ieees.set_round (6);
} catch (ieee_round_value_except) {
  putln ("  got invalid round value");
}

s1 = ieees.single ("5");
var ms = s1.to_mpi (4);
putln ("ms (from s1) = ", mpis.to_string (ms));
s1.from_mpi (ms);
putln ("s1 (from ms) = ", s1.to_string ());

//////////////////////////////////////////////////////////////

ieees.reset ();
var d1 = ieees.double(), d2 = ieees.double();
putln ("*******IEEE doubles:**********");

putln ("pzero d1 (2, 4, 8, 16)=", d1.to_binary_string (2), ", ",
       d1.to_binary_string (4), ", ", d1.to_binary_string (8), ", ",
       d1.to_binary_string (16));
putln ("pzero d1=", d1.to_string ());
putln ("pzero d2 (2, 4, 8, 16)=", d2.to_binary_string (2), ", ",
       d2.to_binary_string (4), ", ", d2.to_binary_string (8), ", ",
       d2.to_binary_string (16));
putln ("pzero d2=", d2.to_string ());

d1 = ieees.double("0");
d2 = ieees.double("0");

d1.nzero();
putln ("-zero d1=", d1.to_string (), " d1 is -zero = ", d1.is_nzero ());
d1.nan();
putln ("nan d1=", d1.to_string (), " d1 is nan = ", d1.is_nan ());
d1.trap_nan();
putln ("trap nan d1=", d1.to_string (),
       " d1 is trap nan = ", d1.is_trap_nan ());
d1.pinfinity();
putln ("+infinity d1=", d1.to_string (),
       " d1 is +infinity = ", d1.is_pinfinity ());
d1.ninfinity();
putln ("-infinity d1=", d1.to_string (),
       " d1 is -infinity = ", d1.is_ninfinity ());
d1.pmax();
putln ("+max d1 (10, 16)=", d1.to_string (), ", ", d1.to_binary_string (16),
       " d1 is norm = ", d1.is_normalized ());
d1.nmax();
putln ("-max d1 (10, 16)=", d1.to_string (), ", ", d1.to_binary_string (16),
       " d1 is norm = ", d1.is_normalized ());
d1.pmin();
putln ("+min d1 (10, 16)=", d1.to_string (), ", ", d1.to_binary_string (16),
       " d1 is denorm = ", d1.is_denormalized ());
d1.nmin();
putln ("-min d1 (10,16)=", d1.to_string (), ", ", d1.to_binary_string (16),
       " d1 is denorm = ", d1.is_denormalized ());

d1.from_float(5.0);
d2.from_float(10.0);
putln ("d1 (10,2,4,8,16)= ", d1.to_string (), ", ", d1.to_binary_string (2),
       ", ", d1.to_binary_string (4), ", ", d1.to_binary_string (8),
       ", ", d1.to_binary_string (16));
putln ("d2 = ", d2.to_string ());

d1.from_string("5.0");
d2.from_string("10.0");
putln ("d1 = ", d1.to_string ());
putln ("d2 = ", d2.to_string ());

d1.from_binary_string("5.0", 16);
d2.from_binary_string("2.8p2", 16);
putln ("d1 = ", d1.to_string ());
putln ("d2 = ", d2.to_string ());

putln ("d1 + d2 = ", d1.add (d2).to_string ());
putln ("d1 - d2 = ", d1.subtract (d2).to_string ());
putln ("d2 - d1 = ", d2.subtract (d1).to_string ());
putln ("d1 * d2 = ", d1.multiply (d2).to_string ());
putln ("d1 / d2 = ", d1.divide (d2).to_string ());
putln ("d1 == d2 = ", d1.eq (d2));
putln ("d1 != d2 = ", d1.ne (d2));
putln ("d1 < d2 = ", d1.lt (d2));
putln ("d1 <= d2 = ", d1.le (d2));
putln ("d1 > d2 = ", d1.gt (d2));
putln ("d1 >= d2 = ", d1.ge (d2));

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

try {
  var d3 = ieees.double ();
  put (d1.to_string (), " / ", d3.to_string (), " ...");
  d1.divide (d3);
} catch (ieee_zero_division_except) {
  putln ("  got zero_division");
}

{
  var d3 = ieees.double (), st, res;
  ieees.ignore_excepts = 1;
  put (d1.to_string (), " / ", d3.to_string (), " = ");
  res = d1.divide (d3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.dz);
  ieees.ignore_excepts = 0;
}

try {
  var d3 = ieees.double ("3");
  put (d1.to_string (), " / ", d3.to_string (), " ...");
  d1.divide (d3);
} catch (ieee_imprecise_result_except) {
  putln ("  got imprecise result");
}

{
  var d3 = ieees.double ("3"), st, res;
  ieees.ignore_excepts = 1;
  put (d1.to_string (), " / ", d3.to_string (), " = ");
  res = d1.divide (d3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.imp);
  ieees.ignore_excepts = 0;
}

try {
  var d3 = ieees.double ();
  d3.pmax ();
  put (d3.to_string (), " + ", d3.to_string (), " ...");
  d3.add (d3);
} catch (ieee_overflow_except) {
  putln ("  got overflow");
}

{
  var d3 = ieees.double (), st, res;
  ieees.ignore_excepts = 1;
  d3.pmax ();
  put (d3.to_string (), " + ", d3.to_string (), " = ");
  res = d3.add (d3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ofl);
  ieees.ignore_excepts = 0;
}

try {
  var d3 = ieees.double ();
  d3.pmin ();
  put (d3.to_string (), " / 10 ...");
  d3.divide (ieees.double ("10"));
} catch (ieee_underflow_except) {
  putln ("  got underflow");
}

{
  var d3 = ieees.double (), st, res;
  d3.pmin ();
  ieees.ignore_excepts = 1;
  put (d3.to_string (), " / 10 = ");
  res = d3.divide (ieees.double ("10"));
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ufl);
  ieees.ignore_excepts = 0;
}

try {
  var d3 = ieees.double ("SNaN");
  put (d3.to_string (), " + ", d3.to_string (), " ...");
  d3.add (d3);
} catch (ieee_invalid_operation_except) {
  putln ("  got invalid operation");
}

{
  var d3 = ieees.double ("SNaN"), st, res;
  ieees.ignore_excepts = 1;
  put (d3.to_string (), " + ", d3.to_string (), " = ");
  res = d3.add (d3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.inv);
  ieees.ignore_excepts = 0;
}

try {
  var d3 = ieees.double ("QNaN");
  put (d3.to_string (), " + ", d3.to_string (), " ...");
  d3.add (d3);
} catch (ieee_reserved_operand_except) {
  putln ("  got reserved operand");
}

{
  var d3 = ieees.double ("QNaN"), st, res;
  ieees.ignore_excepts = 1;
  put (d3.to_string (), " + ", d3.to_string (), " = ");
  res = d3.add (d3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ro);
  ieees.ignore_excepts = 0;
}

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

putln ("trap mask = ", ieees.get_trap_mask ());

ieees.set_trap_mask (ieees.inv|ieees.ro|ieees.ofl
		     |ieees.ufl|ieees.imp|ieees.dz);
putln ("trap mask = ", ieees.get_trap_mask ());

var d3 = ieees.double ();
put (d1.to_string (), " / ", d3.to_string (), " = ");
putln (d1.divide (d3).to_string ());

d3 = ieees.double ("3");
put (d1.to_string (), " / ", d3.to_string (), " = ");
putln (d1.divide (d3).to_string ());

d3 = ieees.double ();
d3.pmax ();
put (d3.to_string (), " + ", d3.to_string (), " = ");
putln (d3.add (d3).to_string ());

d3 = ieees.double ();
d3.pmin ();
put (d3.to_string (), " / 10 = ");
putln (d3.divide (ieees.double ("10")).to_string ());

d3 = ieees.double ("SNaN");
put (d3.to_string (), " + ", d3.to_string (), " = ");
putln (d3.add (d3).to_string ());

d3 = ieees.double ("QNaN");
put (d3.to_string (), " + ", d3.to_string (), " = ");
putln (d3.add (d3).to_string ());

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

putln ("round = ", ieees.get_round ());

d3 = ieees.double ("1.2345678901234567");
d1 = ieees.double ("0.0000000000000004");
putln (d3.to_string (), " + ", d1.to_string (), " = ",
       d3.add (d1).to_string ());

ieees.set_round (ieees.rni);
putln ("round = ", ieees.get_round ());

d3 = ieees.double ("1.2345678901234567");
d1 = ieees.double ("0.0000000000000004");
putln (d3.to_string (), " + ", d1.to_string (), " = ",
       d3.add (d1).to_string ());

ieees.set_round (ieees.rpi);
putln ("round = ", ieees.get_round ());

d3 = ieees.double ("1.2345678901234567");
d1 = ieees.double ("0.0000000000000004");
putln (d3.to_string (), " + ", d1.to_string (), " = ",
       d3.add (d1).to_string ());

ieees.set_round (ieees.rz);
putln ("round = ", ieees.get_round ());

d3 = ieees.double ("1.2345678901234567");
d1 = ieees.double ("0.0000000000000004");
putln (d3.to_string (), " + ", d1.to_string (), " = ",
       d3.add (d1).to_string ());

try {
  ieees.set_round (6);
} catch (ieee_round_value_except) {
  putln ("  got invalid round value");
}

d1 = ieees.double ("5");
var md = d1.to_mpi (4);
putln ("md (from d1) = ", mpis.to_string (md));
d1.from_mpi (md);
putln ("d1 (from md) = ", d1.to_string ());

//////////////////////////////////////////////////////////////

ieees.reset ();
var q1 = ieees.quad(), q2 = ieees.quad();
putln ("*******IEEE quads:**********");

putln ("pzero q1 (2, 4, 8, 16)=", q1.to_binary_string (2), ", ",
       q1.to_binary_string (4), ", ", q1.to_binary_string (8), ", ",
       q1.to_binary_string (16));
putln ("pzero q1=", q1.to_string ());
putln ("pzero q2 (2, 4, 8, 16)=", q2.to_binary_string (2), ", ",
       q2.to_binary_string (4), ", ", q2.to_binary_string (8), ", ",
       q2.to_binary_string (16));
putln ("pzero q2=", q2.to_string ());

q1 = ieees.quad("0");
q2 = ieees.quad("0");

q1.nzero();
putln ("-zero q1=", q1.to_string (), " q1 is -zero = ", q1.is_nzero ());
q1.nan();
putln ("nan q1=", q1.to_string (), " q1 is nan = ", q1.is_nan ());
q1.trap_nan();
putln ("trap nan q1=", q1.to_string (),
       " q1 is trap nan = ", q1.is_trap_nan ());
q1.pinfinity();
putln ("+infinity q1=", q1.to_string (),
       " q1 is +infinity = ", q1.is_pinfinity ());
q1.ninfinity();
putln ("-infinity q1=", q1.to_string (),
       " q1 is -infinity = ", q1.is_ninfinity ());
q1.pmax();
putln ("+max q1 (10, 16)=", q1.to_string (), ", ", q1.to_binary_string (16),
       " q1 is norm = ", q1.is_normalized ());
q1.nmax();
putln ("-max q1 (10, 16)=", q1.to_string (), ", ", q1.to_binary_string (16),
       " q1 is norm = ", q1.is_normalized ());
q1.pmin();
putln ("+min q1 (10, 16)=", q1.to_string (), ", ", q1.to_binary_string (16),
       " q1 is denorm = ", q1.is_denormalized ());
q1.nmin();
putln ("-min q1 (10,16)=", q1.to_string (), ", ", q1.to_binary_string (16),
       " q1 is denorm = ", q1.is_denormalized ());

q1.from_float(5.0);
q2.from_float(10.0);
putln ("q1 (10,2,4,8,16)= ", q1.to_string (), ", ", q1.to_binary_string (2),
       ", ", q1.to_binary_string (4), ", ", q1.to_binary_string (8),
       ", ", q1.to_binary_string (16));
putln ("q2 = ", q2.to_string ());

q1.from_string("5.0");
q2.from_string("10.0");
putln ("q1 = ", q1.to_string ());
putln ("q2 = ", q2.to_string ());

q1.from_binary_string("5.0", 16);
q2.from_binary_string("2.8p2", 16);
putln ("q1 = ", q1.to_string ());
putln ("q2 = ", q2.to_string ());

putln ("q1 + q2 = ", q1.add (q2).to_string ());
putln ("q1 - q2 = ", q1.subtract (q2).to_string ());
putln ("q2 - q1 = ", q2.subtract (q1).to_string ());
putln ("q1 * q2 = ", q1.multiply (q2).to_string ());
putln ("q1 / q2 = ", q1.divide (q2).to_string ());
putln ("q1 == q2 = ", q1.eq (q2));
putln ("q1 != q2 = ", q1.ne (q2));
putln ("q1 < q2 = ", q1.lt (q2));
putln ("q1 <= q2 = ", q1.le (q2));
putln ("q1 > q2 = ", q1.gt (q2));
putln ("q1 >= q2 = ", q1.ge (q2));

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

try {
  var q3 = ieees.quad ();
  put (q1.to_string (), " / ", q3.to_string (), " ...");
  q1.divide (q3);
} catch (ieee_zero_division_except) {
  putln ("  got zero_division");
}

{
  var q3 = ieees.quad (), st, res;
  ieees.ignore_excepts = 1;
  put (q1.to_string (), " / ", q3.to_string (), " = ");
  res = q1.divide (q3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.dz);
  ieees.ignore_excepts = 0;
}

try {
  var q3 = ieees.quad ("3");
  put (q1.to_string (), " / ", q3.to_string (), " ...");
  q1.divide (q3);
} catch (ieee_imprecise_result_except) {
  putln ("  got imprecise result");
}

{
  var q3 = ieees.quad ("3"), st, res;
  ieees.ignore_excepts = 1;
  put (q1.to_string (), " / ", q3.to_string (), " = ");
  res = q1.divide (q3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.imp);
  ieees.ignore_excepts = 0;
}

try {
  var q3 = ieees.quad ();
  q3.pmax ();
  put (q3.to_string (), " + ", q3.to_string (), " ...");
  q3.add (q3);
} catch (ieee_overflow_except) {
  putln ("  got overflow");
}

{
  var q3 = ieees.quad (), st, res;
  ieees.ignore_excepts = 1;
  q3.pmax ();
  put (q3.to_string (), " + ", q3.to_string (), " = ");
  res = q3.add (q3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ofl);
  ieees.ignore_excepts = 0;
}

try {
  var q3 = ieees.quad ();
  q3.pmin ();
  put (q3.to_string (), " / 10 ...");
  q3.divide (ieees.quad ("10"));
} catch (ieee_underflow_except) {
  putln ("  got underflow");
}

{
  var q3 = ieees.quad (), st, res;
  q3.pmin ();
  ieees.ignore_excepts = 1;
  put (q3.to_string (), " / 10 = ");
  res = q3.divide (ieees.quad ("10"));
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ufl);
  ieees.ignore_excepts = 0;
}

try {
  var q3 = ieees.quad ("SNaN");
  put (q3.to_string (), " + ", q3.to_string (), " ...");
  q3.add (q3);
} catch (ieee_invalid_operation_except) {
  putln ("  got invalid operation");
}

{
  var q3 = ieees.quad ("SNaN"), st, res;
  ieees.ignore_excepts = 1;
  put (q3.to_string (), " + ", q3.to_string (), " = ");
  res = q3.add (q3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.inv);
  ieees.ignore_excepts = 0;
}

try {
  var q3 = ieees.quad ("QNaN");
  put (q3.to_string (), " + ", q3.to_string (), " ...");
  q3.add (q3);
} catch (ieee_reserved_operand_except) {
  putln ("  got reserved operand");
}

{
  var q3 = ieees.quad ("QNaN"), st, res;
  ieees.ignore_excepts = 1;
  put (q3.to_string (), " + ", q3.to_string (), " = ");
  res = q3.add (q3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ro);
  ieees.ignore_excepts = 0;
}

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

putln ("trap mask = ", ieees.get_trap_mask ());

ieees.set_trap_mask (ieees.inv|ieees.ro|ieees.ofl
		     |ieees.ufl|ieees.imp|ieees.dz);
putln ("trap mask = ", ieees.get_trap_mask ());

var q3 = ieees.quad ();
put (q1.to_string (), " / ", q3.to_string (), " = ");
putln (q1.divide (q3).to_string ());

q3 = ieees.quad ("3");
put (q1.to_string (), " / ", q3.to_string (), " = ");
putln (q1.divide (q3).to_string ());

q3 = ieees.quad ();
q3.pmax ();
put (q3.to_string (), " + ", q3.to_string (), " = ");
putln (q3.add (q3).to_string ());

q3 = ieees.quad ();
q3.pmin ();
put (q3.to_string (), " / 10 = ");
putln (q3.divide (ieees.quad ("10")).to_string ());

q3 = ieees.quad ("SNaN");
put (q3.to_string (), " + ", q3.to_string (), " = ");
putln (q3.add (q3).to_string ());

q3 = ieees.quad ("QNaN");
put (q3.to_string (), " + ", q3.to_string (), " = ");
putln (q3.add (q3).to_string ());

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

putln ("round = ", ieees.get_round ());

q3 = ieees.quad ("1.23456789012345678901234567890123456");
q1 = ieees.quad ("0.00000000000000000000000000000000015");
putln (q3.to_string (), " + ", q1.to_string (), " = ",
       q3.add (q1).to_string ());

ieees.set_round (ieees.rni);
putln ("round = ", ieees.get_round ());

q3 = ieees.quad ("1.23456789012345678901234567890123456");
q1 = ieees.quad ("0.00000000000000000000000000000000015");
putln (q3.to_string (), " + ", q1.to_string (), " = ",
       q3.add (q1).to_string ());

ieees.set_round (ieees.rpi);
putln ("round = ", ieees.get_round ());

q3 = ieees.quad ("1.23456789012345678901234567890123456");
q1 = ieees.quad ("0.00000000000000000000000000000000015");
putln (q3.to_string (), " + ", q1.to_string (), " = ",
       q3.add (q1).to_string ());

ieees.set_round (ieees.rz);
putln ("round = ", ieees.get_round ());

q3 = ieees.quad ("1.23456789012345678901234567890123456");
q1 = ieees.quad ("0.00000000000000000000000000000000015");
putln (q3.to_string (), " + ", q1.to_string (), " = ",
       q3.add (q1).to_string ());

try {
  ieees.set_round (6);
} catch (ieee_round_value_except) {
  putln ("  got invalid round value");
}

q1 = ieees.quad ("5");
var mq = q1.to_mpi (4);
putln ("mq (from q1) = ", mpis.to_string (mq));
q1.from_mpi (mq);
putln ("q1 (from mq) = ", q1.to_string ());

// Transformation single -> double -> quad

d1 = s1.to_double ();
putln ("single ", s1.to_string (), " -> double ", d1.to_string ());
q1 = s1.to_quad ();
putln ("single ", s1.to_string (), " -> quad ", q1.to_string ());

s1 = d1.to_single ();
putln ("double ", d1.to_string (), " -> single ", s1.to_string ());
q1 = d1.to_quad ();
putln ("double ", d1.to_string (), " -> quad ", q1.to_string ());

s1 = q1.to_single ();
putln ("quad ", q1.to_string (), " -> single ", s1.to_string ());
d1 = q1.to_double ();
putln ("quad ", q1.to_string (), " -> double ", d1.to_string ());
TEST453
        if uname | fgrep CYGWIN; then
            echo '      ' $DINO -L./d_ieee.dll -L./d_mpi.dll -I@srcdir@ $test_file "2>$stderr"
	    if $DINO -Lieee.dll -Lmpi.dll -I@srcdir@ $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT453' && $CMP $stdout $ftemp2; then
*******IEEE singles:**********
pzero s1 (2, 4, 8, 16)=+0, +0, +0, +0
pzero s1=+0
pzero s2 (2, 4, 8, 16)=+0, +0, +0, +0
pzero s2=+0
-zero s1=-0 s1 is -zero = 1
nan s1=QNaN s1 is nan = 1
trap nan s1=SNaN s1 is trap nan = 1
+infinity s1=+Inf s1 is +infinity = 1
-infinity s1=-Inf s1 is -infinity = 1
+max s1 (10, 16)=3.40282347e38, 1.fffffep127 s1 is norm = 1
-max s1 (10, 16)=-3.40282347e38, -1.fffffep127 s1 is norm = 1
+min s1 (10, 16)=1.40129846e-45, 1.p-149 s1 is denorm = 1
-min s1 (10,16)=-1.40129846e-45, -1.p-149 s1 is denorm = 1
s1 (10,2,4,8,16)= 5.00000000, 1.01p2, 1.1p2, 1.2p2, 1.4p2
s2 = 1.00000000e1
s1 = 5.00000000
s2 = 1.00000000e1
s1 = 5.00000000
s2 = 1.00000000e1
s1 + s2 = 1.50000000e1
s1 - s2 = -5.00000000
s2 - s1 = 5.00000000
s1 * s2 = 5.00000000e1
s1 / s2 = 5.00000000e-1
s1 == s2 = 0
s1 != s2 = 1
s1 < s2 = 1
s1 <= s2 = 1
s1 > s2 = 0
s1 >= s2 = 0
sticky status bits = 0
5.00000000 / +0 ...  got zero_division
5.00000000 / +0 = +Inf status bits = 32, 32
5.00000000 / 3.00000000 ...  got imprecise result
5.00000000 / 3.00000000 = 1.66666663 status bits = 16, 16
3.40282347e38 + 3.40282347e38 ...  got overflow
3.40282347e38 + 3.40282347e38 = +Inf status bits = 4, 4
1.40129846e-45 / 10 ...  got underflow
1.40129846e-45 / 10 = +0 status bits = 24, 8
SNaN + SNaN ...  got invalid operation
SNaN + SNaN = QNaN status bits = 3, 1
QNaN + QNaN ...  got reserved operand
QNaN + QNaN = QNaN status bits = 2, 2
sticky status bits = 0
trap mask = 0
trap mask = 63
5.00000000 / +0 = +Inf
5.00000000 / 3.00000000 = 1.66666663
3.40282347e38 + 3.40282347e38 = +Inf
1.40129846e-45 / 10 = +0
SNaN + SNaN = QNaN
QNaN + QNaN = QNaN
sticky status bits = 63
round = 0
1.23456788 + 9.99999994e-9 = 1.23456788
round = 1
1.23456776 + 9.99999994e-9 = 1.23456776
round = 2
1.23456788 + 1.00000008e-8 = 1.23456800
round = 3
1.23456776 + 9.99999994e-9 = 1.23456776
  got invalid round value
ms (from s1) = 5
s1 (from ms) = 5.00000000
*******IEEE doubles:**********
pzero d1 (2, 4, 8, 16)=+0, +0, +0, +0
pzero d1=+0
pzero d2 (2, 4, 8, 16)=+0, +0, +0, +0
pzero d2=+0
-zero d1=-0 d1 is -zero = 1
nan d1=QNaN d1 is nan = 1
trap nan d1=SNaN d1 is trap nan = 1
+infinity d1=+Inf d1 is +infinity = 1
-infinity d1=-Inf d1 is -infinity = 1
+max d1 (10, 16)=1.7976931348623157e308, 1.fffffffffffffp1023 d1 is norm = 1
-max d1 (10, 16)=-1.7976931348623157e308, -1.fffffffffffffp1023 d1 is norm = 1
+min d1 (10, 16)=4.9406564584124654e-324, 1.p-1074 d1 is denorm = 1
-min d1 (10,16)=-4.9406564584124654e-324, -1.p-1074 d1 is denorm = 1
d1 (10,2,4,8,16)= 5.0000000000000000, 1.01p2, 1.1p2, 1.2p2, 1.4p2
d2 = 1.0000000000000000e1
d1 = 5.0000000000000000
d2 = 1.0000000000000000e1
d1 = 5.0000000000000000
d2 = 1.0000000000000000e1
d1 + d2 = 1.5000000000000000e1
d1 - d2 = -5.0000000000000000
d2 - d1 = 5.0000000000000000
d1 * d2 = 5.0000000000000000e1
d1 / d2 = 5.0000000000000000e-1
d1 == d2 = 0
d1 != d2 = 1
d1 < d2 = 1
d1 <= d2 = 1
d1 > d2 = 0
d1 >= d2 = 0
sticky status bits = 0
5.0000000000000000 / +0 ...  got zero_division
5.0000000000000000 / +0 = +Inf status bits = 32, 32
5.0000000000000000 / 3.0000000000000000 ...  got imprecise result
5.0000000000000000 / 3.0000000000000000 = 1.6666666666666667 status bits = 16, 16
1.7976931348623157e308 + 1.7976931348623157e308 ...  got overflow
1.7976931348623157e308 + 1.7976931348623157e308 = +Inf status bits = 4, 4
4.9406564584124654e-324 / 10 ...  got underflow
4.9406564584124654e-324 / 10 = +0 status bits = 24, 8
SNaN + SNaN ...  got invalid operation
SNaN + SNaN = QNaN status bits = 3, 1
QNaN + QNaN ...  got reserved operand
QNaN + QNaN = QNaN status bits = 2, 2
sticky status bits = 0
trap mask = 0
trap mask = 63
5.0000000000000000 / +0 = +Inf
5.0000000000000000 / 3.0000000000000000 = 1.6666666666666667
1.7976931348623157e308 + 1.7976931348623157e308 = +Inf
4.9406564584124654e-324 / 10 = +0
SNaN + SNaN = QNaN
QNaN + QNaN = QNaN
sticky status bits = 63
round = 0
1.2345678901234567 + 3.9999999999999999e-16 = 1.2345678901234571
round = 1
1.2345678901234567 + 3.9999999999999999e-16 = 1.2345678901234569
round = 2
1.2345678901234569 + 4.0000000000000004e-16 = 1.2345678901234574
round = 3
1.2345678901234567 + 3.9999999999999999e-16 = 1.2345678901234569
  got invalid round value
md (from d1) = 5
d1 (from md) = 5.0000000000000000
*******IEEE quads:**********
pzero q1 (2, 4, 8, 16)=+0, +0, +0, +0
pzero q1=+0
pzero q2 (2, 4, 8, 16)=+0, +0, +0, +0
pzero q2=+0
-zero q1=-0 q1 is -zero = 1
nan q1=QNaN q1 is nan = 1
trap nan q1=SNaN q1 is trap nan = 1
+infinity q1=+Inf q1 is +infinity = 1
-infinity q1=-Inf q1 is -infinity = 1
+max q1 (10, 16)=1.18973149535723176508575932662800702e4932, 1.ffffffffffffffffffffffffffffp16383 q1 is norm = 1
-max q1 (10, 16)=-1.18973149535723176508575932662800702e4932, -1.ffffffffffffffffffffffffffffp16383 q1 is norm = 1
+min q1 (10, 16)=6.47517511943802511092443895822764655e-4966, 1.p-16494 q1 is denorm = 1
-min q1 (10,16)=-6.47517511943802511092443895822764655e-4966, -1.p-16494 q1 is denorm = 1
q1 (10,2,4,8,16)= 5.00000000000000000000000000000000000, 1.01p2, 1.1p2, 1.2p2, 1.4p2
q2 = 1.00000000000000000000000000000000000e1
q1 = 5.00000000000000000000000000000000000
q2 = 1.00000000000000000000000000000000000e1
q1 = 5.00000000000000000000000000000000000
q2 = 1.00000000000000000000000000000000000e1
q1 + q2 = 1.50000000000000000000000000000000000e1
q1 - q2 = -5.00000000000000000000000000000000000
q2 - q1 = 5.00000000000000000000000000000000000
q1 * q2 = 5.00000000000000000000000000000000000e1
q1 / q2 = 5.00000000000000000000000000000000000e-1
q1 == q2 = 0
q1 != q2 = 1
q1 < q2 = 1
q1 <= q2 = 1
q1 > q2 = 0
q1 >= q2 = 0
sticky status bits = 0
5.00000000000000000000000000000000000 / +0 ...  got zero_division
5.00000000000000000000000000000000000 / +0 = +Inf status bits = 32, 32
5.00000000000000000000000000000000000 / 3.00000000000000000000000000000000000 ...  got imprecise result
5.00000000000000000000000000000000000 / 3.00000000000000000000000000000000000 = 1.66666666666666666666666666666666673 status bits = 16, 16
1.18973149535723176508575932662800702e4932 + 1.18973149535723176508575932662800702e4932 ...  got overflow
1.18973149535723176508575932662800702e4932 + 1.18973149535723176508575932662800702e4932 = +Inf status bits = 4, 4
6.47517511943802511092443895822764655e-4966 / 10 ...  got underflow
6.47517511943802511092443895822764655e-4966 / 10 = +0 status bits = 24, 8
SNaN + SNaN ...  got invalid operation
SNaN + SNaN = QNaN status bits = 3, 1
QNaN + QNaN ...  got reserved operand
QNaN + QNaN = QNaN status bits = 2, 2
sticky status bits = 0
trap mask = 0
trap mask = 63
5.00000000000000000000000000000000000 / +0 = +Inf
5.00000000000000000000000000000000000 / 3.00000000000000000000000000000000000 = 1.66666666666666666666666666666666673
1.18973149535723176508575932662800702e4932 + 1.18973149535723176508575932662800702e4932 = +Inf
6.47517511943802511092443895822764655e-4966 / 10 = +0
SNaN + SNaN = QNaN
QNaN + QNaN = QNaN
sticky status bits = 63
round = 0
1.23456789012345678901234567890123455 + 1.49999999999999999999999999999999996e-34 = 1.23456789012345678901234567890123475
round = 1
1.23456789012345678901234567890123455 + 1.49999999999999999999999999999999996e-34 = 1.23456789012345678901234567890123455
round = 2
1.23456789012345678901234567890123475 + 1.50000000000000000000000000000000015e-34 = 1.23456789012345678901234567890123494
round = 3
1.23456789012345678901234567890123455 + 1.49999999999999999999999999999999996e-34 = 1.23456789012345678901234567890123455
  got invalid round value
mq (from q1) = 5
q1 (from mq) = 5.00000000000000000000000000000000000
single 5.00000000 -> double 5.0000000000000000
single 5.00000000 -> quad 5.00000000000000000000000000000000000
double 5.0000000000000000 -> single 5.00000000
double 5.0000000000000000 -> quad 5.00000000000000000000000000000000000
quad 5.00000000000000000000000000000000000 -> single 5.00000000
quad 5.00000000000000000000000000000000000 -> double 5.0000000000000000
OUTPUT453
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
            echo '      ' $DINO -L./d_ieee.@EXTERN_LIB_SUFFIX@ -L./d_mpi.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file "2>$stderr"
	    if $DINO -L./d_ieee.@EXTERN_LIB_SUFFIX@ -L./d_mpi.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT453' && $CMP $stdout $ftemp2; then
*******IEEE singles:**********
pzero s1 (2, 4, 8, 16)=+0, +0, +0, +0
pzero s1=+0
pzero s2 (2, 4, 8, 16)=+0, +0, +0, +0
pzero s2=+0
-zero s1=-0 s1 is -zero = 1
nan s1=QNaN s1 is nan = 1
trap nan s1=SNaN s1 is trap nan = 1
+infinity s1=+Inf s1 is +infinity = 1
-infinity s1=-Inf s1 is -infinity = 1
+max s1 (10, 16)=3.40282347e38, 1.fffffep127 s1 is norm = 1
-max s1 (10, 16)=-3.40282347e38, -1.fffffep127 s1 is norm = 1
+min s1 (10, 16)=1.40129846e-45, 1.p-149 s1 is denorm = 1
-min s1 (10,16)=-1.40129846e-45, -1.p-149 s1 is denorm = 1
s1 (10,2,4,8,16)= 5.00000000, 1.01p2, 1.1p2, 1.2p2, 1.4p2
s2 = 1.00000000e1
s1 = 5.00000000
s2 = 1.00000000e1
s1 = 5.00000000
s2 = 1.00000000e1
s1 + s2 = 1.50000000e1
s1 - s2 = -5.00000000
s2 - s1 = 5.00000000
s1 * s2 = 5.00000000e1
s1 / s2 = 5.00000000e-1
s1 == s2 = 0
s1 != s2 = 1
s1 < s2 = 1
s1 <= s2 = 1
s1 > s2 = 0
s1 >= s2 = 0
sticky status bits = 0
5.00000000 / +0 ...  got zero_division
5.00000000 / +0 = +Inf status bits = 32, 32
5.00000000 / 3.00000000 ...  got imprecise result
5.00000000 / 3.00000000 = 1.66666663 status bits = 16, 16
3.40282347e38 + 3.40282347e38 ...  got overflow
3.40282347e38 + 3.40282347e38 = +Inf status bits = 4, 4
1.40129846e-45 / 10 ...  got underflow
1.40129846e-45 / 10 = +0 status bits = 24, 8
SNaN + SNaN ...  got invalid operation
SNaN + SNaN = QNaN status bits = 3, 1
QNaN + QNaN ...  got reserved operand
QNaN + QNaN = QNaN status bits = 2, 2
sticky status bits = 0
trap mask = 0
trap mask = 63
5.00000000 / +0 = +Inf
5.00000000 / 3.00000000 = 1.66666663
3.40282347e38 + 3.40282347e38 = +Inf
1.40129846e-45 / 10 = +0
SNaN + SNaN = QNaN
QNaN + QNaN = QNaN
sticky status bits = 63
round = 0
1.23456788 + 9.99999994e-9 = 1.23456788
round = 1
1.23456776 + 9.99999994e-9 = 1.23456776
round = 2
1.23456788 + 1.00000008e-8 = 1.23456800
round = 3
1.23456776 + 9.99999994e-9 = 1.23456776
  got invalid round value
ms (from s1) = 5
s1 (from ms) = 5.00000000
*******IEEE doubles:**********
pzero d1 (2, 4, 8, 16)=+0, +0, +0, +0
pzero d1=+0
pzero d2 (2, 4, 8, 16)=+0, +0, +0, +0
pzero d2=+0
-zero d1=-0 d1 is -zero = 1
nan d1=QNaN d1 is nan = 1
trap nan d1=SNaN d1 is trap nan = 1
+infinity d1=+Inf d1 is +infinity = 1
-infinity d1=-Inf d1 is -infinity = 1
+max d1 (10, 16)=1.7976931348623157e308, 1.fffffffffffffp1023 d1 is norm = 1
-max d1 (10, 16)=-1.7976931348623157e308, -1.fffffffffffffp1023 d1 is norm = 1
+min d1 (10, 16)=4.9406564584124654e-324, 1.p-1074 d1 is denorm = 1
-min d1 (10,16)=-4.9406564584124654e-324, -1.p-1074 d1 is denorm = 1
d1 (10,2,4,8,16)= 5.0000000000000000, 1.01p2, 1.1p2, 1.2p2, 1.4p2
d2 = 1.0000000000000000e1
d1 = 5.0000000000000000
d2 = 1.0000000000000000e1
d1 = 5.0000000000000000
d2 = 1.0000000000000000e1
d1 + d2 = 1.5000000000000000e1
d1 - d2 = -5.0000000000000000
d2 - d1 = 5.0000000000000000
d1 * d2 = 5.0000000000000000e1
d1 / d2 = 5.0000000000000000e-1
d1 == d2 = 0
d1 != d2 = 1
d1 < d2 = 1
d1 <= d2 = 1
d1 > d2 = 0
d1 >= d2 = 0
sticky status bits = 0
5.0000000000000000 / +0 ...  got zero_division
5.0000000000000000 / +0 = +Inf status bits = 32, 32
5.0000000000000000 / 3.0000000000000000 ...  got imprecise result
5.0000000000000000 / 3.0000000000000000 = 1.6666666666666667 status bits = 16, 16
1.7976931348623157e308 + 1.7976931348623157e308 ...  got overflow
1.7976931348623157e308 + 1.7976931348623157e308 = +Inf status bits = 4, 4
4.9406564584124654e-324 / 10 ...  got underflow
4.9406564584124654e-324 / 10 = +0 status bits = 24, 8
SNaN + SNaN ...  got invalid operation
SNaN + SNaN = QNaN status bits = 3, 1
QNaN + QNaN ...  got reserved operand
QNaN + QNaN = QNaN status bits = 2, 2
sticky status bits = 0
trap mask = 0
trap mask = 63
5.0000000000000000 / +0 = +Inf
5.0000000000000000 / 3.0000000000000000 = 1.6666666666666667
1.7976931348623157e308 + 1.7976931348623157e308 = +Inf
4.9406564584124654e-324 / 10 = +0
SNaN + SNaN = QNaN
QNaN + QNaN = QNaN
sticky status bits = 63
round = 0
1.2345678901234567 + 3.9999999999999999e-16 = 1.2345678901234571
round = 1
1.2345678901234567 + 3.9999999999999999e-16 = 1.2345678901234569
round = 2
1.2345678901234569 + 4.0000000000000004e-16 = 1.2345678901234574
round = 3
1.2345678901234567 + 3.9999999999999999e-16 = 1.2345678901234569
  got invalid round value
md (from d1) = 5
d1 (from md) = 5.0000000000000000
*******IEEE quads:**********
pzero q1 (2, 4, 8, 16)=+0, +0, +0, +0
pzero q1=+0
pzero q2 (2, 4, 8, 16)=+0, +0, +0, +0
pzero q2=+0
-zero q1=-0 q1 is -zero = 1
nan q1=QNaN q1 is nan = 1
trap nan q1=SNaN q1 is trap nan = 1
+infinity q1=+Inf q1 is +infinity = 1
-infinity q1=-Inf q1 is -infinity = 1
+max q1 (10, 16)=1.18973149535723176508575932662800702e4932, 1.ffffffffffffffffffffffffffffp16383 q1 is norm = 1
-max q1 (10, 16)=-1.18973149535723176508575932662800702e4932, -1.ffffffffffffffffffffffffffffp16383 q1 is norm = 1
+min q1 (10, 16)=6.47517511943802511092443895822764655e-4966, 1.p-16494 q1 is denorm = 1
-min q1 (10,16)=-6.47517511943802511092443895822764655e-4966, -1.p-16494 q1 is denorm = 1
q1 (10,2,4,8,16)= 5.00000000000000000000000000000000000, 1.01p2, 1.1p2, 1.2p2, 1.4p2
q2 = 1.00000000000000000000000000000000000e1
q1 = 5.00000000000000000000000000000000000
q2 = 1.00000000000000000000000000000000000e1
q1 = 5.00000000000000000000000000000000000
q2 = 1.00000000000000000000000000000000000e1
q1 + q2 = 1.50000000000000000000000000000000000e1
q1 - q2 = -5.00000000000000000000000000000000000
q2 - q1 = 5.00000000000000000000000000000000000
q1 * q2 = 5.00000000000000000000000000000000000e1
q1 / q2 = 5.00000000000000000000000000000000000e-1
q1 == q2 = 0
q1 != q2 = 1
q1 < q2 = 1
q1 <= q2 = 1
q1 > q2 = 0
q1 >= q2 = 0
sticky status bits = 0
5.00000000000000000000000000000000000 / +0 ...  got zero_division
5.00000000000000000000000000000000000 / +0 = +Inf status bits = 32, 32
5.00000000000000000000000000000000000 / 3.00000000000000000000000000000000000 ...  got imprecise result
5.00000000000000000000000000000000000 / 3.00000000000000000000000000000000000 = 1.66666666666666666666666666666666673 status bits = 16, 16
1.18973149535723176508575932662800702e4932 + 1.18973149535723176508575932662800702e4932 ...  got overflow
1.18973149535723176508575932662800702e4932 + 1.18973149535723176508575932662800702e4932 = +Inf status bits = 4, 4
6.47517511943802511092443895822764655e-4966 / 10 ...  got underflow
6.47517511943802511092443895822764655e-4966 / 10 = +0 status bits = 24, 8
SNaN + SNaN ...  got invalid operation
SNaN + SNaN = QNaN status bits = 3, 1
QNaN + QNaN ...  got reserved operand
QNaN + QNaN = QNaN status bits = 2, 2
sticky status bits = 0
trap mask = 0
trap mask = 63
5.00000000000000000000000000000000000 / +0 = +Inf
5.00000000000000000000000000000000000 / 3.00000000000000000000000000000000000 = 1.66666666666666666666666666666666673
1.18973149535723176508575932662800702e4932 + 1.18973149535723176508575932662800702e4932 = +Inf
6.47517511943802511092443895822764655e-4966 / 10 = +0
SNaN + SNaN = QNaN
QNaN + QNaN = QNaN
sticky status bits = 63
round = 0
1.23456789012345678901234567890123455 + 1.49999999999999999999999999999999996e-34 = 1.23456789012345678901234567890123475
round = 1
1.23456789012345678901234567890123455 + 1.49999999999999999999999999999999996e-34 = 1.23456789012345678901234567890123455
round = 2
1.23456789012345678901234567890123475 + 1.50000000000000000000000000000000015e-34 = 1.23456789012345678901234567890123494
round = 3
1.23456789012345678901234567890123455 + 1.49999999999999999999999999999999996e-34 = 1.23456789012345678901234567890123455
  got invalid round value
mq (from q1) = 5
q1 (from mq) = 5.00000000000000000000000000000000000
single 5.00000000 -> double 5.0000000000000000
single 5.00000000 -> quad 5.00000000000000000000000000000000000
double 5.0000000000000000 -> single 5.00000000
double 5.0000000000000000 -> quad 5.00000000000000000000000000000000000
quad 5.00000000000000000000000000000000000 -> single 5.00000000
quad 5.00000000000000000000000000000000000 -> double 5.0000000000000000
OUTPUT453
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
        fi
fi

# Test 454.
if test $result = ok -a $start_test_number -le 454; then
	echo test 454
        cat >$test_file <<'TEST454'
println (gmatch ("aa", "aaaaa"));
TEST454
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT454' && $CMP $stdout $ftemp2; then
[0, 2, 2, 4]
OUTPUT454
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 455.
if test $result = ok -a $start_test_number -le 455; then
	echo test 455
        cat >$test_file <<'TEST455'
println (gmatch ("aa", "aaaaa", 1));
TEST455
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT455' && $CMP $stdout $ftemp2; then
[0, 2, 1, 3, 2, 4, 3, 5]
OUTPUT455
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 456.
if test $result = ok -a $start_test_number -le 456; then
	echo test 456
        cat >$test_file <<'TEST456'
var i;
for (i = 0; i < 300000; i++)
  gmatch ("aa", "aaaaa", 1);
TEST456
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT456' && $CMP $stdout $ftemp2; then
OUTPUT456
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 457.
if test $result = ok -a $start_test_number -le 457; then
	echo test 457
        cat >$test_file <<'TEST457'
gmatch ("aa", "aaaaa", nil);
TEST457
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=fail
        elif $SCMP $stderr - <<'TEST457-1'; then
test.d:1:8: run time error - invalid parameter type of `gmatch'
TEST457-1
                result=ok
        else
                result=fail
        fi
fi

# Test 458.
if test $result = ok -a $start_test_number -le 458; then
	echo test 458
        cat >$test_file <<'TEST458'
gmatch ("aa");
TEST458
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=fail
        elif $SCMP $stderr - <<'TEST458-1'; then
test.d:1:8: run time error - invalid number of actual parameters for `gmatch'
TEST458-1
                result=ok
        else
                result=fail
        fi
fi

# Test 459.
if test $result = ok -a $start_test_number -le 459; then
	echo test 459
        cat >$test_file <<'TEST459'
gmatch ("[aa", "aa");
TEST459
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=fail
        elif $SCMP $stderr - <<'TEST459-1'; then
test.d:1:8: run time error - unmatched bracket list operators in regexp
TEST459-1
                result=ok
        else
                result=fail
        fi
fi

# Test 460.
if test $result = ok -a $start_test_number -le 460; then
	echo test 460
        cat >$test_file <<'TEST460'
gmatch (nil, "aa");
TEST460
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=fail
        elif $SCMP $stderr - <<'TEST460-1'; then
test.d:1:8: run time error - invalid parameter type of `gmatch'
TEST460-1
                result=ok
        else
                result=fail
        fi
fi

# Test 461.
if test $result = ok -a $start_test_number -le 461; then
	echo test 461
        cat >$test_file <<'TEST461'
gmatch ("aa", nil);
TEST461
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=fail
        elif $SCMP $stderr - <<'TEST461-1'; then
test.d:1:8: run time error - invalid parameter type of `gmatch'
TEST461-1
                result=ok
        else
                result=fail
        fi
fi

# Test 462.
if test $result = ok -a $start_test_number -le 462; then
	echo test 462
        cat >$test_file <<'TEST462'
put (getf());
TEST462
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT462' && $CMP $stdout $ftemp2; then
abcd
OUTPUT462
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 463.
if test $result = ok -a $start_test_number -le 463; then
	echo test 463
        cat >$test_file <<'TEST463'
var c, f = open ("test.d", "r");
put (fgetf (f));
TEST463
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT463' && $CMP $stdout $ftemp2; then
var c, f = open ("test.d", "r");
put (fgetf (f));
OUTPUT463
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 464.
if test $result = ok -a $start_test_number -le 464; then
	echo test 464
        cat >$test_file <<'TEST464'
put (getf ());
put (getf ());
TEST464
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT464' && $CMP $stderr $ftemp2; then
test.d:2:11: run time error - EOF occured in `getf'
OUTPUT464
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 465.
if test $result = ok -a $start_test_number -le 465; then
	echo test 465
        cat >$test_file <<'TEST465'
var c, f=open ("test.d", "r");
for (;1;)
  put (fgetf (f));
TEST465
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT465' && $CMP $stderr $ftemp2; then
test.d:3:14: run time error - EOF occured in `fgetf'
OUTPUT465
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 466.
if test $result = ok -a $start_test_number -le 466; then
	echo test 466
        cat >$test_file <<'TEST466'
var c = getf (nil);
TEST466
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT466' && $CMP $stderr $ftemp2; then
test.d:1:14: run time error - invalid parameter type of `getf'
OUTPUT466
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 467.
if test $result = ok -a $start_test_number -le 467; then
	echo test 467
        cat >$test_file <<'TEST467'
var c = fgetf ();
TEST467
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT467' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid number of actual parameters for `fgetf'
OUTPUT467
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 468.
if test $result = ok -a $start_test_number -le 468; then
	echo test 468
        cat >$test_file <<'TEST468'
var c = fgetf (nil);
TEST468
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT468' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid parameter type of `fgetf'
OUTPUT468
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 469.
if test $result = ok -a $start_test_number -le 469; then
	echo test 469
        cat >$test_file <<'TEST469'
var c = fgetf (stdin, nil);
TEST469
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT469' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid parameter type of `fgetf'
OUTPUT469
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 470.
if test $result = ok -a $start_test_number -le 470; then
	echo test 470
        cat >$test_file <<'TEST470'
println (char ('a'));
println (char ("97"));
TEST470
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT470' && $CMP $stdout $ftemp2; then
'a'
'a'
OUTPUT470
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 471.
if test $result = ok -a $start_test_number -le 471; then
	echo test 471
        cat >$test_file <<'TEST471'
println (int (10.0));
println (int ("10"));
TEST471
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT471' && $CMP $stdout $ftemp2; then
10
10
OUTPUT471
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 472.
if test $result = ok -a $start_test_number -le 472; then
	echo test 472
        cat >$test_file <<'TEST472'
println (float (10.5));
println (float ("10.5"));
println (float (10));
TEST472
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT472' && $CMP $stdout $ftemp2; then
10.5
10.5
10
OUTPUT472
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 473.
if test $result = ok -a $start_test_number -le 473; then
	echo test 473
        cat >$test_file <<'TEST473'
println (char (nil));
TEST473
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT473' && $CMP $stderr $ftemp2; then
test.d:1:10: run time error - invalid type of operand of char (...)
OUTPUT473
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 474.
if test $result = ok -a $start_test_number -le 474; then
	echo test 474
        cat >$test_file <<'TEST474'
println (char (tab []));
TEST474
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT474' && $CMP $stderr $ftemp2; then
test.d:1:16: invalid operand type in char (...)
OUTPUT474
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 475.
if test $result = ok -a $start_test_number -le 475; then
	echo test 475
        cat >$test_file <<'TEST475'
println (char (300));
TEST475
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT475' && $CMP $stderr $ftemp2; then
test.d:1:10: system error - result too big (small): `int-to-char conversion'
OUTPUT475
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 476.
if test $result = ok -a $start_test_number -le 476; then
	echo test 476
        cat >$test_file <<'TEST476'
println (char ("30000000000000000"));
TEST476
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT476' && $CMP $stderr $ftemp2; then
test.d:1:10: system error - result too big (small): `string-to-int conversion'
OUTPUT476
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 477.
if test $result = ok -a $start_test_number -le 477; then
	echo test 477
        cat >$test_file <<'TEST477'
println (int (nil));
TEST477
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT477' && $CMP $stderr $ftemp2; then
test.d:1:10: run time error - invalid type of operand of int (...)
OUTPUT477
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 478.
if test $result = ok -a $start_test_number -le 478; then
	echo test 478
        cat >$test_file <<'TEST478'
println (int (tab []));
TEST478
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT478' && $CMP $stderr $ftemp2; then
test.d:1:15: invalid operand type in int (...)
OUTPUT478
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 479.
if test $result = ok -a $start_test_number -le 479; then
	echo test 479
        cat >$test_file <<'TEST479'
println (int ("30000000000000000"));
TEST479
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT479' && $CMP $stderr $ftemp2; then
test.d:1:10: system error - result too big (small): `string-to-int conversion'
OUTPUT479
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 480.
if test $result = ok -a $start_test_number -le 480; then
	echo test 480
        cat >$test_file <<'TEST480'
println (float (nil));
TEST480
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT480' && $CMP $stderr $ftemp2; then
test.d:1:10: run time error - invalid type of operand of float (...)
OUTPUT480
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 481.
if test $result = ok -a $start_test_number -le 481; then
	echo test 481
        cat >$test_file <<'TEST481'
println (float (tab []));
TEST481
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT481' && $CMP $stderr $ftemp2; then
test.d:1:17: invalid operand type in float (...)
OUTPUT481
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 482.
if test $result = ok -a $start_test_number -le 482; then
	echo test 482
        cat >$test_file <<'TEST482'
println (float ("1e500"));
TEST482
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT482' && $CMP $stderr $ftemp2; then
test.d:1:10: system error - result too big (small): `string-to-float conversion'
OUTPUT482
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 483.
if test $result = ok -a $start_test_number -le 483; then
	echo test 483
        cat >$test_file <<'TEST483'
println (float ("1e-500"));
TEST483
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT483' && $CMP $stdout $ftemp2; then
0
OUTPUT483
                        result=ok
                else
                        result=fail
                fi
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT483-1' && $CMP $stderr $ftemp2; then
test.d:1:10: system error - result too big (small): `string-to-float conversion'
OUTPUT483-1
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 484.
if test $result = ok -a $start_test_number -le 484; then
	echo test 484
        cat >$test_file <<'TEST484'
putln (version);
TEST484
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                regex="^[0-9]\.[0-9][0-9]$"
                echo '      ' egrep \'$regex\' $stdout
                if egrep "$regex" $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 485.
if test $result = ok -a $start_test_number -le 485; then
	echo test 485
        cat >$test_file <<'TEST485'
var objs_number = 0;
class object {
  priv var n = objs_number;
  objs_number++;
  putln ("creating ", n);
  priv fun destroy {objs_number--; putln ("destroying ", n);}
}

var i;
for (i = 0; i < 20; i++)
  object ();
gc ();
putln (objs_number);
TEST485
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT485' && $CMP $stdout $ftemp2; then
creating 0
creating 1
creating 2
creating 3
creating 4
creating 5
creating 6
creating 7
creating 8
creating 9
creating 10
creating 11
creating 12
creating 13
creating 14
creating 15
creating 16
creating 17
creating 18
creating 19
destroying 0
destroying 1
destroying 2
destroying 3
destroying 4
destroying 5
destroying 6
destroying 7
destroying 8
destroying 9
destroying 10
destroying 11
destroying 12
destroying 13
destroying 14
destroying 15
destroying 16
destroying 17
destroying 18
destroying 19
0
OUTPUT485
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 486.
if test $result = ok -a $start_test_number -le 486; then
	echo test 486
        cat >$test_file <<'TEST486'
put (sprint (nil));put (" ");
put (sprint (10));put (" ");
put (sprint (10.2e10));put (" ");
put (sprint ('c'));put (" ");
put (sprintln ("ssss"));
put (sprintln (["aaa", "bbb", "ccc"]));
put (sprintln (["v1", tab ["key":"val", tab ["key1":"val1"]]]));
fun f {}
put (sprintln (f));
class c {}
put (sprintln (c));
put (sprintln (c ()));
var stop;
stop = 0;
thread t {wait (stop);}
put (sprintln (t()));
wait (1) stop = 1;
TEST486
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT486' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+11 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", tab ["key":"val", tab ["key1":"val1"]:nil]]
fun f
class c
instance c()
thread 1 t()
OUTPUT486
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT486-1' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+011 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", tab ["key":"val", tab ["key1":"val1"]:nil]]
fun f
class c
instance c()
thread 1 t()
OUTPUT486-1
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT486-2' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+11 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", tab [tab ["key1":"val1"]:nil, "key":"val"]]
fun f
class c
instance c()
thread 1 t()
OUTPUT486-2
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT486-3' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+011 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", tab [tab ["key1":"val1"]:nil, "key":"val"]]
fun f
class c
instance c()
thread 1 t()
OUTPUT486-3
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 487.
if test $result = ok -a $start_test_number -le 487; then
	echo test 487
        cat >$test_file <<'TEST487'
put (sput (10));put (" ");
put (sput (10.2e10, " "));
put (sputln ('c', " ", "ssss"));
TEST487
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT487' && $CMP $stdout $ftemp2; then
10 1.02e+11 c ssss
OUTPUT487
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT487a' && $CMP $stdout $ftemp2; then
10 1.02e+011 c ssss
OUTPUT487a
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 488.
if test $result = ok -a $start_test_number -le 488; then
	echo test 488
        cat >$test_file <<'TEST488'
sputln (nil);
TEST488
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT488' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `sputln'
OUTPUT488
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 489.
if test $result = ok -a $start_test_number -le 489; then
	echo test 489
        cat >$test_file <<'TEST489'
sput ([10]);
TEST489
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT489' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `sput'
OUTPUT489
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 490.
if test $result = ok -a $start_test_number -le 490; then
	echo test 490: More error recovery with 2 
        cat >$test_file <<'TEST490'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_recovery (0);
p.set_grammar (g, 1);

var str = "a+a*(a*)+(*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

println (root);
exit (p.ambiguous_p);
TEST490
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT490' && $CMP $stdout $ftemp2; then
syntax error on token #7 (41) -- ignore 0 tokens starting with token #-1
nil
OUTPUT490
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 491.
if test $result = ok -a $start_test_number -le 491; then
	echo test 491: Parsing expression without lookahead
        cat >$test_file <<'TEST491'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

class tok (code) { use token former code; var order;}

p.set_debug (0);
println (p.set_lookahead (0));
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(a+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = tok (str[i] + 0);
  inp [i].order = i;
}

fun error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

fun pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
println (p.set_lookahead (1));
exit (p.ambiguous_p);
TEST491
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT491' && $CMP $stdout $ftemp2; then
1
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      $term(97, 5)
      mult(
        $term(97, 7)
        $term(97, 9)
      )
    )
  )
)
0
OUTPUT491
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 492.
if test $result = ok -a $start_test_number -le 492; then
	echo test 492: More parameter exception.
        cat >$test_file <<'TEST492'
var p = parser ();
p.set_lookahead ("0");
p.set_debug ("0");
p.set_lookahead (nil);
exit (0);
TEST492
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT492' && $CMP $stderr $ftemp2; then
test.d:4:17: run time error - invalid parameter type of `set_lookahead'
OUTPUT492
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 493.
if test $result = ok -a $start_test_number -le 493; then
	echo test 493: gethostinfo.
        cat >$test_file <<'TEST493'
include "socket";
var hi = sockets.gethostinfo (argv [0]);
println (hi.name, hi.aliases, hi.ipaddrs);
exit (0);
TEST493
        if uname | fgrep CYGWIN; then
            echo '      ' "$DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@  $test_file 127.0.0.1 >$stdout"
            if $DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file 127.0.0.1 >$stdout; then
                echo '      ' egrep '^".+"\[.*\]\[".+"\]$' $stdout
                if egrep '^".+"\[.*\]\[".+"\]$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
            else
                result=fail
            fi
        else
            echo '      ' "$DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file 127.0.0.1 >$stdout"
            if $DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 127.0.0.1 >$stdout; then
                echo '      ' egrep '^".+"\[.*\]\[".+"\]$' $stdout
                if egrep '^".+"\[.*\]\[".+"\]$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
            else
                result=fail
            fi
	fi
fi

# Test 494.
if test $result = ok -a $start_test_number -le 494; then
	echo test 494: getservbyname.
        cat >$test_file <<'TEST494'
include "socket";

var s = sockets.getservbyname (argv[0], "tcp");
if (s != nil)
  println (s.name, s.aliases, s.port, s.proto);
exit (0);
TEST494
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@  $test_file time >$stdout"
        if $DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file time >$stdout; then
                echo '      ' egrep '^".+"\[".+"\]37"tcp"$' $stdout
                if egrep '^".+"\[".+"\]37"tcp"$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     else
        echo '      ' "$DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file time >$stdout"
        if $DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file time >$stdout; then
                echo '      ' egrep '^".+"\[".+"\]37"tcp"$' $stdout
                if egrep '^".+"\[".+"\]37"tcp"$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     fi
fi

# Test 495.
if test $result = ok; then
	echo test 495: Skipping daytime udp.
elif test $result = ok -a $start_test_number -le 495; then
	echo test 495: daytime udp.
        cat >$test_file <<'TEST495'
include "socket";

var str, s = sockets.dgram_client ();
s.sendto ("get me date", "tock.usno.navy.mil", 13);
var d = s.recvfrom (300);
putln (d.str);
exit (0);
TEST495
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@  $test_file time >$stdout"
        if $DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file time >$stdout; then
                echo '      ' egrep '^[A-Za-z]+ [A-Za-z]+ [0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9]' $stdout
                if egrep '^[A-Za-z]+ [A-Za-z]+ [0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9]' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     else
        echo '      ' "$DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file time >$stdout"
        if $DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file time >$stdout; then
                echo '      ' egrep '^[A-Za-z]+ [A-Za-z]+ [0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9]' $stdout
                if egrep '^[A-Za-z]+ [A-Za-z]+ [0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9]' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     fi
fi

# Test 496.
if test $result = ok -a $start_test_number -le 496; then
	echo test 496: daytime udp.
        cat >$test_file <<'TEST496'
include "socket";

var str, s = sockets.stream_client ("time.ien.it", 13);

str = "";
try {
  for (;;) {str @= s.read (20);}
} catch (socket_eof_except) {
}

putln (str);
exit (0);
TEST496
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@  $test_file time >$stdout"
        if $DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file time >$stdout; then
                echo '      ' egrep '(^[A-Za-z]+ [A-Za-z]+[ ]+[0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [0-9][0-9][0-9][0-9])|(^[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z0-9]+)' $stdout
                if egrep '(^[A-Za-z]+ [A-Za-z]+[ ]+[0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [0-9][0-9][0-9][0-9])|(^[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z0-9]+)' $stdout; then
                        result=ok
                else
			cat $stdout
                        result=fail
                fi
        else
                result=fail
        fi
     else
        echo '      ' "$DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file time >$stdout"
        if $DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file time >$stdout; then
                echo '      ' egrep '(^[A-Za-z]+ [A-Za-z]+[ ]+[0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [0-9][0-9][0-9][0-9])|(^[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z0-9]+)' $stdout
                if egrep '(^[A-Za-z]+ [A-Za-z]+[ ]+[0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [0-9][0-9][0-9][0-9])|(^[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z0-9]+)' $stdout; then
                        result=ok
                else
			cat $stdout
                        result=fail
                fi
        else
                result=fail
        fi
     fi
fi

# Test 497.
if test $result = ok -a $start_test_number -le 497; then
	echo test 497: host is unknown
        cat >$test_file <<'TEST497'
include "socket";
var cl, send, rec, i;
cl = sockets.stream_client ("abracadabra", 10003);
exit (0);
TEST497
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file 2>$stderr"
        if $DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file 2>$stderr >$stdout; then
                result=fail
        else
		sed 's,\\,/,g' $stderr|sed 's%^.*socket.d%@srcdir@/socket.d%' >$ftemp
                echo '      ' $CMP $ftemp $ftemp2
                if cat >$ftemp2 <<'OUTPUT497' && $CMP $ftemp $ftemp2; then
In file processed from test.d:1:18:
@srcdir@/socket.d:51:7: host is unknown
OUTPUT497
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT497-2' && $CMP $ftemp $ftemp2; then
In file processed from test.d:1:18:
@srcdir@/socket.d:47:45: connection timed out
OUTPUT497-2
                        result=ok
                else
                        result=fail
                fi
        fi
     else
        echo '      ' "$DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 2>$stderr"
        if $DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 2>$stderr >$stdout; then
                result=fail
        else
		sed 's,\\,/,g' $stderr|sed 's%^.*socket.d%@srcdir@/socket.d%' >$ftemp
                echo '      ' $CMP $ftemp $ftemp2
                if cat >$ftemp2 <<'OUTPUT497-3' && $CMP $ftemp $ftemp2; then
In file processed from test.d:1:18:
@srcdir@/socket.d:51:7: host is unknown
OUTPUT497-3
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT497-4' && $CMP $ftemp $ftemp2; then
In file processed from test.d:1:18:
@srcdir@/socket.d:47:45: connection timed out
OUTPUT497-4
                        result=ok
                else
                        result=fail
                fi
        fi
     fi
fi

# Test 498.
if test $result = ok -a $start_test_number -le 498; then
	echo test 498: Contexts and internal caches.
        cat >$test_file <<'TEST498'
class a (i, n) {
  fun ex {
    putln ("before = ", i);
    if (n != nil) n.ex ();
    putln ("after = ", i);
  }
}

var o = a (1, a (10, nil));

o.ex ();
TEST498
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT498' && $CMP $stdout $ftemp2; then
before = 1
before = 10
after = 10
after = 1
OUTPUT498
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 499.
if test $result = ok -a $start_test_number -le 499; then
	echo test 499: getservbyport.
        cat >$test_file <<'TEST499'
include "socket";

var s = sockets.getservbyport (argv [0] + 0, "tcp");
if (s != nil)
  println (s.name, s.aliases, s.port, s.proto);
exit (0);
TEST499
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@  $test_file 37 >$stdout"
        if $DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file 37 >$stdout; then
                echo '      ' test -z "\`cat $stdout\`" '|| egrep ^".+"\[".+"\]37"tcp"$' $stdout
                if test -z "`cat $stdout`" || egrep '^".+"\[".+"\]37"tcp"$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     else
        echo '      ' "$DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file 37 >$stdout"
        if $DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 37 >$stdout; then
                echo '      ' test -z "\`cat $stdout\`" '|| egrep ^".+"\[".+"\]37"tcp"$' $stdout
                if test -z "`cat $stdout`" || egrep '^".+"\[".+"\]37"tcp"$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     fi
fi

# Test 500.
if test $result = ok -a $start_test_number -le 500; then
	echo test 500: getservbyname for unknown name.
        cat >$test_file <<'TEST500'
include "socket";

var s = sockets.getservbyname (argv[0], "tcp");
if (s != nil)
  println (s.name, s.aliases, s.port, s.proto);
exit (0);
TEST500
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@  $test_file abracadabra >$stdout"
        if $DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file abracadabra >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT500' && $CMP $stdout $ftemp2; then
OUTPUT500
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     else
        echo '      ' "$DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file abracadabra >$stdout"
        if $DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file abracadabra >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT500a' && $CMP $stdout $ftemp2; then
OUTPUT500a
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     fi
fi

# Test 501.
if test $result = ok -a $start_test_number -le 501; then
	echo test 501: getservbyport for unknown port.
        cat >$test_file <<'TEST501'
include "socket";

var s = sockets.getservbyport (argv[0] + 0, "tcp");
if (s != nil)
  println (s.name, s.aliases, s.port, s.proto);
exit (0);
TEST501
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@  $test_file 313131 >$stdout"
        if $DINO -L./d_ipcerr.dll -L./d_socket.dll -I@srcdir@ $test_file 313131 >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT501' && $CMP $stdout $ftemp2; then
OUTPUT501
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     else
        echo '      ' "$DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file 313131 >$stdout"
        if $DINO -L./d_ipcerr.@EXTERN_LIB_SUFFIX@ -L./d_socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 313131 >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT501a' && $CMP $stdout $ftemp2; then
OUTPUT501a
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     fi
fi

# Test 502.
if test $result = ok -a $start_test_number -le 502; then
	echo test 502: Final destroying by implicit program finish.
        cat >$test_file <<'TEST502'
class c {
  putln ("creating instance");
  fun destroy {putln ("destroying instance");}
}

var i = c ();
TEST502
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT502' && $CMP $stdout $ftemp2; then
creating instance
destroying instance
OUTPUT502
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 503.
if test $result = ok -a $start_test_number -le 503; then
	echo test 503: Final destroying by zero exit.
        cat >$test_file <<'TEST503'
class c {
  putln ("creating instance");
  fun destroy {putln ("destroying instance");}
}

var i = c ();
exit (0);
TEST503
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT503' && $CMP $stdout $ftemp2; then
creating instance
destroying instance
OUTPUT503
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 504.
if test $result = ok -a $start_test_number -le 504; then
	echo test 504: Final destroying by nonzero exit.
        cat >$test_file <<'TEST504'
class c {
  putln ("creating instance");
  fun destroy {putln ("destroying instance");}
}

var i = c ();
exit (1);
TEST504
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT504' && $CMP $stdout $ftemp2; then
creating instance
destroying instance
OUTPUT504
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 505.
if test $result = ok -a $start_test_number -le 505; then
	echo test 505: Final destroying by throw.
        cat >$test_file <<'TEST505'
class c {
  putln ("creating instance");
  fun destroy {putln ("destroying instance");}
}

var i = c ();
throw except ();
TEST505
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT505' && $CMP $stdout $ftemp2; then
creating instance
destroying instance
OUTPUT505
	           if cat >$ftemp2 <<'OUTPUT505a' && $CMP $stderr $ftemp2; then
test.d:7:1: run time error - exception except has not been processed
OUTPUT505a
                        result=ok
                   else
                        result=fail
                   fi
                else
                        result=fail
                fi
        fi
fi

# Test 506.
if test $result = ok -a $start_test_number -le 506; then
	echo test 506: Serhei\'s interpereter -- big program - 1500 lines.
	echo '      ' rm -rf $tempdir
	echo '      ' mkdir $tempdir
	if rm -rf $tempdir && mkdir $tempdir; then
	  echo '      ' Forming Grip interpriter files and test program in $tempdir
	  cat >$tempdir/anode_work.d <<'TEST506'
/***********************************************************
** These functions are used to translate a given object   **
** of class anode() to the equivalent object of class     **
** prog().                                                **
***********************************************************/
// For elaborate dumpings:
var dumpfl = 0;
fun bad_anode; fun parse_instruction_anode; fun check_block;
fun parse_expression_anode; fun flatten;
// Here is the function to parse a program anode. It is very trivial and
// is included for the client's convenience.
fun parse_program_anode (program_anode, local_dumpfl = 1) {
  // Initialize the dumpings.
  dumpfl = local_dumpfl;
  var object_program = prog (), intermediate_view;
  if (program_anode.name != "program") { // Wrong node.
    putln ("! Wrong grammar. Root anode name is : ", program_anode.name);
    bad_anode ();
  }
  if (dumpfl) putln ("& Entering translation phase.");
  intermediate_view =
  parse_instruction_anode (program_anode.transl[0]);
  // If we parsed a block, we return it as the object program so as to
  // have a bit of efficiency.
  if (intermediate_view. name == "block")
    object_program = intermediate_view.args[0];
  // Otherwise we copy the instruction.
  else object_program.exec = [intermediate_view];
  if (dumpfl)
    putln ("& Entering semantical checking phase.");
  object_program = check_block (object_program);
  if (dumpfl) {
    if (global_errfl) putln ("! Semantic check failed.");
    else putln ("& Semantic check sucessful.");
  }
  return object_program;
}
/* The function parse_instruction_anode() is used to parse an instruction. */
fun parse_instruction_anode (instruction_anode) {
  // We declare a variable to work on the result, which is an object of class
  // instr().
  if (dumpfl) {
    putln ("@ Initializing instruction parsing operation with node:");
    print_anode (instruction_anode);
  }
  var result = instr ();
  if (instruction_anode.name == "assign") { // Assignment statement.
    if (dumpfl) putln ("* Identified assignment statement.");
    result.name = "assign";
    result.args = [3 : nil];
    result.args [0] = instruction_anode.transl [0].transl [0].transl;
    result.args [2] = parse_expression_anode (instruction_anode.transl[1]);
    result.args [1] = (instruction_anode.transl [0].transl [0].transl.type0
                      == 'I' ?
                      instruction_anode.transl [0].transl :
                      bad_anode () );
    if (instruction_anode.transl [0].name == "array")
      result.args [1] = parse_expression_anode (instruction_anode.
                       transl [0].transl [1]);
    else if (instruction_anode.transl [0].name == "varac") {
      result.args [1] = expression ();
      result.args [1].opr = "num";
      result.args [1].opa1 = tok (0);
      // For compatibility with the semantic checker.
      result.args [1].opa1.type0 = "I";
      result.args [1].opa1.value = "0";
      result.args [1].opa2 = "integer";
    } else bad_anode ();
  } else if (instruction_anode.name == "vblock") {
    // Parse the block now.
    if (dumpfl) putln ("@ Initiating block parsing.");
    result.name = "block";
    result.args = [1 : nil];
    result.args [0] = prog ();
    // A block should be an object of class prog().
    // Process the declarations:
    if (dumpfl) putln ("@ Processing declarations...");
    var declarations = flatten (instruction_anode.transl[0], 2),
    current_identifier_declared_flag = new tab[];
    for (var current_declaration_processed = 0;
         current_declaration_processed < #declarations;
         current_declaration_processed++) {
      // "Flatten" the identifiers we want to declare.
      var identifiers_on_wait = flatten (
                                declarations [current_declaration_processed]
                              . transl[0], 1),
      // Analyze the specification.
      current_specification_analysis =
      component (declarations [current_declaration_processed]
                . transl [1]. transl [0],
                declarations [current_declaration_processed]
                . transl [1]. name);
      // We just assigned an object of class anode() where it is
      // not needed, so we must eradicate that.

      // Here we declare a shortcut variable used to declare arrays.
      var array_translation = current_specification_analysis.value;

      // Declare arrays here by deriving their size.
      if (current_specification_analysis.type0 != "constant")
        current_specification_analysis.arrfl +=
                      ( array_translation.name == "$nil" ? 0
                      : array_translation.name == "$term" ?
                        array_translation.transl.value
                      : bad_anode () ); // The grammar is corrupted.
      current_specification_analysis.value =
                   ( current_specification_analysis.type0 == "constant" ?
                     +array_translation.transl.value
                   : array_translation.name == "$nil" ? 0
                   : [current_specification_analysis.arrfl : 0]
                   // For arrays.
                   );
      // Now that we have the specification, we may introduce the identifiers
      // into the environment.
      if (dumpfl) putln ("@ Declaring identifiers...");
      for (var current_identifier_processing = 0;
           current_identifier_processing < #identifiers_on_wait;
           current_identifier_processing++) {
        if (identifiers_on_wait [current_identifier_processing]
           . transl [0].transl in current_identifier_declared_flag) {
          if (dumpfl) putln ("! Identifier declared twice.");
          put (program_file, ":",
               identifiers_on_wait [current_identifier_processing]
               . transl [0].transl.line_num, ":", identifiers_on_wait
               [current_identifier_processing]. transl [0].transl.char_num,
               ": ");
          grip_error ("Attempt to declare an identifier twice.");
        }
        result.args [0].vartable
        [identifiers_on_wait [current_identifier_processing]
        . transl [0].transl] = new current_specification_analysis;
        // Now we make a note of the fact that we have just declared the
        // identifier to solve the fact that the semantic checker that is
        // applied later to the block has no way of knowing that we attempted
        // to declare an identifier twice, so we check it right now.
        current_identifier_declared_flag
        [identifiers_on_wait
        [current_identifier_processing].transl [0].transl] = 1;
      }
    }
    // In case we stumble on a wrong node.
    /* The rest is pretty easy sailing. All we have to do now
    is let the instructions be parsed, and convert tokens in the table to
    strings. */
    var current_declaration, declarations_to_convert =
    keys (result.args [0].vartable);
    if (dumpfl) putln ("* Convert values : ",
                       sprint (declarations_to_convert));
    for (var current_declaration_num = 0;
         current_declaration_num < #declarations_to_convert;
         current_declaration_num++) {
      current_declaration = declarations_to_convert [current_declaration_num];
      if (dumpfl)
        putln ("* Conversion of ",
               sprint (current_declaration));
      if (type (current_declaration) == obj) {
        if (dumpfl)
          putln ("* Conversion worthy to ",
                 sprint (current_declaration.value));
        result.args [0].vartable [current_declaration.value] =
        result.args [0].vartable [current_declaration];
        result.args [0].vartable =
        del (result.args [0].vartable, current_declaration);
      } else if (dumpfl) putln ("* Conversion unworthy.");
    }
    if (dumpfl) {
      putln ("* Result variables :");
      println (result.args [0].vartable);
      putln ("@ Parsing the instructions...");
    }
    var instructions = flatten (instruction_anode.transl [1],
                                1);
    // We recursively call parse_instruction_anode() for each instruction.
    for (var current_instruction_number = 0;
         current_instruction_number < #instructions;
         current_instruction_number++) {
      result.args [0].exec @=
      [parse_instruction_anode (instructions [current_instruction_number].
                               transl [0])];
    }
    fun redeclare_block;
    // Now we must declare the configuration of variables here for the
    // other blocks.
    if (dumpfl) putln ("@ Redeclaring underlying blocks...");
    result.args [0] = redeclare_block (result.args [0]);
    fun redeclare_block (block) {
      fun do_redeclaration (block_to_redeclare) {
        // We have a block we need to define with synchronized variables.
        var current_identifier_processed_key;
        for (current_identifier_processed_key: block.vartable)
          if (!(current_identifier_processed_key
	        in block_to_redeclare.vartable)) {
            block_to_redeclare.vartable [current_identifier_processed_key] =
            block.vartable [current_identifier_processed_key];
          }
          redeclare_block (block_to_redeclare);
      }
      fun do_instruction (instr) {
        if (instr.name == "block") {
          do_redeclaration (instr.args [0]);
        } else if (instr.name == "for") {
          do_instruction (instr.args [0]);
          do_instruction (instr.args [2]);
          do_instruction (instr.args [3]);
        } else if (instr.name == "cond") {
          for (var current_alternative_processing = 1;
               current_alternative_processing < #instr.args;
               current_alternative_processing += 2)
            do_instruction (instr.args [current_alternative_processing]);
        }
      }
      try {
        for (var current_candidate_number = 0;
             current_candidate_number < #block.exec;
             current_candidate_number++)
          do_instruction (block.exec [current_candidate_number]);
      } catch ( error ) {
        if (dumpfl) putln ("! Synchronization of declarations failed.");
        bad_anode();
      }
      return block;
    }
    if (dumpfl) putln ("@ Block parsing over.");
    // Now we are done with our work on the block.
  } else if (instruction_anode.name == "condit") { // The GRIP conditional.
    /* In general, a GRIP conditional is written like this:
       'cond' '{'
        (<condition> <statement>)...
        ['else'      <statement>]
       '}'
       Not unlike the LISP version. */
       if (dumpfl) putln ("* Processing conditional.");
       // Do any initial poking around with the nodes:
       result = instr ();
       result.name = "cond";
       var option_list = flatten (instruction_anode.transl [0], 2);
       /* Now that we've done that, let's translate that conditional.
       Args[] for a cond statement look like this:
        [condition, statement,...]
       and the else part is represented by a expression evaluating to 1. */
       for (var current_option_number = 0;
            current_option_number < #option_list;
            current_option_number++) {
         var temp, current_parsed_option;
         if (option_list [current_option_number].name == "elsif")
           temp = parse_expression_anode (option_list [current_option_number].
                                          transl [0]);
         else if (option_list [current_option_number].name == "else") {
           temp = expression ();
           temp.opr = "num";
           temp.opa1 = tok (3);
           temp.opa1.type0 = 'I';
           temp.opa1.value = "1";
           temp.opa2 = "integer";
         } else bad_anode ();
         result.args @= [temp, parse_instruction_anode
                        (option_list [current_option_number].transl [1])];
       }
  } else if (instruction_anode.name == "foritr") {
  /* The GRIP for statement is exactly like the C one,
     except for the fact that a guard expression is REQUIRED.
     The internal representation is self-explanatory and represented
     by the tuple [initialization, guard, increment, body]. */
    // This is a quite trivial process:
    if (dumpfl) putln ("* For loop identified.");
    result.name = "for";
    result.args = [parse_instruction_anode (instruction_anode.transl [0]),
                   parse_expression_anode  (instruction_anode.transl [1]),
                   parse_instruction_anode (instruction_anode.transl [2]),
                   parse_instruction_anode (instruction_anode.transl [3])];
  /* The remaining commands are very trivial: The put statement, and the
     empty statement. */
  } else if (instruction_anode.name == "output") {
  /* The put statement outputs all its parameters with an additional newline
     character at the end. */
    // Trivial stuff first:
    if (dumpfl) putln ("* Analyzing output statement.");
    result.name = "put";
    var objects_on_wait_list = flatten (instruction_anode.transl [0],
                                        1);
    // Now, a loop to deal with every object we want to output.
    for (var current_object_processing = 0;
         current_object_processing < #objects_on_wait_list;
         current_object_processing++) {
      if (objects_on_wait_list [current_object_processing].name
          == "expressionel")
        result.args @= [parse_expression_anode
                       (objects_on_wait_list
                       [current_object_processing].transl [0])];
      else if (objects_on_wait_list [current_object_processing].name
               == "stringel") {
        var temp = expression ();
        temp.opr = "num";
        temp.opa1 = objects_on_wait_list [current_object_processing].transl[0]
                                         . transl;
        temp.opa2 = "string";
        result.args @= [temp];
      } else {
        if (dumpfl) putln ("! Wrong instruction node, name : ",               
                           instruction_anode.name);
        bad_anode ();
      }
    }
  } else if (instruction_anode.name == "$nil") {
    // The empty statement is represented by a nil-anode.
    if (dumpfl) putln ("* Conversion $nil -> empty statement.");
    result.name = "empty";
  /* If we get an unknown node, we finish with a fatal error message. */
  } else {
    if (dumpfl) putln ("! Unknown node name : ", instruction_anode.name);
    bad_anode ();
  }
  return result; // Now the result is returned.
}

fun parse_expression_anode (expression_anode) {
  /* This function parses an expression node into an object of
     class expression(). It can take both a factor and an expression. */
  if (dumpfl) {
    putln ("@ Initiating expression parsing with node :");
    print_anode (expression_anode);
  }
  // A variable on which to work and then return.
  var result = expression ();
  // For describing a factor.
  if (expression_anode.name == "factor") {
    if (dumpfl) putln ("* Identified a factor.");
    if (expression_anode.transl [0].name == "$term") { // Literal numbers.
      if (dumpfl) putln ("* Found literal number.");
      result.opr = "num";
      result.opa1 = expression_anode.transl [0].transl;
      result.opa2 = (expression_anode.transl [0].transl.value ==
                     int (expression_anode.transl [0].transl.value) ?
                     "integer" : "real");
    } else if (expression_anode.transl [0].name == "varac") {
      // Variable acessing.
      result.opr = "var";
      result.opa1 = expression_anode.transl [0].transl [0].transl;
      result.opa2 = expression ();
      result.opa2.opr = "num";
      result.opa2.opa1 = tok (3);
      result.opa2.opa1.type0 = 'N';
      result.opa2.opa1.value = "0";
      result.opa2.opa2 = "integer";
      if (dumpfl) putln ("* Parsed an variable reference.");
    } else if (expression_anode.transl [0].name == "array") {
      // Array referencing -- done by the same operator.
      result.opr = "var";
      result.opa1 = expression_anode.transl [0].transl [0].transl;
      result.opa2 = parse_expression_anode
      (expression_anode.transl [0].transl [1]);
      if (dumpfl) putln ("* Parsed an array reference.");
    } else if (expression_anode.transl [0].name == "expression" ||
               expression_anode.transl [0].name == "double" ||
               expression_anode.transl [0].name == "single") {
      // We have a parenthesized expression for which we just recursively
      // invoke parse_expression_anode().
      result = parse_expression_anode (expression_anode.transl [0]);
      if (dumpfl) putln ("* Processed parenthesized expression.");
    } else {
      if (dumpfl) putln ("! Bad node, name is ", expression_anode.name);
      bad_anode ();
    }
  } else if (expression_anode.name == "double") { // Binary operators.
    result.opr = (expression_anode.transl [1].transl.code == 21 ? // Plus.
                  "add" :
                  expression_anode.transl [1].transl.code == 22 ? // Minus.
                  "sub" :
                  expression_anode.transl [1].transl.code == 23 ? // Times.
                  "mul" :
                  expression_anode.transl [1].transl.code == 24 ?
                  // Division.
                  "div" :
                  expression_anode.transl [1].transl.code == 26 ?
                  // Logical or.
                  "or " :
                  expression_anode.transl [1].transl.code == 25 ?
                  // Logical and.
                  "and" :
                  expression_anode.transl [1].transl.code == 14 ?
                  "gtt" :
                  expression_anode.transl [1].transl.code == 13 ?
                  "ltt" :
                  expression_anode.transl [1].transl.code == 29 ?
                  "eqs" : bad_anode () );
    result.opa1 = parse_expression_anode (expression_anode.transl [0]);
    result.opa2 = parse_expression_anode (expression_anode.transl [2]);
    /* Now, for efficiency we replace ltt (A,B) by gtt (B,A). */
    if (result.opr == "ltt") {
        // Swap the operands.
        var temp = result.opa1;
        result.opa1 = result.opa2;
        result.opa2 = temp;
        // Rename the operator.
        result.opr = "gtt";
    }
  } else if (expression_anode.name == "single") {
    // To work on unary operators.
    if (expression_anode.transl [0].transl.code == 21) {
      // We have a unary plus operation that does not affect the operand.
      result = parse_expression_anode (expression_anode.transl [1]);
    } else {
      // Other possible operators include unary minus and negation (!).
      result.opr = ( expression_anode.transl [0].transl.code == 22 ?
                     // Unary minus.
                     "neg" :
                     expression_anode.transl [0].transl.code == 27 ?
                     // Logical negation.
                     "not" : bad_anode () );
      result.opa1 = parse_expression_anode (expression_anode.transl [1]);
    }
  } else if (expression_anode.name == "expression") {
    // This is a reference to a factor.
    result = parse_expression_anode (expression_anode.transl [0]);
  } else bad_anode ();
  return result;
}
       /**************************************************
       ** These are the functions to perform semantical **
       ** checking. The errors recognized are:          **
       ** 1. Attempt to declare identifier twice (found **
       ** at translation time).                         **
       ** 2. No such identifier declared.               **
       ** 3. Vector in a context expecting a scalar     **
       ** value.                                        **
       ** 4. Attempt to extract an element of a scalar  **
       ** value.                                        **
       ** 5. Attempt to assign to a constant.           **
       **************************************************/
// The function to check a block does nothing but introduce a name scope for
// its two internal functions and call check_instruction() for each statement.
fun check_block (block) {
  fun check_expression;
  /* check_block() has two internal functions that work on an instruction
     (check_instruction()) and expression (check_expression()). */
  fun check_instruction (instruction) {
    /* Most of the commands just cause invocations of other functions,
       but assignment finds four important semantic errors (see #2-5). */
    // Most important parts first this time.
    if (instruction.name == "assign") {
      if (dumpfl) putln ("* Checking an assignment statement.");
      /* First, check for error #2. */
      if (!(instruction.args [0].value in block.vartable)) {
        put (program_file, ":", instruction.args [0].line_num, ":",
        instruction.args [0].char_num, ": ");
        grip_error ("No such variable declared.");
      } else {
        /* If these would have appeared after the conditional, !keyvalue would
           be generated, which is undesirable. */
        /* Now, we may check for error #3. */
//        if (type (block.vartable [instruction.args [0].value].value)
//            == vec 
//            && instruction.args [1].opr == "num" &&
//            int (instruction.args [1].opa1.value) == 0) {
//          put (program_file, ":", instruction.args [0].line_num, ":",
//               instruction.args [0].char_num, ": ");
//          grip_error ("Structured value in scalar context.");
//        }
//        /* Lastly, error #4 must be checked. "elsif" is used for efficiency. */
//        else
        if (type (block.vartable [instruction.args [0].value].value) !=
                 vec &&
                 instruction.args [1].opr != "num" &&
                 int (instruction.args [1].opa1.value) != 0) {
          put (program_file, ":", instruction.args [0].line_num, ":",
               instruction.args [0].char_num, ": ");
          grip_error ("Attempt to reference element of scalar value.");
        } else if (block.vartable [instruction.args [0].value].type0 ==
                   "constant") {
          put (program_file, ":", instruction.args [0].line_num, ":",
               instruction.args [0].char_num, ": ");
          grip_error ("Attempt to assign to a constant.");
        }
      }
      // Here, we change the token to its value field.
      instruction.args [0] = instruction.args [0].value;
      // Now, we invoke check_expression to check two of the expressions:
      instruction.args [1] = check_expression (instruction.args [1]);
      instruction.args [2] = check_expression (instruction.args [2]);
      // Now we are done with our work.
    } else if (instruction.name == "put") {
      if (dumpfl) putln ("* Checking a put statement.");
    /* Here we just invoke check_expression() for every expression. */
      for (var current_object_num = 0;
           current_object_num < #instruction.args;
           current_object_num++) {
       instruction.args [current_object_num] =
        check_expression (instruction.args [current_object_num]);
      }
    } else if (instruction.name == "empty") {
      if (dumpfl) putln ("* Checking an empty statement.");
      // The empty statement is automatically correct.
    /* All the recursion is done by the statements that are structured. */
    } else if (instruction.name == "cond") {
      // Here we juct iterate through all the possible alternatives,
      // verifying whether each is correct.
      for (var current_alternative_num = 0;
           current_alternative_num < #instruction.args;
           current_alternative_num += 2) {
        instruction.args [current_alternative_num] =
        check_expression (instruction.args [current_alternative_num]);
        instruction.args [current_alternative_num + 1] =
        check_instruction (instruction.args [current_alternative_num + 1]);
      }
    } else if (instruction.name == "for") {
      // Here, it is even more basic.
      if (dumpfl) putln ("* Checking a for loop.");
      instruction.args [0] = check_instruction (instruction.args [0]);
      instruction.args [2] = check_instruction (instruction.args [2]);
      instruction.args [3] = check_instruction (instruction.args [3]);
      instruction.args [1] = check_expression  (instruction.args [1]);
    } else if (instruction.name == "block") {
      /* The block statement is resolved by a recursive invocation of
         check_block(). */
      instruction.args [0] = check_block (instruction.args [0]);
    } else fatal_error ("Internal error in translator.");
    if (dumpfl) {
      putln ("* Checked instruction, value :");
      print_instruction (instruction);
    }
    return instruction;
  }
  /* This function is used to check an expression and replace all tokens with
     corresponding values. */
  fun check_expression (expression) {
    /* Let us discuss the values that we need to check. Our errors
       shall be found all in one operator: var. Its internal representation
       is as follows:
       | opr   | opa1  | opa2    |
       +-------+-------+---------+
       | "var" | IDENT | ELEMENT |
       As you can see, it acts both as a reference to a scalar value
       and a vector. The other operators are trivial:
       num : don't do anything.
       neg, not : check opa1 only.
       Otherwise, we check both operands. */
    if (expression.opr == "num") { // Don't do anything except replace tokens:
      expression.opa1 = expression.opa1.value;
    } else if (expression.opr == "neg" ||
               expression.opr == "not") { // Check opa1:
      expression.opa1 = check_expression (expression.opa1);
    } else if (expression.opr == "var") { // Check for 
      /* The same errors are fixed here as the ones in the assignment
         statement. In fact, almost the same procedure is used here,
         except that we do only one recursive invokation at the end, and we
         work on a different domain of objects. For a more detailed explanation
         of the algorithm's quirks, see the procedure for assignment.*/
      if (!(expression.opa1.value in block.vartable)) {
        put (program_file, ":", expression.opa1.line_num, ":0: ");
        grip_error ("No such variable declared.");
      } else {
        /* Check for error #3. */
//        if (type (block.vartable [expression.opa1.value].value) == vec &&
//            expression.opa2.opr == "num" &&
//            int (expression.opa2.opa1.value) == 0) {
//          put (program_file, ":", expression.opa1.line_num, ":0: ");
//          grip_error ("Structured value in scalar context.");
//        }
//        else
          if (type (block.vartable [expression.opa1.value].value) !=
                 vec &&
                 expression.opa2.opr != "num" &&
                 int (expression.opa2.opa1.value) != 0) {
          put (program_file, ":", expression.opa1.value, ":0: ");
          grip_error ("Scalar value in structured context.");
        }
      }
      expression.opa1 = expression.opa1.value;
      expression.opa2 = check_expression (expression.opa2);
    } else { // A binary operator. Recursively invoke check_expression():
      expression.opa1 = check_expression (expression.opa1);
      expression.opa2 = check_expression (expression.opa2);
    }
    return expression;
  }
  if (dumpfl) putln ("@ Initiating block checking.");
  /* The main body of the function is quite trivial and consists of just a
     for-loop. Also, we must process the declarations. */
  for (var current_instruction_num = 0;
       current_instruction_num < #block.exec;
       current_instruction_num++)
    block.exec [current_instruction_num] =
    check_instruction (block.exec [current_instruction_num]);
  // Process the declarations.
  var current_declaration;
  return block;
}
/* What we have left now is a couple of common tasks I found to be
   easier to put in separate functions. */
// When an anode that is not supposed to turn up turns up, we finish
// with a diagnostic message.
fun bad_anode {
  fatal_error ("Grammar 'grip.g' corrupted or internal error.");
}
// For flattening recursive lists. This is so easily encoded in functional
// programming languages like ML! Wish I could use it here, but the SPI
// doesn't allow it.
fun flatten (list_anode_to_flatten, next_num) {
  if (dumpfl) {
    putln ("@ Executing flatten operation with:");
    println (list_anode_to_flatten.transl);
    print_anode (list_anode_to_flatten);
  }
  return // Last element or not?
         (list_anode_to_flatten.name != "$nil" ?
          [list_anode_to_flatten] @
          flatten (list_anode_to_flatten.transl [next_num], next_num) : []);
}
TEST506
	  cat >$tempdir/error.d <<'TEST506a'
/* If an error arises, this function shall perform the necessary dumping, and
   increment global_errfl. Other procedures check this variable occasionally,
   and if it isn't zero, call abend(). */
var global_errfl = 0;

fun grip_error (message, ...) {
  putln ("Error : ", message); // Print a general description of the problem.
  // Do any dumping necessary to roughly locate the problem.
  if (#args != 0)
    for (var i = 0; i < #args; i++)
      try {putln(args[i]);} catch ( partype)
          {println(args[i]);}
  global_errfl++; // Increment the global error counter.
}

// For fatal errors :
fun fatal_error (message, ...) {
  putln ("Fatal Error : ", message);
  if (#args != 0)
    for (var i = 0; i < #args; i++)
      try {putln (args[i]);}
      catch ( partype)
          {println (args[i]);}
  exit (3);
}

// To assist with abnormal endings.

fun abend (message) {
  putln (global_errfl, message, "error" @ (global_errfl == 1 ? "." : "s."));
  exit (2);
}

// To print out abstract nodes in a readable manner:

fun print_anode (node_to_print, tablevel = 0, tabchar = ' ') {
  for (var i = 0; i < tablevel; i++) put (tabchar);
  put (node_to_print.name, " ");
  if (node_to_print.name == "$nil") println ();
  else if (node_to_print.name == "$term")
    putln (node_to_print.transl.code, ":",
           node_to_print.transl.type0, ":",
           sprint (node_to_print.transl.value));
  else {
    putln ("(");
    for (i = 0; i < #node_to_print.transl; i++)
      print_anode (node_to_print.transl [i], tablevel + 2, tabchar);
    for (i = 0; i < tablevel; i++) put (tabchar);
    putln (")");
  }
}

// For printing objects of class expr().

fun print_expression (expr, tablevel = 0, tabchar = ' ') {
  for (var i = 0; i < tablevel; i++) put (tabchar);
  if (expr == nil) return;
  if (expr.opr == "num") putln (sprint (expr.opa1), " : ", sprint (expr.opa2));
  else if (expr.opr == "var") {
    put ("$", sprint (expr.opa1));
    if (!(expr.opa2.opr == "num" && expr.opa2.opa1 == "0")) {
      putln (" [");
      print_expression (expr.opa2, tablevel + 2, tabchar);
      for (i = 0; i < tablevel; i++) put (tabchar);
      putln ("]");
    } else putln ();
  } else {
    putln (expr.opr, " (");
    print_expression (expr.opa1, tablevel + 2, tabchar);
    print_expression (expr.opa2, tablevel + 2, tabchar);
    for (i = 0; i < tablevel; i++) put (tabchar);
    putln (")");
  }
}
// This function is used to print an instruction:
fun print_instruction (instruction, tablevel = 0, tabchar = ' ') {
  for (var i = 0; i < tablevel; i++) put (tabchar);
  if (instruction.name == "empty") putln ("-");
  else {
    put (instruction.name, " ");
    if (instruction.name == "block") {
      putln ("{");
      for (i: instruction.args [0].vartable) {
        for (var j = 0; j < tablevel + 2; j++) put (tabchar);
        putln ("$", sprint (i), " : ", instruction.args [0].vartable [i].type0,
               instruction.args [0].vartable [i].arrfl ?
               " [" @ instruction.args [0].vartable [i].arrfl @ "]" : "");
      }
      for (i = 0; i < #instruction.args [0].exec; i++)
        print_instruction (instruction.args [0].exec [i],
                           tablevel + 2, tabchar);
      for (i = 0; i < tablevel; i++) put (tabchar);
      putln ("}");
    } else if (instruction.name == "for") {
      putln ();
      for (i = 0; i < tablevel + 2; i++) put (tabchar);
      putln ("Initialization : ");
      print_instruction (instruction.args [0], tablevel + 2, tabchar);
      for (i = 0; i < tablevel + 2; i++) put (tabchar);
      putln ("---");
      for (i = 0; i < tablevel + 2; i++) put (tabchar);
      putln ("Condition : ");
      print_expression (instruction.args [1], tablevel + 2, tabchar);
      for (i = 0; i < tablevel + 2; i++) put (tabchar);
      putln ("Body : ");
      print_instruction (instruction.args [3], tablevel + 2, tabchar);
      for (i = 0; i < tablevel + 2; i++) put (tabchar);
      put ("Increment : ");
      print_instruction (instruction.args [2]);
    } else if (instruction.name == "cond") {
      putln ();
      for (i = 0; i < #instruction.args; i += 2) {
        print_expression  (instruction.args [i], tablevel + 2, tabchar);
        print_instruction (instruction.args [i + 1], tablevel + 2, tabchar);
        if (i < #instruction.args - 1) {
          for (var j = 0; j < tablevel; j++) put (tabchar);
          putln ("---");
        }
      }
    } else if (instruction.name == "assign") {
      put ("$", sprint (instruction.args [0]));
      if (!(instruction.args [1].opr == "num" &&
            instruction.args [1].opa1 == "0")) {
        putln (" [");
        print_expression (instruction.args [1], tablevel + 2, tabchar);
        for (i = 0; i < tablevel; i++) put (tabchar);
        putln ("]");
      } else putln ();
      print_expression (instruction.args [2], tablevel + 2, tabchar);
    } else if (instruction.name == "put") {
      putln ();
      for (i = 0; i < #instruction.args; i++)
        print_expression (instruction.args [i], tablevel + 2, tabchar);
      }
    }
}
TEST506a
	  cat >$tempdir/grip.d <<'TEST506b'
////////////////////////////////////////////////////////////////
// Grip 0.5s54 Designed and implemented by: Serhei Makarov.   //
// Special thanks to: Vladimir Makarov, for mentoring and     //
// moral support,                                             //
//                    Nadia Makarov, for moral support, and   //
//                    The person who invented ISPs, otherwise //
// I might not have gotten time to get such a head start in   //
// programming language design.                               //
////////////////////////////////////////////////////////////////

// GRIP 0.5 is a structured language roughly capable of performing
// algorhythmic calculations, e.g. a sieve for primes.
// WARNING : WE HAVE NOT IMPLEMENTED ANY INPUT DEVICES.

// Command line options :
//  -v
//  --verbose       Turns on dumpings at runtime.
//
//  -t
//  --parse-results Output the results of parsing.
//
//  -d
//  --full-parse    Output information about how
//                  the parse went.
//
//  -h
//  --help          Print possible command line
//                  options and quit.
//
//  -n
//  --version       Print version number and quit.
//
//  filename        Interpret 'filename'.
var verbose_flag = 0, debug_level = 0, file_name = "";

include "error"; // The error management package.
include "intrep"; // Interpretation package.
include "parser"; // Translation package.

var translator = grip_parser(), db_fl = 0;

// Db_fl is defined to find conflicting -td options and for -hn option usage.
// Find if we just want help.
if (#argv == 0) {
  putln ("No arguments found. Use 'grip --help' for help.");
  exit (0);
}
for (var argpos = 0; argpos < #argv; argpos++)
  if (argv[argpos] == "--help" ||
      argv[argpos] == "-h") {
    putln ("GRIP 0.5s54.");
    putln ("Usage: grip (option | filename)...");
    putln ("Options:");
    putln ("POSIX one character | GNU style long");
    putln (" -v                 | --verbose       : ",
           "Turn on dumpings at runtime.");
    putln (" -t                 | --parse-results : ",
           "Show the results of parsing.");
    putln (" -d                 | --full-parse    : ",
           "Show how the parse went.");
    putln (" -n                 | --version       : ",
           "Print version number and quit.");
    putln (" -h                 | --help          : ",
           "Show this screen.");
    putln ();
    putln ("Grip returns 0 on success, 2 on a non-fatal error, and");
    putln ("3 on a fatal error that prevents its functioning properly."); 
    exit (0);
  } else if (argv[argpos] == "-n" ||
             argv[argpos] == "--version") {
    putln ("GRIP 0.5s54 designed and implemented by Serhei V. Makarov.");
    putln ("Special thanks to:");
    putln ("                   Vladimir Makarov, for mentoring and");
    putln ("                   moral support, and");
    putln ("                   Nadia Makarov, for moral support.");
    exit (0);
  }
// Analyze argv[] to find out the filename needed.
for (argpos = 0; argpos < #argv; argpos++) {
  if (argv[argpos] == "-v" ||
      argv[argpos] == "--verbose") verbose_flag = 1;
  else if (argv[argpos] == "-t" ||
           argv[argpos] == "--parse-results") if (!db_fl) {
                debug_level = 2;
                db_fl++;
        } else grip_error ("Conflicting '-t' and '-d' options.");
  else if (argv[argpos] == "-d" ||
           argv[argpos] == "--full-parse") if (!db_fl) {
                debug_level = 5;
                db_fl++;
        } else grip_error ("Conflicting '-t' and '-d' options.");
  else if (argv[argpos] == "-" && file_name == "") file_name = "/dev/stdin";
  else if (file_name == "") file_name = argv[argpos];
  else grip_error ("Too many arguments or arguments invalid.");
}
if (file_name == "") grip_error ("No file name specified or file name invalid");
if (global_errfl) abend (" command line ");
// Translate and interpret.
var executable_program = 
translator.parse_file(file_name, debug_level, verbose_flag);
executable_program.execute (verbose_flag, verbose_flag, verbose_flag);
exit(0);
TEST506b
	  cat >$tempdir/grip.g <<'TEST506c'
TERM string = 1
      ident = 2
     number = 3
   programk = 4
        ddt = 5
   constant = 6
    integer = 7
       real = 8
       cond = 9
        for = 10
        put = 11
       else = 12
        lts = 13
        gts = 14
        lfp = 15
        rtp = 16
        lbr = 17
        rbr = 18
        lsb = 19
        rsb = 20
        pls = 21
        mns = 22
        str = 23
        fsl = 24
        amp = 25
        vrt = 26
        exc = 27
        smc = 28
        eqs = 29
        spc = 30
    invalid = 31;
program : programk ident statement # program (2)
statement : varac lts mns expression smc # assign (0 3)
          | lbr decl st_list rbr         # vblock (1 2)
          | cond lbr c_list              # condit (2)
          | for lfp statement expression smc statement rtp statement # foritr (2 3 5 7)
          | put p_list smc               # output (1)
          | smc                          # -
expression : expression dop factor # double (0 1 2)
           | uop factor            # single (0 1)
           | factor                # expression (0)
factor : varac              # factor (0)
       | number             # factor (0)
       | lfp expression rtp # factor (1)
dop : pls # 0
    | mns # 0
    | str # 0
    | fsl # 0
    | vrt # 0
    | amp # 0
    | eqs # 0
    | gts # 0
    | lts # 0
uop : pls # 0
    | mns # 0
    | exc # 0
decl : ident_list ddt specif smc decl # declare (0 2 4)
     |                                # -
ident_list : ident ident_list  # idl (0 1)
           |                   # -
specif : integer as      # integer (1)
       | real as         # real (1)
       | constant number # constant (1)
as : lsb number rsb # 1
   |                # -
st_list : statement st_list # st_list (0 1)
        |                   # -
c_list : expression statement c_list # elsif (0 1 2)
       | else statement rbr          # else (- 1 -)
       | rbr                         # -
p_list : expression p_list # expressionel (0 1)
       | string p_list     # stringel (0 1)
       |                   # -
varac : ident                    # varac (0)
      | ident lsb expression rsb # array (0 2)
TEST506c
	  cat >$tempdir/intrep.d <<'TEST506d'
// Here follows the internal representation of a GRIP program.
/* This is a variable cell class, designed for use with eval(). */
class component (value, type0) {
  var arrfl = 0;
}
/* This is a simple instruction definition, with a descriptor and arguments. */
class instr (){
  var name = "", args = [];
}
/* This is an expression class. Note that at most two operands are allowed. */
class expression (){
  var opr, opa1, opa2;
}

/******************************************************************************
** This is the definition for the actual internal representation of the      **
** program. Note that the high level structure is almost just an abstract    **
** form of the source code. There are only two variables: exec, which is     **
** a vector of instructions, and vartable, a table of component cells.       **
** This class also contains a virtual machine capable of executing the code. **
******************************************************************************/
class prog {
  var exec = []; // The executable code.
  var vartable = new tab [];
  // The environment, statically derived during translation.
  fun eval (expr, dumpfl = 0) { // The expression evaluator.
    var res; // The result is retained for debugging purposes.
    if (dumpfl) putln ("@ Initiating expression evaluator.");
    fun ovrlap (type1, type2) // A function to derive the type of the result. 
      { return type1 == "real" || type2 == "real" ? "real" : "integer"; }
    if (expr.opr == "num") res = component(expr.opa1,expr.opa2);
                           /* Expression is a single constant */
    else if (expr.opr == "var") {
      var index = eval (expr.opa2, dumpfl).value;

      res = vartable [expr.opa1];
      if (type (res.value) == vec) {
	//        println (index, "--", #res.value);
	if (index < 1 || index > #res.value) {
	  grip_error ("Runtime error : Array index out of bounds.");
	  exit (2);
	}
        res = component (res.value [index - 1], res.type0);
      }
    }
    // Variable reference.
    else if (expr.opr == "neg") // Unary minus.
      res = component (-eval (expr.opa1, dumpfl).value,
                        eval (expr.opa1, dumpfl).type0);
    else if (expr.opr == "add") // Addition.
      res = component (eval (expr.opa1, dumpfl).value +
                       eval (expr.opa2, dumpfl).value,
                       ovrlap (eval (expr.opa1, dumpfl).type0,
                               eval (expr.opa2, dumpfl).type0));
    else if (expr.opr == "sub") // Subtraction.
      res = component (eval (expr.opa1, dumpfl).value -
                       eval (expr.opa2, dumpfl).value,
                       ovrlap (eval (expr.opa1, dumpfl).type0,
                               eval (expr.opa2, dumpfl).type0));
    else if (expr.opr == "mul") // Multiplication.
      res = component (eval (expr.opa1, dumpfl).value *
                       eval (expr.opa2, dumpfl).value,
                       ovrlap (eval (expr.opa1, dumpfl).type0,
                               eval (expr.opa2, dumpfl).type0));
    else if (expr.opr == "div") {// Division.
      res = component (eval (expr.opa1, dumpfl).value /
                       eval (expr.opa2, dumpfl).value,
                       ovrlap (eval (expr.opa1, dumpfl).type0,
                               eval (expr.opa2, dumpfl).type0));
    }
    else if (expr.opr == "and") // Logical and.
      res = component (eval (expr.opa1, dumpfl).value &&
                       eval (expr.opa2, dumpfl).value,
                       "integer");
    else if (expr.opr == "or ") // Logical or.
      res = component (eval (expr.opa1, dumpfl).value ||
                       eval (expr.opa2, dumpfl).value,
                       "integer");
    else if (expr.opr == "not") // Logical negation
      res = component (!eval (expr.opa1, dumpfl).value, "integer");
    else if (expr.opr == "gtt") // Greater than.
      res = component (eval (expr.opa1, dumpfl).value >
                       eval (expr.opa2, dumpfl).value,
                       "integer");
    // The lack of a less than operation is for the fact that x<y <=> y>x.
    else if (expr.opr == "eqs") // Equals.
      res = component (eval (expr.opa1, dumpfl).value ==
                       eval (expr.opa2, dumpfl).value,
                       "integer");
    else {
      // If opr is not one of the specified operations, then there is an
      // error in the coding.
      putln ("Fatal Error : Internal error in expression generator :");
      print_expression (expr);
    }
    if (dumpfl) { // Dumping.
      putln ("* Expression Dumping:\n", sprint (res.value), " : ",
             sprint (res.type0));
      if (expr.opr != "num") print_expression (expr);
      putln ();
    }
    return res; // Now the result is made available to the client function.
  }
  /***********************************************************************
  ** This is the actual execution function. It invokes execinstr(), a   **
  ** function internal to execute(), which may recursively invoke       **
  ** itself, eval(), and execute() to evaluate expressions, or use      **
  ** structures.                                                        **
  ***********************************************************************/
  fun execute (dumpfl, strdumpfl, edumpfl) {
    if (dumpfl) putln ("& Entering execution phase.");
    // Dumping for blocks :
    if (dumpfl) {
      putln ("* Preliminary dumping of variables for this block:\n",
             vartable != tab [] ?
             sprint (vartable) : "", "\n"); 
    }
    fun execinstr;
    for (var instr = 0; instr < #exec; instr++) {
      // Sequentially perform statements.
      execinstr (exec [instr], strdumpfl, edumpfl); 
      /* Invoke execinstr() with the current instruction. */
    }
    if (global_errfl) abend (" runtime ");
    /*******************************************************
    ** Implementation of execinstr(). Like eval(), it     **
    ** chooses from a list of possible operations it can  **
    ** do, and executes the corresponding procedure       **
    ** needed to do the job.                              **
    *******************************************************/
    fun execinstr (currinstr, dumpfl, edumpfl = 0) {
      // Dumping for instructions :
      if (dumpfl) { putln ("@ Executing of instruction #",
                           instr + 1, ", value:");
                    print_instruction (currinstr);
      }
      if (currinstr.name == "cond") { /* Conditional branch. */
        for (var current_option_number = 0;
             current_option_number < #currinstr.args;
             current_option_number += 2) {
          /* This loop iterates through all of the
             alternatives, checking each one. */
          if (eval (currinstr.args [current_option_number], edumpfl).value) { 
            /* Check the current alternative. */
            execinstr (currinstr.args [current_option_number + 1], dumpfl); 
            // True: Execute this branch.
            break; // Exit the loop : No more altenatives need to be checked. 
          }
        }
      } else if (currinstr.name == "for") {
         // C-style 'for' loop implementation. Note that this statement can
         // loop at most 100,000 times.
         var g = 0; // This variable is used for enforcing the iteration limit.
         for (execinstr (currinstr.args [0], dumpfl); // Initialization.
              eval (currinstr.args [1], edumpfl). value; // Condition.
              execinstr (currinstr.args [2], dumpfl)) { // Increment.
           execinstr (currinstr.args [3], dumpfl); // Execute the body.
           g++; // Iteration count.
           if (g > 99999) { // Kill the for loop if alloted
                            // iterations are used up.
             if (dumpfl) putln ("! For loop ran out of iterations.");
             putln ("Warning: Iteration limit exceeded: For loop killed.");
             break; // Kill the loop.
           }
         }
       } else if (currinstr.name == "assign") {
         // Classical absolute assignment.
         var res = eval (currinstr.args [2], edumpfl),
             index = eval (currinstr.args [1], edumpfl).value,
             ourtype;
         // Ourtype is for real <- int compatibility.
         if (vartable  [currinstr.args [0]].type0 == "real") ourtype = "real";
         else ourtype = "integer";
         var target = vartable [currinstr.args [0]];
         if (type (target.value) != vec) {
           // Is this an array? If no :
          target.value = (ourtype == "real"
			  ? float (res. value) : int (res. value));
         } else { // If yes :
           if (#target.value < index || index < 1) {
             grip_error ("Runtime error : Array index out of bounds.");
             exit (2);
           }
           target.value [index - 1] = res.value;
         }
         vartable [currinstr.args [0]].type0 = ourtype;
       } else if (currinstr.name == "block") { // The compound statement.
         currinstr.args [0].execute (dumpfl, dumpfl, edumpfl);
       } else if (currinstr.name == "put") { // Output statement.
         var put_objs = []; // So as not to intermingle output with dumpings.
         for (var i = 0; i < #currinstr.args; i++)
           put_objs @= eval (currinstr.args [i], edumpfl).value;
         for (i = 0; i < #put_objs; i++)
           put (put_objs [i]);
           // Output the values of all expressions.
         putln (); // Don't forget a newline.
       } else if (currinstr.name == "empty") {
         // The nil statement - does nothing.
       } else { // Coding error.
         putln ("Fatal Error : Internal parsing error : ",
                "Illegal instruction generated as follows :");
         print_instruction (currinstr.name, currinstr.args);
         exit (3);
       }
     }
     // Dumping for blocks :
     if (dumpfl) {
       putln ("* Dumping of variables for this block:\n", #vartable != 0 ?
              sprint (vartable) : "", "\n"); 
     }
   } // End execute().
} // End class prog.
TEST506d
	  cat >$tempdir/parser.d <<'TEST506e'
/****************************************************************************
** This is the translator for the source code.                             **
****************************************************************************/
class tok (code) { // For encoding of identifiers, etc.
  use token former code;
  var value, type0, line_num, char_num;
}
class grip_parser {
  // The grip_parser class, using the Earley parser.
  var grammar, source_code; // Grammar is the Earley Parser code.
  include "scanner"; // Lexical analysis.
  include "translates"; // Syntactical and semantical analysis.
}
TEST506e
	  cat >$tempdir/scanner.d <<'TEST506f'
 /*****************************************************************
 ** The scanner() function does lexical analysis, i.e. finding   **
 ** numbers, and returns a vector of tokens ready for parsing.   **
 *****************************************************************/
fun scanner (code) {
  var tokens = [],
  /* Array that will later be translated to tokens and returned,
     which will be called the "token stream". */
  lexem = "", /* Lexem will accumulate characters in case we wanted to
  make a token with more than one character, i.e. an identifier.
  (Will be referred to as the "accumulation stream".) */
  /* Note on streams: We can't write to the token stream unless
                      accumulation stream is empty.
  */
  /* Next come two important tables to increase parsing efficiency. */
  character = final tab [':' : 5,
                         '<' : 13,
                         '>' : 14,
                         '(' : 15,
                         ')' : 16,
                         '{' : 17,
                         '}' : 18,
                         '[' : 19,
                         ']' : 20,
                         '+' : 21,
                         '-' : 22,
                         '*' : 23,
                         '/' : 24,
                         '&' : 25,
                         '|' : 26,
                         '!' : 27,
                         ';' : 28,
                         '=' : 29,
                         ' ' : 30], // For encoding special characters.
  keyword = final tab ["program" : 4,
                       "constant" : 6,
                       "integer" : 7,
                       "real" : 8,
                       "for" : 10,
                      "cond" : 9,
                      "else" : 12,
                      "put" : 11], // For encoding keywords.
  char0, /* Counter for the loop that follows. */
  lx = 0,
  lnn = 1; // For retaining the line number of a token.
  for (char0 = 0; char0 < #code;) { // Build up tokens[].
    if (char0 != 0 &&
        code[char0 - 1] == '\n') lnn++;
    if (code[char0] == '/') { // Value might be a comment.
      var nofl = 1; // Tells us whether we should keep the slash.
      char0++; // Look at the next character.
      if (code[char0] == '*') {
        nofl = 0; // Don't put the slash to tokens[].
        for (;; char0++) // It is a comment.
          if (code[char0] == '*') { // Comment might end.
            char0++; // Look at next character.
            if (code[char0] == '/') {
              char0++;
              break; // Comment is over.
            }
          }
      }
      // So that the slash is preserved if there was no comment.
      if (nofl) tokens = tokens @ '/';
    } else if (code[char0] <= '9' && code[char0] >= '0') {
      var realfl = 0; // For support of reals.
      lexem = "N";
      for (;; char0++) {
        for (; code[char0] <= '9' && code[char0] >= '0'; char0++)
          lexem = lexem @ code[char0];
        if (code[char0] == '.' && ! realfl) {
          realfl++; // To avoid meaningless constructs such as 2.3.56.
          continue; // For scanning reals.
        }
        break;
      }
      tokens = ins (tokens, lexem, #tokens);
      lexem = "";
    } else if (code [char0] <= 'z' &&
               code [char0] >= 'a' || code[char0] <= 'Z' &&
               code [char0] >= 'A') {
      lexem = "I";
      for (; code [char0] <= 'z' && code[char0] >= 'a'
             || code [char0] <= 'Z' && code [char0] >= 'A'
             || code [char0] <= '9' && code [char0] >= '0';
             char0++)
        lexem = lexem @ tolower (code [char0]);
      tokens = ins (tokens, lexem, #tokens);
      lexem = "";
    } else if (char0 < #code && (code [char0] == ' '  ||
                                 code [char0] == '\n' ||
                                 code [char0] == '\t' ||
                                 code [char0] == '\f' ||
                                 code [char0] == '\r' ||
                                 code [char0] == '\v')) {
      for (; char0 < #code && (code [char0] == ' '  ||
                               code [char0] == '\n' ||
                               code [char0] == '\t' ||
                               code [char0] == '\f' ||
                               code [char0] == '\r' ||
                               code [char0] == '\v');
           char0++)
        if (char0 != 0 && code [char0 - 1] == '\n') lnn++;
    } else if (code[char0] == '"'){
      char0++;
      lexem = "S";
      for (; char0 < #code && code[char0] != '"'; char0++)
        lexem = lexem @ code[char0];
      char0++;
      tokens = ins (tokens, lexem, #tokens);
      lexem = "";
    } else {
      tokens = ins (tokens, code[char0], #tokens);
      char0++;
    }
    // Translate what we got to a token.
    if (lx < #tokens &&
        type (tokens[lx]) != char) { // Are we dealing with a string?
      if (tokens[lx][0] == 'S') { // We have a string constant.
        var temp = tok (1); // Token with code 1.
        temp.type0 = tokens[lx][0]; // Add the type specifier.
        temp.value = del (tokens[lx], 0, 1); // Put the rest into value.
        tokens[lx] = temp; // Put the result into tokens.
      } else if (tokens[lx][0] == 'I') { // Identifier.
        var temp;
        if (del (tokens[lx], 0, 1) in keyword) {
          // Translate it into a keyword token if it's a keyword.
          temp = tok(keyword[tokens[lx]]);
          // Look it up in the keyword table.
          temp.type0 = 'K';
          // Give it type "K".
          temp.value = tokens[lx];
          // Give its reproduction for the syntax error manager.
        } else {
          temp = tok (2); // Token - code 2.
          temp.type0 = 'I';
          temp.value = tokens[lx];
          // Same procedure here as for string constants.
        }
        tokens[lx] = temp;
      } else if (tokens[lx][0] == 'N') { // Number.
        var temp = tok (3); // Token - code 3.
        temp.type0 = tokens[lx][0];
        temp.value = del (tokens[lx], 0, 1);
        tokens[lx] = temp;
      } else fatal_error ("Internal scanner error.", tokens, tokens[lx]);
      // Scanner malfunction.
    } else if (lx < #tokens) { // Single character.
      if (!(tokens[lx] in character)) { 
        // We have a bad character that we know the parser will spit out.
        put (file_name, ":", lnn, ":", char0 % lnn, ": ");
        grip_error ("Lexical error: Invalid character -- no encoding available.",
               sprint(tokens[lx]));
        /* Generate an invalid token that the parser recognizes, but does
           not use in any rule. */
        tokens [lx] = tok (31);
        lx++;
        continue;
      } else {
        var temp = tok(character [tokens[lx]]);
        temp.type0 = 'C';
        temp.value = tokens[lx];
        tokens[lx] = temp;
      }
    }
    if (lx < #tokens) {
      tokens[lx].line_num = lnn;
      tokens[lx].char_num = char0 % lnn;
      lx++;
    }
  }
  return tokens; // Make the result available to the client.
}
TEST506f
	  cat >$tempdir/translates.d <<'TEST506g'
 /*************************************************************************
 ** This is the actual translation function. It does any necessary       **
 ** operations that are done after the translation, so all the main      **
 ** block needs to do is analyze args and determine the parameters to    **
 ** this method.                                                         **
 *************************************************************************/
fun parse_file (program_file, debug_level, verbose_flag) {
  if (verbose_flag) putln ("& Entering parsing phase.");
  var token_vector; // To save typing.
  /* The following function is called by the parser to
     do any error messaging. */
  fun syntax_error (error_token_index,
                     error_token_value,
                     first_ignored_token_index,
                     first_ignored_token_value,
                     new_starting_token_index,
                     new_starting_token_value) {
    if (error_token_value == nil ||
        error_token_value.code != 31) {
      if (verbose_flag) putln ("! Syntax error.");
      if (error_token_value != nil)
        put (program_file, ":", error_token_value.line_num, ":0: ");
      grip_error (sput ("Syntax error at token value ",
                        error_token_value
                        == nil ? "EOF" :
                        error_token_value.code,
                   ":", error_token_value
                        == nil ? "EOF" :
                        error_token_value.type0,
                   ":", error_token_value
                        == nil ? "EOF" :
                        sprint (error_token_value.value)
                  )
            );
    }
  }
  // The next few lines install the grammar.
  try { // In case we can't find the file.
    var tape = open (env ["GRAMMARPATH"],"read");
    grammar = fgetf (tape);
    close (tape);
  } catch (eaccess,
           eagain,
           ebadf,
           ebusy,
           edom,
           efault,
           efbig,
           eio,
           eisdir,
           emfile,
           emlink,
           enametoolong,
           enfile,
           enodev,
           enoent,
           enomem,
           eperm,
           epipe,
           espipe,
           exdev)
  {fatal_error ("Could not find grammar file 'grip.g'.");}
  var program, // Source code.
  abstract_tree; // Intermediate code.
  try { // To cause exception !pmemory to die with a graceful error message.
    pub var machine = parser();
    machine.set_grammar (grammar, 1);
    machine.set_debug (debug_level); // Turns on verbose mode if applicable.
    machine.set_one_parse (1); // In case the grammar is ambiguous.
    machine.set_recovery (1); // Turn off error recovery.
    machine.set_recovery_match (0); // Shift 5 tokens when error is found.
    try { // To cover 'no such file' 
      program = open (program_file, "read"); // Get the source code.
    } catch (eaccess,
             eagain,
             ebadf,
             ebusy,
             edom,
             efault,
             efbig,
             eio,
             eisdir,
             emfile,
             emlink,
             enametoolong,
             enfile,
             enodev,
             enoent,
             enomem,
             eperm,
             epipe,
             espipe,
             exdev
             ) { // No such file in reach.
      putln ("Error: No valid file named ",
             sprint (program_file), " found.");
      global_errfl++;
      abend (" I/O ");
    }
    source_code = fgetf (program) @ " ";
    // So we don't get out-of range array bounds during scanning.
    close(program);
    if (verbose_flag) putln ("@ Initiating scanner.");
    token_vector = scanner (source_code);
    if (verbose_flag && global_errfl)
      putln ("! Scanner failed, working in error recovery mode.");
    // Use scanner() to process source_code.
    if (verbose_flag) putln ("@ Initiating Earley's Parser.");
    abstract_tree =
    machine.parse (token_vector, syntax_error);
    // Parse token_vector into abstract_tree.
  } catch ( pmemory) {
    // There wasn't enough memory to parse the program.
    if (verbose_flag)
      putln ("! Insufficient memory to set up parser, parsing failed.");
    grip_error ("Insufficient memory for parser.");
  }
  if (global_errfl) { // If syntax errors were found, stop the program.
    if (verbose_flag) putln ("! Syntax error: Terminating now.");
    abend (" syntax ");
  } else if (verbose_flag) {
    putln ("& Parsing phase sucessful.");
  /* Here ends the grammar checking. abstract_tree contains the
     intermediate representation of the program. The task now is
     to translate it into an object of class prog, and check it
     for semantical correctness. */
  }
  include "anode_work"; // Used to derive an object of class prog().
  if (verbose_flag) print_anode (abstract_tree);
  return parse_program_anode (abstract_tree, verbose_flag);
}
TEST506g
	  cat >$tempdir/sieve.g <<'TEST506h'
/* The program heading. The identifier can conflict with identifiers in
   the statement. */
program primeSieve 
/* This is all one block statement. A GRIP program in fact consists of
    only one statement. */
{
        /* Constant declarations. */
        sievesize : constant 100;
        /* Global variables. */
        i count : integer;
        /* An array. */
        flags : integer [100];
        /* Initialize count and flags. */
        count <- 0;
        /* If it isn't the C-style for loop :-) */
        for (i <- 0; i < sievesize; i <- i + 1; /* This semicolon has to be here. */)
                flags[i + 1] <- 1;
        /* Now get to work! */
        for (i <- 0; i < sievesize; i <- i + 1;)
                /* This is a multi-branch form of if-then-else. */
                cond { /* This is NOT a block statement. Negative. */
                        flags[i + 1] { /* This is another block-statement. */
                                /* Two local variables. */
                                k prime : integer;
                                prime <- 2 * i + 3;
                                k <- prime + i;
                                for (; k < sievesize; k <- k + prime;)
                                        flags[k + 1] <- 0;
                                count <- count + 1;
                        }
                        /* Here would have been "else blablablablabla...", but primeSieve has no
                            need for "else blablablablabla..." */
                }
        /* I/O, unfortunately without the I. Maybe later ;-( */
        put "The number of primes less than " sievesize " is " count;
}
/* This has all of the constructs available to a GRIP programmer. Not much, eh? :-| */
TEST506h
	  echo '      ' GRAMMARPATH=$tempdir/grip.g $DINO $tempdir/grip.d $tempdir/sieve.g
          if GRAMMARPATH=$tempdir/grip.g $DINO $tempdir/grip.d $tempdir/sieve.g 2>$stderr >$stdout; then
              echo '      ' $CMP $stdout $ftemp2
              if cat >$ftemp2 <<'OUTPUT506-2' && $CMP $stdout $ftemp2; then
The number of primes less than 100 is 45
OUTPUT506-2
                  result=ok
              else
                  result=fail
              fi
          else
              result=fail
          fi
        else
          result=fail
        fi
        if test $result = ok; then
          echo '      ' Serhei\'s interpreter test is ok  -- rm -rf $tempdir
          rm -rf $tempdir
        else
          echo '      ' Serhei\'s interpreter test failed -- look at directory $tempdir
        fi
fi

# Test 507.
if test $result = ok -a $start_test_number -le 507; then
	echo test 507: Check bug of deleting elements from table.
        cat >$test_file <<'TEST507'
var ts = ["MII", "MI;I", "MMI", "M;MI", "MFI", "MMF", "BBB", "MBB",
	  "MIB", "MMB", "MFB", "MIb", "MMb", "MFb"];
var seq = tab [], ignore = tab [], useq;

fun add_transl (seq, s, t) {
  var i;

  if (s in seq) {
    for (i = 0; i < #seq [s]; i++)
      if (seq [s] [i] == t)
	return;
    seq [s] = seq [s] @ [t];
  } else
    seq [s] = [t];
}

fun add_seq (str) {
  var start, i, j, s;
  start = 0;
  for (i = 0; i < #str; i++)
    if (str [i] == ';') {
      s = subv (str, start, i + 1 - start);
      start = i + 1;
      for (j = start; j < #str; j++)
        if (str [j] == 't')
          break;
      if (!(s in ignore))
	add_transl (seq, s, subv (str, start, j - start));
    }
  if (#str - start >= 3) {
    s = subv (str, start, -1);
    if (!(s in ignore))
      add_transl (seq, s, "");
  }
}

fun build_start_seqs {
  var i, j;

  for (i = 0; i < #ts; i++) {
    add_seq ("t" @ ts [i] @ ";");
    for (j = 0; j < #ts; j++) {
      add_seq ("t" @ ts [i] @ "t" @ ts [j] @ ";");
      add_seq ("t" @ ts [i] @ "t" @ ts [j]);
    }
  }
}

fun subscr_divide (s) {
  var v = [nil, nil], k, m = 0, i = 0, f = 0, b = 0, nopb = 0;
  
  for (k = 0; k < #s; k++)
    if (s [k] == 'I') {
      if (i == 2)
        break;
      i++;
    } else if (s [k] == 'M') {
      if (m == 2)
        break;
      m++;
    } else if (s [k] == 'F') {
      if (f == 2)
        break;
      f++;
    } else if (s [k] == 'B' || s [k] == 'b') {
      if (nopb && (k != 0 && s [k - 1] == 't' || s [k] == 'b') || b == 3)
        break; // conflict on B0
      if (s [k] == 'b')
	nopb = 1;
      b++;
    }
  if (k < #s && s [k - 1] == 't')
    k--;
  v [0] = subv (s, 0, k);
  if (k < #s)
    v [1] = subv (s, k, -1);
  return v;
}

fun build_all_seqs (seq) {
  var i, j, v, cont, p, s;

  for (;;) {
    cont = 0;
    v = vec (seq);
    for (i = 0; i < #v; i += 2) {
      s = v [i];
      p = subscr_divide (s);
      if (p [1] != nil) {
	ignore [s] = nil;
	del (seq, s);
	add_transl (seq, p[0], p [1][0] != 't' ? p[1] : "");
	if (p [1][0] != 't') {
	  add_transl (seq, p[1], "");
	  for (j = 0; j < #ts; j++) {
	    add_seq (p [1] @ "t" @ ts [j] @ ";");
	    add_seq (p [1] @ "t" @ ts [j]);
	  }
	}
	cont = 1;
      }
    }
    if (!cont)
      break;
  }
}

build_start_seqs ();
build_all_seqs (seq);
TEST507
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        else
                result=fail
        fi
fi

# Test 508.
if test $result = ok -a $start_test_number -le 508; then
	echo test 508: Check bug of deleting elements from table.
        cat >$test_file <<'TEST508'
class c (i) {
  class sc (ai) {}
}
var i = c (10);
putln (i.sc (20) == i.sc (20));
putln (i.sc (20) == i.sc (30));
putln (i.sc (20) == c(10).sc (20));
putln (i.sc (20) == c(30).sc (20));
TEST508
        echo '      ' $DINO $test_file ">$stdout" "2>$stderr"
        if $DINO $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT508' && $CMP $stdout $ftemp2; then
1
0
0
0
OUTPUT508
                  result=ok
                else
                  result=fail
                fi
        else
                result=fail
        fi
fi


# Test 509.
if test $result = ok -a $start_test_number -le 509; then
	echo test 509: Checking that return is in function/class/ext.
        cat >$test_file <<'TEST509'
return 10;
TEST509
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST509-1'; then
test.d:1:1: statement return is not in function or class
TEST509-1
                result=ok
        else
                result=fail
        fi
fi

# Test 510.
if test $result = ok -a $start_test_number -le 510; then
	echo test 510: Checking that return is in function/class/ext.
        cat >$test_file <<'TEST510'
var k = "aaa", t = tab [];
t [k] = 10;
k [1] = 'b';
TEST510
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST510-1'; then
test.d:3:3: run time error - attempt to modify immutable vector
TEST510-1
                result=ok
        else
                result=fail
        fi
fi

# Test 511.
if test $result = ok -a $start_test_number -le 511; then
	echo test 511: format output
        cat >$test_file <<'TEST511'
// default conversion
putf ("%d\n", 10);
putf ("%o\n", 10);
putf ("%x\n", 10);
putf ("%X\n", 10);
putf ("%e\n", 10.5);
putf ("%E\n", 10.5);
putf ("%f\n", 10.5);
putf ("%g\n", 10.5);
putf ("%G\n", 10.5);
putf ("%c\n", 'z');
putf ("%s\n", "Abracadabra");
// width
putf ("%15d\n", 10);
putf ("%15o\n", 10);
putf ("%15x\n", 10);
putf ("%15X\n", 10);
putf ("%15e\n", 10.5);
putf ("%15E\n", 10.5);
putf ("%15f\n", 10.5);
putf ("%15g\n", 10.5);
putf ("%15G\n", 10.5);
putf ("%15c\n", 'z');
putf ("%15s\n", "Abracadabra");
// flag -
putf ("%-15d\n", 10);
putf ("%-15o\n", 10);
putf ("%-15x\n", 10);
putf ("%-15X\n", 10);
putf ("%-15e\n", 10.5);
putf ("%-15E\n", 10.5);
putf ("%-15f\n", 10.5);
putf ("%-15g\n", 10.5);
putf ("%-15G\n", 10.5);
putf ("%-15c\n", 'z');
putf ("%-15s\n", "Abracadabra");
// flag #
putf ("%#o\n", 10);
putf ("%#x\n", 10);
putf ("%#X\n", 10);
putf ("%#e\n", 10.5);
putf ("%#E\n", 10.5);
putf ("%#f\n", 10.5);
putf ("%#g\n", 10.5);
putf ("%#G\n", 10.5);
// flag 0
putf ("%015d\n", 10);
putf ("%015o\n", 10);
putf ("%015x\n", 10);
putf ("%015X\n", 10);
putf ("%015e\n", 10.5);
putf ("%015E\n", 10.5);
putf ("%015f\n", 10.5);
putf ("%015g\n", 10.5);
putf ("%015G\n", 10.5);
// flag <blank>
putf ("% 15d\n", 10);
putf ("% 15e\n", 10.5);
putf ("% 15E\n", 10.5);
putf ("% 15f\n", 10.5);
putf ("% 15g\n", 10.5);
putf ("% 15G\n", 10.5);
// flag +
putf ("%+15d\n", 10);
putf ("%+15e\n", 10.5);
putf ("%+15E\n", 10.5);
putf ("%+15f\n", 10.5);
putf ("%+15g\n", 10.5);
putf ("%+15G\n", 10.5);
// flag + and <blank> -> ignore blank
putf ("%+ 15d\n", 10);
putf ("%+ 15e\n", 10.5);
putf ("%+ 15E\n", 10.5);
putf ("%+ 15f\n", 10.5);
putf ("%+ 15g\n", 10.5);
putf ("%+ 15G\n", 10.5);
// flag - and 0 -> ignore 0
putf ("%-015d\n", 10);
putf ("%-015o\n", 10);
putf ("%-015x\n", 10);
putf ("%-015X\n", 10);
putf ("%-015e\n", 10.5);
putf ("%-015E\n", 10.5);
putf ("%-015f\n", 10.5);
putf ("%-015g\n", 10.5);
putf ("%-015G\n", 10.5);
// parameter defined width
putf ("%*d\n", 15, 10);
putf ("%*o\n", 15, 10);
putf ("%*x\n", 15, 10);
putf ("%*X\n", 15, 10);
putf ("%*e\n", 15, 10.5);
putf ("%*E\n", 15, 10.5);
putf ("%*f\n", 15, 10.5);
putf ("%*g\n", 15, 10.5);
putf ("%*G\n", 15, 10.5);
putf ("%*c\n", 15, 'z');
// negative width -> absolute value and flag -
putf ("%*s\n", 15, "Abracadabra");
putf ("%*d\n", -15, 10);
putf ("%*o\n", -15, 10);
putf ("%*x\n", -15, 10);
putf ("%*X\n", -15, 10);
putf ("%*e\n", -15, 10.5);
putf ("%*E\n", -15, 10.5);
putf ("%*f\n", -15, 10.5);
putf ("%*g\n", -15, 10.5);
putf ("%*G\n", -15, 10.5);
putf ("%*c\n", -15, 'z');
putf ("%*s\n", -15, "Abracadabra");
// zero width
putf ("%*d\n", 0, 10);
putf ("%*o\n", 0, 10);
putf ("%*x\n", 0, 10);
putf ("%*X\n", 0, 10);
putf ("%*e\n", 0, 10.5);
putf ("%*E\n", 0, 10.5);
putf ("%*f\n", 0, 10.5);
putf ("%*g\n", 0, 10.5);
putf ("%*G\n", 0, 10.5);
putf ("%*c\n", 0, 'z');
putf ("%*s\n", 0, "Abracadabra");
// zero precision value
putf ("%.0d\n", 10);
putf ("%.0o\n", 10);
putf ("%.0x\n", 10);
putf ("%.0X\n", 10);
putf ("%.0e\n", 10.5);
putf ("%.0E\n", 10.5);
putf ("%.0f\n", 10.5);
putf ("%.0g\n", 10.5);
putf ("%.0G\n", 10.5);
putf ("%.0s\n", "Abracadabra");
// absent precision value -> zero value
putf ("%.d\n", 10);
putf ("%.o\n", 10);
putf ("%.x\n", 10);
putf ("%.X\n", 10);
putf ("%.e\n", 10.5);
putf ("%.E\n", 10.5);
putf ("%.f\n", 10.5);
putf ("%.g\n", 10.5);
putf ("%.G\n", 10.5);
putf ("%.s\n", "Abracadabra");
// precision with numeric conversion and flag 0 -> ignore flag 0
putf ("%05.0d\n", 10);
putf ("%05.0o\n", 10);
putf ("%05.0x\n", 10);
putf ("%05.0X\n", 10);
putf ("%05.d\n", 10);
putf ("%05.o\n", 10);
putf ("%05.x\n", 10);
putf ("%05.X\n", 10);
// precision value 10
putf ("%.10d\n", 10);
putf ("%.10o\n", 10);
putf ("%.10x\n", 10);
putf ("%.10X\n", 10);
putf ("%.10e\n", 10.5);
putf ("%.10E\n", 10.5);
putf ("%.10f\n", 10.5);
putf ("%.10g\n", 10.5);
putf ("%.10G\n", 10.5);
putf ("%.10s\n", "Abracadabra");
// precision value as parameter
putf ("%.*d\n", 10, 10);
putf ("%.*o\n", 10, 10);
putf ("%.*x\n", 10, 10);
putf ("%.*X\n", 10, 10);
putf ("%.*e\n", 10, 10.5);
putf ("%.*E\n", 10, 10.5);
putf ("%.*f\n", 10, 10.5);
putf ("%.*g\n", 10, 10.5);
putf ("%.*G\n", 10, 10.5);
putf ("%.*s\n", 10, "Abracadabra");
// negative precision value -> value zero
putf ("%.*d\n", -10, 10);
putf ("%.*o\n", -10, 10);
putf ("%.*x\n", -10, 10);
putf ("%.*X\n", -10, 10);
putf ("%.*e\n", -10, 10.5);
putf ("%.*E\n", -10, 10.5);
putf ("%.*f\n", -10, 10.5);
putf ("%.*g\n", -10, 10.5);
putf ("%.*G\n", -10, 10.5);
putf ("%.*s\n", -10, "Abracadabra");
// zero precision value for outputing zero
putf ("%.0d\n", 0);
putf ("%.0o\n", 0);
putf ("%.0x\n", 0);
putf ("%.0X\n", 0);
// %
putf ("%%\n");

// The same for fputf
// default conversion
fputf (stdout, "%d\n", 10);
fputf (stdout, "%o\n", 10);
fputf (stdout, "%x\n", 10);
fputf (stdout, "%X\n", 10);
fputf (stdout, "%e\n", 10.5);
fputf (stdout, "%E\n", 10.5);
fputf (stdout, "%f\n", 10.5);
fputf (stdout, "%g\n", 10.5);
fputf (stdout, "%G\n", 10.5);
fputf (stdout, "%c\n", 'z');
fputf (stdout, "%s\n", "Abracadabra");
// width
fputf (stdout, "%15d\n", 10);
fputf (stdout, "%15o\n", 10);
fputf (stdout, "%15x\n", 10);
fputf (stdout, "%15X\n", 10);
fputf (stdout, "%15e\n", 10.5);
fputf (stdout, "%15E\n", 10.5);
fputf (stdout, "%15f\n", 10.5);
fputf (stdout, "%15g\n", 10.5);
fputf (stdout, "%15G\n", 10.5);
fputf (stdout, "%15c\n", 'z');
fputf (stdout, "%15s\n", "Abracadabra");
// flag -
fputf (stdout, "%-15d\n", 10);
fputf (stdout, "%-15o\n", 10);
fputf (stdout, "%-15x\n", 10);
fputf (stdout, "%-15X\n", 10);
fputf (stdout, "%-15e\n", 10.5);
fputf (stdout, "%-15E\n", 10.5);
fputf (stdout, "%-15f\n", 10.5);
fputf (stdout, "%-15g\n", 10.5);
fputf (stdout, "%-15G\n", 10.5);
fputf (stdout, "%-15c\n", 'z');
fputf (stdout, "%-15s\n", "Abracadabra");
// flag #
fputf (stdout, "%#o\n", 10);
fputf (stdout, "%#x\n", 10);
fputf (stdout, "%#X\n", 10);
fputf (stdout, "%#e\n", 10.5);
fputf (stdout, "%#E\n", 10.5);
fputf (stdout, "%#f\n", 10.5);
fputf (stdout, "%#g\n", 10.5);
fputf (stdout, "%#G\n", 10.5);
// flag 0
fputf (stdout, "%015d\n", 10);
fputf (stdout, "%015o\n", 10);
fputf (stdout, "%015x\n", 10);
fputf (stdout, "%015X\n", 10);
fputf (stdout, "%015e\n", 10.5);
fputf (stdout, "%015E\n", 10.5);
fputf (stdout, "%015f\n", 10.5);
fputf (stdout, "%015g\n", 10.5);
fputf (stdout, "%015G\n", 10.5);
// flag <blank>
fputf (stdout, "% 15d\n", 10);
fputf (stdout, "% 15e\n", 10.5);
fputf (stdout, "% 15E\n", 10.5);
fputf (stdout, "% 15f\n", 10.5);
fputf (stdout, "% 15g\n", 10.5);
fputf (stdout, "% 15G\n", 10.5);
// flag +
fputf (stdout, "%+15d\n", 10);
fputf (stdout, "%+15e\n", 10.5);
fputf (stdout, "%+15E\n", 10.5);
fputf (stdout, "%+15f\n", 10.5);
fputf (stdout, "%+15g\n", 10.5);
fputf (stdout, "%+15G\n", 10.5);
// flag + and <blank> -> ignore blank
fputf (stdout, "%+ 15d\n", 10);
fputf (stdout, "%+ 15e\n", 10.5);
fputf (stdout, "%+ 15E\n", 10.5);
fputf (stdout, "%+ 15f\n", 10.5);
fputf (stdout, "%+ 15g\n", 10.5);
fputf (stdout, "%+ 15G\n", 10.5);
// flag - and 0 -> ignore 0
fputf (stdout, "%-015d\n", 10);
fputf (stdout, "%-015o\n", 10);
fputf (stdout, "%-015x\n", 10);
fputf (stdout, "%-015X\n", 10);
fputf (stdout, "%-015e\n", 10.5);
fputf (stdout, "%-015E\n", 10.5);
fputf (stdout, "%-015f\n", 10.5);
fputf (stdout, "%-015g\n", 10.5);
fputf (stdout, "%-015G\n", 10.5);
// parameter defined width
fputf (stdout, "%*d\n", 15, 10);
fputf (stdout, "%*o\n", 15, 10);
fputf (stdout, "%*x\n", 15, 10);
fputf (stdout, "%*X\n", 15, 10);
fputf (stdout, "%*e\n", 15, 10.5);
fputf (stdout, "%*E\n", 15, 10.5);
fputf (stdout, "%*f\n", 15, 10.5);
fputf (stdout, "%*g\n", 15, 10.5);
fputf (stdout, "%*G\n", 15, 10.5);
fputf (stdout, "%*c\n", 15, 'z');
// negative width -> absolute value and flag -
fputf (stdout, "%*s\n", 15, "Abracadabra");
fputf (stdout, "%*d\n", -15, 10);
fputf (stdout, "%*o\n", -15, 10);
fputf (stdout, "%*x\n", -15, 10);
fputf (stdout, "%*X\n", -15, 10);
fputf (stdout, "%*e\n", -15, 10.5);
fputf (stdout, "%*E\n", -15, 10.5);
fputf (stdout, "%*f\n", -15, 10.5);
fputf (stdout, "%*g\n", -15, 10.5);
fputf (stdout, "%*G\n", -15, 10.5);
fputf (stdout, "%*c\n", -15, 'z');
fputf (stdout, "%*s\n", -15, "Abracadabra");
// zero width
fputf (stdout, "%*d\n", 0, 10);
fputf (stdout, "%*o\n", 0, 10);
fputf (stdout, "%*x\n", 0, 10);
fputf (stdout, "%*X\n", 0, 10);
fputf (stdout, "%*e\n", 0, 10.5);
fputf (stdout, "%*E\n", 0, 10.5);
fputf (stdout, "%*f\n", 0, 10.5);
fputf (stdout, "%*g\n", 0, 10.5);
fputf (stdout, "%*G\n", 0, 10.5);
fputf (stdout, "%*c\n", 0, 'z');
fputf (stdout, "%*s\n", 0, "Abracadabra");
// zero precision value
fputf (stdout, "%.0d\n", 10);
fputf (stdout, "%.0o\n", 10);
fputf (stdout, "%.0x\n", 10);
fputf (stdout, "%.0X\n", 10);
fputf (stdout, "%.0e\n", 10.5);
fputf (stdout, "%.0E\n", 10.5);
fputf (stdout, "%.0f\n", 10.5);
fputf (stdout, "%.0g\n", 10.5);
fputf (stdout, "%.0G\n", 10.5);
fputf (stdout, "%.0s\n", "Abracadabra");
// absent precision value -> zero value
fputf (stdout, "%.d\n", 10);
fputf (stdout, "%.o\n", 10);
fputf (stdout, "%.x\n", 10);
fputf (stdout, "%.X\n", 10);
fputf (stdout, "%.e\n", 10.5);
fputf (stdout, "%.E\n", 10.5);
fputf (stdout, "%.f\n", 10.5);
fputf (stdout, "%.g\n", 10.5);
fputf (stdout, "%.G\n", 10.5);
fputf (stdout, "%.s\n", "Abracadabra");
// precision with numeric conversion and flag 0 -> ignore flag 0
fputf (stdout, "%05.0d\n", 10);
fputf (stdout, "%05.0o\n", 10);
fputf (stdout, "%05.0x\n", 10);
fputf (stdout, "%05.0X\n", 10);
fputf (stdout, "%05.d\n", 10);
fputf (stdout, "%05.o\n", 10);
fputf (stdout, "%05.x\n", 10);
fputf (stdout, "%05.X\n", 10);
// precision value 10
fputf (stdout, "%.10d\n", 10);
fputf (stdout, "%.10o\n", 10);
fputf (stdout, "%.10x\n", 10);
fputf (stdout, "%.10X\n", 10);
fputf (stdout, "%.10e\n", 10.5);
fputf (stdout, "%.10E\n", 10.5);
fputf (stdout, "%.10f\n", 10.5);
fputf (stdout, "%.10g\n", 10.5);
fputf (stdout, "%.10G\n", 10.5);
fputf (stdout, "%.10s\n", "Abracadabra");
// precision value as parameter
fputf (stdout, "%.*d\n", 10, 10);
fputf (stdout, "%.*o\n", 10, 10);
fputf (stdout, "%.*x\n", 10, 10);
fputf (stdout, "%.*X\n", 10, 10);
fputf (stdout, "%.*e\n", 10, 10.5);
fputf (stdout, "%.*E\n", 10, 10.5);
fputf (stdout, "%.*f\n", 10, 10.5);
fputf (stdout, "%.*g\n", 10, 10.5);
fputf (stdout, "%.*G\n", 10, 10.5);
fputf (stdout, "%.*s\n", 10, "Abracadabra");
// negative precision value -> value zero
fputf (stdout, "%.*d\n", -10, 10);
fputf (stdout, "%.*o\n", -10, 10);
fputf (stdout, "%.*x\n", -10, 10);
fputf (stdout, "%.*X\n", -10, 10);
fputf (stdout, "%.*e\n", -10, 10.5);
fputf (stdout, "%.*E\n", -10, 10.5);
fputf (stdout, "%.*f\n", -10, 10.5);
fputf (stdout, "%.*g\n", -10, 10.5);
fputf (stdout, "%.*G\n", -10, 10.5);
fputf (stdout, "%.*s\n", -10, "Abracadabra");
// zero precision value for outputing zero
fputf (stdout, "%.0d\n", 0);
fputf (stdout, "%.0o\n", 0);
fputf (stdout, "%.0x\n", 0);
fputf (stdout, "%.0X\n", 0);
// %
fputf (stdout, "%%\n");

// The same for sputf
// default conversion
put (sputf ("%d\n", 10));
put (sputf ("%o\n", 10));
put (sputf ("%x\n", 10));
put (sputf ("%X\n", 10));
put (sputf ("%e\n", 10.5));
put (sputf ("%E\n", 10.5));
put (sputf ("%f\n", 10.5));
put (sputf ("%g\n", 10.5));
put (sputf ("%G\n", 10.5));
put (sputf ("%c\n", 'z'));
put (sputf ("%s\n", "Abracadabra"));
// width
put (sputf ("%15d\n", 10));
put (sputf ("%15o\n", 10));
put (sputf ("%15x\n", 10));
put (sputf ("%15X\n", 10));
put (sputf ("%15e\n", 10.5));
put (sputf ("%15E\n", 10.5));
put (sputf ("%15f\n", 10.5));
put (sputf ("%15g\n", 10.5));
put (sputf ("%15G\n", 10.5));
put (sputf ("%15c\n", 'z'));
put (sputf ("%15s\n", "Abracadabra"));
// flag -
put (sputf ("%-15d\n", 10));
put (sputf ("%-15o\n", 10));
put (sputf ("%-15x\n", 10));
put (sputf ("%-15X\n", 10));
put (sputf ("%-15e\n", 10.5));
put (sputf ("%-15E\n", 10.5));
put (sputf ("%-15f\n", 10.5));
put (sputf ("%-15g\n", 10.5));
put (sputf ("%-15G\n", 10.5));
put (sputf ("%-15c\n", 'z'));
put (sputf ("%-15s\n", "Abracadabra"));
// flag #
put (sputf ("%#o\n", 10));
put (sputf ("%#x\n", 10));
put (sputf ("%#X\n", 10));
put (sputf ("%#e\n", 10.5));
put (sputf ("%#E\n", 10.5));
put (sputf ("%#f\n", 10.5));
put (sputf ("%#g\n", 10.5));
put (sputf ("%#G\n", 10.5));
// flag 0
put (sputf ("%015d\n", 10));
put (sputf ("%015o\n", 10));
put (sputf ("%015x\n", 10));
put (sputf ("%015X\n", 10));
put (sputf ("%015e\n", 10.5));
put (sputf ("%015E\n", 10.5));
put (sputf ("%015f\n", 10.5));
put (sputf ("%015g\n", 10.5));
put (sputf ("%015G\n", 10.5));
// flag <blank>
put (sputf ("% 15d\n", 10));
put (sputf ("% 15e\n", 10.5));
put (sputf ("% 15E\n", 10.5));
put (sputf ("% 15f\n", 10.5));
put (sputf ("% 15g\n", 10.5));
put (sputf ("% 15G\n", 10.5));
// flag +
put (sputf ("%+15d\n", 10));
put (sputf ("%+15e\n", 10.5));
put (sputf ("%+15E\n", 10.5));
put (sputf ("%+15f\n", 10.5));
put (sputf ("%+15g\n", 10.5));
put (sputf ("%+15G\n", 10.5));
// flag + and <blank> -> ignore blank
put (sputf ("%+ 15d\n", 10));
put (sputf ("%+ 15e\n", 10.5));
put (sputf ("%+ 15E\n", 10.5));
put (sputf ("%+ 15f\n", 10.5));
put (sputf ("%+ 15g\n", 10.5));
put (sputf ("%+ 15G\n", 10.5));
// flag - and 0 -> ignore 0
put (sputf ("%-015d\n", 10));
put (sputf ("%-015o\n", 10));
put (sputf ("%-015x\n", 10));
put (sputf ("%-015X\n", 10));
put (sputf ("%-015e\n", 10.5));
put (sputf ("%-015E\n", 10.5));
put (sputf ("%-015f\n", 10.5));
put (sputf ("%-015g\n", 10.5));
put (sputf ("%-015G\n", 10.5));
// parameter defined width
put (sputf ("%*d\n", 15, 10));
put (sputf ("%*o\n", 15, 10));
put (sputf ("%*x\n", 15, 10));
put (sputf ("%*X\n", 15, 10));
put (sputf ("%*e\n", 15, 10.5));
put (sputf ("%*E\n", 15, 10.5));
put (sputf ("%*f\n", 15, 10.5));
put (sputf ("%*g\n", 15, 10.5));
put (sputf ("%*G\n", 15, 10.5));
put (sputf ("%*c\n", 15, 'z'));
// negative width -> absolute value and flag -
put (sputf ("%*s\n", 15, "Abracadabra"));
put (sputf ("%*d\n", -15, 10));
put (sputf ("%*o\n", -15, 10));
put (sputf ("%*x\n", -15, 10));
put (sputf ("%*X\n", -15, 10));
put (sputf ("%*e\n", -15, 10.5));
put (sputf ("%*E\n", -15, 10.5));
put (sputf ("%*f\n", -15, 10.5));
put (sputf ("%*g\n", -15, 10.5));
put (sputf ("%*G\n", -15, 10.5));
put (sputf ("%*c\n", -15, 'z'));
put (sputf ("%*s\n", -15, "Abracadabra"));
// zero width
put (sputf ("%*d\n", 0, 10));
put (sputf ("%*o\n", 0, 10));
put (sputf ("%*x\n", 0, 10));
put (sputf ("%*X\n", 0, 10));
put (sputf ("%*e\n", 0, 10.5));
put (sputf ("%*E\n", 0, 10.5));
put (sputf ("%*f\n", 0, 10.5));
put (sputf ("%*g\n", 0, 10.5));
put (sputf ("%*G\n", 0, 10.5));
put (sputf ("%*c\n", 0, 'z'));
put (sputf ("%*s\n", 0, "Abracadabra"));
// zero precision value
put (sputf ("%.0d\n", 10));
put (sputf ("%.0o\n", 10));
put (sputf ("%.0x\n", 10));
put (sputf ("%.0X\n", 10));
put (sputf ("%.0e\n", 10.5));
put (sputf ("%.0E\n", 10.5));
put (sputf ("%.0f\n", 10.5));
put (sputf ("%.0g\n", 10.5));
put (sputf ("%.0G\n", 10.5));
put (sputf ("%.0s\n", "Abracadabra"));
// absent precision value -> zero value
put (sputf ("%.d\n", 10));
put (sputf ("%.o\n", 10));
put (sputf ("%.x\n", 10));
put (sputf ("%.X\n", 10));
put (sputf ("%.e\n", 10.5));
put (sputf ("%.E\n", 10.5));
put (sputf ("%.f\n", 10.5));
put (sputf ("%.g\n", 10.5));
put (sputf ("%.G\n", 10.5));
put (sputf ("%.s\n", "Abracadabra"));
// precision with numeric conversion and flag 0 -> ignore flag 0
put (sputf ("%05.0d\n", 10));
put (sputf ("%05.0o\n", 10));
put (sputf ("%05.0x\n", 10));
put (sputf ("%05.0X\n", 10));
put (sputf ("%05.d\n", 10));
put (sputf ("%05.o\n", 10));
put (sputf ("%05.x\n", 10));
put (sputf ("%05.X\n", 10));
// precision value 10
put (sputf ("%.10d\n", 10));
put (sputf ("%.10o\n", 10));
put (sputf ("%.10x\n", 10));
put (sputf ("%.10X\n", 10));
put (sputf ("%.10e\n", 10.5));
put (sputf ("%.10E\n", 10.5));
put (sputf ("%.10f\n", 10.5));
put (sputf ("%.10g\n", 10.5));
put (sputf ("%.10G\n", 10.5));
put (sputf ("%.10s\n", "Abracadabra"));
// precision value as parameter
put (sputf ("%.*d\n", 10, 10));
put (sputf ("%.*o\n", 10, 10));
put (sputf ("%.*x\n", 10, 10));
put (sputf ("%.*X\n", 10, 10));
put (sputf ("%.*e\n", 10, 10.5));
put (sputf ("%.*E\n", 10, 10.5));
put (sputf ("%.*f\n", 10, 10.5));
put (sputf ("%.*g\n", 10, 10.5));
put (sputf ("%.*G\n", 10, 10.5));
put (sputf ("%.*s\n", 10, "Abracadabra"));
// negative precision value -> value zero
put (sputf ("%.*d\n", -10, 10));
put (sputf ("%.*o\n", -10, 10));
put (sputf ("%.*x\n", -10, 10));
put (sputf ("%.*X\n", -10, 10));
put (sputf ("%.*e\n", -10, 10.5));
put (sputf ("%.*E\n", -10, 10.5));
put (sputf ("%.*f\n", -10, 10.5));
put (sputf ("%.*g\n", -10, 10.5));
put (sputf ("%.*G\n", -10, 10.5));
put (sputf ("%.*s\n", -10, "Abracadabra"));
// zero precision value for outputing zero
put (sputf ("%.0d\n", 0));
put (sputf ("%.0o\n", 0));
put (sputf ("%.0x\n", 0));
put (sputf ("%.0X\n", 0));
// %
put (sputf ("%%\n"));
// big precision
putf ("%.21474836s", "stop\n");
TEST511
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT511' && $CMP $stdout $ftemp2; then
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
012
0xa
0XA
1.050000e+01
1.050000E+01
10.500000
10.5000
10.5000
000000000000010
000000000000012
00000000000000a
00000000000000A
0001.050000e+01
0001.050000E+01
00000010.500000
0000000000010.5
0000000000010.5
             10
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

   10
   12
    a
    A
   10
   12
    a
    A
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01





%
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
012
0xa
0XA
1.050000e+01
1.050000E+01
10.500000
10.5000
10.5000
000000000000010
000000000000012
00000000000000a
00000000000000A
0001.050000e+01
0001.050000E+01
00000010.500000
0000000000010.5
0000000000010.5
             10
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

   10
   12
    a
    A
   10
   12
    a
    A
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01





%
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
012
0xa
0XA
1.050000e+01
1.050000E+01
10.500000
10.5000
10.5000
000000000000010
000000000000012
00000000000000a
00000000000000A
0001.050000e+01
0001.050000E+01
00000010.500000
0000000000010.5
0000000000010.5
             10
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

   10
   12
    a
    A
   10
   12
    a
    A
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01





%
stop
OUTPUT511
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT511-1' && $CMP $stdout $ftemp2; then
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
012
0xa
0XA
1.050000e+01
1.050000E+01
10.500000
10.5000
10.5000
000000000000010
000000000000012
00000000000000a
00000000000000A
0001.050000e+01
0001.050000E+01
00000010.500000
0000000000010.5
0000000000010.5
             10
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

   10
   12
    a
    A
   10
   12
    a
    A
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01





%
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
012
0xa
0XA
1.050000e+01
1.050000E+01
10.500000
10.5000
10.5000
000000000000010
000000000000012
00000000000000a
00000000000000A
0001.050000e+01
0001.050000E+01
00000010.500000
0000000000010.5
0000000000010.5
             10
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

   10
   12
    a
    A
   10
   12
    a
    A
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01





%
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
012
0xa
0XA
1.050000e+01
1.050000E+01
10.500000
10.5000
10.5000
000000000000010
000000000000012
00000000000000a
00000000000000A
0001.050000e+01
0001.050000E+01
00000010.500000
0000000000010.5
0000000000010.5
             10
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

   10
   12
    a
    A
   10
   12
    a
    A
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01





%
stop
OUTPUT511-1
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 512.
if test $result = ok -a $start_test_number -le 512; then
	echo test 512: adjustment for %d
        cat >$test_file <<'TEST512'
sputf ("%#d", 10);
TEST512
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST512-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST512-1
                result=ok
        else
                result=fail
        fi
fi

# Test 513.
if test $result = ok -a $start_test_number -le 513; then
	echo test 513: adjustment for %c
        cat >$test_file <<'TEST513'
sputf ("%#c", 10);
TEST513
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST513-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST513-1
                result=ok
        else
                result=fail
        fi
fi

# Test 514.
if test $result = ok -a $start_test_number -le 514; then
	echo test 514: blank flag for %o
        cat >$test_file <<'TEST514'
sputf ("% o", 10);
TEST514
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST514-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST514-1
                result=ok
        else
                result=fail
        fi
fi

# Test 515.
if test $result = ok -a $start_test_number -le 515; then
	echo test 515: adjustment for %s
        cat >$test_file <<'TEST515'
sputf ("%#s", "Abracadabra");
TEST515
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST515-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST515-1
                result=ok
        else
                result=fail
        fi
fi

# Test 516.
if test $result = ok -a $start_test_number -le 516; then
	echo test 516: zero flag for %c
        cat >$test_file <<'TEST516'
sputf ("%015c", 'z');
TEST516
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST516-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST516-1
                result=ok
        else
                result=fail
        fi
fi

# Test 517.
if test $result = ok -a $start_test_number -le 517; then
	echo test 517: zero flag for %s
        cat >$test_file <<'TEST517'
sputf ("%015s", "Abracadabra");
TEST517
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST517-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST517-1
                result=ok
        else
                result=fail
        fi
fi

# Test 518.
if test $result = ok -a $start_test_number -le 518; then
	echo test 518: blank flag for %o
        cat >$test_file <<'TEST518'
sputf ("% 15o", 10);
TEST518
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST518-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST518-1
                result=ok
        else
                result=fail
        fi
fi

# Test 519.
if test $result = ok -a $start_test_number -le 519; then
	echo test 519: blank flag for %x
        cat >$test_file <<'TEST519'
sputf ("% 15x", 10);
TEST519
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST519-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST519-1
                result=ok
        else
                result=fail
        fi
fi

# Test 520.
if test $result = ok -a $start_test_number -le 520; then
	echo test 520: blank flag for %X
        cat >$test_file <<'TEST520'
sputf ("% 15X", 10);
TEST520
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST520-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST520-1
                result=ok
        else
                result=fail
        fi
fi

# Test 521.
if test $result = ok -a $start_test_number -le 521; then
	echo test 521: blank flag for %c
        cat >$test_file <<'TEST521'
sputf ("% 15c", 10);
TEST521
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST521-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST521-1
                result=ok
        else
                result=fail
        fi
fi

# Test 522.
if test $result = ok -a $start_test_number -le 522; then
	echo test 522: blank flag for %s
        cat >$test_file <<'TEST522'
sputf ("% 15s", "Abracadabra");
TEST522
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST522-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST522-1
                result=ok
        else
                result=fail
        fi
fi

# Test 523.
if test $result = ok -a $start_test_number -le 523; then
	echo test 523: flag + for %o
        cat >$test_file <<'TEST523'
sputf ("%+15o", 10);
TEST523
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST523-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST523-1
                result=ok
        else
                result=fail
        fi
fi

# Test 524.
if test $result = ok -a $start_test_number -le 524; then
	echo test 524: flag + for %x
        cat >$test_file <<'TEST524'
sputf ("%+15x", 10);
TEST524
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST524-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST524-1
                result=ok
        else
                result=fail
        fi
fi

# Test 525.
if test $result = ok -a $start_test_number -le 525; then
	echo test 525: flag + for %X
        cat >$test_file <<'TEST525'
sputf ("%+15X", 10);
TEST525
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST525-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST525-1
                result=ok
        else
                result=fail
        fi
fi

# Test 526.
if test $result = ok -a $start_test_number -le 526; then
	echo test 526: flag + for %c
        cat >$test_file <<'TEST526'
sputf ("%+15c", 10);
TEST526
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST526-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST526-1
                result=ok
        else
                result=fail
        fi
fi

# Test 527.
if test $result = ok -a $start_test_number -le 527; then
	echo test 527: flag + for %s
        cat >$test_file <<'TEST527'
sputf ("%+15s", 10);
TEST527
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST527-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST527-1
                result=ok
        else
                result=fail
        fi
fi

# Test 528.
if test $result = ok -a $start_test_number -le 528; then
	echo test 528: Few arguments for format
        cat >$test_file <<'TEST528'
sputf ("%d");
TEST528
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST528-1'; then
test.d:1:7: run time error - invalid number of actual parameters for `sputf'
TEST528-1
                result=ok
        else
                result=fail
        fi
fi

# Test 529.
if test $result = ok -a $start_test_number -le 529; then
	echo test 529: Few arguments for format
        cat >$test_file <<'TEST529'
sputf ("%*d", 10);
TEST529
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST529-1'; then
test.d:1:7: run time error - invalid number of actual parameters for `sputf'
TEST529-1
                result=ok
        else
                result=fail
        fi
fi

# Test 530.
if test $result = ok -a $start_test_number -le 530; then
	echo test 530: Too many parameters
        cat >$test_file <<'TEST530'
sputf ("%*d", 10, 10, 10);
TEST530
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST530-1'; then
test.d:1:7: run time error - invalid number of actual parameters for `sputf'
TEST530-1
                result=ok
        else
                result=fail
        fi
fi

# Test 531.
if test $result = ok -a $start_test_number -le 531; then
	echo test 531: Too many parameters
        cat >$test_file <<'TEST531'
sputf ("%d", 10, 10);
TEST531
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST531-1'; then
test.d:1:7: run time error - invalid number of actual parameters for `sputf'
TEST531-1
                result=ok
        else
                result=fail
        fi
fi

# Test 532.
if test $result = ok -a $start_test_number -le 532; then
	echo test 532: Parameter does not correspond to conversion
        cat >$test_file <<'TEST532'
sputf ("%d", "");
TEST532
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST532-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST532-1
                result=ok
        else
                result=fail
        fi
fi

# Test 533.
if test $result = ok -a $start_test_number -le 533; then
	echo test 533: Parameter does not correspond to conversion
        cat >$test_file <<'TEST533'
sputf ("%d", 'c');
TEST533
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST533-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST533-1
                result=ok
        else
                result=fail
        fi
fi

# Test 534.
if test $result = ok -a $start_test_number -le 534; then
	echo test 534: Parameter does not correspond to conversion
        cat >$test_file <<'TEST534'
sputf ("%d", 10.0);
TEST534
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST534-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST534-1
                result=ok
        else
                result=fail
        fi
fi

# Test 535.
if test $result = ok -a $start_test_number -le 535; then
	echo test 535: Parameter does not correspond to conversion
        cat >$test_file <<'TEST535'
sputf ("%c", 10);
TEST535
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST535-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST535-1
                result=ok
        else
                result=fail
        fi
fi

# Test 536.
if test $result = ok -a $start_test_number -le 536; then
	echo test 536: Parameter does not correspond to conversion
        cat >$test_file <<'TEST536'
sputf ("%c", "");
TEST536
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST536-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST536-1
                result=ok
        else
                result=fail
        fi
fi

# Test 537.
if test $result = ok -a $start_test_number -le 537; then
	echo test 537: Parameter does not correspond to conversion
        cat >$test_file <<'TEST537'
sputf ("%c", 10.0);
TEST537
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST537-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST537-1
                result=ok
        else
                result=fail
        fi
fi

# Test 538.
if test $result = ok -a $start_test_number -le 538; then
	echo test 538: Parameter does not correspond to conversion
        cat >$test_file <<'TEST538'
sputf ("%g", "");
TEST538
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST538-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST538-1
                result=ok
        else
                result=fail
        fi
fi

# Test 539.
if test $result = ok -a $start_test_number -le 539; then
	echo test 539: Parameter does not correspond to conversion
        cat >$test_file <<'TEST539'
sputf ("%g", 'c');
TEST539
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST539-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST539-1
                result=ok
        else
                result=fail
        fi
fi

# Test 540.
if test $result = ok -a $start_test_number -le 540; then
	echo test 540: Parameter does not correspond to conversion
        cat >$test_file <<'TEST540'
sputf ("%g", 10);
TEST540
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST540-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST540-1
                result=ok
        else
                result=fail
        fi
fi

# Test 541.
if test $result = ok -a $start_test_number -le 541; then
	echo test 541: Absent format
        cat >$test_file <<'TEST541'
sputf ();
TEST541
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST541-1'; then
test.d:1:7: run time error - invalid number of actual parameters for `sputf'
TEST541-1
                result=ok
        else
                result=fail
        fi
fi

# Test 542.
if test $result = ok -a $start_test_number -le 542; then
	echo test 542: Absent format
        cat >$test_file <<'TEST542'
fputf (stdout);
TEST542
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST542-1'; then
test.d:1:7: run time error - invalid number of actual parameters for `fputf'
TEST542-1
                result=ok
        else
                result=fail
        fi
fi

# Test 543.
if test $result = ok -a $start_test_number -le 543; then
	echo test 543: Invalid parameter
        cat >$test_file <<'TEST543'
sputf ([]);
TEST543
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST543-1'; then
test.d:1:7: run time error - invalid parameter type of `sputf'
TEST543-1
                result=ok
        else
                result=fail
        fi
fi

# Test 544.
if test $result = ok -a $start_test_number -le 544; then
	echo test 544: Invalid %%
        cat >$test_file <<'TEST544'
sputf ("%#%");
TEST544
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST544-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST544-1
                result=ok
        else
                result=fail
        fi
fi

# Test 545.
if test $result = ok -a $start_test_number -le 545; then
	echo test 545: Invalid %%
        cat >$test_file <<'TEST545'
sputf ("%0%");
TEST545
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST545-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST545-1
                result=ok
        else
                result=fail
        fi
fi

# Test 546.
if test $result = ok -a $start_test_number -le 546; then
	echo test 546: Invalid %%
        cat >$test_file <<'TEST546'
sputf ("%-%");
TEST546
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST546-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST546-1
                result=ok
        else
                result=fail
        fi
fi

# Test 547.
if test $result = ok -a $start_test_number -le 547; then
	echo test 547: Invalid %%
        cat >$test_file <<'TEST547'
sputf ("% %");
TEST547
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST547-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST547-1
                result=ok
        else
                result=fail
        fi
fi

# Test 548.
if test $result = ok -a $start_test_number -le 548; then
	echo test 548: Invalid %%
        cat >$test_file <<'TEST548'
sputf ("%+%");
TEST548
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST548-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST548-1
                result=ok
        else
                result=fail
        fi
fi

# Test 549.
if test $result = ok -a $start_test_number -le 549; then
	echo test 549: Unknown conversion
        cat >$test_file <<'TEST549'
sputf ("%w", 10);
TEST549
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST549-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST549-1
                result=ok
        else
                result=fail
        fi
fi

# Test 550.
if test $result = ok -a $start_test_number -le 550; then
	echo test 550: Too big width
        cat >$test_file <<'TEST550'
sputf ("%214748364s", "");
TEST550
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST550-1'; then
test.d:1:7: no memory
TEST550-1
                result=ok
        else
                result=fail
        fi
fi

# Test 551.
if test $result = ok -a $start_test_number -le 551; then
	echo test 551: Too big width
        cat >$test_file <<'TEST551'
sputf ("%2147483648s", "");
TEST551
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST551-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST551-1
                result=ok
        else
                result=fail
        fi
fi

# Test 552.
if test $result = ok -a $start_test_number -le 552; then
	echo test 552: Too big precision
        cat >$test_file <<'TEST552'
sputf ("%.2147483648s", "");
TEST552
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST552-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST552-1
                result=ok
        else
                result=fail
        fi
fi

# Test 553.
if test $result = ok -a $start_test_number -le 553; then
	echo test 553: Precision with %c
        cat >$test_file <<'TEST553'
sputf ("%.0c", 'z');
TEST553
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST553-1'; then
test.d:1:7: run time error - invalid format in `sputf'
TEST553-1
                result=ok
        else
                result=fail
        fi
fi

# Test 553.
if test $result = ok -a $start_test_number -le 553; then
	echo test 553: Ackermann from Language Shootout
        cat >$test_file <<'TEST553'
fun Ack (m, n) {
  if (m == 0) return n + 1;
  if (n == 0) return Ack (m - 1, 1);
  return Ack (m - 1, Ack (m, n - 1));
}

var N = int (#argv < 1 ? 1 : argv [0]);
putln ("Ack(3,", N ,"): ", Ack (3, N));

TEST553
        echo '      ' $DINO $test_file 9 "2>$stderr"
        if $DINO $test_file 9 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT553' && $CMP $stdout $ftemp2; then
Ack(3,9): 4093
OUTPUT553
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 554.
if test $result = ok -a $start_test_number -le 554; then
	echo test 554: Binary Trees from Language Shootout
        cat >$test_file <<'TEST554'
class node (item, left, right) {}

fun BottomUpTree (item, depth) {
  if (depth <= 0) return item;
  var i = item + item;

  depth--;
  return node (item, BottomUpTree (i - 1, depth), BottomUpTree (i, depth));
}

fun ItemCheck (tree) {
  return (type (tree) != obj
	  ? tree : tree.item + ItemCheck (tree.left) - ItemCheck (tree.right));
}

var N = int (#argv < 1 ? 0 : argv [0]);
var mindepth = 4, maxdepth = max (N, mindepth + 2);
var stretchdepth = maxdepth + 1, stretchtree = BottomUpTree (0, stretchdepth);

putf ("stretch tree of depth %d\t  check: %d\n", stretchdepth,
      ItemCheck (stretchtree));

var i, depth, longlivedtree = BottomUpTree (0, maxdepth);

for (depth = mindepth; depth <= maxdepth; depth += 2) {
  var iterations = 1 << (maxdepth - depth + mindepth), check = 0;

  for (i = 0; i < iterations; i++)
    check += (ItemCheck (BottomUpTree (1, depth))
	      + ItemCheck (BottomUpTree (-1, depth)));
  putf ("%d\t  trees of depth %d\t  check: %d\n", iterations*2, depth, check);
}

putf ("long lived tree of depth %d\t  check: %d\n",
      maxdepth, ItemCheck (longlivedtree));
TEST554
        echo '      ' $DINO $test_file 12 "2>$stderr"
        if $DINO $test_file 12 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT554' && $CMP $stdout $ftemp2; then
stretch tree of depth 13	  check: -1
8192	  trees of depth 4	  check: -8192
2048	  trees of depth 6	  check: -2048
512	  trees of depth 8	  check: -512
128	  trees of depth 10	  check: -128
32	  trees of depth 12	  check: -32
long lived tree of depth 12	  check: -1
OUTPUT554
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 555.
if test $result = ok -a $start_test_number -le 555; then
	echo test 555: Chameneos from Language Shootout
        cat >$test_file <<'TEST555'
val blue = 0, red = 1, yellow = 2, faded = 3;
var colors = [blue, red, yellow, blue], N = int (#argv < 1 ? 10 : argv [0]);
var first = nil, second = nil;

// Create a very social creature.
class creature (my_color, creatures_met = 0) {
  thread be {
    for (;my_color != faded;) {
      var other;

      wait (second == nil); // Wait until meeting place clears.
      if (first != nil) { // Hey, I found a new friend!
	other = first; wait (1) {first = nil; second = my_color;}
      } else if (N > 0) { // Sniff, nobody here (yet).
	N--; first = my_color;
	wait (second != nil);
	other = second; wait (1) second = nil;
      } else other = faded; // meeting place is closed

      // change color
      if (other == faded) my_color = other;
      else {
	creatures_met++;
	if (my_color == other) ;
	else if (my_color == blue) my_color = (other == red ? yellow : red);
	else if (my_color == red) my_color = (other == blue ? yellow : blue);
	else if (my_color == yellow) my_color = (other == blue ? red : blue);
      }
    }
  }
}

var i, meetings = 0, creatures = [#colors : nil];

for (i = 0; i < #colors; i++) {
  creatures [i] = creature (colors [i]); creatures [i].be ();
}

for (i = 0; i < #colors; i++) {
  wait (creatures [i].my_color == faded);
  meetings += creatures [i].creatures_met;
}
putln (meetings);
TEST555
        echo '      ' $DINO $test_file 1000000 "2>$stderr"
        if $DINO $test_file 1000000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT555' && $CMP $stdout $ftemp2; then
2000000
OUTPUT555
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 556.
if test $result = ok -a $start_test_number -le 556; then
	echo test 556: Cheap Concurrency from Language Shootout
        cat >$test_file <<'TEST556'
var N = int (#argv < 1 ? 10 : argv [0]);
var cont_p = 1, i, t, first = nil, last = nil, count = 0;

class thread_node (next = nil, n = -1) {
  thread start {
    for (; cont_p;) {
      wait (n >= 0 || ! cont_p);
      if (next != nil) {next.n = n + 1; n = -1;}
    }
  }
}


for (i = 0; i < 500; i++) {
  t = thread_node (); t.start ();
  if (last == nil) {last = t; first = last;}
  else {last.next = t; last = last.next;}
}

for (i = 0; i < N; i++) {
  first.n = count; wait (last.n >= 0); count = last.n + 1; last.n = -1;
}
wait (1) cont_p = 0; putln (count);
TEST556
        echo '      ' $DINO $test_file 3000 "2>$stderr"
        if $DINO $test_file 3000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT556' && $CMP $stdout $ftemp2; then
1500000
OUTPUT556
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 557.
if test $result = ok -a $start_test_number -le 557; then
	echo test 557: Cheap Concurrency from Language Shootout
        cat >$test_file <<'TEST557'
var N = int (#argv < 1 ? 10 : argv [0]);
var cont_p = 1, i, t, first = nil, last = nil, count = 0;

class thread_node (next = nil, n = -1) {
  thread start {
    for (; cont_p;) {
      wait (n >= 0 || ! cont_p);
      if (next != nil) {next.n = n + 1; n = -1;}
    }
  }
}


for (i = 0; i < 500; i++) {
  t = thread_node (); t.start ();
  if (last == nil) {last = t; first = last;}
  else {last.next = t; last = last.next;}
}

for (i = 0; i < N; i++) {
  first.n = count; wait (last.n >= 0); count = last.n + 1; last.n = -1;
}
wait (1)cont_p = 0; putln (count);
TEST557
        echo '      ' $DINO $test_file 3000 "2>$stderr"
        if $DINO $test_file 3000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT557' && $CMP $stdout $ftemp2; then
1500000
OUTPUT557
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 558.
if test $result = ok -a $start_test_number -le 558; then
	echo test 558: Fasta from Language Shootout
        cat >$test_file <<'TEST558'
var IM = 139968, IA = 3877, IC = 29573, Last = 42;

fun random (max) {
  Last = (Last * IA + IC) % IM;
  return (max * Last) / IM;
}

class freq (c, p) {}

// Weighted selection from alphabet

fun makeCumulative (a) {
  var i, cp = 0, len = #a;

   for (i = 0; i < len; i++) {
     cp += a [i].p; a [i].p = cp;
   }
}

fun selectRandom (a) {
  var i, len = #a, r = random (1.0);

  for (i = 0; i < len; i++)
    if (r < a[i].p) return a [i].c;
  return a [len - 1].c;
}

// Generate and write FASTA format

fun makeRandomFasta (id, desc, a, n) {
  var i, m, length = 60;

  putln (">", id, " ", desc);
  for (;n > 0; n -= length) {
    m = (n < length ? n : length);
    for (i = 0; i < m; i++)
      put (selectRandom (a));
    putln ();
  }
}

fun makeRepeatFasta (id, desc, s, n) {
  var i, m, todo = n, length = 60, k = 0, kn = #s;

  putln (">", id, " ", desc);
  for (; todo > 0;) {
    m = (todo < length ? todo : length);
    for (i = 0; i < m; i++) {
      if (k >= kn)
	k = 0;
      put (s [k]);
      k++;
    }
    putln ();
    todo -= length;
  }
}


// Main -- define alphabets, make 3 fragments

var alu =   "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG"
          @ "GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA"
          @ "CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT"
          @ "ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA"
          @ "GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG"
	  @ "AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC"
          @ "AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA";

var iub = [ freq ('a', 0.27), freq ('c', 0.12), freq ('g', 0.12),
	    freq ('t', 0.27), freq ('B', 0.02), freq ('D', 0.02),
	    freq ('H', 0.02), freq ('K', 0.02), freq ('M', 0.02),
	    freq ('N', 0.02), freq ('R', 0.02), freq ('S', 0.02),
	    freq ('V', 0.02), freq ('W', 0.02), freq ('Y', 0.02) ];
makeCumulative (iub);

var homosapiens = [ freq ('a', 0.3029549426680), freq ('c', 0.1979883004921),
		    freq ('g', 0.1975473066391), freq ('t', 0.3015094502008) ];
makeCumulative (homosapiens);

var N = int (#argv < 1 ? 1000 : argv [0]);
makeRepeatFasta ("ONE", "Homo sapiens alu", alu, N * 2);
makeRandomFasta ("TWO", "IUB ambiguity codes", iub, N * 3);
makeRandomFasta ("THREE", "Homo sapiens frequency", homosapiens, N * 5);
TEST558
        echo '      ' $DINO $test_file 1000 "2>$stderr"
        if $DINO $test_file 1000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT558' && $CMP $stdout $ftemp2; then
>ONE Homo sapiens alu
GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGA
TCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACT
AAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAG
GCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCG
CCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGT
GGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCA
GGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAA
TTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAG
AATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCA
GCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGT
AATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACC
AGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTG
GTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACC
CGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAG
AGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTT
TGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACA
TGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCT
GTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGG
TTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGT
CTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGG
CGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCG
TCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTA
CTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCG
AGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCG
GGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACC
TGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAA
TACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGA
GGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACT
GCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTC
ACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGT
TCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGC
CGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCG
CTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTG
GGCGACAGAGCGAGACTCCG
>TWO IUB ambiguity codes
cttBtatcatatgctaKggNcataaaSatgtaaaDcDRtBggDtctttataattcBgtcg
tactDtDagcctatttSVHtHttKtgtHMaSattgWaHKHttttagacatWatgtRgaaa
NtactMcSMtYtcMgRtacttctWBacgaaatatagScDtttgaagacacatagtVgYgt
cattHWtMMWcStgttaggKtSgaYaaccWStcgBttgcgaMttBYatcWtgacaYcaga
gtaBDtRacttttcWatMttDBcatWtatcttactaBgaYtcttgttttttttYaaScYa
HgtgttNtSatcMtcVaaaStccRcctDaataataStcYtRDSaMtDttgttSagtRRca
tttHatSttMtWgtcgtatSSagactYaaattcaMtWatttaSgYttaRgKaRtccactt
tattRggaMcDaWaWagttttgacatgttctacaaaRaatataataaMttcgDacgaSSt
acaStYRctVaNMtMgtaggcKatcttttattaaaaagVWaHKYagtttttatttaacct
tacgtVtcVaattVMBcttaMtttaStgacttagattWWacVtgWYagWVRctDattBYt
gtttaagaagattattgacVatMaacattVctgtBSgaVtgWWggaKHaatKWcBScSWa
accRVacacaaactaccScattRatatKVtactatatttHttaagtttSKtRtacaaagt
RDttcaaaaWgcacatWaDgtDKacgaacaattacaRNWaatHtttStgttattaaMtgt
tgDcgtMgcatBtgcttcgcgaDWgagctgcgaggggVtaaScNatttacttaatgacag
cccccacatYScaMgtaggtYaNgttctgaMaacNaMRaacaaacaKctacatagYWctg
ttWaaataaaataRattagHacacaagcgKatacBttRttaagtatttccgatctHSaat
actcNttMaagtattMtgRtgaMgcataatHcMtaBSaRattagttgatHtMttaaKagg
YtaaBataSaVatactWtataVWgKgttaaaacagtgcgRatatacatVtHRtVYataSa
KtWaStVcNKHKttactatccctcatgWHatWaRcttactaggatctataDtDHBttata
aaaHgtacVtagaYttYaKcctattcttcttaataNDaaggaaaDYgcggctaaWSctBa
aNtgctggMBaKctaMVKagBaactaWaDaMaccYVtNtaHtVWtKgRtcaaNtYaNacg
gtttNattgVtttctgtBaWgtaattcaagtcaVWtactNggattctttaYtaaagccgc
tcttagHVggaYtgtNcDaVagctctctKgacgtatagYcctRYHDtgBattDaaDgccK
tcHaaStttMcctagtattgcRgWBaVatHaaaataYtgtttagMDMRtaataaggatMt
ttctWgtNtgtgaaaaMaatatRtttMtDgHHtgtcattttcWattRSHcVagaagtacg
ggtaKVattKYagactNaatgtttgKMMgYNtcccgSKttctaStatatNVataYHgtNa
BKRgNacaactgatttcctttaNcgatttctctataScaHtataRagtcRVttacDSDtt
aRtSatacHgtSKacYagttMHtWataggatgactNtatSaNctataVtttRNKtgRacc
tttYtatgttactttttcctttaaacatacaHactMacacggtWataMtBVacRaSaatc
cgtaBVttccagccBcttaRKtgtgcctttttRtgtcagcRttKtaaacKtaaatctcac
aattgcaNtSBaaccgggttattaaBcKatDagttactcttcattVtttHaaggctKKga
tacatcBggScagtVcacattttgaHaDSgHatRMaHWggtatatRgccDttcgtatcga
aacaHtaagttaRatgaVacttagattVKtaaYttaaatcaNatccRttRRaMScNaaaD
gttVHWgtcHaaHgacVaWtgttScactaagSgttatcttagggDtaccagWattWtRtg
ttHWHacgattBtgVcaYatcggttgagKcWtKKcaVtgaYgWctgYggVctgtHgaNcV
taBtWaaYatcDRaaRtSctgaHaYRttagatMatgcatttNattaDttaattgttctaa
ccctcccctagaWBtttHtBccttagaVaatMcBHagaVcWcagBVttcBtaYMccagat
gaaaaHctctaacgttagNWRtcggattNatcRaNHttcagtKttttgWatWttcSaNgg
gaWtactKKMaacatKatacNattgctWtatctaVgagctatgtRaHtYcWcttagccaa
tYttWttaWSSttaHcaaaaagVacVgtaVaRMgattaVcDactttcHHggHRtgNcctt
tYatcatKgctcctctatVcaaaaKaaaagtatatctgMtWtaaaacaStttMtcgactt
taSatcgDataaactaaacaagtaaVctaggaSccaatMVtaaSKNVattttgHccatca
cBVctgcaVatVttRtactgtVcaattHgtaaattaaattttYtatattaaRSgYtgBag
aHSBDgtagcacRHtYcBgtcacttacactaYcgctWtattgSHtSatcataaatataHt
cgtYaaMNgBaatttaRgaMaatatttBtttaaaHHKaatctgatWatYaacttMctctt
ttVctagctDaaagtaVaKaKRtaacBgtatccaaccactHHaagaagaaggaNaaatBW
attccgStaMSaMatBttgcatgRSacgttVVtaaDMtcSgVatWcaSatcttttVatag
ttactttacgatcaccNtaDVgSRcgVcgtgaacgaNtaNatatagtHtMgtHcMtagaa
attBgtataRaaaacaYKgtRccYtatgaagtaataKgtaaMttgaaRVatgcagaKStc
tHNaaatctBBtcttaYaBWHgtVtgacagcaRcataWctcaBcYacYgatDgtDHccta
>THREE Homo sapiens frequency
aacacttcaccaggtatcgtgaaggctcaagattacccagagaacctttgcaatataaga
atatgtatgcagcattaccctaagtaattatattctttttctgactcaaagtgacaagcc
ctagtgtatattaaatcggtatatttgggaaattcctcaaactatcctaatcaggtagcc
atgaaagtgatcaaaaaagttcgtacttataccatacatgaattctggccaagtaaaaaa
tagattgcgcaaaattcgtaccttaagtctctcgccaagatattaggatcctattactca
tatcgtgtttttctttattgccgccatccccggagtatctcacccatccttctcttaaag
gcctaatattacctatgcaaataaacatatattgttgaaaattgagaacctgatcgtgat
tcttatgtgtaccatatgtatagtaatcacgcgactatatagtgctttagtatcgcccgt
gggtgagtgaatattctgggctagcgtgagatagtttcttgtcctaatatttttcagatc
gaatagcttctatttttgtgtttattgacatatgtcgaaactccttactcagtgaaagtc
atgaccagatccacgaacaatcttcggaatcagtctcgttttacggcggaatcttgagtc
taacttatatcccgtcgcttactttctaacaccccttatgtatttttaaaattacgttta
ttcgaacgtacttggcggaagcgttattttttgaagtaagttacattgggcagactcttg
acattttcgatacgactttctttcatccatcacaggactcgttcgtattgatatcagaag
ctcgtgatgattagttgtcttctttaccaatactttgaggcctattctgcgaaatttttg
ttgccctgcgaacttcacataccaaggaacacctcgcaacatgccttcatatccatcgtt
cattgtaattcttacacaatgaatcctaagtaattacatccctgcgtaaaagatggtagg
ggcactgaggatatattaccaagcatttagttatgagtaatcagcaatgtttcttgtatt
aagttctctaaaatagttacatcgtaatgttatctcgggttccgcgaataaacgagatag
attcattatatatggccctaagcaaaaacctcctcgtattctgttggtaattagaatcac
acaatacgggttgagatattaattatttgtagtacgaagagatataaaaagatgaacaat
tactcaagtcaagatgtatacgggatttataataaaaatcgggtagagatctgctttgca
attcagacgtgccactaaatcgtaatatgtcgcgttacatcagaaagggtaactattatt
aattaataaagggcttaatcactacatattagatcttatccgatagtcttatctattcgt
tgtatttttaagcggttctaattcagtcattatatcagtgctccgagttctttattattg
ttttaaggatgacaaaatgcctcttgttataacgctgggagaagcagactaagagtcgga
gcagttggtagaatgaggctgcaaaagacggtctcgacgaatggacagactttactaaac
caatgaaagacagaagtagagcaaagtctgaagtggtatcagcttaattatgacaaccct
taatacttccctttcgccgaatactggcgtggaaaggttttaaaagtcgaagtagttaga
ggcatctctcgctcataaataggtagactactcgcaatccaatgtgactatgtaatactg
ggaacatcagtccgcgatgcagcgtgtttatcaaccgtccccactcgcctggggagacat
gagaccacccccgtggggattattagtccgcagtaatcgactcttgacaatccttttcga
ttatgtcatagcaatttacgacagttcagcgaagtgactactcggcgaaatggtattact
aaagcattcgaacccacatgaatgtgattcttggcaatttctaatccactaaagcttttc
cgttgaatctggttgtagatatttatataagttcactaattaagatcacggtagtatatt
gatagtgatgtctttgcaagaggttggccgaggaatttacggattctctattgatacaat
ttgtctggcttataactcttaaggctgaaccaggcgtttttagacgacttgatcagctgt
tagaatggtttggactccctctttcatgtcagtaacatttcagccgttattgttacgata
tgcttgaacaatattgatctaccacacacccatagtatattttataggtcatgctgttac
ctacgagcatggtattccacttcccattcaatgagtattcaacatcactagcctcagaga
tgatgacccacctctaataacgtcacgttgcggccatgtgaaacctgaacttgagtagac
gatatcaagcgctttaaattgcatataacatttgagggtaaagctaagcggatgctttat
ataatcaatactcaataataagatttgattgcattttagagttatgacacgacatagttc
actaacgagttactattcccagatctagactgaagtactgatcgagacgatccttacgtc
gatgatcgttagttatcgacttaggtcgggtctctagcggtattggtacttaaccggaca
ctatactaataacccatgatcaaagcataacagaatacagacgataatttcgccaacata
tatgtacagaccccaagcatgagaagctcattgaaagctatcattgaagtcccgctcaca
atgtgtcttttccagacggtttaactggttcccgggagtcctggagtttcgacttacata
aatggaaacaatgtattttgctaatttatctatagcgtcatttggaccaatacagaatat
tatgttgcctagtaatccactataacccgcaagtgctgatagaaaatttttagacgattt
ataaatgccccaagtatccctcccgtgaatcctccgttatactaattagtattcgttcat
acgtataccgcgcatatatgaacatttggcgataaggcgcgtgaattgttacgtgacaga
gatagcagtttcttgtgatatggttaacagacgtacatgaagggaaactttatatctata
gtgatgcttccgtagaaataccgccactggtctgccaatgatgaagtatgtagctttagg
tttgtactatgaggctttcgtttgtttgcagagtataacagttgcgagtgaaaaaccgac
gaatttatactaatacgctttcactattggctacaaaatagggaagagtttcaatcatga
gagggagtatatggatgctttgtagctaaaggtagaacgtatgtatatgctgccgttcat
tcttgaaagatacataagcgataagttacgacaattataagcaacatccctaccttcgta
acgatttcactgttactgcgcttgaaatacactatggggctattggcggagagaagcaga
tcgcgccgagcatatacgagacctataatgttgatgatagagaaggcgtctgaattgata
catcgaagtacactttctttcgtagtatctctcgtcctctttctatctccggacacaaga
attaagttatatatatagagtcttaccaatcatgttgaatcctgattctcagagttcttt
ggcgggccttgtgatgactgagaaacaatgcaatattgctccaaatttcctaagcaaatt
ctcggttatgttatgttatcagcaaagcgttacgttatgttatttaaatctggaatgacg
gagcgaagttcttatgtcggtgtgggaataattcttttgaagacagcactccttaaataa
tatcgctccgtgtttgtatttatcgaatgggtctgtaaccttgcacaagcaaatcggtgg
tgtatatatcggataacaattaatacgatgttcatagtgacagtatactgatcgagtcct
ctaaagtcaattacctcacttaacaatctcattgatgttgtgtcattcccggtatcgccc
gtagtatgtgctctgattgaccgagtgtgaaccaaggaacatctactaatgcctttgtta
ggtaagatctctctgaattccttcgtgccaacttaaaacattatcaaaatttcttctact
tggattaactacttttacgagcatggcaaattcccctgtggaagacggttcattattatc
ggaaaccttatagaaattgcgtgttgactgaaattagatttttattgtaagagttgcatc
tttgcgattcctctggtctagcttccaatgaacagtcctcccttctattcgacatcgggt
ccttcgtacatgtctttgcgatgtaataattaggttcggagtgtggccttaatgggtgca
actaggaatacaacgcaaatttgctgacatgatagcaaatcggtatgccggcaccaaaac
gtgctccttgcttagcttgtgaatgagactcagtagttaaataaatccatatctgcaatc
gattccacaggtattgtccactatctttgaactactctaagagatacaagcttagctgag
accgaggtgtatatgactacgctgatatctgtaaggtaccaatgcaggcaaagtatgcga
gaagctaataccggctgtttccagctttataagattaaaatttggctgtcctggcggcct
cagaattgttctatcgtaatcagttggttcattaattagctaagtacgaggtacaactta
tctgtcccagaacagctccacaagtttttttacagccgaaacccctgtgtgaatcttaat
atccaagcgcgttatctgattagagtttacaactcagtattttatcagtacgttttgttt
ccaacattacccggtatgacaaaatgacgccacgtgtcgaataatggtctgaccaatgta
ggaagtgaaaagataaatat
OUTPUT558
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 559.
if test $result = ok -a $start_test_number -le 559; then
	echo test 559: Fannkuch from Language Shootout
        cat >$test_file <<'TEST559'
fun fannkuch (n) {
   var perm, maxperm, perm1 = [n : 0], count = [n : 0];
   var i, k, t, flipscount, maxflipscount = 0, m = n - 1, r = n, check = 0;

   for (i = 0; i < n; i++) perm1 [i] = i;
   for (;;) {
      if (check < 30) {
         for (i = 0; i < n; i++) put (perm1 [i] + 1);
         putln (); check++;
      }

      for (; r != 1; r--) count [r - 1] = r;
      if (perm1 [0] != 0 && perm1 [m] != m) {
	perm = new perm1;
	for (flipscount = 0;; flipscount++) {
	  k = perm [0];
	  if (k == 0) break;
	  for (i = (k + 1) / 2 - 1; i >= 0 ; i--) {
            t = perm [i]; perm [i] = perm [k - i]; perm[k - i] = t;
          }
	}

	if (flipscount > maxflipscount) {
	  maxflipscount = flipscount; maxperm = new perm1;
	}
      }

      for (;;r++) {
         if (r == n) return maxflipscount;
         t = perm1 [0];
         for (i = 0; i < r; i++) perm1 [i] = perm1 [i + 1];
         perm1 [r] = t;
	 count [r]--;
         if (count [r] > 0) break;
      }
   }
}

var n = int (#argv < 1 ? 1 : argv [0]);
putln ("Pfannkuchen(", n, ") = ", fannkuch(n));
TEST559
        echo '      ' $DINO $test_file 9 "2>$stderr"
        if $DINO $test_file 9 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT559' && $CMP $stdout $ftemp2; then
123456789
213456789
231456789
321456789
312456789
132456789
234156789
324156789
342156789
432156789
423156789
243156789
341256789
431256789
413256789
143256789
134256789
314256789
412356789
142356789
124356789
214356789
241356789
421356789
234516789
324516789
342516789
432516789
423516789
243516789
Pfannkuchen(9) = 30
OUTPUT559
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 560.
if test $result = ok -a $start_test_number -le 560; then
	echo test 560: Harmonic from Language Shootout
        cat >$test_file <<'TEST560'
var d, partialSum = 0.0, n = int (#argv < 1 ? 10000000 : argv [0]);

for (d = 1; d <= n; d++) partialSum += 1.0 / d;
putf ("%0.9f\n", partialSum);
TEST560
        echo '      ' $DINO $test_file 10000000 "2>$stderr"
        if $DINO $test_file 10000000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT560' && $CMP $stdout $ftemp2; then
16.695311366
OUTPUT560
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 561.
if test $result = ok -a $start_test_number -le 561; then
	echo test 561: K-nucleotide from Language Shootout
        cat >$test_file <<'TEST561'
fun kfrequency (seq, freq, k, frame) {
  var i, c, stop = #seq - k + 1;

  for (i = frame; i < stop; i += k) {
    c = subv (seq, i, k);
    if (c in freq) freq [c]++;
    else freq [c] = 1;
  }
}

fun count (seq, frag) {
  var frame, k = #frag, freq = tab [];

  for (frame = 0; frame < k; frame++) kfrequency (seq, freq, k, frame);
  putln (frag in freq ? freq [frag] : 0, "\t", frag);
}

fun frequency (seq, k) {
  var i, c, sum, frame, freq = tab [], sfreq = [];
  fun freq_cmp (el1, el2) {
    return freq [el2] - freq [el1];
  }

  for (frame = 0; frame < k; frame++) kfrequency (seq, freq, k, frame);
  for (c: freq) ins (sfreq, c, -1);
  sfreq = sort (sfreq, freq_cmp);
  sum = #seq - k + 1;
  for (i = 0; i < #sfreq; i++) {
    c = sfreq [i];
    putf ("%s %0.3f\n", c, (freq [c] * 100.) / sum);
  }
  putln ();
}

fun readseq {
  var c, line, lines = [];

  try {
    for (;;) {
      line = getln ();
      if (line [0] == '>' && subv (line, 1, 5) == "THREE") break;
    }
    for (;;) {
      line = getln ();
      c = line [0];
      if (c == '>')
	break;
      else if (c != ';')
	insv (lines, toupper (line), -1);
    }
  } catch (eof) {}
  return lines;
}

var seq = readseq ();
frequency (seq, 1);
frequency (seq, 2);
count (seq, "GGT");
count (seq, "GGTA");
count (seq, "GGTATT");
count (seq, "GGTATTTTAATT");
count (seq, "GGTATTTTAATTTATAGT");
TEST561
        echo '      ' $DINO $test_file 1000 "2>$stderr"
        if $DINO $test_file 1000 <<'INPUT561' 2>$stderr >$stdout; then
>ONE Homo sapiens alu
GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGA
TCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACT
AAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAG
GCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCG
CCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGT
GGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCA
GGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAA
TTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAG
AATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCA
GCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGT
AATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACC
AGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTG
GTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACC
CGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAG
AGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTT
TGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACA
TGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCT
GTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGG
TTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGT
CTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGG
CGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCG
TCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTA
CTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCG
AGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCG
GGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACC
TGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAA
TACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGA
GGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACT
GCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTC
ACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGT
TCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGC
CGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCG
CTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTG
GGCGACAGAGCGAGACTCCG
>TWO IUB ambiguity codes
cttBtatcatatgctaKggNcataaaSatgtaaaDcDRtBggDtctttataattcBgtcg
tactDtDagcctatttSVHtHttKtgtHMaSattgWaHKHttttagacatWatgtRgaaa
NtactMcSMtYtcMgRtacttctWBacgaaatatagScDtttgaagacacatagtVgYgt
cattHWtMMWcStgttaggKtSgaYaaccWStcgBttgcgaMttBYatcWtgacaYcaga
gtaBDtRacttttcWatMttDBcatWtatcttactaBgaYtcttgttttttttYaaScYa
HgtgttNtSatcMtcVaaaStccRcctDaataataStcYtRDSaMtDttgttSagtRRca
tttHatSttMtWgtcgtatSSagactYaaattcaMtWatttaSgYttaRgKaRtccactt
tattRggaMcDaWaWagttttgacatgttctacaaaRaatataataaMttcgDacgaSSt
acaStYRctVaNMtMgtaggcKatcttttattaaaaagVWaHKYagtttttatttaacct
tacgtVtcVaattVMBcttaMtttaStgacttagattWWacVtgWYagWVRctDattBYt
gtttaagaagattattgacVatMaacattVctgtBSgaVtgWWggaKHaatKWcBScSWa
accRVacacaaactaccScattRatatKVtactatatttHttaagtttSKtRtacaaagt
RDttcaaaaWgcacatWaDgtDKacgaacaattacaRNWaatHtttStgttattaaMtgt
tgDcgtMgcatBtgcttcgcgaDWgagctgcgaggggVtaaScNatttacttaatgacag
cccccacatYScaMgtaggtYaNgttctgaMaacNaMRaacaaacaKctacatagYWctg
ttWaaataaaataRattagHacacaagcgKatacBttRttaagtatttccgatctHSaat
actcNttMaagtattMtgRtgaMgcataatHcMtaBSaRattagttgatHtMttaaKagg
YtaaBataSaVatactWtataVWgKgttaaaacagtgcgRatatacatVtHRtVYataSa
KtWaStVcNKHKttactatccctcatgWHatWaRcttactaggatctataDtDHBttata
aaaHgtacVtagaYttYaKcctattcttcttaataNDaaggaaaDYgcggctaaWSctBa
aNtgctggMBaKctaMVKagBaactaWaDaMaccYVtNtaHtVWtKgRtcaaNtYaNacg
gtttNattgVtttctgtBaWgtaattcaagtcaVWtactNggattctttaYtaaagccgc
tcttagHVggaYtgtNcDaVagctctctKgacgtatagYcctRYHDtgBattDaaDgccK
tcHaaStttMcctagtattgcRgWBaVatHaaaataYtgtttagMDMRtaataaggatMt
ttctWgtNtgtgaaaaMaatatRtttMtDgHHtgtcattttcWattRSHcVagaagtacg
ggtaKVattKYagactNaatgtttgKMMgYNtcccgSKttctaStatatNVataYHgtNa
BKRgNacaactgatttcctttaNcgatttctctataScaHtataRagtcRVttacDSDtt
aRtSatacHgtSKacYagttMHtWataggatgactNtatSaNctataVtttRNKtgRacc
tttYtatgttactttttcctttaaacatacaHactMacacggtWataMtBVacRaSaatc
cgtaBVttccagccBcttaRKtgtgcctttttRtgtcagcRttKtaaacKtaaatctcac
aattgcaNtSBaaccgggttattaaBcKatDagttactcttcattVtttHaaggctKKga
tacatcBggScagtVcacattttgaHaDSgHatRMaHWggtatatRgccDttcgtatcga
aacaHtaagttaRatgaVacttagattVKtaaYttaaatcaNatccRttRRaMScNaaaD
gttVHWgtcHaaHgacVaWtgttScactaagSgttatcttagggDtaccagWattWtRtg
ttHWHacgattBtgVcaYatcggttgagKcWtKKcaVtgaYgWctgYggVctgtHgaNcV
taBtWaaYatcDRaaRtSctgaHaYRttagatMatgcatttNattaDttaattgttctaa
ccctcccctagaWBtttHtBccttagaVaatMcBHagaVcWcagBVttcBtaYMccagat
gaaaaHctctaacgttagNWRtcggattNatcRaNHttcagtKttttgWatWttcSaNgg
gaWtactKKMaacatKatacNattgctWtatctaVgagctatgtRaHtYcWcttagccaa
tYttWttaWSSttaHcaaaaagVacVgtaVaRMgattaVcDactttcHHggHRtgNcctt
tYatcatKgctcctctatVcaaaaKaaaagtatatctgMtWtaaaacaStttMtcgactt
taSatcgDataaactaaacaagtaaVctaggaSccaatMVtaaSKNVattttgHccatca
cBVctgcaVatVttRtactgtVcaattHgtaaattaaattttYtatattaaRSgYtgBag
aHSBDgtagcacRHtYcBgtcacttacactaYcgctWtattgSHtSatcataaatataHt
cgtYaaMNgBaatttaRgaMaatatttBtttaaaHHKaatctgatWatYaacttMctctt
ttVctagctDaaagtaVaKaKRtaacBgtatccaaccactHHaagaagaaggaNaaatBW
attccgStaMSaMatBttgcatgRSacgttVVtaaDMtcSgVatWcaSatcttttVatag
ttactttacgatcaccNtaDVgSRcgVcgtgaacgaNtaNatatagtHtMgtHcMtagaa
attBgtataRaaaacaYKgtRccYtatgaagtaataKgtaaMttgaaRVatgcagaKStc
tHNaaatctBBtcttaYaBWHgtVtgacagcaRcataWctcaBcYacYgatDgtDHccta
>THREE Homo sapiens frequency
aacacttcaccaggtatcgtgaaggctcaagattacccagagaacctttgcaatataaga
atatgtatgcagcattaccctaagtaattatattctttttctgactcaaagtgacaagcc
ctagtgtatattaaatcggtatatttgggaaattcctcaaactatcctaatcaggtagcc
atgaaagtgatcaaaaaagttcgtacttataccatacatgaattctggccaagtaaaaaa
tagattgcgcaaaattcgtaccttaagtctctcgccaagatattaggatcctattactca
tatcgtgtttttctttattgccgccatccccggagtatctcacccatccttctcttaaag
gcctaatattacctatgcaaataaacatatattgttgaaaattgagaacctgatcgtgat
tcttatgtgtaccatatgtatagtaatcacgcgactatatagtgctttagtatcgcccgt
gggtgagtgaatattctgggctagcgtgagatagtttcttgtcctaatatttttcagatc
gaatagcttctatttttgtgtttattgacatatgtcgaaactccttactcagtgaaagtc
atgaccagatccacgaacaatcttcggaatcagtctcgttttacggcggaatcttgagtc
taacttatatcccgtcgcttactttctaacaccccttatgtatttttaaaattacgttta
ttcgaacgtacttggcggaagcgttattttttgaagtaagttacattgggcagactcttg
acattttcgatacgactttctttcatccatcacaggactcgttcgtattgatatcagaag
ctcgtgatgattagttgtcttctttaccaatactttgaggcctattctgcgaaatttttg
ttgccctgcgaacttcacataccaaggaacacctcgcaacatgccttcatatccatcgtt
cattgtaattcttacacaatgaatcctaagtaattacatccctgcgtaaaagatggtagg
ggcactgaggatatattaccaagcatttagttatgagtaatcagcaatgtttcttgtatt
aagttctctaaaatagttacatcgtaatgttatctcgggttccgcgaataaacgagatag
attcattatatatggccctaagcaaaaacctcctcgtattctgttggtaattagaatcac
acaatacgggttgagatattaattatttgtagtacgaagagatataaaaagatgaacaat
tactcaagtcaagatgtatacgggatttataataaaaatcgggtagagatctgctttgca
attcagacgtgccactaaatcgtaatatgtcgcgttacatcagaaagggtaactattatt
aattaataaagggcttaatcactacatattagatcttatccgatagtcttatctattcgt
tgtatttttaagcggttctaattcagtcattatatcagtgctccgagttctttattattg
ttttaaggatgacaaaatgcctcttgttataacgctgggagaagcagactaagagtcgga
gcagttggtagaatgaggctgcaaaagacggtctcgacgaatggacagactttactaaac
caatgaaagacagaagtagagcaaagtctgaagtggtatcagcttaattatgacaaccct
taatacttccctttcgccgaatactggcgtggaaaggttttaaaagtcgaagtagttaga
ggcatctctcgctcataaataggtagactactcgcaatccaatgtgactatgtaatactg
ggaacatcagtccgcgatgcagcgtgtttatcaaccgtccccactcgcctggggagacat
gagaccacccccgtggggattattagtccgcagtaatcgactcttgacaatccttttcga
ttatgtcatagcaatttacgacagttcagcgaagtgactactcggcgaaatggtattact
aaagcattcgaacccacatgaatgtgattcttggcaatttctaatccactaaagcttttc
cgttgaatctggttgtagatatttatataagttcactaattaagatcacggtagtatatt
gatagtgatgtctttgcaagaggttggccgaggaatttacggattctctattgatacaat
ttgtctggcttataactcttaaggctgaaccaggcgtttttagacgacttgatcagctgt
tagaatggtttggactccctctttcatgtcagtaacatttcagccgttattgttacgata
tgcttgaacaatattgatctaccacacacccatagtatattttataggtcatgctgttac
ctacgagcatggtattccacttcccattcaatgagtattcaacatcactagcctcagaga
tgatgacccacctctaataacgtcacgttgcggccatgtgaaacctgaacttgagtagac
gatatcaagcgctttaaattgcatataacatttgagggtaaagctaagcggatgctttat
ataatcaatactcaataataagatttgattgcattttagagttatgacacgacatagttc
actaacgagttactattcccagatctagactgaagtactgatcgagacgatccttacgtc
gatgatcgttagttatcgacttaggtcgggtctctagcggtattggtacttaaccggaca
ctatactaataacccatgatcaaagcataacagaatacagacgataatttcgccaacata
tatgtacagaccccaagcatgagaagctcattgaaagctatcattgaagtcccgctcaca
atgtgtcttttccagacggtttaactggttcccgggagtcctggagtttcgacttacata
aatggaaacaatgtattttgctaatttatctatagcgtcatttggaccaatacagaatat
tatgttgcctagtaatccactataacccgcaagtgctgatagaaaatttttagacgattt
ataaatgccccaagtatccctcccgtgaatcctccgttatactaattagtattcgttcat
acgtataccgcgcatatatgaacatttggcgataaggcgcgtgaattgttacgtgacaga
gatagcagtttcttgtgatatggttaacagacgtacatgaagggaaactttatatctata
gtgatgcttccgtagaaataccgccactggtctgccaatgatgaagtatgtagctttagg
tttgtactatgaggctttcgtttgtttgcagagtataacagttgcgagtgaaaaaccgac
gaatttatactaatacgctttcactattggctacaaaatagggaagagtttcaatcatga
gagggagtatatggatgctttgtagctaaaggtagaacgtatgtatatgctgccgttcat
tcttgaaagatacataagcgataagttacgacaattataagcaacatccctaccttcgta
acgatttcactgttactgcgcttgaaatacactatggggctattggcggagagaagcaga
tcgcgccgagcatatacgagacctataatgttgatgatagagaaggcgtctgaattgata
catcgaagtacactttctttcgtagtatctctcgtcctctttctatctccggacacaaga
attaagttatatatatagagtcttaccaatcatgttgaatcctgattctcagagttcttt
ggcgggccttgtgatgactgagaaacaatgcaatattgctccaaatttcctaagcaaatt
ctcggttatgttatgttatcagcaaagcgttacgttatgttatttaaatctggaatgacg
gagcgaagttcttatgtcggtgtgggaataattcttttgaagacagcactccttaaataa
tatcgctccgtgtttgtatttatcgaatgggtctgtaaccttgcacaagcaaatcggtgg
tgtatatatcggataacaattaatacgatgttcatagtgacagtatactgatcgagtcct
ctaaagtcaattacctcacttaacaatctcattgatgttgtgtcattcccggtatcgccc
gtagtatgtgctctgattgaccgagtgtgaaccaaggaacatctactaatgcctttgtta
ggtaagatctctctgaattccttcgtgccaacttaaaacattatcaaaatttcttctact
tggattaactacttttacgagcatggcaaattcccctgtggaagacggttcattattatc
ggaaaccttatagaaattgcgtgttgactgaaattagatttttattgtaagagttgcatc
tttgcgattcctctggtctagcttccaatgaacagtcctcccttctattcgacatcgggt
ccttcgtacatgtctttgcgatgtaataattaggttcggagtgtggccttaatgggtgca
actaggaatacaacgcaaatttgctgacatgatagcaaatcggtatgccggcaccaaaac
gtgctccttgcttagcttgtgaatgagactcagtagttaaataaatccatatctgcaatc
gattccacaggtattgtccactatctttgaactactctaagagatacaagcttagctgag
accgaggtgtatatgactacgctgatatctgtaaggtaccaatgcaggcaaagtatgcga
gaagctaataccggctgtttccagctttataagattaaaatttggctgtcctggcggcct
cagaattgttctatcgtaatcagttggttcattaattagctaagtacgaggtacaactta
tctgtcccagaacagctccacaagtttttttacagccgaaacccctgtgtgaatcttaat
atccaagcgcgttatctgattagagtttacaactcagtattttatcagtacgttttgttt
ccaacattacccggtatgacaaaatgacgccacgtgtcgaataatggtctgaccaatgta
ggaagtgaaaagataaatat
INPUT561
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT561' && $CMP $stdout $ftemp2; then
T 31.520
A 29.600
C 19.480
G 19.400

AT 9.922
TT 9.602
TA 9.402
AA 8.402
GA 6.321
TC 6.301
TG 6.201
GT 6.041
CT 5.961
AG 5.841
CA 5.461
AC 5.441
CC 4.041
CG 4.021
GC 3.701
GG 3.341

54	GGT
24	GGTA
4	GGTATT
0	GGTATTTTAATT
0	GGTATTTTAATTTATAGT
OUTPUT561
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 562.
if test $result = ok -a $start_test_number -le 562; then
	echo test 562: Fasta from Language Shootout
        cat >$test_file <<'TEST562'
var PI = 3.141592653589793;
var SOLAR_MASS = 4 * PI * PI;
var DAYS_PER_YEAR = 365.24;

class body (x, y, z, vx, vy, vz, mass) {}

var Jupiter = body (4.84143144246472090e+00,
		    -1.16032004402742839e+00,
	            -1.03622044471123109e-01,
		    1.66007664274403694e-03 * DAYS_PER_YEAR,
		    7.69901118419740425e-03 * DAYS_PER_YEAR,
		    -6.90460016972063023e-05 * DAYS_PER_YEAR,
		    9.54791938424326609e-04 * SOLAR_MASS);

var Saturn = body (8.34336671824457987e+00,
		   4.12479856412430479e+00,
		   -4.03523417114321381e-01,
		   -2.76742510726862411e-03 * DAYS_PER_YEAR,
		   4.99852801234917238e-03 * DAYS_PER_YEAR,
		   2.30417297573763929e-05 * DAYS_PER_YEAR,
		   2.85885980666130812e-04 * SOLAR_MASS);

var Uranus = body (1.28943695621391310e+01,
		   -1.51111514016986312e+01,
		   -2.23307578892655734e-01,
		   2.96460137564761618e-03 * DAYS_PER_YEAR,
		   2.37847173959480950e-03 * DAYS_PER_YEAR,
		   -2.96589568540237556e-05 * DAYS_PER_YEAR,
		   4.36624404335156298e-05 * SOLAR_MASS);

var Neptune = body (1.53796971148509165e+01,
		    -2.59193146099879641e+01,
		    1.79258772950371181e-01,
		    2.68067772490389322e-03 * DAYS_PER_YEAR,
		    1.62824170038242295e-03 * DAYS_PER_YEAR,
		    -9.51592254519715870e-05 * DAYS_PER_YEAR,
		    5.15138902046611451e-05 * SOLAR_MASS);

var Sun = body (0., 0., 0., 0., 0., 0., SOLAR_MASS);

fun advance (bodies, dt) {
  var i, j;

  for (i = 0; i < #bodies; i++) {
    var bi = bodies [i];
    var bix = bi.x, biy = bi.y, biz = bi.z, bimass = bi.mass;
    var bivx = bi.vx, bivy = bi.vy, bivz = bi.vz;

    for (j = i + 1; j < #bodies; j++) {
      var bj = bodies [j];
      var dx = bix - bj.x, dy = biy - bj.y, dz = biz - bj.z;
      var distance = sqrt (dx * dx + dy * dy + dz * dz);
      var mag = dt / (distance * distance * distance);
      var bim = bimass * mag, bjm = bj.mass * mag;
      
      bivx -= dx * bjm; bivy -= dy * bjm; bivz -= dz * bjm;
      bj.vx += dx * bim; bj.vy += dy * bim; bj.vz += dz * bim;
    }
    bi.vx = bivx; bi.vy = bivy; bi.vz = bivz;
  }
  for (i = 0; i < #bodies; i++) {
    var bi = bodies[i];

    bi.x += dt * bi.vx; bi.y += dt * bi.vy; bi.z += dt * bi.vz;
  }
}

fun energy (bodies) {
  var i, j, e = 0.;

  for (i = 0; i < #bodies; i++) {
    var bi = bodies [i];
    var vx = bi.vx, vy = bi.vy, vz = bi.vz, bim = bi.mass;

    e = e + (0.5 * bim * (vx * vx + vy * vy + vz * vz));
    for (j = i + 1; j < #bodies; j++) {
      var bj = bodies [j];
      var dx = bi.x - bj.x, dy = bi.y - bj.y, dz = bi.z - bj.z;
      var distance = sqrt (dx * dx + dy * dy + dz * dz);

      e = e - ((bim * bj.mass) / distance);
    }
  }
  return e;
}

fun offsetMomentum (b) {
  var i, px = 0., py = 0., pz = 0.;

  for (i = 0; i < #b; i++) {
    var bi = b [i];
    var bim = bi.mass;

    px = px + (bi.vx * bim);
    py = py + (bi.vy * bim);
    pz = pz + (bi.vz * bim);
  }
  b [0].vx = -px / SOLAR_MASS;
  b [0].vy = -py / SOLAR_MASS;
  b [0].vz = -pz / SOLAR_MASS;
}

var i, N = int (#argv < 1 ? 1000 : argv [0]);
var bodies = [Sun, Jupiter, Saturn, Uranus, Neptune];

offsetMomentum (bodies);
putf ("%0.9f\n", energy (bodies));
for (i = 0; i < N; i++) {advance (bodies, 0.01);}
putf ("%0.9f\n", energy (bodies));
TEST562
        echo '      ' $DINO $test_file 100000 "2>$stderr"
        if $DINO $test_file 100000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT562' && $CMP $stdout $ftemp2; then
-0.169075164
-0.169079859
OUTPUT562
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 563.
if test $result = ok -a $start_test_number -le 563; then
	echo test 563: Nsieve from Language Shootout
        cat >$test_file <<'TEST563'
fun nsieve (m) {
  var i, k, flags = [m + 1 : 1], count = 0;
  
  for (i = 2; i <= m; i++)
    if (flags [i]) {
      for (k = i + i; k <= m; k += i)
	flags [k] = 0;
      count++;
    }
  return count;
}

var i, m, n = max (2, int (#argv < 1 ? 1 : argv [0]));

for (i = 0; i <= 2; i++) {
  m = (1 << (n - i)) * 10000; putf ("Primes up to %8d %8d\n", m, nsieve (m));
}
TEST563
        echo '      ' $DINO $test_file 8 "2>$stderr"
        if $DINO $test_file 8 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT563' && $CMP $stdout $ftemp2; then
Primes up to  2560000   187134
Primes up to  1280000    98610
Primes up to   640000    52074
OUTPUT563
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 564.
if test $result = ok -a $start_test_number -le 564; then
	echo test 564: Nsieve Bits from Language Shootout
        cat >$test_file <<'TEST564'
var power = 5, precision = 1 << power, mask = precision - 1;

fun nsieve (m) {
  var i, k, cm = (m + precision) / precision, flags = [cm : ~0], count = 0;
  
  for (i = 2; i <= m; i++)
    if (flags [i >> power] & (1 << (i & mask))) {
      for (k = i + i; k <= m; k += i)
	flags [k >> power] &= ~(1 << (k & mask));
      count++;
    }
  return count;
}


var i, m, N = max (2, int (#argv < 1 ? 1 : argv [0]));

for (i = 0; i <= 2; i++) {
  m = (1 << (N - i)) * 10000;
  putf ("Primes up to %8d %8d\n", m, nsieve (m));
}
TEST564
        echo '      ' $DINO $test_file 8 "2>$stderr"
        if $DINO $test_file 8 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT564' && $CMP $stdout $ftemp2; then
Primes up to  2560000   187134
Primes up to  1280000    98610
Primes up to   640000    52074
OUTPUT564
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 565.
if test $result = ok -a $start_test_number -le 565; then
	echo test 565: Pidigits from Language Shootout
        cat >$test_file <<'TEST565'
var k = 0, z = [1L, 0L, 0L, 1L];

fun extract_digit; fun compose; fun next_lft;

fun next_digit {
  var y;

  for (;;) {
    y = extract_digit (3);
    if (y == extract_digit (4)) {
      z = compose ([10L, long (-10 * y), 0L, 1L], z);
      return y;
    }
    z = compose (z, next_lft ());
  }
}

fun next_lft {
  k++;
  return [long (k), long (4 * k + 2), 0L, long (2 * k + 1)];
}

fun extract_digit (x) {
  var xx = long (x);

  return int ((z [0] * xx + z [1]) / (z [2] * xx + z [3]));
}

fun compose (z, w) {
  return [z [0] * w [0] + z [1] * w [2], z [0] * w [1] + z [1] * w [3],
	  z [2] * w [0] + z [3] * w [2], z [2] * w [1] + z [3] * w [3]];
}

// main loop

var i, j, n = int (argv [0]);

for(i = 1; i <= n; i++) {
  put (next_digit());
  if (i % 10 == 0) putln ("\t:", i);
}

if (n % 10 != 0) {
  for (j = n % 10; j <= 10; j++) put (" ");
  putln ("\t:", n);
}
TEST565
        echo '      ' $DINO $test_file 1000 "2>$stderr"
        if $DINO $test_file 1000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT565' && $CMP $stdout $ftemp2; then
3141592653	:10
5897932384	:20
6264338327	:30
9502884197	:40
1693993751	:50
0582097494	:60
4592307816	:70
4062862089	:80
9862803482	:90
5342117067	:100
9821480865	:110
1328230664	:120
7093844609	:130
5505822317	:140
2535940812	:150
8481117450	:160
2841027019	:170
3852110555	:180
9644622948	:190
9549303819	:200
6442881097	:210
5665933446	:220
1284756482	:230
3378678316	:240
5271201909	:250
1456485669	:260
2346034861	:270
0454326648	:280
2133936072	:290
6024914127	:300
3724587006	:310
6063155881	:320
7488152092	:330
0962829254	:340
0917153643	:350
6789259036	:360
0011330530	:370
5488204665	:380
2138414695	:390
1941511609	:400
4330572703	:410
6575959195	:420
3092186117	:430
3819326117	:440
9310511854	:450
8074462379	:460
9627495673	:470
5188575272	:480
4891227938	:490
1830119491	:500
2983367336	:510
2440656643	:520
0860213949	:530
4639522473	:540
7190702179	:550
8609437027	:560
7053921717	:570
6293176752	:580
3846748184	:590
6766940513	:600
2000568127	:610
1452635608	:620
2778577134	:630
2757789609	:640
1736371787	:650
2146844090	:660
1224953430	:670
1465495853	:680
7105079227	:690
9689258923	:700
5420199561	:710
1212902196	:720
0864034418	:730
1598136297	:740
7477130996	:750
0518707211	:760
3499999983	:770
7297804995	:780
1059731732	:790
8160963185	:800
9502445945	:810
5346908302	:820
6425223082	:830
5334468503	:840
5261931188	:850
1710100031	:860
3783875288	:870
6587533208	:880
3814206171	:890
7766914730	:900
3598253490	:910
4287554687	:920
3115956286	:930
3882353787	:940
5937519577	:950
8185778053	:960
2171226806	:970
6130019278	:980
7661119590	:990
9216420198	:1000
OUTPUT565
                        result=ok
                else
                        result=fail
                fi
       elif fgrep 'run time error - can not find external function' $stderr >/dev/null;then
		echo GMP package is absent -- skip
                result=ok
        else
                result=fail
        fi
fi

# Test 567.
if test $result = ok -a $start_test_number -le 566; then
	echo test 566: Random from Language Shootout
        cat >$test_file <<'TEST567'
var c, i, v, seq = getf (), ilen = #seq;

seq = gsub (">[^\n]+\n|\n", seq, "");

var clen = #seq;
var variants = ["agggtaaa|tttaccct", "[cgt]gggtaaa|tttaccc[acg]",
		"a[act]ggtaaa|tttacc[agt]t", "ag[act]gtaaa|tttac[agt]ct",
		"agg[act]taaa|ttta[agt]cct", "aggg[acg]aaa|ttt[cgt]ccct",
		"agggt[cgt]aa|tt[acg]accct", "agggta[cgt]a|t[acg]taccct",
		"agggtaa[cgt]|[acg]ttaccct"];

for (i = 0; i < #variants; i++) {
  v = gmatch (variants [i], seq);
  putln (variants [i], " ", v == nil ? 0 : #v / 2);
}

var subst = tab [
  "B" : "(c|g|t)", "D" : "(a|g|t)", "H" : "(a|c|t)", "K" : "(g|t)",
  "M" : "(a|c)", "N" : "(a|c|g|t)", "R" : "(a|g)", "S" : "(c|g)",
  "V" : "(a|c|g)", "W" : "(a|t)", "Y" : "(c|t)"
];

for (c: subst)
  seq = gsub (c, seq, subst [c]);

putln ("\n", ilen, "\n", clen, "\n", #seq);
TEST567
        echo '      ' $DINO $test_file 1000 "2>$stderr"
        if $DINO $test_file 1000 <<'INPUT567' 2>$stderr >$stdout; then
>ONE Homo sapiens alu
GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGA
TCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACT
AAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAG
GCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCG
CCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGT
GGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCA
GGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAA
TTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAG
AATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCA
GCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGT
AATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACC
AGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTG
GTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACC
CGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAG
AGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTT
TGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACA
TGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCT
GTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGG
TTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGT
CTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGG
CGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCG
TCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTA
CTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCG
AGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCG
GGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACC
TGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAA
TACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGA
GGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACT
GCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTC
ACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGT
TCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGC
CGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCG
CTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTG
GGCGACAGAGCGAGACTCCG
>TWO IUB ambiguity codes
cttBtatcatatgctaKggNcataaaSatgtaaaDcDRtBggDtctttataattcBgtcg
tactDtDagcctatttSVHtHttKtgtHMaSattgWaHKHttttagacatWatgtRgaaa
NtactMcSMtYtcMgRtacttctWBacgaaatatagScDtttgaagacacatagtVgYgt
cattHWtMMWcStgttaggKtSgaYaaccWStcgBttgcgaMttBYatcWtgacaYcaga
gtaBDtRacttttcWatMttDBcatWtatcttactaBgaYtcttgttttttttYaaScYa
HgtgttNtSatcMtcVaaaStccRcctDaataataStcYtRDSaMtDttgttSagtRRca
tttHatSttMtWgtcgtatSSagactYaaattcaMtWatttaSgYttaRgKaRtccactt
tattRggaMcDaWaWagttttgacatgttctacaaaRaatataataaMttcgDacgaSSt
acaStYRctVaNMtMgtaggcKatcttttattaaaaagVWaHKYagtttttatttaacct
tacgtVtcVaattVMBcttaMtttaStgacttagattWWacVtgWYagWVRctDattBYt
gtttaagaagattattgacVatMaacattVctgtBSgaVtgWWggaKHaatKWcBScSWa
accRVacacaaactaccScattRatatKVtactatatttHttaagtttSKtRtacaaagt
RDttcaaaaWgcacatWaDgtDKacgaacaattacaRNWaatHtttStgttattaaMtgt
tgDcgtMgcatBtgcttcgcgaDWgagctgcgaggggVtaaScNatttacttaatgacag
cccccacatYScaMgtaggtYaNgttctgaMaacNaMRaacaaacaKctacatagYWctg
ttWaaataaaataRattagHacacaagcgKatacBttRttaagtatttccgatctHSaat
actcNttMaagtattMtgRtgaMgcataatHcMtaBSaRattagttgatHtMttaaKagg
YtaaBataSaVatactWtataVWgKgttaaaacagtgcgRatatacatVtHRtVYataSa
KtWaStVcNKHKttactatccctcatgWHatWaRcttactaggatctataDtDHBttata
aaaHgtacVtagaYttYaKcctattcttcttaataNDaaggaaaDYgcggctaaWSctBa
aNtgctggMBaKctaMVKagBaactaWaDaMaccYVtNtaHtVWtKgRtcaaNtYaNacg
gtttNattgVtttctgtBaWgtaattcaagtcaVWtactNggattctttaYtaaagccgc
tcttagHVggaYtgtNcDaVagctctctKgacgtatagYcctRYHDtgBattDaaDgccK
tcHaaStttMcctagtattgcRgWBaVatHaaaataYtgtttagMDMRtaataaggatMt
ttctWgtNtgtgaaaaMaatatRtttMtDgHHtgtcattttcWattRSHcVagaagtacg
ggtaKVattKYagactNaatgtttgKMMgYNtcccgSKttctaStatatNVataYHgtNa
BKRgNacaactgatttcctttaNcgatttctctataScaHtataRagtcRVttacDSDtt
aRtSatacHgtSKacYagttMHtWataggatgactNtatSaNctataVtttRNKtgRacc
tttYtatgttactttttcctttaaacatacaHactMacacggtWataMtBVacRaSaatc
cgtaBVttccagccBcttaRKtgtgcctttttRtgtcagcRttKtaaacKtaaatctcac
aattgcaNtSBaaccgggttattaaBcKatDagttactcttcattVtttHaaggctKKga
tacatcBggScagtVcacattttgaHaDSgHatRMaHWggtatatRgccDttcgtatcga
aacaHtaagttaRatgaVacttagattVKtaaYttaaatcaNatccRttRRaMScNaaaD
gttVHWgtcHaaHgacVaWtgttScactaagSgttatcttagggDtaccagWattWtRtg
ttHWHacgattBtgVcaYatcggttgagKcWtKKcaVtgaYgWctgYggVctgtHgaNcV
taBtWaaYatcDRaaRtSctgaHaYRttagatMatgcatttNattaDttaattgttctaa
ccctcccctagaWBtttHtBccttagaVaatMcBHagaVcWcagBVttcBtaYMccagat
gaaaaHctctaacgttagNWRtcggattNatcRaNHttcagtKttttgWatWttcSaNgg
gaWtactKKMaacatKatacNattgctWtatctaVgagctatgtRaHtYcWcttagccaa
tYttWttaWSSttaHcaaaaagVacVgtaVaRMgattaVcDactttcHHggHRtgNcctt
tYatcatKgctcctctatVcaaaaKaaaagtatatctgMtWtaaaacaStttMtcgactt
taSatcgDataaactaaacaagtaaVctaggaSccaatMVtaaSKNVattttgHccatca
cBVctgcaVatVttRtactgtVcaattHgtaaattaaattttYtatattaaRSgYtgBag
aHSBDgtagcacRHtYcBgtcacttacactaYcgctWtattgSHtSatcataaatataHt
cgtYaaMNgBaatttaRgaMaatatttBtttaaaHHKaatctgatWatYaacttMctctt
ttVctagctDaaagtaVaKaKRtaacBgtatccaaccactHHaagaagaaggaNaaatBW
attccgStaMSaMatBttgcatgRSacgttVVtaaDMtcSgVatWcaSatcttttVatag
ttactttacgatcaccNtaDVgSRcgVcgtgaacgaNtaNatatagtHtMgtHcMtagaa
attBgtataRaaaacaYKgtRccYtatgaagtaataKgtaaMttgaaRVatgcagaKStc
tHNaaatctBBtcttaYaBWHgtVtgacagcaRcataWctcaBcYacYgatDgtDHccta
>THREE Homo sapiens frequency
aacacttcaccaggtatcgtgaaggctcaagattacccagagaacctttgcaatataaga
atatgtatgcagcattaccctaagtaattatattctttttctgactcaaagtgacaagcc
ctagtgtatattaaatcggtatatttgggaaattcctcaaactatcctaatcaggtagcc
atgaaagtgatcaaaaaagttcgtacttataccatacatgaattctggccaagtaaaaaa
tagattgcgcaaaattcgtaccttaagtctctcgccaagatattaggatcctattactca
tatcgtgtttttctttattgccgccatccccggagtatctcacccatccttctcttaaag
gcctaatattacctatgcaaataaacatatattgttgaaaattgagaacctgatcgtgat
tcttatgtgtaccatatgtatagtaatcacgcgactatatagtgctttagtatcgcccgt
gggtgagtgaatattctgggctagcgtgagatagtttcttgtcctaatatttttcagatc
gaatagcttctatttttgtgtttattgacatatgtcgaaactccttactcagtgaaagtc
atgaccagatccacgaacaatcttcggaatcagtctcgttttacggcggaatcttgagtc
taacttatatcccgtcgcttactttctaacaccccttatgtatttttaaaattacgttta
ttcgaacgtacttggcggaagcgttattttttgaagtaagttacattgggcagactcttg
acattttcgatacgactttctttcatccatcacaggactcgttcgtattgatatcagaag
ctcgtgatgattagttgtcttctttaccaatactttgaggcctattctgcgaaatttttg
ttgccctgcgaacttcacataccaaggaacacctcgcaacatgccttcatatccatcgtt
cattgtaattcttacacaatgaatcctaagtaattacatccctgcgtaaaagatggtagg
ggcactgaggatatattaccaagcatttagttatgagtaatcagcaatgtttcttgtatt
aagttctctaaaatagttacatcgtaatgttatctcgggttccgcgaataaacgagatag
attcattatatatggccctaagcaaaaacctcctcgtattctgttggtaattagaatcac
acaatacgggttgagatattaattatttgtagtacgaagagatataaaaagatgaacaat
tactcaagtcaagatgtatacgggatttataataaaaatcgggtagagatctgctttgca
attcagacgtgccactaaatcgtaatatgtcgcgttacatcagaaagggtaactattatt
aattaataaagggcttaatcactacatattagatcttatccgatagtcttatctattcgt
tgtatttttaagcggttctaattcagtcattatatcagtgctccgagttctttattattg
ttttaaggatgacaaaatgcctcttgttataacgctgggagaagcagactaagagtcgga
gcagttggtagaatgaggctgcaaaagacggtctcgacgaatggacagactttactaaac
caatgaaagacagaagtagagcaaagtctgaagtggtatcagcttaattatgacaaccct
taatacttccctttcgccgaatactggcgtggaaaggttttaaaagtcgaagtagttaga
ggcatctctcgctcataaataggtagactactcgcaatccaatgtgactatgtaatactg
ggaacatcagtccgcgatgcagcgtgtttatcaaccgtccccactcgcctggggagacat
gagaccacccccgtggggattattagtccgcagtaatcgactcttgacaatccttttcga
ttatgtcatagcaatttacgacagttcagcgaagtgactactcggcgaaatggtattact
aaagcattcgaacccacatgaatgtgattcttggcaatttctaatccactaaagcttttc
cgttgaatctggttgtagatatttatataagttcactaattaagatcacggtagtatatt
gatagtgatgtctttgcaagaggttggccgaggaatttacggattctctattgatacaat
ttgtctggcttataactcttaaggctgaaccaggcgtttttagacgacttgatcagctgt
tagaatggtttggactccctctttcatgtcagtaacatttcagccgttattgttacgata
tgcttgaacaatattgatctaccacacacccatagtatattttataggtcatgctgttac
ctacgagcatggtattccacttcccattcaatgagtattcaacatcactagcctcagaga
tgatgacccacctctaataacgtcacgttgcggccatgtgaaacctgaacttgagtagac
gatatcaagcgctttaaattgcatataacatttgagggtaaagctaagcggatgctttat
ataatcaatactcaataataagatttgattgcattttagagttatgacacgacatagttc
actaacgagttactattcccagatctagactgaagtactgatcgagacgatccttacgtc
gatgatcgttagttatcgacttaggtcgggtctctagcggtattggtacttaaccggaca
ctatactaataacccatgatcaaagcataacagaatacagacgataatttcgccaacata
tatgtacagaccccaagcatgagaagctcattgaaagctatcattgaagtcccgctcaca
atgtgtcttttccagacggtttaactggttcccgggagtcctggagtttcgacttacata
aatggaaacaatgtattttgctaatttatctatagcgtcatttggaccaatacagaatat
tatgttgcctagtaatccactataacccgcaagtgctgatagaaaatttttagacgattt
ataaatgccccaagtatccctcccgtgaatcctccgttatactaattagtattcgttcat
acgtataccgcgcatatatgaacatttggcgataaggcgcgtgaattgttacgtgacaga
gatagcagtttcttgtgatatggttaacagacgtacatgaagggaaactttatatctata
gtgatgcttccgtagaaataccgccactggtctgccaatgatgaagtatgtagctttagg
tttgtactatgaggctttcgtttgtttgcagagtataacagttgcgagtgaaaaaccgac
gaatttatactaatacgctttcactattggctacaaaatagggaagagtttcaatcatga
gagggagtatatggatgctttgtagctaaaggtagaacgtatgtatatgctgccgttcat
tcttgaaagatacataagcgataagttacgacaattataagcaacatccctaccttcgta
acgatttcactgttactgcgcttgaaatacactatggggctattggcggagagaagcaga
tcgcgccgagcatatacgagacctataatgttgatgatagagaaggcgtctgaattgata
catcgaagtacactttctttcgtagtatctctcgtcctctttctatctccggacacaaga
attaagttatatatatagagtcttaccaatcatgttgaatcctgattctcagagttcttt
ggcgggccttgtgatgactgagaaacaatgcaatattgctccaaatttcctaagcaaatt
ctcggttatgttatgttatcagcaaagcgttacgttatgttatttaaatctggaatgacg
gagcgaagttcttatgtcggtgtgggaataattcttttgaagacagcactccttaaataa
tatcgctccgtgtttgtatttatcgaatgggtctgtaaccttgcacaagcaaatcggtgg
tgtatatatcggataacaattaatacgatgttcatagtgacagtatactgatcgagtcct
ctaaagtcaattacctcacttaacaatctcattgatgttgtgtcattcccggtatcgccc
gtagtatgtgctctgattgaccgagtgtgaaccaaggaacatctactaatgcctttgtta
ggtaagatctctctgaattccttcgtgccaacttaaaacattatcaaaatttcttctact
tggattaactacttttacgagcatggcaaattcccctgtggaagacggttcattattatc
ggaaaccttatagaaattgcgtgttgactgaaattagatttttattgtaagagttgcatc
tttgcgattcctctggtctagcttccaatgaacagtcctcccttctattcgacatcgggt
ccttcgtacatgtctttgcgatgtaataattaggttcggagtgtggccttaatgggtgca
actaggaatacaacgcaaatttgctgacatgatagcaaatcggtatgccggcaccaaaac
gtgctccttgcttagcttgtgaatgagactcagtagttaaataaatccatatctgcaatc
gattccacaggtattgtccactatctttgaactactctaagagatacaagcttagctgag
accgaggtgtatatgactacgctgatatctgtaaggtaccaatgcaggcaaagtatgcga
gaagctaataccggctgtttccagctttataagattaaaatttggctgtcctggcggcct
cagaattgttctatcgtaatcagttggttcattaattagctaagtacgaggtacaactta
tctgtcccagaacagctccacaagtttttttacagccgaaacccctgtgtgaatcttaat
atccaagcgcgttatctgattagagtttacaactcagtattttatcagtacgttttgttt
ccaacattacccggtatgacaaaatgacgccacgtgtcgaataatggtctgaccaatgta
ggaagtgaaaagataaatat
INPUT567
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT567' && $CMP $stdout $ftemp2; then
agggtaaa|tttaccct 1
[cgt]gggtaaa|tttaccc[acg] 0
a[act]ggtaaa|tttacc[agt]t 0
ag[act]gtaaa|tttac[agt]ct 0
agg[act]taaa|ttta[agt]cct 1
aggg[acg]aaa|ttt[cgt]ccct 0
agggt[cgt]aa|tt[acg]accct 0
agggta[cgt]a|t[acg]taccct 0
agggtaa[cgt]|[acg]ttaccct 2

10245
10000
13348
OUTPUT567
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 568.
if test $result = ok -a $start_test_number -le 568; then
	echo test 568: Reverse Complement from Language Shootout
        cat >$test_file <<'TEST568'
var tr =   "ACBDGHKMNSRUTWVYacbdghkmnsrutwvy";
var subst = "TGVHCDMKNSYAAWBRTGVHCDMKNSYAAWBR";
var line, seq = [];

fun output_seq (seq) {
  var i;

  for (i = 0; i < #seq; i += 60) putln (subv (seq, i, 60));
}

try {
  for (;;) {
    line = getln ();
    if (line [0] != '>') insv (seq, line, -1);
    else {
      output_seq (translit (rev (seq), tr, subst));
      del (seq, 0, -1); putln (line);
    }
  }
} catch (eof) {}

output_seq (translit (rev (seq), tr, subst));
TEST568
        echo '      ' $DINO $test_file 1000 "2>$stderr"
        if $DINO $test_file 1000 <<'INPUT568' 2>$stderr >$stdout; then
>ONE Homo sapiens alu
GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGA
TCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACT
AAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAG
GCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCG
CCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGT
GGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCA
GGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAA
TTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAG
AATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCA
GCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGT
AATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACC
AGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTG
GTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACC
CGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAG
AGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTT
TGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACA
TGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCT
GTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGG
TTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGT
CTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGG
CGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCG
TCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTA
CTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCG
AGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCG
GGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACC
TGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAA
TACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGA
GGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACT
GCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTC
ACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGT
TCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGC
CGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCG
CTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTG
GGCGACAGAGCGAGACTCCG
>TWO IUB ambiguity codes
cttBtatcatatgctaKggNcataaaSatgtaaaDcDRtBggDtctttataattcBgtcg
tactDtDagcctatttSVHtHttKtgtHMaSattgWaHKHttttagacatWatgtRgaaa
NtactMcSMtYtcMgRtacttctWBacgaaatatagScDtttgaagacacatagtVgYgt
cattHWtMMWcStgttaggKtSgaYaaccWStcgBttgcgaMttBYatcWtgacaYcaga
gtaBDtRacttttcWatMttDBcatWtatcttactaBgaYtcttgttttttttYaaScYa
HgtgttNtSatcMtcVaaaStccRcctDaataataStcYtRDSaMtDttgttSagtRRca
tttHatSttMtWgtcgtatSSagactYaaattcaMtWatttaSgYttaRgKaRtccactt
tattRggaMcDaWaWagttttgacatgttctacaaaRaatataataaMttcgDacgaSSt
acaStYRctVaNMtMgtaggcKatcttttattaaaaagVWaHKYagtttttatttaacct
tacgtVtcVaattVMBcttaMtttaStgacttagattWWacVtgWYagWVRctDattBYt
gtttaagaagattattgacVatMaacattVctgtBSgaVtgWWggaKHaatKWcBScSWa
accRVacacaaactaccScattRatatKVtactatatttHttaagtttSKtRtacaaagt
RDttcaaaaWgcacatWaDgtDKacgaacaattacaRNWaatHtttStgttattaaMtgt
tgDcgtMgcatBtgcttcgcgaDWgagctgcgaggggVtaaScNatttacttaatgacag
cccccacatYScaMgtaggtYaNgttctgaMaacNaMRaacaaacaKctacatagYWctg
ttWaaataaaataRattagHacacaagcgKatacBttRttaagtatttccgatctHSaat
actcNttMaagtattMtgRtgaMgcataatHcMtaBSaRattagttgatHtMttaaKagg
YtaaBataSaVatactWtataVWgKgttaaaacagtgcgRatatacatVtHRtVYataSa
KtWaStVcNKHKttactatccctcatgWHatWaRcttactaggatctataDtDHBttata
aaaHgtacVtagaYttYaKcctattcttcttaataNDaaggaaaDYgcggctaaWSctBa
aNtgctggMBaKctaMVKagBaactaWaDaMaccYVtNtaHtVWtKgRtcaaNtYaNacg
gtttNattgVtttctgtBaWgtaattcaagtcaVWtactNggattctttaYtaaagccgc
tcttagHVggaYtgtNcDaVagctctctKgacgtatagYcctRYHDtgBattDaaDgccK
tcHaaStttMcctagtattgcRgWBaVatHaaaataYtgtttagMDMRtaataaggatMt
ttctWgtNtgtgaaaaMaatatRtttMtDgHHtgtcattttcWattRSHcVagaagtacg
ggtaKVattKYagactNaatgtttgKMMgYNtcccgSKttctaStatatNVataYHgtNa
BKRgNacaactgatttcctttaNcgatttctctataScaHtataRagtcRVttacDSDtt
aRtSatacHgtSKacYagttMHtWataggatgactNtatSaNctataVtttRNKtgRacc
tttYtatgttactttttcctttaaacatacaHactMacacggtWataMtBVacRaSaatc
cgtaBVttccagccBcttaRKtgtgcctttttRtgtcagcRttKtaaacKtaaatctcac
aattgcaNtSBaaccgggttattaaBcKatDagttactcttcattVtttHaaggctKKga
tacatcBggScagtVcacattttgaHaDSgHatRMaHWggtatatRgccDttcgtatcga
aacaHtaagttaRatgaVacttagattVKtaaYttaaatcaNatccRttRRaMScNaaaD
gttVHWgtcHaaHgacVaWtgttScactaagSgttatcttagggDtaccagWattWtRtg
ttHWHacgattBtgVcaYatcggttgagKcWtKKcaVtgaYgWctgYggVctgtHgaNcV
taBtWaaYatcDRaaRtSctgaHaYRttagatMatgcatttNattaDttaattgttctaa
ccctcccctagaWBtttHtBccttagaVaatMcBHagaVcWcagBVttcBtaYMccagat
gaaaaHctctaacgttagNWRtcggattNatcRaNHttcagtKttttgWatWttcSaNgg
gaWtactKKMaacatKatacNattgctWtatctaVgagctatgtRaHtYcWcttagccaa
tYttWttaWSSttaHcaaaaagVacVgtaVaRMgattaVcDactttcHHggHRtgNcctt
tYatcatKgctcctctatVcaaaaKaaaagtatatctgMtWtaaaacaStttMtcgactt
taSatcgDataaactaaacaagtaaVctaggaSccaatMVtaaSKNVattttgHccatca
cBVctgcaVatVttRtactgtVcaattHgtaaattaaattttYtatattaaRSgYtgBag
aHSBDgtagcacRHtYcBgtcacttacactaYcgctWtattgSHtSatcataaatataHt
cgtYaaMNgBaatttaRgaMaatatttBtttaaaHHKaatctgatWatYaacttMctctt
ttVctagctDaaagtaVaKaKRtaacBgtatccaaccactHHaagaagaaggaNaaatBW
attccgStaMSaMatBttgcatgRSacgttVVtaaDMtcSgVatWcaSatcttttVatag
ttactttacgatcaccNtaDVgSRcgVcgtgaacgaNtaNatatagtHtMgtHcMtagaa
attBgtataRaaaacaYKgtRccYtatgaagtaataKgtaaMttgaaRVatgcagaKStc
tHNaaatctBBtcttaYaBWHgtVtgacagcaRcataWctcaBcYacYgatDgtDHccta
>THREE Homo sapiens frequency
aacacttcaccaggtatcgtgaaggctcaagattacccagagaacctttgcaatataaga
atatgtatgcagcattaccctaagtaattatattctttttctgactcaaagtgacaagcc
ctagtgtatattaaatcggtatatttgggaaattcctcaaactatcctaatcaggtagcc
atgaaagtgatcaaaaaagttcgtacttataccatacatgaattctggccaagtaaaaaa
tagattgcgcaaaattcgtaccttaagtctctcgccaagatattaggatcctattactca
tatcgtgtttttctttattgccgccatccccggagtatctcacccatccttctcttaaag
gcctaatattacctatgcaaataaacatatattgttgaaaattgagaacctgatcgtgat
tcttatgtgtaccatatgtatagtaatcacgcgactatatagtgctttagtatcgcccgt
gggtgagtgaatattctgggctagcgtgagatagtttcttgtcctaatatttttcagatc
gaatagcttctatttttgtgtttattgacatatgtcgaaactccttactcagtgaaagtc
atgaccagatccacgaacaatcttcggaatcagtctcgttttacggcggaatcttgagtc
taacttatatcccgtcgcttactttctaacaccccttatgtatttttaaaattacgttta
ttcgaacgtacttggcggaagcgttattttttgaagtaagttacattgggcagactcttg
acattttcgatacgactttctttcatccatcacaggactcgttcgtattgatatcagaag
ctcgtgatgattagttgtcttctttaccaatactttgaggcctattctgcgaaatttttg
ttgccctgcgaacttcacataccaaggaacacctcgcaacatgccttcatatccatcgtt
cattgtaattcttacacaatgaatcctaagtaattacatccctgcgtaaaagatggtagg
ggcactgaggatatattaccaagcatttagttatgagtaatcagcaatgtttcttgtatt
aagttctctaaaatagttacatcgtaatgttatctcgggttccgcgaataaacgagatag
attcattatatatggccctaagcaaaaacctcctcgtattctgttggtaattagaatcac
acaatacgggttgagatattaattatttgtagtacgaagagatataaaaagatgaacaat
tactcaagtcaagatgtatacgggatttataataaaaatcgggtagagatctgctttgca
attcagacgtgccactaaatcgtaatatgtcgcgttacatcagaaagggtaactattatt
aattaataaagggcttaatcactacatattagatcttatccgatagtcttatctattcgt
tgtatttttaagcggttctaattcagtcattatatcagtgctccgagttctttattattg
ttttaaggatgacaaaatgcctcttgttataacgctgggagaagcagactaagagtcgga
gcagttggtagaatgaggctgcaaaagacggtctcgacgaatggacagactttactaaac
caatgaaagacagaagtagagcaaagtctgaagtggtatcagcttaattatgacaaccct
taatacttccctttcgccgaatactggcgtggaaaggttttaaaagtcgaagtagttaga
ggcatctctcgctcataaataggtagactactcgcaatccaatgtgactatgtaatactg
ggaacatcagtccgcgatgcagcgtgtttatcaaccgtccccactcgcctggggagacat
gagaccacccccgtggggattattagtccgcagtaatcgactcttgacaatccttttcga
ttatgtcatagcaatttacgacagttcagcgaagtgactactcggcgaaatggtattact
aaagcattcgaacccacatgaatgtgattcttggcaatttctaatccactaaagcttttc
cgttgaatctggttgtagatatttatataagttcactaattaagatcacggtagtatatt
gatagtgatgtctttgcaagaggttggccgaggaatttacggattctctattgatacaat
ttgtctggcttataactcttaaggctgaaccaggcgtttttagacgacttgatcagctgt
tagaatggtttggactccctctttcatgtcagtaacatttcagccgttattgttacgata
tgcttgaacaatattgatctaccacacacccatagtatattttataggtcatgctgttac
ctacgagcatggtattccacttcccattcaatgagtattcaacatcactagcctcagaga
tgatgacccacctctaataacgtcacgttgcggccatgtgaaacctgaacttgagtagac
gatatcaagcgctttaaattgcatataacatttgagggtaaagctaagcggatgctttat
ataatcaatactcaataataagatttgattgcattttagagttatgacacgacatagttc
actaacgagttactattcccagatctagactgaagtactgatcgagacgatccttacgtc
gatgatcgttagttatcgacttaggtcgggtctctagcggtattggtacttaaccggaca
ctatactaataacccatgatcaaagcataacagaatacagacgataatttcgccaacata
tatgtacagaccccaagcatgagaagctcattgaaagctatcattgaagtcccgctcaca
atgtgtcttttccagacggtttaactggttcccgggagtcctggagtttcgacttacata
aatggaaacaatgtattttgctaatttatctatagcgtcatttggaccaatacagaatat
tatgttgcctagtaatccactataacccgcaagtgctgatagaaaatttttagacgattt
ataaatgccccaagtatccctcccgtgaatcctccgttatactaattagtattcgttcat
acgtataccgcgcatatatgaacatttggcgataaggcgcgtgaattgttacgtgacaga
gatagcagtttcttgtgatatggttaacagacgtacatgaagggaaactttatatctata
gtgatgcttccgtagaaataccgccactggtctgccaatgatgaagtatgtagctttagg
tttgtactatgaggctttcgtttgtttgcagagtataacagttgcgagtgaaaaaccgac
gaatttatactaatacgctttcactattggctacaaaatagggaagagtttcaatcatga
gagggagtatatggatgctttgtagctaaaggtagaacgtatgtatatgctgccgttcat
tcttgaaagatacataagcgataagttacgacaattataagcaacatccctaccttcgta
acgatttcactgttactgcgcttgaaatacactatggggctattggcggagagaagcaga
tcgcgccgagcatatacgagacctataatgttgatgatagagaaggcgtctgaattgata
catcgaagtacactttctttcgtagtatctctcgtcctctttctatctccggacacaaga
attaagttatatatatagagtcttaccaatcatgttgaatcctgattctcagagttcttt
ggcgggccttgtgatgactgagaaacaatgcaatattgctccaaatttcctaagcaaatt
ctcggttatgttatgttatcagcaaagcgttacgttatgttatttaaatctggaatgacg
gagcgaagttcttatgtcggtgtgggaataattcttttgaagacagcactccttaaataa
tatcgctccgtgtttgtatttatcgaatgggtctgtaaccttgcacaagcaaatcggtgg
tgtatatatcggataacaattaatacgatgttcatagtgacagtatactgatcgagtcct
ctaaagtcaattacctcacttaacaatctcattgatgttgtgtcattcccggtatcgccc
gtagtatgtgctctgattgaccgagtgtgaaccaaggaacatctactaatgcctttgtta
ggtaagatctctctgaattccttcgtgccaacttaaaacattatcaaaatttcttctact
tggattaactacttttacgagcatggcaaattcccctgtggaagacggttcattattatc
ggaaaccttatagaaattgcgtgttgactgaaattagatttttattgtaagagttgcatc
tttgcgattcctctggtctagcttccaatgaacagtcctcccttctattcgacatcgggt
ccttcgtacatgtctttgcgatgtaataattaggttcggagtgtggccttaatgggtgca
actaggaatacaacgcaaatttgctgacatgatagcaaatcggtatgccggcaccaaaac
gtgctccttgcttagcttgtgaatgagactcagtagttaaataaatccatatctgcaatc
gattccacaggtattgtccactatctttgaactactctaagagatacaagcttagctgag
accgaggtgtatatgactacgctgatatctgtaaggtaccaatgcaggcaaagtatgcga
gaagctaataccggctgtttccagctttataagattaaaatttggctgtcctggcggcct
cagaattgttctatcgtaatcagttggttcattaattagctaagtacgaggtacaactta
tctgtcccagaacagctccacaagtttttttacagccgaaacccctgtgtgaatcttaat
atccaagcgcgttatctgattagagtttacaactcagtattttatcagtacgttttgttt
ccaacattacccggtatgacaaaatgacgccacgtgtcgaataatggtctgaccaatgta
ggaagtgaaaagataaatat
INPUT568
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT568' && $CMP $stdout $ftemp2; then
>ONE Homo sapiens alu
CGGAGTCTCGCTCTGTCGCCCAGGCTGGAGTGCAGTGGCGCGATCTCGGCTCACTGCAAC
CTCCGCCTCCCGGGTTCAAGCGATTCTCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACA
GGCGCGCGCCACCACGCCCGGCTAATTTTTGTATTTTTAGTAGAGACGGGGTTTCACCAT
GTTGGCCAGGCTGGTCTCGAACTCCTGACCTCAGGTGATCCGCCCGCCTCGGCCTCCCAA
AGTGCTGGGATTACAGGCGTGAGCCACCGCGCCCGGCCTTTTTGAGACGGAGTCTCGCTC
TGTCGCCCAGGCTGGAGTGCAGTGGCGCGATCTCGGCTCACTGCAACCTCCGCCTCCCGG
GTTCAAGCGATTCTCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACAGGCGCGCGCCACC
ACGCCCGGCTAATTTTTGTATTTTTAGTAGAGACGGGGTTTCACCATGTTGGCCAGGCTG
GTCTCGAACTCCTGACCTCAGGTGATCCGCCCGCCTCGGCCTCCCAAAGTGCTGGGATTA
CAGGCGTGAGCCACCGCGCCCGGCCTTTTTGAGACGGAGTCTCGCTCTGTCGCCCAGGCT
GGAGTGCAGTGGCGCGATCTCGGCTCACTGCAACCTCCGCCTCCCGGGTTCAAGCGATTC
TCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACAGGCGCGCGCCACCACGCCCGGCTAAT
TTTTGTATTTTTAGTAGAGACGGGGTTTCACCATGTTGGCCAGGCTGGTCTCGAACTCCT
GACCTCAGGTGATCCGCCCGCCTCGGCCTCCCAAAGTGCTGGGATTACAGGCGTGAGCCA
CCGCGCCCGGCCTTTTTGAGACGGAGTCTCGCTCTGTCGCCCAGGCTGGAGTGCAGTGGC
GCGATCTCGGCTCACTGCAACCTCCGCCTCCCGGGTTCAAGCGATTCTCCTGCCTCAGCC
TCCCGAGTAGCTGGGATTACAGGCGCGCGCCACCACGCCCGGCTAATTTTTGTATTTTTA
GTAGAGACGGGGTTTCACCATGTTGGCCAGGCTGGTCTCGAACTCCTGACCTCAGGTGAT
CCGCCCGCCTCGGCCTCCCAAAGTGCTGGGATTACAGGCGTGAGCCACCGCGCCCGGCCT
TTTTGAGACGGAGTCTCGCTCTGTCGCCCAGGCTGGAGTGCAGTGGCGCGATCTCGGCTC
ACTGCAACCTCCGCCTCCCGGGTTCAAGCGATTCTCCTGCCTCAGCCTCCCGAGTAGCTG
GGATTACAGGCGCGCGCCACCACGCCCGGCTAATTTTTGTATTTTTAGTAGAGACGGGGT
TTCACCATGTTGGCCAGGCTGGTCTCGAACTCCTGACCTCAGGTGATCCGCCCGCCTCGG
CCTCCCAAAGTGCTGGGATTACAGGCGTGAGCCACCGCGCCCGGCCTTTTTGAGACGGAG
TCTCGCTCTGTCGCCCAGGCTGGAGTGCAGTGGCGCGATCTCGGCTCACTGCAACCTCCG
CCTCCCGGGTTCAAGCGATTCTCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACAGGCGC
GCGCCACCACGCCCGGCTAATTTTTGTATTTTTAGTAGAGACGGGGTTTCACCATGTTGG
CCAGGCTGGTCTCGAACTCCTGACCTCAGGTGATCCGCCCGCCTCGGCCTCCCAAAGTGC
TGGGATTACAGGCGTGAGCCACCGCGCCCGGCCTTTTTGAGACGGAGTCTCGCTCTGTCG
CCCAGGCTGGAGTGCAGTGGCGCGATCTCGGCTCACTGCAACCTCCGCCTCCCGGGTTCA
AGCGATTCTCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACAGGCGCGCGCCACCACGCC
CGGCTAATTTTTGTATTTTTAGTAGAGACGGGGTTTCACCATGTTGGCCAGGCTGGTCTC
GAACTCCTGACCTCAGGTGATCCGCCCGCCTCGGCCTCCCAAAGTGCTGGGATTACAGGC
GTGAGCCACCGCGCCCGGCC
>TWO IUB ambiguity codes
TAGGDHACHATCRGTRGVTGAGWTATGYTGCTGTCABACDWVTRTAAGAVVAGATTTNDA
GASMTCTGCATBYTTCAAKTTACMTATTACTTCATARGGYACMRTGTTTTYTATACVAAT
TTCTAKGDACKADACTATATNTANTCGTTCACGBCGYSCBHTANGGTGATCGTAAAGTAA
CTATBAAAAGATSTGWATBCSGAKHTTABBAACGTSYCATGCAAVATKTSKTASCGGAAT
WVATTTNTCCTTCTTCTTDDAGTGGTTGGATACVGTTAYMTMTBTACTTTHAGCTAGBAA
AAGAGKAAGTTRATWATCAGATTMDDTTTAAAVAAATATTKTCYTAAATTVCNKTTRACG
ADTATATTTATGATSADSCAATAWAGCGRTAGTGTAAGTGACVGRADYGTGCTACHVSDT
CTVCARCSYTTAATATARAAAATTTAATTTACDAATTGBACAGTAYAABATBTGCAGBVG
TGATGGDCAAAATBNMSTTABKATTGGSTCCTAGBTTACTTGTTTAGTTTATHCGATSTA
AAGTCGAKAAASTGTTTTAWAKCAGATATACTTTTMTTTTGBATAGAGGAGCMATGATRA
AAGGNCAYDCCDDGAAAGTHGBTAATCKYTBTACBGTBCTTTTTGDTAASSWTAAWAARA
TTGGCTAAGWGRADTYACATAGCTCBTAGATAWAGCAATNGTATMATGTTKMMAGTAWTC
CCNTSGAAWATWCAAAAMACTGAADNTYGATNAATCCGAYWNCTAACGTTAGAGDTTTTC
ATCTGGKRTAVGAABVCTGWGBTCTDVGKATTBTCTAAGGVADAAAVWTCTAGGGGAGGG
TTAGAACAATTAAHTAATNAAATGCATKATCTAAYRTDTCAGSAYTTYHGATRTTWAVTA
BGNTCDACAGBCCRCAGWCRTCABTGMMAWGMCTCAACCGATRTGBCAVAATCGTDWDAA
CAYAWAATWCTGGTAHCCCTAAGATAACSCTTAGTGSAACAWTBGTCDTTDGACWDBAAC
HTTTNGSKTYYAAYGGATNTGATTTAARTTAMBAATCTAAGTBTCATYTAACTTADTGTT
TCGATACGAAHGGCYATATACCWDTKYATDCSHTDTCAAAATGTGBACTGSCCVGATGTA
TCMMAGCCTTDAAABAATGAAGAGTAACTHATMGVTTAATAACCCGGTTVSANTGCAATT
GTGAGATTTAMGTTTAMAAYGCTGACAYAAAAAGGCACAMYTAAGVGGCTGGAABVTACG
GATTSTYGTBVAKTATWACCGTGTKAGTDTGTATGTTTAAAGGAAAAAGTAACATARAAA
GGTYCAMNYAAABTATAGNTSATANAGTCATCCTATWADKAACTRGTMSACDGTATSAYT
AAHSHGTAABYGACTYTATADTGSTATAGAGAAATCGNTAAAGGAAATCAGTTGTNCYMV
TNACDRTATBNATATASTAGAAMSCGGGANRCKKMCAAACATTNAGTCTRMAATBMTACC
CGTACTTCTBGDSYAATWGAAAATGACADDCHAKAAAYATATTKTTTTCACANACWAGAA
AKATCCTTATTAYKHKCTAAACARTATTTTDATBTVWCYGCAATACTAGGKAAASTTDGA
MGGCHTTHAATVCAHDRYAGGRCTATACGTCMAGAGAGCTBTHGNACARTCCBDCTAAGA
GCGGCTTTARTAAAGAATCCNAGTAWBTGACTTGAATTACWTVACAGAAABCAATNAAAC
CGTNTRANTTGAYCMAWBADTANABRGGTKTHTWTAGTTVCTMBKTAGMTVKCCAGCANT
TVAGSWTTAGCCGCRHTTTCCTTHNTATTAAGAAGAATAGGMTRAARTCTABGTACDTTT
TATAAVDHAHTATAGATCCTAGTAAGYTWATDWCATGAGGGATAGTAAMDMNGBASTWAM
TSTATRBAYDABATGTATATYCGCACTGTTTTAACMCWBTATAWAGTATBTSTATVTTAR
CCTMTTAAKADATCAACTAATYTSVTAKGDATTATGCKTCAYCAKAATACTTKAANGAGT
ATTSDAGATCGGAAATACTTAAYAAVGTATMCGCTTGTGTDCTAATYTATTTTATTTWAA
CAGWRCTATGTAGMTGTTTGTTYKTNGTTKTCAGAACNTRACCTACKTGSRATGTGGGGG
CTGTCATTAAGTAAATNGSTTABCCCCTCGCAGCTCWHTCGCGAAGCAVATGCKACGHCA
ACAKTTAATAACASAAADATTWNYTGTAATTGTTCGTMHACHTWATGTGCWTTTTGAAHY
ACTTTGTAYAMSAAACTTAADAAATATAGTABMATATYAATGSGGTAGTTTGTGTBYGGT
TWSGSVGWMATTDMTCCWWCABTCSVACAGBAATGTTKATBGTCAATAATCTTCTTAAAC
ARVAATHAGYBWCTRWCABGTWWAATCTAAGTCASTAAAKTAAGVKBAATTBGABACGTA
AGGTTAAATAAAAACTRMDTWBCTTTTTAATAAAAGATMGCCTACKAKNTBAGYRASTGT
ASSTCGTHCGAAKTTATTATATTYTTTGTAGAACATGTCAAAACTWTWTHGKTCCYAATA
AAGTGGAYTMCYTAARCSTAAATWAKTGAATTTRAGTCTSSATACGACWAKAASATDAAA
TGYYACTSAACAAHAKTSHYARGASTATTATTHAGGYGGASTTTBGAKGATSANAACACD
TRGSTTRAAAAAAAACAAGARTCVTAGTAAGATAWATGVHAAKATWGAAAAGTYAHVTAC
TCTGRTGTCAWGATRVAAKTCGCAAVCGASWGGTTRTCSAMCCTAACASGWKKAWDAATG
ACRCBACTATGTGTCTTCAAAHGSCTATATTTCGTVWAGAAGTAYCKGARAKSGKAGTAN
TTTCYACATWATGTCTAAAADMDTWCAATSTKDACAMAADADBSAAATAGGCTHAHAGTA
CGACVGAATTATAAAGAHCCVAYHGHTTTACATSTTTATGNCCMTAGCATATGATAVAAG
>THREE Homo sapiens frequency
ATATTTATCTTTTCACTTCCTACATTGGTCAGACCATTATTCGACACGTGGCGTCATTTT
GTCATACCGGGTAATGTTGGAAACAAAACGTACTGATAAAATACTGAGTTGTAAACTCTA
ATCAGATAACGCGCTTGGATATTAAGATTCACACAGGGGTTTCGGCTGTAAAAAAACTTG
TGGAGCTGTTCTGGGACAGATAAGTTGTACCTCGTACTTAGCTAATTAATGAACCAACTG
ATTACGATAGAACAATTCTGAGGCCGCCAGGACAGCCAAATTTTAATCTTATAAAGCTGG
AAACAGCCGGTATTAGCTTCTCGCATACTTTGCCTGCATTGGTACCTTACAGATATCAGC
GTAGTCATATACACCTCGGTCTCAGCTAAGCTTGTATCTCTTAGAGTAGTTCAAAGATAG
TGGACAATACCTGTGGAATCGATTGCAGATATGGATTTATTTAACTACTGAGTCTCATTC
ACAAGCTAAGCAAGGAGCACGTTTTGGTGCCGGCATACCGATTTGCTATCATGTCAGCAA
ATTTGCGTTGTATTCCTAGTTGCACCCATTAAGGCCACACTCCGAACCTAATTATTACAT
CGCAAAGACATGTACGAAGGACCCGATGTCGAATAGAAGGGAGGACTGTTCATTGGAAGC
TAGACCAGAGGAATCGCAAAGATGCAACTCTTACAATAAAAATCTAATTTCAGTCAACAC
GCAATTTCTATAAGGTTTCCGATAATAATGAACCGTCTTCCACAGGGGAATTTGCCATGC
TCGTAAAAGTAGTTAATCCAAGTAGAAGAAATTTTGATAATGTTTTAAGTTGGCACGAAG
GAATTCAGAGAGATCTTACCTAACAAAGGCATTAGTAGATGTTCCTTGGTTCACACTCGG
TCAATCAGAGCACATACTACGGGCGATACCGGGAATGACACAACATCAATGAGATTGTTA
AGTGAGGTAATTGACTTTAGAGGACTCGATCAGTATACTGTCACTATGAACATCGTATTA
ATTGTTATCCGATATATACACCACCGATTTGCTTGTGCAAGGTTACAGACCCATTCGATA
AATACAAACACGGAGCGATATTATTTAAGGAGTGCTGTCTTCAAAAGAATTATTCCCACA
CCGACATAAGAACTTCGCTCCGTCATTCCAGATTTAAATAACATAACGTAACGCTTTGCT
GATAACATAACATAACCGAGAATTTGCTTAGGAAATTTGGAGCAATATTGCATTGTTTCT
CAGTCATCACAAGGCCCGCCAAAGAACTCTGAGAATCAGGATTCAACATGATTGGTAAGA
CTCTATATATATAACTTAATTCTTGTGTCCGGAGATAGAAAGAGGACGAGAGATACTACG
AAAGAAAGTGTACTTCGATGTATCAATTCAGACGCCTTCTCTATCATCAACATTATAGGT
CTCGTATATGCTCGGCGCGATCTGCTTCTCTCCGCCAATAGCCCCATAGTGTATTTCAAG
CGCAGTAACAGTGAAATCGTTACGAAGGTAGGGATGTTGCTTATAATTGTCGTAACTTAT
CGCTTATGTATCTTTCAAGAATGAACGGCAGCATATACATACGTTCTACCTTTAGCTACA
AAGCATCCATATACTCCCTCTCATGATTGAAACTCTTCCCTATTTTGTAGCCAATAGTGA
AAGCGTATTAGTATAAATTCGTCGGTTTTTCACTCGCAACTGTTATACTCTGCAAACAAA
CGAAAGCCTCATAGTACAAACCTAAAGCTACATACTTCATCATTGGCAGACCAGTGGCGG
TATTTCTACGGAAGCATCACTATAGATATAAAGTTTCCCTTCATGTACGTCTGTTAACCA
TATCACAAGAAACTGCTATCTCTGTCACGTAACAATTCACGCGCCTTATCGCCAAATGTT
CATATATGCGCGGTATACGTATGAACGAATACTAATTAGTATAACGGAGGATTCACGGGA
GGGATACTTGGGGCATTTATAAATCGTCTAAAAATTTTCTATCAGCACTTGCGGGTTATA
GTGGATTACTAGGCAACATAATATTCTGTATTGGTCCAAATGACGCTATAGATAAATTAG
CAAAATACATTGTTTCCATTTATGTAAGTCGAAACTCCAGGACTCCCGGGAACCAGTTAA
ACCGTCTGGAAAAGACACATTGTGAGCGGGACTTCAATGATAGCTTTCAATGAGCTTCTC
ATGCTTGGGGTCTGTACATATATGTTGGCGAAATTATCGTCTGTATTCTGTTATGCTTTG
ATCATGGGTTATTAGTATAGTGTCCGGTTAAGTACCAATACCGCTAGAGACCCGACCTAA
GTCGATAACTAACGATCATCGACGTAAGGATCGTCTCGATCAGTACTTCAGTCTAGATCT
GGGAATAGTAACTCGTTAGTGAACTATGTCGTGTCATAACTCTAAAATGCAATCAAATCT
TATTATTGAGTATTGATTATATAAAGCATCCGCTTAGCTTTACCCTCAAATGTTATATGC
AATTTAAAGCGCTTGATATCGTCTACTCAAGTTCAGGTTTCACATGGCCGCAACGTGACG
TTATTAGAGGTGGGTCATCATCTCTGAGGCTAGTGATGTTGAATACTCATTGAATGGGAA
GTGGAATACCATGCTCGTAGGTAACAGCATGACCTATAAAATATACTATGGGTGTGTGGT
AGATCAATATTGTTCAAGCATATCGTAACAATAACGGCTGAAATGTTACTGACATGAAAG
AGGGAGTCCAAACCATTCTAACAGCTGATCAAGTCGTCTAAAAACGCCTGGTTCAGCCTT
AAGAGTTATAAGCCAGACAAATTGTATCAATAGAGAATCCGTAAATTCCTCGGCCAACCT
CTTGCAAAGACATCACTATCAATATACTACCGTGATCTTAATTAGTGAACTTATATAAAT
ATCTACAACCAGATTCAACGGAAAAGCTTTAGTGGATTAGAAATTGCCAAGAATCACATT
CATGTGGGTTCGAATGCTTTAGTAATACCATTTCGCCGAGTAGTCACTTCGCTGAACTGT
CGTAAATTGCTATGACATAATCGAAAAGGATTGTCAAGAGTCGATTACTGCGGACTAATA
ATCCCCACGGGGGTGGTCTCATGTCTCCCCAGGCGAGTGGGGACGGTTGATAAACACGCT
GCATCGCGGACTGATGTTCCCAGTATTACATAGTCACATTGGATTGCGAGTAGTCTACCT
ATTTATGAGCGAGAGATGCCTCTAACTACTTCGACTTTTAAAACCTTTCCACGCCAGTAT
TCGGCGAAAGGGAAGTATTAAGGGTTGTCATAATTAAGCTGATACCACTTCAGACTTTGC
TCTACTTCTGTCTTTCATTGGTTTAGTAAAGTCTGTCCATTCGTCGAGACCGTCTTTTGC
AGCCTCATTCTACCAACTGCTCCGACTCTTAGTCTGCTTCTCCCAGCGTTATAACAAGAG
GCATTTTGTCATCCTTAAAACAATAATAAAGAACTCGGAGCACTGATATAATGACTGAAT
TAGAACCGCTTAAAAATACAACGAATAGATAAGACTATCGGATAAGATCTAATATGTAGT
GATTAAGCCCTTTATTAATTAATAATAGTTACCCTTTCTGATGTAACGCGACATATTACG
ATTTAGTGGCACGTCTGAATTGCAAAGCAGATCTCTACCCGATTTTTATTATAAATCCCG
TATACATCTTGACTTGAGTAATTGTTCATCTTTTTATATCTCTTCGTACTACAAATAATT
AATATCTCAACCCGTATTGTGTGATTCTAATTACCAACAGAATACGAGGAGGTTTTTGCT
TAGGGCCATATATAATGAATCTATCTCGTTTATTCGCGGAACCCGAGATAACATTACGAT
GTAACTATTTTAGAGAACTTAATACAAGAAACATTGCTGATTACTCATAACTAAATGCTT
GGTAATATATCCTCAGTGCCCCTACCATCTTTTACGCAGGGATGTAATTACTTAGGATTC
ATTGTGTAAGAATTACAATGAACGATGGATATGAAGGCATGTTGCGAGGTGTTCCTTGGT
ATGTGAAGTTCGCAGGGCAACAAAAATTTCGCAGAATAGGCCTCAAAGTATTGGTAAAGA
AGACAACTAATCATCACGAGCTTCTGATATCAATACGAACGAGTCCTGTGATGGATGAAA
GAAAGTCGTATCGAAAATGTCAAGAGTCTGCCCAATGTAACTTACTTCAAAAAATAACGC
TTCCGCCAAGTACGTTCGAATAAACGTAATTTTAAAAATACATAAGGGGTGTTAGAAAGT
AAGCGACGGGATATAAGTTAGACTCAAGATTCCGCCGTAAAACGAGACTGATTCCGAAGA
TTGTTCGTGGATCTGGTCATGACTTTCACTGAGTAAGGAGTTTCGACATATGTCAATAAA
CACAAAAATAGAAGCTATTCGATCTGAAAAATATTAGGACAAGAAACTATCTCACGCTAG
CCCAGAATATTCACTCACCCACGGGCGATACTAAAGCACTATATAGTCGCGTGATTACTA
TACATATGGTACACATAAGAATCACGATCAGGTTCTCAATTTTCAACAATATATGTTTAT
TTGCATAGGTAATATTAGGCCTTTAAGAGAAGGATGGGTGAGATACTCCGGGGATGGCGG
CAATAAAGAAAAACACGATATGAGTAATAGGATCCTAATATCTTGGCGAGAGACTTAAGG
TACGAATTTTGCGCAATCTATTTTTTACTTGGCCAGAATTCATGTATGGTATAAGTACGA
ACTTTTTTGATCACTTTCATGGCTACCTGATTAGGATAGTTTGAGGAATTTCCCAAATAT
ACCGATTTAATATACACTAGGGCTTGTCACTTTGAGTCAGAAAAAGAATATAATTACTTA
GGGTAATGCTGCATACATATTCTTATATTGCAAAGGTTCTCTGGGTAATCTTGAGCCTTC
ACGATACCTGGTGAAGTGTT
OUTPUT568
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 569.
if test $result = ok -a $start_test_number -le 569; then
	echo test 569: Spectral Norm from Language Shootout
        cat >$test_file <<'TEST569'
fun A (i, j) { return 1.0 / ((i + j) * (i + j + 1) / 2 + i + 1); }

fun Av (n, v) {
   var i, j, Av = [n : 0.0];

   for (i = 0; i < n; i++)
      for (j = 0; j < n; j++) Av [i] += A (i, j) * v [j];
   return Av;
}

fun Atv (n, v) {
   var i, j, Atv = [n : 0.0];

   for (i = 0; i < n; i++)
     for (j = 0; j < n; j++) Atv [i] += A (j, i) * v [j];
   return Atv;
}

fun AtAv (n, v) {return Atv (n, Av (n, v));}

var n = int (#argv < 1 ? 100 : argv [0]);
var i, u = [n : 1.0], v = [n : 0.0], vBv = 0.0, vv = 0.0;

for (i = 0; i < 10; i++) { v = AtAv (n, u); u = AtAv (n, v); }
for (i = 0; i < n; i++) { vBv += u [i] * v [i]; vv += v [i] * v [i]; }

putf ("%0.9f\n", sqrt (vBv / vv));
TEST569
        echo '      ' $DINO $test_file 200 "2>$stderr"
        if $DINO $test_file 200 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT569' && $CMP $stdout $ftemp2; then
1.274223601
OUTPUT569
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 570.
if test $result = ok -a $start_test_number -le 570; then
	echo test 570: Sum file Language Shootout
        cat >$test_file <<'TEST570'
var sum = 0;
try {
  for (;;) sum += int (getln ());
} catch (eof) {}

putln (sum);
TEST570
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file  <<'INPUT570' 2>$stderr >$stdout; then
276
498
-981
770
-401
702
966
950
-853
-53
-293
604
288
892
-697
204
96
408
880
-7
-817
422
-261
-485
-77
826
184
864
-751
626
812
-369
-353
-371
488
-83
-659
24
524
-21
840
-757
-17
-973
-843
260
858
-389
-521
-99
482
-561
-213
630
766
932
112
-419
-877
762
266
-837
170
834
746
764
922
-89
576
-63
90
684
316
506
-959
708
70
252
-747
342
-593
-895
-937
-707
350
588
-201
-683
-113
-511
-867
322
202
472
150
-9
-643
28
336
86
-925
836
-473
-451
-971
-805
-619
84
-67
806
270
366
334
-555
-557
-331
-409
-553
-145
-71
528
490
492
828
628
-961
536
-859
-271
974
-671
-749
414
-257
778
56
598
-437
-899
-785
-987
32
-999
132
-821
-209
402
-543
194
-967
294
-943
-285
-483
-97
660
-481
-829
-309
-597
-855
80
-355
192
-823
436
916
282
-629
612
-329
-535
780
-47
706
110
756
-857
-933
-345
-523
718
-31
902
678
540
698
456
-399
126
412
-563
-321
-487
-641
-195
-199
-955
772
INPUT570
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT570' && $CMP $stdout $ftemp2; then
-4818
OUTPUT570
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 571.
if test $result = ok -a $start_test_number -le 571; then
	echo test 571: Takfp Language Shootout
        cat >$test_file <<'TEST571'
fun Tak (x, y, z) {
  if (y >= x) return z;
  return Tak (Tak (x - 1.0, y, z), Tak (y - 1.0, z, x), Tak (z -1.0, x, y));
}

var n = int (#argv < 1 ? 1 : argv [0]);
putf ("%.1f\n", Tak (n * 3.0, n * 2.0, n * 1.0));
TEST571
        echo '      ' $DINO $test_file 9 "2>$stderr"
        if $DINO $test_file 9 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT571' && $CMP $stdout $ftemp2; then
18.0
OUTPUT571
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 572.
if test $result = ok -a $start_test_number -le 572; then
	echo test 572: Swap statement implementation.
        cat >$test_file <<'TEST572'
var t, a = 1, b = 2;

putln (a, " ", b);
t = a; a = b; b = t;
putln (a, " ", b);

var ar = [1, 2, 3];
println (ar);
t = ar[0]; ar[0] = ar[2]; ar[2] = t;
println (ar);

class s (i) {}
var c1 = s (0), c2 = s (3);
putln (c1.i, ' ', c2.i);
t = c1.i; c1.i = c2.i; c2.i = t;
putln (c1.i, ' ', c2.i);

var tbl = tab ["s" : 1, "t" : 2];
putln (tbl["s"], ' ', tbl["t"]);
t = tbl["s"]; tbl["s"] = tbl["t"]; tbl["t"] = t;
putln (tbl["s"], ' ', tbl["t"]);
TEST572
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT572' && $CMP $stdout $ftemp2; then
1 2
2 1
[1, 2, 3]
[3, 2, 1]
0 3
3 0
1 2
2 1
OUTPUT572
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 573.
if test $result = ok -a $start_test_number -le 573; then
	echo test 573: Health from Language Shootout.
        cat >$test_file <<'TEST573'
class queue {
  class node (item, next) {}
  var first = nil, last = nil;

  fun Add (o) {
    var a = node (o, nil);

    if (first == nil) first = a; else last.next = a;
    last = a;
  }
  
  fun Remove (o) {
    var c, p = nil;

    for (c = first; c != nil && c.item !== o; c = c.next) p = c;
    if (c == nil) return;
    if (p == nil) first = first.next; else p.next = c.next;
    if (last === c) last = p;
  }

  fun Clear { first = nil; last = nil; }
}

class Patient (remainingTime = 0, hospitalTime = 0, hospitalVisits = 0) {}

val LEVELS = 5, DISTRICTS = 4;

class Hospital; class Totals;

class HealthcareRegion (level, s) {
  var districts = [DISTRICTS : nil];
  var localHospital = Hospital (level == LEVELS, level, s);

  fun TransferPatients {
    var i, n;
    
    for (i = #districts - 1; i >= 0; i--)
      if (districts [i] != nil)
	for (n = districts [i].TransferPatients().first; n != nil; n = n.next)
	  localHospital.NewArrival(n.item);

    localHospital.TriageExaminationTreatment ();
    return localHospital.transfers;
  }

  fun AccumulateTotals {
    var i, t = Totals ();

    for (i = #districts - 1; i >= 0; i--)
      if (districts [i] != nil)
	t.PlusTotal (districts [i].AccumulateTotals ());
    
    localHospital.AccumulateTotals (t);
    return t;
  }

  fun TreatmentQueue { return localHospital.treatment; }
}

fun CreateRegion (level, seed1, seed2) {
  var i, r = nil;
  
  if(level > 0) {
    r = HealthcareRegion (level, seed1 * seed2);
    for(i = #r.districts - 1; i >= 0; i--)
      r.districts [i] = CreateRegion (level - 1, seed1 * 4 + i + 1, seed2);
  }
  return r;
}

class Hospital (hasNoRegionalHospital, level, seed) {
  var availableStaff = 1 << (level - 1);
  var triage = queue (), examination = queue ();
  var treatment = queue (), transfers = queue ();
  var discharged = Totals ();

  fun DischargePatients; fun TreatOrTransferPatients; fun TriagePatients;
  fun genRandom; fun NewArrival;

  fun TriageExaminationTreatment {
    DischargePatients ();
    TreatOrTransferPatients ();
    TriagePatients ();
    
    if (genRandom (1.0) > 0.7) NewArrival (Patient ());
  }
  
  fun AccumulateTotals (t) {
    var n;
    
    for (n = triage.first; n != nil; n = n.next) t.PlusPatient (n.item);
    for (n = examination.first; n != nil; n = n.next) t.PlusPatient (n.item);
    for (n = treatment.first; n != nil; n = n.next) t.PlusPatient (n.item);
    t.PlusTotal (discharged);
  }
  
  fun NewArrival (p) {
    p.hospitalVisits++;
    if (availableStaff == 0) triage.Add (p);
    else {
      availableStaff--;
      p.remainingTime = 3;
      p.hospitalTime += 3;
      examination.Add (p);
    }
  }
  
  fun DischargePatients {
    var n, p;
    
    for (n = treatment.first; n != nil; n = n.next) {
      p = n.item; p.remainingTime--;
      if (p.remainingTime == 0) {
	availableStaff++;
	treatment.Remove (p);
	discharged.PlusPatient (p);
      }
    }
  }

  fun TreatOrTransferPatients {
    var p, n;

    transfers.Clear ();
    for (n = examination.first; n != nil; n = n.next) {
      p = n.item; p.remainingTime--;
      if (p.remainingTime == 0) { // no transfer
	if (genRandom (1.0) > 0.1 || hasNoRegionalHospital) {
	  treatment.Add(p);
	  p.remainingTime = 10;
	  p.hospitalTime += 10;
	} else { // transfer
	  availableStaff++;
	  transfers.Add (p);
	}
	examination.Remove(p);
      }
    }
  }

  fun TriagePatients {
    var p, n;

    for (n = triage.first; n != nil; n = n.next) {
      p = n.item;
      if (availableStaff == 0) p.hospitalTime++;
      else {
	availableStaff--;
	p.remainingTime = 3;
	p.hospitalTime += 3;
	examination.Add (p);
	triage.Remove (p);
      }
    }
  }

  val IM = 139968, IA = 3877, IC = 29573;

  fun genRandom (max) {
    seed = (seed * IA + IC) % IM;
    return max * seed / IM ;
  }
}

class Totals {
  var patients = 0, hospitalTime = 0, hospitalVisits = 0;

  fun PlusTotal (t) {
    patients += t.patients;
    hospitalTime += t.hospitalTime;
    hospitalVisits += t.hospitalVisits;
  }

   fun PlusPatient (p) {
     patients++;
     hospitalTime += p.hospitalTime;
     hospitalVisits += p.hospitalVisits;
   }
}

var N = int (#argv < 1 ? 100 : argv [0]);
var i, healthcareSystem = CreateRegion (LEVELS, 0, 42), t, n;

for (i = 0; i < N; i++)
  healthcareSystem.TransferPatients ();

t = healthcareSystem.AccumulateTotals ();

putln ("Patients: ", t.patients);
putln ("Time:     ", t.hospitalTime);
putln ("Visits:   ", t.hospitalVisits);

putln ("\nTreatment Queue - Remaining Treatment Time");
for (n = healthcareSystem.TreatmentQueue ().first; n != nil; n = n.next)
  putln (n.item.remainingTime, "\tanonymous patient");
TEST573
        echo '      ' $DINO $test_file 100 "2>$stderr"
        if $DINO $test_file 100 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT573' && $CMP $stdout $ftemp2; then
Patients: 10151
Time:     363815
Visits:   10526

Treatment Queue - Remaining Treatment Time
1	anonymous patient
3	anonymous patient
9	anonymous patient
10	anonymous patient
OUTPUT573
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 574.
if test $result = ok -a $start_test_number -le 574; then
	echo test 574: Sync-statement
        cat >$test_file <<'TEST574'
var f = 1;
thread t {
  wait (1) {
    var i;

    f = 0;
    for (i = 0; i < 1000000; i++)
      if (i % 100000 == 0) putln (i);
  }
}

t ();
wait (! f);
putln ("it should be the last message");
TEST574
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT574' && $CMP $stdout $ftemp2; then
0
100000
200000
300000
400000
500000
600000
700000
800000
900000
it should be the last message
OUTPUT574
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 575.
if test $result = ok -a $start_test_number -le 575; then
	echo test 575: Wait in sync-statement
        cat >$test_file <<'TEST575'
var flag = 0;

thread f {
  wait (1) {
    wait (flag);
    flag = 0;
  }
}

f ();
flag = 1;
wait (! flag);
putln ("it can not be printed");
TEST575
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT575' && $CMP $stderr $ftemp2; then
test.d:5:5: wait in sync-statement
OUTPUT575
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 576.
if test $result = ok -a $start_test_number -le 576; then
	echo test 576: Catching wait in sync-statement
        cat >$test_file <<'TEST576'
var flag = 0;

thread f {
  try {
    wait (1) wait (flag);
  } catch (syncwait) {
    putln ("got the exception");
    flag = 0;
  }
}

f ();
flag = 1;
wait (! flag);
putln ("continue");
TEST576
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT576' && $CMP $stdout $ftemp2; then
got the exception
continue
OUTPUT576
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 577.
if test $result = ok -a $start_test_number -le 577; then
	echo test 577: Thread call in sync-statement
        cat >$test_file <<'TEST577'
var flag = 0;

thread f {
}

wait (1) f ();
putln ("it can not be printed");
TEST577
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT577' && $CMP $stderr $ftemp2; then
test.d:6:12: thread call in sync-statement
OUTPUT577
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 578.
if test $result = ok -a $start_test_number -le 578; then
	echo test 578: Catching thread call in sync-statement
        cat >$test_file <<'TEST578'
var flag = 0;

thread f {
}

try {
  wait (1) f ();
} catch (syncthreadcall) {
  putln ("got the exception");
}

putln ("continue");
TEST578
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT578' && $CMP $stdout $ftemp2; then
got the exception
continue
OUTPUT578
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 579.
if test $result = ok -a $start_test_number -le 579; then
	echo test 579: Longs
        cat >$test_file <<'TEST579'
var gmp1 = 5L;
var gmp2 = 10L;
var gmp3 = 0L;

putln (int (gmp1));
putln (float (gmp2));
gmp1 = long ("10000000000000000000000000000000000000000000000L");
gmp2 = long ("5000000000000000000000000000000000000000000000L");
putln (gmp1 + gmp2);
putln (gmp1 - gmp2);
putln (-gmp1);
putln (-gmp1 < 0 ? gmp1 : -gmp1);
putln (gmp1 * gmp2);
putln (gmp1 / gmp2);
putln (gmp1 % gmp2);
putln (gmp2 % gmp1);
putln (gmp1 < gmp2);
putln (gmp2 <= gmp1);
putf ("%o\n", gmp1);
putf ("%o\n", gmp2);
TEST579
        if uname | fgrep CYGWIN; then
            echo '      ' $DINO $test_file "2>$stderr"
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT579' && $CMP $stdout $ftemp2; then
5
10
15000000000000000000000000000000000000000000000
5000000000000000000000000000000000000000000000
-10000000000000000000000000000000000000000000000
10000000000000000000000000000000000000000000000
50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
2
0
5000000000000000000000000000000000000000000000
0
1
700324573052063614067325026200675322000000000000000
340152275425031706033552413100336551000000000000000
OUTPUT579
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
            echo '      ' $DINO $test_file "2>$stderr"
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT579' && $CMP $stdout $ftemp2; then
5
10
15000000000000000000000000000000000000000000000
5000000000000000000000000000000000000000000000
-10000000000000000000000000000000000000000000000
10000000000000000000000000000000000000000000000
50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
2
0
5000000000000000000000000000000000000000000000
0
1
700324573052063614067325026200675322000000000000000
340152275425031706033552413100336551000000000000000
OUTPUT579
                        result=ok
                else
                        result=fail
                fi
	    elif fgrep 'run time error - can not find external function' $stderr >/dev/null;then
		echo GMP package is absent -- skip
                result=ok
	    else
                result=fail
	    fi
        fi
fi

# Test 580.
if test $result = ok -a $start_test_number -le 580; then
	echo test 580: exit tracing
        cat >$test_file <<'TEST580'
fun a {
  exit (0);
}
fun b {
  a ();
}
fun c (i) {
  if (i == 0) b (); else c (i - 1);
}
class d {
  c (5);
}
d ();
TEST580
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT580' && $CMP $stderr $ftemp2; then
test.d:11:5:calling a
test.d:13:3:calling d
OUTPUT580
                        result=ok
                else
                        result=fail
                fi
	else
                result=fail
        fi
fi

# Test 581.
if test $result = ok -a $start_test_number -le 581; then
	echo test 581: exception tracing
        cat >$test_file <<'TEST581'
fun a {
  throw except ();
}
fun b {
  a ();
}
fun c (i) {
  if (i == 0) b (); else c (i - 1);
}
class d {
  c (5);
}
d ();
TEST581
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT581' && $CMP $stderr $ftemp2; then
test.d:2:3: run time error - exception except has not been processed
test.d:11:5:calling a
test.d:13:3:calling d
OUTPUT581
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 582.
if test $result = ok -a $start_test_number -le 582; then
	echo test 582: catched exception tracing
        cat >$test_file <<'TEST582'
fun a {
  var i = 0;
  i[10]=0;
}
fun b {
  a ();
}
fun c (i) {
  if (i == 0) b (); else c (i - 1);
}
class d {
  c (5);
}
var i;
for (i = 0; i < 10; i++) 
  try {
    d ();
  } catch (error) {
    putln ("got it: ", e.msg);
  }
TEST582
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT582' && $CMP $stdout $ftemp2; then
got it: run time error - index operation for non vector or table
got it: run time error - index operation for non vector or table
got it: run time error - index operation for non vector or table
got it: run time error - index operation for non vector or table
got it: run time error - index operation for non vector or table
got it: run time error - index operation for non vector or table
got it: run time error - index operation for non vector or table
got it: run time error - index operation for non vector or table
got it: run time error - index operation for non vector or table
got it: run time error - index operation for non vector or table
OUTPUT582
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 583.
if test $result = ok -a $start_test_number -le 583; then
	echo test 583: normal exit tracing
        cat >$test_file <<'TEST583'
var i;
for (i =0; i < 10; i++);
TEST583
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT583' && $CMP $stdout $ftemp2; then
OUTPUT583
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 584.
if test $result = ok -a $start_test_number -le 584; then
	echo test 584: Normal dump
        cat >$test_file <<'TEST584'
var SieveSize, i, prime, k, count, flags;
SieveSize = 8190;

flags = [SieveSize + 1 : 0];
count = 0;
for (i = 0; i <= SieveSize; i++)
  flags[i] = 1;
for (i = 0; i <= SieveSize; i++;)
  if (flags[i])
    {
      prime = i + i + 3;
      k = i + prime;
      for (;1;;)
        {
	      if (k > SieveSize)
            break;
          flags[k] = 0;
          k += prime;
        }
      count++;
    }

println (count);
TEST584
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT584' && $CMP $stdout $ftemp2; then
     0 block pos=0 next=738 vars_num=18 tvars_num=3 // ident=(null)
       0 fdecl fn="<environment>" ln=1 pos=7 ident=except ident_num=1 decl_scope=0 fblock=1
       1 fblock pos=14 fdecl=0 class_p=1 simple_p=1 pure_fun_p=1 scope=0 vars_num=0 tvars_num=0 ext_life_p=1 // ident=except

         2 fbend pos=14 block=1
       1 fdecl ln=2 pos=8 ident=error ident_num=2 decl_scope=0 fblock=3
       3 fblock pos=26 next=4 fdecl=1 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=1 // ident=error
         2 vdecl pos=15 ident=msg ident_num=3 decl_scope=3 public_p=1 var_num=0

         4 btdef pos=15 op1=0 pc=6 // goto 6 unless 0 is undefined
         5 ldnil pos=21 op1=0 // 0 <- nil
         6 fbend pos=15 block=3
       3 fdecl ln=3 pos=9 ident=signal ident_num=4 decl_scope=0 fblock=7
       7 fblock pos=28 next=8 fdecl=3 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=3 use=1 // ident=signal
         4 vdecl pos=17 ident=msg ident_num=3 decl_scope=7 public_p=1 var_num=0

         8 btdef pos=17 op1=0 pc=10 // goto 10 unless 0 is undefined
         9 ldnil pos=23 op1=0 // 0 <- nil
        10 fbend ln=2 pos=15 block=7
       5 fdecl ln=4 pos=10 ident=sigint ident_num=5 decl_scope=0 fblock=11
      11 fblock pos=29 next=12 fdecl=5 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=7 use=1 use=3 // ident=sigint
         6 vdecl pos=18 ident=msg ident_num=3 decl_scope=11 public_p=1 var_num=0

        12 btdef pos=18 op1=0 pc=14 // goto 14 unless 0 is undefined
        13 ldnil pos=24 op1=0 // 0 <- nil
        14 fbend ln=2 pos=15 block=11
       7 fdecl ln=5 pos=10 ident=sigill ident_num=6 decl_scope=0 fblock=15
      15 fblock pos=29 next=16 fdecl=7 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=7 use=1 use=3 // ident=sigill
         8 vdecl pos=18 ident=msg ident_num=3 decl_scope=15 public_p=1 var_num=0

        16 btdef pos=18 op1=0 pc=18 // goto 18 unless 0 is undefined
        17 ldnil pos=24 op1=0 // 0 <- nil
        18 fbend ln=2 pos=15 block=15
       9 fdecl ln=6 pos=10 ident=sigabrt ident_num=7 decl_scope=0 fblock=19
      19 fblock pos=30 next=20 fdecl=9 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=7 use=1 use=3 // ident=sigabrt
        10 vdecl pos=19 ident=msg ident_num=3 decl_scope=19 public_p=1 var_num=0

        20 btdef pos=19 op1=0 pc=22 // goto 22 unless 0 is undefined
        21 ldnil pos=25 op1=0 // 0 <- nil
        22 fbend ln=2 pos=15 block=19
      11 fdecl ln=7 pos=10 ident=sigfpe ident_num=8 decl_scope=0 fblock=23
      23 fblock pos=29 next=24 fdecl=11 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=7 use=1 use=3 // ident=sigfpe
        12 vdecl pos=18 ident=msg ident_num=3 decl_scope=23 public_p=1 var_num=0

        24 btdef pos=18 op1=0 pc=26 // goto 26 unless 0 is undefined
        25 ldnil pos=24 op1=0 // 0 <- nil
        26 fbend ln=2 pos=15 block=23
      13 fdecl ln=8 pos=10 ident=sigterm ident_num=9 decl_scope=0 fblock=27
      27 fblock pos=30 next=28 fdecl=13 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=7 use=1 use=3 // ident=sigterm
        14 vdecl pos=19 ident=msg ident_num=3 decl_scope=27 public_p=1 var_num=0

        28 btdef pos=19 op1=0 pc=30 // goto 30 unless 0 is undefined
        29 ldnil pos=25 op1=0 // 0 <- nil
        30 fbend ln=2 pos=15 block=27
      15 fdecl ln=9 pos=10 ident=sigsegv ident_num=10 decl_scope=0 fblock=31
      31 fblock pos=30 next=32 fdecl=15 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=7 use=1 use=3 // ident=sigsegv
        16 vdecl pos=19 ident=msg ident_num=3 decl_scope=31 public_p=1 var_num=0

        32 btdef pos=19 op1=0 pc=34 // goto 34 unless 0 is undefined
        33 ldnil pos=25 op1=0 // 0 <- nil
        34 fbend ln=2 pos=15 block=31
      17 fdecl ln=10 pos=9 ident=invenv ident_num=11 decl_scope=0 fblock=35
      35 fblock pos=28 next=36 fdecl=17 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=3 use=1 // ident=invenv
        18 vdecl pos=17 ident=msg ident_num=3 decl_scope=35 public_p=1 var_num=0

        36 btdef pos=17 op1=0 pc=38 // goto 38 unless 0 is undefined
        37 ldnil pos=23 op1=0 // 0 <- nil
        38 fbend ln=2 pos=15 block=35
      19 fdecl ln=11 pos=9 ident=invop ident_num=12 decl_scope=0 fblock=39
      39 fblock pos=27 next=40 fdecl=19 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=3 use=1 // ident=invop
        20 vdecl pos=16 ident=msg ident_num=3 decl_scope=39 public_p=1 var_num=0

        40 btdef pos=16 op1=0 pc=42 // goto 42 unless 0 is undefined
        41 ldnil pos=22 op1=0 // 0 <- nil
        42 fbend ln=2 pos=15 block=39
      21 fdecl ln=12 pos=10 ident=optype ident_num=13 decl_scope=0 fblock=43
      43 fblock pos=29 next=44 fdecl=21 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=39 use=1 use=3 // ident=optype
        22 vdecl pos=18 ident=msg ident_num=3 decl_scope=43 public_p=1 var_num=0

        44 btdef pos=18 op1=0 pc=46 // goto 46 unless 0 is undefined
        45 ldnil pos=24 op1=0 // 0 <- nil
        46 fbend ln=2 pos=15 block=43
      23 fdecl ln=13 pos=10 ident=opvalue ident_num=14 decl_scope=0 fblock=47
      47 fblock pos=30 next=48 fdecl=23 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=39 use=1 use=3 // ident=opvalue
        24 vdecl pos=19 ident=msg ident_num=3 decl_scope=47 public_p=1 var_num=0

        48 btdef pos=19 op1=0 pc=50 // goto 50 unless 0 is undefined
        49 ldnil pos=25 op1=0 // 0 <- nil
        50 fbend ln=2 pos=15 block=47
      25 fdecl ln=14 pos=9 ident=invindex ident_num=15 decl_scope=0 fblock=51
      51 fblock pos=30 next=52 fdecl=25 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=3 use=1 // ident=invindex
        26 vdecl pos=19 ident=msg ident_num=3 decl_scope=51 public_p=1 var_num=0

        52 btdef pos=19 op1=0 pc=54 // goto 54 unless 0 is undefined
        53 ldnil pos=25 op1=0 // 0 <- nil
        54 fbend ln=2 pos=15 block=51
      27 fdecl ln=15 pos=10 ident=indextype ident_num=16 decl_scope=0 fblock=55
      55 fblock pos=32 next=56 fdecl=27 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=51 use=1 use=3 // ident=indextype
        28 vdecl pos=21 ident=msg ident_num=3 decl_scope=55 public_p=1 var_num=0

        56 btdef pos=21 op1=0 pc=58 // goto 58 unless 0 is undefined
        57 ldnil pos=27 op1=0 // 0 <- nil
        58 fbend ln=2 pos=15 block=55
      29 fdecl ln=16 pos=10 ident=indexvalue ident_num=17 decl_scope=0 fblock=59
      59 fblock pos=33 next=60 fdecl=29 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=51 use=1 use=3 // ident=indexvalue
        30 vdecl pos=22 ident=msg ident_num=3 decl_scope=59 public_p=1 var_num=0

        60 btdef pos=22 op1=0 pc=62 // goto 62 unless 0 is undefined
        61 ldnil pos=28 op1=0 // 0 <- nil
        62 fbend ln=2 pos=15 block=59
      31 fdecl ln=17 pos=10 ident=indexop ident_num=18 decl_scope=0 fblock=63
      63 fblock pos=30 next=64 fdecl=31 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=51 use=1 use=3 // ident=indexop
        32 vdecl pos=19 ident=msg ident_num=3 decl_scope=63 public_p=1 var_num=0

        64 btdef pos=19 op1=0 pc=66 // goto 66 unless 0 is undefined
        65 ldnil pos=25 op1=0 // 0 <- nil
        66 fbend ln=2 pos=15 block=63
      33 fdecl ln=18 pos=9 ident=invslice ident_num=19 decl_scope=0 fblock=67
      67 fblock pos=30 next=68 fdecl=33 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=3 use=1 // ident=invslice
        34 vdecl pos=19 ident=msg ident_num=3 decl_scope=67 public_p=1 var_num=0

        68 btdef pos=19 op1=0 pc=70 // goto 70 unless 0 is undefined
        69 ldnil pos=25 op1=0 // 0 <- nil
        70 fbend ln=2 pos=15 block=67
      35 fdecl ln=19 pos=10 ident=slicetype ident_num=20 decl_scope=0 fblock=71
      71 fblock pos=32 next=72 fdecl=35 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=67 use=1 use=3 // ident=slicetype
        36 vdecl pos=21 ident=msg ident_num=3 decl_scope=71 public_p=1 var_num=0

        72 btdef pos=21 op1=0 pc=74 // goto 74 unless 0 is undefined
        73 ldnil pos=27 op1=0 // 0 <- nil
        74 fbend ln=2 pos=15 block=71
      37 fdecl ln=20 pos=10 ident=sliceform ident_num=21 decl_scope=0 fblock=75
      75 fblock pos=32 next=76 fdecl=37 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=67 use=1 use=3 // ident=sliceform
        38 vdecl pos=21 ident=msg ident_num=3 decl_scope=75 public_p=1 var_num=0

        76 btdef pos=21 op1=0 pc=78 // goto 78 unless 0 is undefined
        77 ldnil pos=27 op1=0 // 0 <- nil
        78 fbend ln=2 pos=15 block=75
      39 fdecl ln=21 pos=9 ident=invector ident_num=22 decl_scope=0 fblock=79
      79 fblock pos=30 next=80 fdecl=39 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=3 use=1 // ident=invector
        40 vdecl pos=19 ident=msg ident_num=3 decl_scope=79 public_p=1 var_num=0

        80 btdef pos=19 op1=0 pc=82 // goto 82 unless 0 is undefined
        81 ldnil pos=25 op1=0 // 0 <- nil
        82 fbend ln=2 pos=15 block=79
      41 fdecl ln=22 pos=10 ident=veclen ident_num=23 decl_scope=0 fblock=83
      83 fblock pos=29 next=84 fdecl=41 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=79 use=1 use=3 // ident=veclen
        42 vdecl pos=18 ident=msg ident_num=3 decl_scope=83 public_p=1 var_num=0

        84 btdef pos=18 op1=0 pc=86 // goto 86 unless 0 is undefined
        85 ldnil pos=24 op1=0 // 0 <- nil
        86 fbend ln=2 pos=15 block=83
      43 fdecl ln=23 pos=10 ident=vecform ident_num=24 decl_scope=0 fblock=87
      87 fblock pos=30 next=88 fdecl=43 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=79 use=1 use=3 // ident=vecform
        44 vdecl pos=19 ident=msg ident_num=3 decl_scope=87 public_p=1 var_num=0

        88 btdef pos=19 op1=0 pc=90 // goto 90 unless 0 is undefined
        89 ldnil pos=25 op1=0 // 0 <- nil
        90 fbend ln=2 pos=15 block=87
      45 fdecl ln=24 pos=10 ident=matrixform ident_num=25 decl_scope=0 fblock=91
      91 fblock pos=33 next=92 fdecl=45 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=79 use=1 use=3 // ident=matrixform
        46 vdecl pos=22 ident=msg ident_num=3 decl_scope=91 public_p=1 var_num=0

        92 btdef pos=22 op1=0 pc=94 // goto 94 unless 0 is undefined
        93 ldnil pos=28 op1=0 // 0 <- nil
        94 fbend ln=2 pos=15 block=91
      47 fdecl ln=25 pos=9 ident=invkey ident_num=26 decl_scope=0 fblock=95
      95 fblock pos=28 next=96 fdecl=47 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=3 use=1 // ident=invkey
        48 vdecl pos=17 ident=msg ident_num=3 decl_scope=95 public_p=1 var_num=0

        96 btdef pos=17 op1=0 pc=98 // goto 98 unless 0 is undefined
        97 ldnil pos=23 op1=0 // 0 <- nil
        98 fbend ln=2 pos=15 block=95
      49 fdecl ln=26 pos=10 ident=keyvalue ident_num=27 decl_scope=0 fblock=99
      99 fblock pos=31 next=100 fdecl=49 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=95 use=1 use=3 // ident=keyvalue
        50 vdecl pos=20 ident=msg ident_num=3 decl_scope=99 public_p=1 var_num=0

       100 btdef pos=20 op1=0 pc=102 // goto 102 unless 0 is undefined
       101 ldnil pos=26 op1=0 // 0 <- nil
       102 fbend ln=2 pos=15 block=99
      51 fdecl ln=27 pos=10 ident=keyop ident_num=28 decl_scope=0 fblock=103
     103 fblock pos=28 next=104 fdecl=51 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=95 use=1 use=3 // ident=keyop
        52 vdecl pos=17 ident=msg ident_num=3 decl_scope=103 public_p=1 var_num=0

       104 btdef pos=17 op1=0 pc=106 // goto 106 unless 0 is undefined
       105 ldnil pos=23 op1=0 // 0 <- nil
       106 fbend ln=2 pos=15 block=103
      53 fdecl ln=28 pos=9 ident=invcall ident_num=29 decl_scope=0 fblock=107
     107 fblock pos=29 next=108 fdecl=53 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=3 use=1 // ident=invcall
        54 vdecl pos=18 ident=msg ident_num=3 decl_scope=107 public_p=1 var_num=0

       108 btdef pos=18 op1=0 pc=110 // goto 110 unless 0 is undefined
       109 ldnil pos=24 op1=0 // 0 <- nil
       110 fbend ln=2 pos=15 block=107
      55 fdecl ln=29 pos=10 ident=abstrcall ident_num=30 decl_scope=0 fblock=111
     111 fblock pos=32 next=112 fdecl=55 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=107 use=1 use=3 // ident=abstrcall
        56 vdecl pos=21 ident=msg ident_num=3 decl_scope=111 public_p=1 var_num=0

       112 btdef pos=21 op1=0 pc=114 // goto 114 unless 0 is undefined
       113 ldnil pos=27 op1=0 // 0 <- nil
       114 fbend ln=2 pos=15 block=111
      57 fdecl ln=30 pos=10 ident=callop ident_num=31 decl_scope=0 fblock=115
     115 fblock pos=29 next=116 fdecl=57 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=107 use=1 use=3 // ident=callop
        58 vdecl pos=18 ident=msg ident_num=3 decl_scope=115 public_p=1 var_num=0

       116 btdef pos=18 op1=0 pc=118 // goto 118 unless 0 is undefined
       117 ldnil pos=24 op1=0 // 0 <- nil
       118 fbend ln=2 pos=15 block=115
      59 fdecl ln=31 pos=10 ident=partype ident_num=32 decl_scope=0 fblock=119
     119 fblock pos=30 next=120 fdecl=59 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=107 use=1 use=3 // ident=partype
        60 vdecl pos=19 ident=msg ident_num=3 decl_scope=119 public_p=1 var_num=0

       120 btdef pos=19 op1=0 pc=122 // goto 122 unless 0 is undefined
       121 ldnil pos=25 op1=0 // 0 <- nil
       122 fbend ln=2 pos=15 block=119
      61 fdecl ln=32 pos=10 ident=invresult ident_num=33 decl_scope=0 fblock=123
     123 fblock pos=32 next=124 fdecl=61 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=107 use=1 use=3 // ident=invresult
        62 vdecl pos=21 ident=msg ident_num=3 decl_scope=123 public_p=1 var_num=0

       124 btdef pos=21 op1=0 pc=126 // goto 126 unless 0 is undefined
       125 ldnil pos=27 op1=0 // 0 <- nil
       126 fbend ln=2 pos=15 block=123
      63 fdecl ln=33 pos=10 ident=invinput ident_num=34 decl_scope=0 fblock=127
     127 fblock pos=31 next=128 fdecl=63 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=107 use=1 use=3 // ident=invinput
        64 vdecl pos=20 ident=msg ident_num=3 decl_scope=127 public_p=1 var_num=0

       128 btdef pos=20 op1=0 pc=130 // goto 130 unless 0 is undefined
       129 ldnil pos=26 op1=0 // 0 <- nil
       130 fbend ln=2 pos=15 block=127
      65 fdecl ln=34 pos=10 ident=invfmt ident_num=35 decl_scope=0 fblock=131
     131 fblock pos=29 next=132 fdecl=65 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=107 use=1 use=3 // ident=invfmt
        66 vdecl pos=18 ident=msg ident_num=3 decl_scope=131 public_p=1 var_num=0

       132 btdef pos=18 op1=0 pc=134 // goto 134 unless 0 is undefined
       133 ldnil pos=24 op1=0 // 0 <- nil
       134 fbend ln=2 pos=15 block=131
      67 fdecl ln=35 pos=10 ident=eof ident_num=36 decl_scope=0 fblock=135
     135 fblock pos=26 next=136 fdecl=67 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=107 use=1 use=3 // ident=eof
        68 vdecl pos=15 ident=msg ident_num=3 decl_scope=135 public_p=1 var_num=0

       136 btdef pos=15 op1=0 pc=138 // goto 138 unless 0 is undefined
       137 ldnil pos=21 op1=0 // 0 <- nil
       138 fbend ln=2 pos=15 block=135
      69 fdecl ln=36 pos=10 ident=parnumber ident_num=37 decl_scope=0 fblock=139
     139 fblock pos=32 next=140 fdecl=69 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=107 use=1 use=3 // ident=parnumber
        70 vdecl pos=21 ident=msg ident_num=3 decl_scope=139 public_p=1 var_num=0

       140 btdef pos=21 op1=0 pc=142 // goto 142 unless 0 is undefined
       141 ldnil pos=27 op1=0 // 0 <- nil
       142 fbend ln=2 pos=15 block=139
      71 fdecl ln=37 pos=10 ident=syncthreadcall ident_num=38 decl_scope=0 fblock=143
     143 fblock pos=37 next=144 fdecl=71 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=107 use=1 use=3 // ident=syncthreadcall
        72 vdecl pos=26 ident=msg ident_num=3 decl_scope=143 public_p=1 var_num=0

       144 btdef pos=26 op1=0 pc=146 // goto 146 unless 0 is undefined
       145 ldnil pos=32 op1=0 // 0 <- nil
       146 fbend ln=2 pos=15 block=143
      73 fdecl ln=38 pos=10 ident=syserror ident_num=39 decl_scope=0 fblock=147
     147 fblock pos=31 next=148 fdecl=73 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=107 use=1 use=3 // ident=syserror
        74 vdecl pos=20 ident=msg ident_num=3 decl_scope=147 public_p=1 var_num=0

       148 btdef pos=20 op1=0 pc=150 // goto 150 unless 0 is undefined
       149 ldnil pos=26 op1=0 // 0 <- nil
       150 fbend ln=2 pos=15 block=147
      75 fdecl ln=39 pos=11 ident=eaccess ident_num=40 decl_scope=0 fblock=151
     151 fblock pos=31 next=152 fdecl=75 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=eaccess
        76 vdecl pos=20 ident=msg ident_num=3 decl_scope=151 public_p=1 var_num=0

       152 btdef pos=20 op1=0 pc=154 // goto 154 unless 0 is undefined
       153 ldnil pos=26 op1=0 // 0 <- nil
       154 fbend ln=2 pos=15 block=151
      77 fdecl ln=40 pos=11 ident=eagain ident_num=41 decl_scope=0 fblock=155
     155 fblock pos=30 next=156 fdecl=77 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=eagain
        78 vdecl pos=19 ident=msg ident_num=3 decl_scope=155 public_p=1 var_num=0

       156 btdef pos=19 op1=0 pc=158 // goto 158 unless 0 is undefined
       157 ldnil pos=25 op1=0 // 0 <- nil
       158 fbend ln=2 pos=15 block=155
      79 fdecl ln=41 pos=11 ident=ebadf ident_num=42 decl_scope=0 fblock=159
     159 fblock pos=29 next=160 fdecl=79 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=ebadf
        80 vdecl pos=18 ident=msg ident_num=3 decl_scope=159 public_p=1 var_num=0

       160 btdef pos=18 op1=0 pc=162 // goto 162 unless 0 is undefined
       161 ldnil pos=24 op1=0 // 0 <- nil
       162 fbend ln=2 pos=15 block=159
      81 fdecl ln=42 pos=11 ident=ebusy ident_num=43 decl_scope=0 fblock=163
     163 fblock pos=29 next=164 fdecl=81 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=ebusy
        82 vdecl pos=18 ident=msg ident_num=3 decl_scope=163 public_p=1 var_num=0

       164 btdef pos=18 op1=0 pc=166 // goto 166 unless 0 is undefined
       165 ldnil pos=24 op1=0 // 0 <- nil
       166 fbend ln=2 pos=15 block=163
      83 fdecl ln=43 pos=11 ident=echild ident_num=44 decl_scope=0 fblock=167
     167 fblock pos=30 next=168 fdecl=83 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=echild
        84 vdecl pos=19 ident=msg ident_num=3 decl_scope=167 public_p=1 var_num=0

       168 btdef pos=19 op1=0 pc=170 // goto 170 unless 0 is undefined
       169 ldnil pos=25 op1=0 // 0 <- nil
       170 fbend ln=2 pos=15 block=167
      85 fdecl ln=44 pos=11 ident=edeadlk ident_num=45 decl_scope=0 fblock=171
     171 fblock pos=31 next=172 fdecl=85 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=edeadlk
        86 vdecl pos=20 ident=msg ident_num=3 decl_scope=171 public_p=1 var_num=0

       172 btdef pos=20 op1=0 pc=174 // goto 174 unless 0 is undefined
       173 ldnil pos=26 op1=0 // 0 <- nil
       174 fbend ln=2 pos=15 block=171
      87 fdecl ln=45 pos=11 ident=edom ident_num=46 decl_scope=0 fblock=175
     175 fblock pos=28 next=176 fdecl=87 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=edom
        88 vdecl pos=17 ident=msg ident_num=3 decl_scope=175 public_p=1 var_num=0

       176 btdef pos=17 op1=0 pc=178 // goto 178 unless 0 is undefined
       177 ldnil pos=23 op1=0 // 0 <- nil
       178 fbend ln=2 pos=15 block=175
      89 fdecl ln=46 pos=11 ident=eexist ident_num=47 decl_scope=0 fblock=179
     179 fblock pos=30 next=180 fdecl=89 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=eexist
        90 vdecl pos=19 ident=msg ident_num=3 decl_scope=179 public_p=1 var_num=0

       180 btdef pos=19 op1=0 pc=182 // goto 182 unless 0 is undefined
       181 ldnil pos=25 op1=0 // 0 <- nil
       182 fbend ln=2 pos=15 block=179
      91 fdecl ln=47 pos=11 ident=efault ident_num=48 decl_scope=0 fblock=183
     183 fblock pos=30 next=184 fdecl=91 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=efault
        92 vdecl pos=19 ident=msg ident_num=3 decl_scope=183 public_p=1 var_num=0

       184 btdef pos=19 op1=0 pc=186 // goto 186 unless 0 is undefined
       185 ldnil pos=25 op1=0 // 0 <- nil
       186 fbend ln=2 pos=15 block=183
      93 fdecl ln=48 pos=11 ident=efbig ident_num=49 decl_scope=0 fblock=187
     187 fblock pos=29 next=188 fdecl=93 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=efbig
        94 vdecl pos=18 ident=msg ident_num=3 decl_scope=187 public_p=1 var_num=0

       188 btdef pos=18 op1=0 pc=190 // goto 190 unless 0 is undefined
       189 ldnil pos=24 op1=0 // 0 <- nil
       190 fbend ln=2 pos=15 block=187
      95 fdecl ln=49 pos=11 ident=eintr ident_num=50 decl_scope=0 fblock=191
     191 fblock pos=29 next=192 fdecl=95 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=eintr
        96 vdecl pos=18 ident=msg ident_num=3 decl_scope=191 public_p=1 var_num=0

       192 btdef pos=18 op1=0 pc=194 // goto 194 unless 0 is undefined
       193 ldnil pos=24 op1=0 // 0 <- nil
       194 fbend ln=2 pos=15 block=191
      97 fdecl ln=50 pos=11 ident=einval ident_num=51 decl_scope=0 fblock=195
     195 fblock pos=30 next=196 fdecl=97 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=einval
        98 vdecl pos=19 ident=msg ident_num=3 decl_scope=195 public_p=1 var_num=0

       196 btdef pos=19 op1=0 pc=198 // goto 198 unless 0 is undefined
       197 ldnil pos=25 op1=0 // 0 <- nil
       198 fbend ln=2 pos=15 block=195
      99 fdecl ln=51 pos=11 ident=eio ident_num=52 decl_scope=0 fblock=199
     199 fblock pos=27 next=200 fdecl=99 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=eio
       100 vdecl pos=16 ident=msg ident_num=3 decl_scope=199 public_p=1 var_num=0

       200 btdef pos=16 op1=0 pc=202 // goto 202 unless 0 is undefined
       201 ldnil pos=22 op1=0 // 0 <- nil
       202 fbend ln=2 pos=15 block=199
     101 fdecl ln=52 pos=11 ident=eisdir ident_num=53 decl_scope=0 fblock=203
     203 fblock pos=30 next=204 fdecl=101 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=eisdir
       102 vdecl pos=19 ident=msg ident_num=3 decl_scope=203 public_p=1 var_num=0

       204 btdef pos=19 op1=0 pc=206 // goto 206 unless 0 is undefined
       205 ldnil pos=25 op1=0 // 0 <- nil
       206 fbend ln=2 pos=15 block=203
     103 fdecl ln=53 pos=11 ident=emfile ident_num=54 decl_scope=0 fblock=207
     207 fblock pos=30 next=208 fdecl=103 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=emfile
       104 vdecl pos=19 ident=msg ident_num=3 decl_scope=207 public_p=1 var_num=0

       208 btdef pos=19 op1=0 pc=210 // goto 210 unless 0 is undefined
       209 ldnil pos=25 op1=0 // 0 <- nil
       210 fbend ln=2 pos=15 block=207
     105 fdecl ln=54 pos=11 ident=emlink ident_num=55 decl_scope=0 fblock=211
     211 fblock pos=30 next=212 fdecl=105 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=emlink
       106 vdecl pos=19 ident=msg ident_num=3 decl_scope=211 public_p=1 var_num=0

       212 btdef pos=19 op1=0 pc=214 // goto 214 unless 0 is undefined
       213 ldnil pos=25 op1=0 // 0 <- nil
       214 fbend ln=2 pos=15 block=211
     107 fdecl ln=55 pos=11 ident=enametoolong ident_num=56 decl_scope=0 fblock=215
     215 fblock pos=36 next=216 fdecl=107 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=enametoolong
       108 vdecl pos=25 ident=msg ident_num=3 decl_scope=215 public_p=1 var_num=0

       216 btdef pos=25 op1=0 pc=218 // goto 218 unless 0 is undefined
       217 ldnil pos=31 op1=0 // 0 <- nil
       218 fbend ln=2 pos=15 block=215
     109 fdecl ln=56 pos=11 ident=enfile ident_num=57 decl_scope=0 fblock=219
     219 fblock pos=30 next=220 fdecl=109 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=enfile
       110 vdecl pos=19 ident=msg ident_num=3 decl_scope=219 public_p=1 var_num=0

       220 btdef pos=19 op1=0 pc=222 // goto 222 unless 0 is undefined
       221 ldnil pos=25 op1=0 // 0 <- nil
       222 fbend ln=2 pos=15 block=219
     111 fdecl ln=57 pos=11 ident=enodev ident_num=58 decl_scope=0 fblock=223
     223 fblock pos=30 next=224 fdecl=111 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=enodev
       112 vdecl pos=19 ident=msg ident_num=3 decl_scope=223 public_p=1 var_num=0

       224 btdef pos=19 op1=0 pc=226 // goto 226 unless 0 is undefined
       225 ldnil pos=25 op1=0 // 0 <- nil
       226 fbend ln=2 pos=15 block=223
     113 fdecl ln=58 pos=11 ident=enoent ident_num=59 decl_scope=0 fblock=227
     227 fblock pos=30 next=228 fdecl=113 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=enoent
       114 vdecl pos=19 ident=msg ident_num=3 decl_scope=227 public_p=1 var_num=0

       228 btdef pos=19 op1=0 pc=230 // goto 230 unless 0 is undefined
       229 ldnil pos=25 op1=0 // 0 <- nil
       230 fbend ln=2 pos=15 block=227
     115 fdecl ln=59 pos=11 ident=enoexec ident_num=60 decl_scope=0 fblock=231
     231 fblock pos=31 next=232 fdecl=115 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=enoexec
       116 vdecl pos=20 ident=msg ident_num=3 decl_scope=231 public_p=1 var_num=0

       232 btdef pos=20 op1=0 pc=234 // goto 234 unless 0 is undefined
       233 ldnil pos=26 op1=0 // 0 <- nil
       234 fbend ln=2 pos=15 block=231
     117 fdecl ln=60 pos=11 ident=enolck ident_num=61 decl_scope=0 fblock=235
     235 fblock pos=30 next=236 fdecl=117 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=enolck
       118 vdecl pos=19 ident=msg ident_num=3 decl_scope=235 public_p=1 var_num=0

       236 btdef pos=19 op1=0 pc=238 // goto 238 unless 0 is undefined
       237 ldnil pos=25 op1=0 // 0 <- nil
       238 fbend ln=2 pos=15 block=235
     119 fdecl ln=61 pos=11 ident=enomem ident_num=62 decl_scope=0 fblock=239
     239 fblock pos=30 next=240 fdecl=119 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=enomem
       120 vdecl pos=19 ident=msg ident_num=3 decl_scope=239 public_p=1 var_num=0

       240 btdef pos=19 op1=0 pc=242 // goto 242 unless 0 is undefined
       241 ldnil pos=25 op1=0 // 0 <- nil
       242 fbend ln=2 pos=15 block=239
     121 fdecl ln=62 pos=11 ident=enospc ident_num=63 decl_scope=0 fblock=243
     243 fblock pos=30 next=244 fdecl=121 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=enospc
       122 vdecl pos=19 ident=msg ident_num=3 decl_scope=243 public_p=1 var_num=0

       244 btdef pos=19 op1=0 pc=246 // goto 246 unless 0 is undefined
       245 ldnil pos=25 op1=0 // 0 <- nil
       246 fbend ln=2 pos=15 block=243
     123 fdecl ln=63 pos=11 ident=enosys ident_num=64 decl_scope=0 fblock=247
     247 fblock pos=30 next=248 fdecl=123 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=enosys
       124 vdecl pos=19 ident=msg ident_num=3 decl_scope=247 public_p=1 var_num=0

       248 btdef pos=19 op1=0 pc=250 // goto 250 unless 0 is undefined
       249 ldnil pos=25 op1=0 // 0 <- nil
       250 fbend ln=2 pos=15 block=247
     125 fdecl ln=64 pos=11 ident=enotdir ident_num=65 decl_scope=0 fblock=251
     251 fblock pos=31 next=252 fdecl=125 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=enotdir
       126 vdecl pos=20 ident=msg ident_num=3 decl_scope=251 public_p=1 var_num=0

       252 btdef pos=20 op1=0 pc=254 // goto 254 unless 0 is undefined
       253 ldnil pos=26 op1=0 // 0 <- nil
       254 fbend ln=2 pos=15 block=251
     127 fdecl ln=65 pos=11 ident=enotempty ident_num=66 decl_scope=0 fblock=255
     255 fblock pos=33 next=256 fdecl=127 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=enotempty
       128 vdecl pos=22 ident=msg ident_num=3 decl_scope=255 public_p=1 var_num=0

       256 btdef pos=22 op1=0 pc=258 // goto 258 unless 0 is undefined
       257 ldnil pos=28 op1=0 // 0 <- nil
       258 fbend ln=2 pos=15 block=255
     129 fdecl ln=66 pos=11 ident=enotty ident_num=67 decl_scope=0 fblock=259
     259 fblock pos=30 next=260 fdecl=129 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=enotty
       130 vdecl pos=19 ident=msg ident_num=3 decl_scope=259 public_p=1 var_num=0

       260 btdef pos=19 op1=0 pc=262 // goto 262 unless 0 is undefined
       261 ldnil pos=25 op1=0 // 0 <- nil
       262 fbend ln=2 pos=15 block=259
     131 fdecl ln=67 pos=11 ident=enxio ident_num=68 decl_scope=0 fblock=263
     263 fblock pos=29 next=264 fdecl=131 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=enxio
       132 vdecl pos=18 ident=msg ident_num=3 decl_scope=263 public_p=1 var_num=0

       264 btdef pos=18 op1=0 pc=266 // goto 266 unless 0 is undefined
       265 ldnil pos=24 op1=0 // 0 <- nil
       266 fbend ln=2 pos=15 block=263
     133 fdecl ln=68 pos=11 ident=eperm ident_num=69 decl_scope=0 fblock=267
     267 fblock pos=29 next=268 fdecl=133 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=eperm
       134 vdecl pos=18 ident=msg ident_num=3 decl_scope=267 public_p=1 var_num=0

       268 btdef pos=18 op1=0 pc=270 // goto 270 unless 0 is undefined
       269 ldnil pos=24 op1=0 // 0 <- nil
       270 fbend ln=2 pos=15 block=267
     135 fdecl ln=69 pos=11 ident=epipe ident_num=70 decl_scope=0 fblock=271
     271 fblock pos=29 next=272 fdecl=135 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=epipe
       136 vdecl pos=18 ident=msg ident_num=3 decl_scope=271 public_p=1 var_num=0

       272 btdef pos=18 op1=0 pc=274 // goto 274 unless 0 is undefined
       273 ldnil pos=24 op1=0 // 0 <- nil
       274 fbend ln=2 pos=15 block=271
     137 fdecl ln=70 pos=11 ident=erange ident_num=71 decl_scope=0 fblock=275
     275 fblock pos=30 next=276 fdecl=137 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=erange
       138 vdecl pos=19 ident=msg ident_num=3 decl_scope=275 public_p=1 var_num=0

       276 btdef pos=19 op1=0 pc=278 // goto 278 unless 0 is undefined
       277 ldnil pos=25 op1=0 // 0 <- nil
       278 fbend ln=2 pos=15 block=275
     139 fdecl ln=71 pos=11 ident=erofs ident_num=72 decl_scope=0 fblock=279
     279 fblock pos=29 next=280 fdecl=139 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=erofs
       140 vdecl pos=18 ident=msg ident_num=3 decl_scope=279 public_p=1 var_num=0

       280 btdef pos=18 op1=0 pc=282 // goto 282 unless 0 is undefined
       281 ldnil pos=24 op1=0 // 0 <- nil
       282 fbend ln=2 pos=15 block=279
     141 fdecl ln=72 pos=11 ident=espipe ident_num=73 decl_scope=0 fblock=283
     283 fblock pos=30 next=284 fdecl=141 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=espipe
       142 vdecl pos=19 ident=msg ident_num=3 decl_scope=283 public_p=1 var_num=0

       284 btdef pos=19 op1=0 pc=286 // goto 286 unless 0 is undefined
       285 ldnil pos=25 op1=0 // 0 <- nil
       286 fbend ln=2 pos=15 block=283
     143 fdecl ln=73 pos=11 ident=esrch ident_num=74 decl_scope=0 fblock=287
     287 fblock pos=29 next=288 fdecl=143 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=esrch
       144 vdecl pos=18 ident=msg ident_num=3 decl_scope=287 public_p=1 var_num=0

       288 btdef pos=18 op1=0 pc=290 // goto 290 unless 0 is undefined
       289 ldnil pos=24 op1=0 // 0 <- nil
       290 fbend ln=2 pos=15 block=287
     145 fdecl ln=74 pos=11 ident=exdev ident_num=75 decl_scope=0 fblock=291
     291 fblock pos=29 next=292 fdecl=145 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=147 use=3 use=1 use=107 // ident=exdev
       146 vdecl pos=18 ident=msg ident_num=3 decl_scope=291 public_p=1 var_num=0

       292 btdef pos=18 op1=0 pc=294 // goto 294 unless 0 is undefined
       293 ldnil pos=24 op1=0 // 0 <- nil
       294 fbend ln=2 pos=15 block=291
     147 fdecl ln=75 pos=10 ident=systemcall ident_num=76 decl_scope=0 fblock=295
     295 fblock pos=33 next=296 fdecl=147 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=107 use=1 use=3 // ident=systemcall
       148 vdecl pos=22 ident=msg ident_num=3 decl_scope=295 public_p=1 var_num=0

       296 btdef pos=22 op1=0 pc=298 // goto 298 unless 0 is undefined
       297 ldnil pos=28 op1=0 // 0 <- nil
       298 fbend ln=2 pos=15 block=295
     149 fdecl ln=76 pos=11 ident=noshell ident_num=77 decl_scope=0 fblock=299
     299 fblock pos=31 next=300 fdecl=149 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=295 use=3 use=1 use=107 // ident=noshell
       150 vdecl pos=20 ident=msg ident_num=3 decl_scope=299 public_p=1 var_num=0

       300 btdef pos=20 op1=0 pc=302 // goto 302 unless 0 is undefined
       301 ldnil pos=26 op1=0 // 0 <- nil
       302 fbend ln=2 pos=15 block=299
     151 fdecl ln=77 pos=11 ident=systemfail ident_num=78 decl_scope=0 fblock=303
     303 fblock pos=34 next=304 fdecl=151 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=295 use=3 use=1 use=107 // ident=systemfail
       152 vdecl pos=23 ident=msg ident_num=3 decl_scope=303 public_p=1 var_num=0

       304 btdef pos=23 op1=0 pc=306 // goto 306 unless 0 is undefined
       305 ldnil pos=29 op1=0 // 0 <- nil
       306 fbend ln=2 pos=15 block=303
     153 fdecl ln=78 pos=10 ident=invregexp ident_num=79 decl_scope=0 fblock=307
     307 fblock pos=32 next=308 fdecl=153 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=107 use=1 use=3 // ident=invregexp
       154 vdecl pos=21 ident=msg ident_num=3 decl_scope=307 public_p=1 var_num=0

       308 btdef pos=21 op1=0 pc=310 // goto 310 unless 0 is undefined
       309 ldnil pos=27 op1=0 // 0 <- nil
       310 fbend ln=2 pos=15 block=307
     155 fdecl ln=79 pos=11 ident=ebrack ident_num=80 decl_scope=0 fblock=311
     311 fblock pos=30 next=312 fdecl=155 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=307 use=3 use=1 use=107 // ident=ebrack
       156 vdecl pos=19 ident=msg ident_num=3 decl_scope=311 public_p=1 var_num=0

       312 btdef pos=19 op1=0 pc=314 // goto 314 unless 0 is undefined
       313 ldnil pos=25 op1=0 // 0 <- nil
       314 fbend ln=2 pos=15 block=311
     157 fdecl ln=80 pos=11 ident=erange ident_num=71 decl_scope=0 fblock=315
     315 fblock pos=30 next=316 fdecl=157 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=307 use=3 use=1 use=107 // ident=erange
       158 vdecl pos=19 ident=msg ident_num=3 decl_scope=315 public_p=1 var_num=0

       316 btdef pos=19 op1=0 pc=318 // goto 318 unless 0 is undefined
       317 ldnil pos=25 op1=0 // 0 <- nil
       318 fbend ln=2 pos=15 block=315
     159 fdecl ln=81 pos=11 ident=ectype ident_num=81 decl_scope=0 fblock=319
     319 fblock pos=30 next=320 fdecl=159 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=307 use=3 use=1 use=107 // ident=ectype
       160 vdecl pos=19 ident=msg ident_num=3 decl_scope=319 public_p=1 var_num=0

       320 btdef pos=19 op1=0 pc=322 // goto 322 unless 0 is undefined
       321 ldnil pos=25 op1=0 // 0 <- nil
       322 fbend ln=2 pos=15 block=319
     161 fdecl ln=82 pos=11 ident=eparen ident_num=82 decl_scope=0 fblock=323
     323 fblock pos=30 next=324 fdecl=161 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=307 use=3 use=1 use=107 // ident=eparen
       162 vdecl pos=19 ident=msg ident_num=3 decl_scope=323 public_p=1 var_num=0

       324 btdef pos=19 op1=0 pc=326 // goto 326 unless 0 is undefined
       325 ldnil pos=25 op1=0 // 0 <- nil
       326 fbend ln=2 pos=15 block=323
     163 fdecl ln=83 pos=11 ident=esubreg ident_num=83 decl_scope=0 fblock=327
     327 fblock pos=31 next=328 fdecl=163 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=307 use=3 use=1 use=107 // ident=esubreg
       164 vdecl pos=20 ident=msg ident_num=3 decl_scope=327 public_p=1 var_num=0

       328 btdef pos=20 op1=0 pc=330 // goto 330 unless 0 is undefined
       329 ldnil pos=26 op1=0 // 0 <- nil
       330 fbend ln=2 pos=15 block=327
     165 fdecl ln=84 pos=11 ident=eend ident_num=84 decl_scope=0 fblock=331
     331 fblock pos=28 next=332 fdecl=165 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=307 use=3 use=1 use=107 // ident=eend
       166 vdecl pos=17 ident=msg ident_num=3 decl_scope=331 public_p=1 var_num=0

       332 btdef pos=17 op1=0 pc=334 // goto 334 unless 0 is undefined
       333 ldnil pos=23 op1=0 // 0 <- nil
       334 fbend ln=2 pos=15 block=331
     167 fdecl ln=85 pos=11 ident=eescape ident_num=85 decl_scope=0 fblock=335
     335 fblock pos=31 next=336 fdecl=167 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=307 use=3 use=1 use=107 // ident=eescape
       168 vdecl pos=20 ident=msg ident_num=3 decl_scope=335 public_p=1 var_num=0

       336 btdef pos=20 op1=0 pc=338 // goto 338 unless 0 is undefined
       337 ldnil pos=26 op1=0 // 0 <- nil
       338 fbend ln=2 pos=15 block=335
     169 fdecl ln=86 pos=11 ident=badpat ident_num=86 decl_scope=0 fblock=339
     339 fblock pos=30 next=340 fdecl=169 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=307 use=3 use=1 use=107 // ident=badpat
       170 vdecl pos=19 ident=msg ident_num=3 decl_scope=339 public_p=1 var_num=0

       340 btdef pos=19 op1=0 pc=342 // goto 342 unless 0 is undefined
       341 ldnil pos=25 op1=0 // 0 <- nil
       342 fbend ln=2 pos=15 block=339
     171 fdecl ln=87 pos=11 ident=esize ident_num=87 decl_scope=0 fblock=343
     343 fblock pos=29 next=344 fdecl=171 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=307 use=3 use=1 use=107 // ident=esize
       172 vdecl pos=18 ident=msg ident_num=3 decl_scope=343 public_p=1 var_num=0

       344 btdef pos=18 op1=0 pc=346 // goto 346 unless 0 is undefined
       345 ldnil pos=24 op1=0 // 0 <- nil
       346 fbend ln=2 pos=15 block=343
     173 fdecl ln=88 pos=11 ident=espace ident_num=88 decl_scope=0 fblock=347
     347 fblock pos=30 next=348 fdecl=173 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=307 use=3 use=1 use=107 // ident=espace
       174 vdecl pos=19 ident=msg ident_num=3 decl_scope=347 public_p=1 var_num=0

       348 btdef pos=19 op1=0 pc=350 // goto 350 unless 0 is undefined
       349 ldnil pos=25 op1=0 // 0 <- nil
       350 fbend ln=2 pos=15 block=347
     175 fdecl ln=89 pos=10 ident=invparser ident_num=89 decl_scope=0 fblock=351
     351 fblock pos=32 next=352 fdecl=175 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=107 use=1 use=3 // ident=invparser
       176 vdecl pos=21 ident=msg ident_num=3 decl_scope=351 public_p=1 var_num=0

       352 btdef pos=21 op1=0 pc=354 // goto 354 unless 0 is undefined
       353 ldnil pos=27 op1=0 // 0 <- nil
       354 fbend ln=2 pos=15 block=351
     177 fdecl ln=90 pos=11 ident=invgrammar ident_num=90 decl_scope=0 fblock=355
     355 fblock pos=34 next=356 fdecl=177 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=351 use=3 use=1 use=107 // ident=invgrammar
       178 vdecl pos=23 ident=msg ident_num=3 decl_scope=355 public_p=1 var_num=0

       356 btdef pos=23 op1=0 pc=358 // goto 358 unless 0 is undefined
       357 ldnil pos=29 op1=0 // 0 <- nil
       358 fbend ln=2 pos=15 block=355
     179 fdecl ln=91 pos=11 ident=invtoken ident_num=91 decl_scope=0 fblock=359
     359 fblock pos=32 next=360 fdecl=179 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=351 use=3 use=1 use=107 // ident=invtoken
       180 vdecl pos=21 ident=msg ident_num=3 decl_scope=359 public_p=1 var_num=0

       360 btdef pos=21 op1=0 pc=362 // goto 362 unless 0 is undefined
       361 ldnil pos=27 op1=0 // 0 <- nil
       362 fbend ln=2 pos=15 block=359
     181 fdecl ln=92 pos=11 ident=pmemory ident_num=92 decl_scope=0 fblock=363
     363 fblock pos=31 next=364 fdecl=181 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=351 use=3 use=1 use=107 // ident=pmemory
       182 vdecl pos=20 ident=msg ident_num=3 decl_scope=363 public_p=1 var_num=0

       364 btdef pos=20 op1=0 pc=366 // goto 366 unless 0 is undefined
       365 ldnil pos=26 op1=0 // 0 <- nil
       366 fbend ln=2 pos=15 block=363
     183 fdecl ln=93 pos=10 ident=invextern ident_num=93 decl_scope=0 fblock=367
     367 fblock pos=32 next=368 fdecl=183 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=107 use=1 use=3 // ident=invextern
       184 vdecl pos=21 ident=msg ident_num=3 decl_scope=367 public_p=1 var_num=0

       368 btdef pos=21 op1=0 pc=370 // goto 370 unless 0 is undefined
       369 ldnil pos=27 op1=0 // 0 <- nil
       370 fbend ln=2 pos=15 block=367
     185 fdecl ln=94 pos=11 ident=noextern ident_num=94 decl_scope=0 fblock=371
     371 fblock pos=32 next=372 fdecl=185 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=367 use=3 use=1 use=107 // ident=noextern
       186 vdecl pos=21 ident=msg ident_num=3 decl_scope=371 public_p=1 var_num=0

       372 btdef pos=21 op1=0 pc=374 // goto 374 unless 0 is undefined
       373 ldnil pos=27 op1=0 // 0 <- nil
       374 fbend ln=2 pos=15 block=371
     187 fdecl ln=95 pos=11 ident=libclose ident_num=95 decl_scope=0 fblock=375
     375 fblock pos=32 next=376 fdecl=187 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=367 use=3 use=1 use=107 // ident=libclose
       188 vdecl pos=21 ident=msg ident_num=3 decl_scope=375 public_p=1 var_num=0

       376 btdef pos=21 op1=0 pc=378 // goto 378 unless 0 is undefined
       377 ldnil pos=27 op1=0 // 0 <- nil
       378 fbend ln=2 pos=15 block=375
     189 fdecl ln=96 pos=11 ident=noexternsupp ident_num=96 decl_scope=0 fblock=379
     379 fblock pos=36 next=380 fdecl=189 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=367 use=3 use=1 use=107 // ident=noexternsupp
       190 vdecl pos=25 ident=msg ident_num=3 decl_scope=379 public_p=1 var_num=0

       380 btdef pos=25 op1=0 pc=382 // goto 382 unless 0 is undefined
       381 ldnil pos=31 op1=0 // 0 <- nil
       382 fbend ln=2 pos=15 block=379
     191 fdecl ln=97 pos=10 ident=invenvar ident_num=97 decl_scope=0 fblock=383
     383 fblock pos=31 next=384 fdecl=191 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=107 use=1 use=3 // ident=invenvar
       192 vdecl pos=20 ident=msg ident_num=3 decl_scope=383 public_p=1 var_num=0

       384 btdef pos=20 op1=0 pc=386 // goto 386 unless 0 is undefined
       385 ldnil pos=26 op1=0 // 0 <- nil
       386 fbend ln=2 pos=15 block=383
     193 fdecl ln=98 pos=10 ident=internal ident_num=98 decl_scope=0 fblock=387
     387 fblock pos=31 next=388 fdecl=193 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=107 use=1 use=3 // ident=internal
       194 vdecl pos=20 ident=msg ident_num=3 decl_scope=387 public_p=1 var_num=0

       388 btdef pos=20 op1=0 pc=390 // goto 390 unless 0 is undefined
       389 ldnil pos=26 op1=0 // 0 <- nil
       390 fbend ln=2 pos=15 block=387
     195 fdecl ln=99 pos=9 ident=invaccess ident_num=99 decl_scope=0 fblock=391
     391 fblock pos=31 next=392 fdecl=195 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=3 use=1 // ident=invaccess
       196 vdecl pos=20 ident=msg ident_num=3 decl_scope=391 public_p=1 var_num=0

       392 btdef pos=20 op1=0 pc=394 // goto 394 unless 0 is undefined
       393 ldnil pos=26 op1=0 // 0 <- nil
       394 fbend ln=2 pos=15 block=391
     197 fdecl ln=100 pos=10 ident=accessop ident_num=100 decl_scope=0 fblock=395
     395 fblock pos=31 next=396 fdecl=197 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=391 use=1 use=3 // ident=accessop
       198 vdecl pos=20 ident=msg ident_num=3 decl_scope=395 public_p=1 var_num=0

       396 btdef pos=20 op1=0 pc=398 // goto 398 unless 0 is undefined
       397 ldnil pos=26 op1=0 // 0 <- nil
       398 fbend ln=2 pos=15 block=395
     199 fdecl ln=101 pos=10 ident=accessvalue ident_num=101 decl_scope=0 fblock=399
     399 fblock pos=34 next=400 fdecl=199 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=391 use=1 use=3 // ident=accessvalue
       200 vdecl pos=23 ident=msg ident_num=3 decl_scope=399 public_p=1 var_num=0

       400 btdef pos=23 op1=0 pc=402 // goto 402 unless 0 is undefined
       401 ldnil pos=29 op1=0 // 0 <- nil
       402 fbend ln=2 pos=15 block=399
     201 fdecl ln=102 pos=10 ident=immutable ident_num=102 decl_scope=0 fblock=403
     403 fblock pos=32 next=404 fdecl=201 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=391 use=1 use=3 // ident=immutable
       202 vdecl pos=21 ident=msg ident_num=3 decl_scope=403 public_p=1 var_num=0

       404 btdef pos=21 op1=0 pc=406 // goto 406 unless 0 is undefined
       405 ldnil pos=27 op1=0 // 0 <- nil
       406 fbend ln=2 pos=15 block=403
     203 fdecl ln=103 pos=9 ident=deadlock ident_num=103 decl_scope=0 fblock=407
     407 fblock pos=30 next=408 fdecl=203 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=3 use=1 // ident=deadlock
       204 vdecl pos=19 ident=msg ident_num=3 decl_scope=407 public_p=1 var_num=0

       408 btdef pos=19 op1=0 pc=410 // goto 410 unless 0 is undefined
       409 ldnil pos=25 op1=0 // 0 <- nil
       410 fbend ln=2 pos=15 block=407
     205 fdecl ln=104 pos=9 ident=syncwait ident_num=104 decl_scope=0 fblock=411
     411 fblock pos=30 next=412 fdecl=205 class_p=1 pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 use=3 use=1 // ident=syncwait
       206 vdecl pos=19 ident=msg ident_num=3 decl_scope=411 public_p=1 var_num=0

       412 btdef pos=19 op1=0 pc=414 // goto 414 unless 0 is undefined
       413 ldnil pos=25 op1=0 // 0 <- nil
       414 fbend ln=2 pos=15 block=411
     207 vdecl ln=105 pos=5 ident=argv ident_num=105 decl_scope=0 var_num=0
     208 vdecl pos=11 ident=env ident_num=106 decl_scope=0 var_num=1
     209 vdecl pos=20 ident=version ident_num=107 decl_scope=0 var_num=2
     210 vdecl pos=29 ident=main_thread ident_num=108 decl_scope=0 var_num=3
     211 vdecl pos=42 ident=curr_thread ident_num=109 decl_scope=0 var_num=4
     212 fdecl ln=106 pos=7 ident=anode ident_num=110 decl_scope=0 fblock=415
     415 fblock pos=28 next=416 fdecl=212 class_p=1 simple_p=1 pure_fun_p=1 pars_num=2 min_pars_num=2 scope=0 vars_num=2 tvars_num=0 ext_life_p=1 // ident=anode
       213 vdecl pos=14 ident=name ident_num=111 decl_scope=415 public_p=1 var_num=0
       214 vdecl pos=20 ident=transl ident_num=112 decl_scope=415 public_p=1 var_num=1

       416 fbend pos=20 block=415
     215 fdecl ln=107 pos=7 ident=token ident_num=113 decl_scope=0 fblock=417
     417 fblock pos=20 next=418 fdecl=215 class_p=1 simple_p=1 pure_fun_p=1 pars_num=1 min_pars_num=1 scope=0 vars_num=1 tvars_num=0 ext_life_p=1 // ident=token
       216 vdecl pos=14 ident=code ident_num=114 decl_scope=417 public_p=1 var_num=0

       418 fbend pos=14 block=417
     217 vdecl ln=108 pos=5 ident=nil_anode ident_num=115 decl_scope=0 var_num=5
     218 vdecl ln=109 pos=5 ident=error_anode ident_num=116 decl_scope=0 var_num=6
     219 fdecl ln=110 pos=13 ident=parser ident_num=117 decl_scope=0 fblock=419
     419 fblock ln=111 pos=1 next=520 fdecl=219 class_p=1 scope=0 vars_num=2 tvars_num=1 ext_life_p=1 // ident=parser
       220 vdecl ln=112 pos=7 ident=ambiguous_p ident_num=118 decl_scope=419 public_p=1 var_num=0
       221 vdecl ln=113 pos=12 ident=grammar ident_num=119 decl_scope=419 var_num=1
       222 fdecl ln=115 pos=12 ident=int_earley_parse_grammar ident_num=120 decl_scope=419 fblock=420
       420 fblock pos=37 fdecl=222 fun_p=1 scope=419 vars_num=0 tvars_num=0 // ident=int_earley_parse_grammar

         421 fbend pos=37 block=420
       223 fdecl pos=49 ident=int_earley_set_debug_level ident_num=121 decl_scope=419 fblock=422
       422 fblock pos=76 fdecl=223 fun_p=1 scope=419 vars_num=0 tvars_num=0 // ident=int_earley_set_debug_level

         423 fbend pos=76 block=422
       224 fdecl ln=116 pos=12 ident=int_earley_set_one_parse_flag ident_num=122 decl_scope=419 fblock=424
       424 fblock pos=42 fdecl=224 fun_p=1 scope=419 vars_num=0 tvars_num=0 // ident=int_earley_set_one_parse_flag

         425 fbend pos=42 block=424
       225 fdecl ln=117 pos=12 ident=int_earley_set_lookahead_level ident_num=123 decl_scope=419 fblock=426
       426 fblock pos=43 fdecl=225 fun_p=1 scope=419 vars_num=0 tvars_num=0 // ident=int_earley_set_lookahead_level

         427 fbend pos=43 block=426
       226 fdecl ln=118 pos=12 ident=int_earley_set_cost_flag ident_num=124 decl_scope=419 fblock=428
       428 fblock pos=37 fdecl=226 fun_p=1 scope=419 vars_num=0 tvars_num=0 // ident=int_earley_set_cost_flag

         429 fbend pos=37 block=428
       227 fdecl ln=119 pos=12 ident=int_earley_set_error_recovery_flag ident_num=125 decl_scope=419 fblock=430
       430 fblock pos=47 fdecl=227 fun_p=1 scope=419 vars_num=0 tvars_num=0 // ident=int_earley_set_error_recovery_flag

         431 fbend pos=47 block=430
       228 fdecl ln=120 pos=12 ident=int_earley_set_recovery_match ident_num=126 decl_scope=419 fblock=432
       432 fblock pos=42 fdecl=228 fun_p=1 scope=419 vars_num=0 tvars_num=0 // ident=int_earley_set_recovery_match

         433 fbend pos=42 block=432
       229 fdecl pos=54 ident=int_earley_parse ident_num=127 decl_scope=419 fblock=434
       434 fblock pos=71 fdecl=229 fun_p=1 scope=419 vars_num=0 tvars_num=0 // ident=int_earley_parse

         435 fbend pos=71 block=434
       230 fdecl ln=121 pos=12 ident=int_earley_create_grammar ident_num=128 decl_scope=419 fblock=436
       436 fblock pos=38 fdecl=230 fun_p=1 scope=419 vars_num=0 tvars_num=0 // ident=int_earley_create_grammar

         437 fbend pos=38 block=436
       231 fdecl ln=123 pos=7 ident=set_grammar ident_num=129 decl_scope=419 public_p=1 fblock=438
       438 fblock pos=37 next=439 fdecl=231 fun_p=1 pars_num=2 min_pars_num=2 scope=419 vars_num=2 tvars_num=4 // ident=set_grammar
         232 vdecl pos=20 ident=descr ident_num=130 decl_scope=438 var_num=0
         233 vdecl pos=27 ident=strict_p ident_num=131 decl_scope=438 var_num=1

         439 fun ln=124 pos=5 op1=2 decl=222 // int_earley_parse_grammar
         440 var pos=31 op1=3 decl=221 // grammar
         441 move pos=40 op1=4 op2=1 rhs_decl=233 // 4 (strict_p) <- 1
         442 move pos=50 op1=5 op2=0 rhs_decl=232 // 5 (descr) <- 0
         443 call pos=30 op1=2 op2=3 // call (start=2) (npars=3)
         444 fbend pos=50 block=438
       234 fdecl ln=126 pos=7 ident=set_debug ident_num=132 decl_scope=419 public_p=1 fblock=445
       445 fblock pos=25 next=446 fdecl=234 fun_p=1 pars_num=1 min_pars_num=1 scope=419 vars_num=1 tvars_num=3 // ident=set_debug
         235 vdecl pos=18 ident=level ident_num=133 decl_scope=445 var_num=0

         446 fun ln=127 pos=12 op1=1 decl=223 // int_earley_set_debug_level
         447 var pos=40 op1=2 decl=221 // grammar
         448 move pos=49 op1=3 op2=0 rhs_decl=235 // 3 (level) <- 0
         449 call pos=39 op1=1 op2=2 // call (start=1) (npars=2)
         450 ret pos=5 op1=1
         451 fbend pos=49 block=445
       236 fdecl ln=129 pos=7 ident=set_one_parse ident_num=134 decl_scope=419 public_p=1 fblock=452
       452 fblock pos=28 next=453 fdecl=236 fun_p=1 pars_num=1 min_pars_num=1 scope=419 vars_num=1 tvars_num=3 // ident=set_one_parse
         237 vdecl pos=22 ident=flag ident_num=135 decl_scope=452 var_num=0

         453 fun ln=130 pos=12 op1=1 decl=224 // int_earley_set_one_parse_flag
         454 var pos=43 op1=2 decl=221 // grammar
         455 move pos=52 op1=3 op2=0 rhs_decl=237 // 3 (flag) <- 0
         456 call pos=42 op1=1 op2=2 // call (start=1) (npars=2)
         457 ret pos=5 op1=1
         458 fbend pos=52 block=452
       238 fdecl ln=132 pos=7 ident=set_lookahead ident_num=136 decl_scope=419 public_p=1 fblock=459
       459 fblock pos=28 next=460 fdecl=238 fun_p=1 pars_num=1 min_pars_num=1 scope=419 vars_num=1 tvars_num=3 // ident=set_lookahead
         239 vdecl pos=22 ident=flag ident_num=135 decl_scope=459 var_num=0

         460 fun ln=133 pos=12 op1=1 decl=225 // int_earley_set_lookahead_level
         461 var pos=44 op1=2 decl=221 // grammar
         462 move pos=53 op1=3 op2=0 rhs_decl=239 // 3 (flag) <- 0
         463 call pos=43 op1=1 op2=2 // call (start=1) (npars=2)
         464 ret pos=5 op1=1
         465 fbend pos=53 block=459
       240 fdecl ln=135 pos=7 ident=set_cost ident_num=137 decl_scope=419 public_p=1 fblock=466
       466 fblock pos=23 next=467 fdecl=240 fun_p=1 pars_num=1 min_pars_num=1 scope=419 vars_num=1 tvars_num=3 // ident=set_cost
         241 vdecl pos=17 ident=flag ident_num=135 decl_scope=466 var_num=0

         467 fun ln=136 pos=12 op1=1 decl=226 // int_earley_set_cost_flag
         468 var pos=38 op1=2 decl=221 // grammar
         469 move pos=47 op1=3 op2=0 rhs_decl=241 // 3 (flag) <- 0
         470 call pos=37 op1=1 op2=2 // call (start=1) (npars=2)
         471 ret pos=5 op1=1
         472 fbend pos=47 block=466
       242 fdecl ln=138 pos=7 ident=set_recovery ident_num=138 decl_scope=419 public_p=1 fblock=473
       473 fblock pos=27 next=474 fdecl=242 fun_p=1 pars_num=1 min_pars_num=1 scope=419 vars_num=1 tvars_num=3 // ident=set_recovery
         243 vdecl pos=21 ident=flag ident_num=135 decl_scope=473 var_num=0

         474 fun ln=139 pos=12 op1=1 decl=227 // int_earley_set_error_recovery_flag
         475 var pos=48 op1=2 decl=221 // grammar
         476 move pos=57 op1=3 op2=0 rhs_decl=243 // 3 (flag) <- 0
         477 call pos=47 op1=1 op2=2 // call (start=1) (npars=2)
         478 ret pos=5 op1=1
         479 fbend pos=57 block=473
       244 fdecl ln=141 pos=7 ident=set_recovery_match ident_num=139 decl_scope=419 public_p=1 fblock=480
       480 fblock pos=35 next=481 fdecl=244 fun_p=1 pars_num=1 min_pars_num=1 scope=419 vars_num=1 tvars_num=3 // ident=set_recovery_match
         245 vdecl pos=27 ident=n_toks ident_num=140 decl_scope=480 var_num=0

         481 fun ln=142 pos=12 op1=1 decl=228 // int_earley_set_recovery_match
         482 var pos=43 op1=2 decl=221 // grammar
         483 move pos=52 op1=3 op2=0 rhs_decl=245 // 3 (n_toks) <- 0
         484 call pos=42 op1=1 op2=2 // call (start=1) (npars=2)
         485 ret pos=5 op1=1
         486 fbend pos=52 block=480
       246 fdecl ln=144 pos=7 ident=parse ident_num=141 decl_scope=419 public_p=1 fblock=487
       487 fblock pos=33 next=488 fdecl=246 fun_p=1 pars_num=2 min_pars_num=2 scope=419 vars_num=3 tvars_num=13 // ident=parse
         247 vdecl pos=14 ident=tokens ident_num=142 decl_scope=487 var_num=0
         248 vdecl pos=22 ident=error_fun ident_num=143 decl_scope=487 var_num=1
         249 vdecl ln=145 pos=9 ident=__i ident_num=144 decl_scope=487 var_num=2

         488 ldi ln=146 pos=11 op1=3 op2=1 // 3 <- i1
         489 ldi pos=15 op1=4 op2=2 // 4 <- i2
         490 ldi pos=20 op1=5 op2=3 // 5 <- i3
         491 ldi pos=24 op1=6 op2=4 // 6 <- i4
         492 ldi pos=29 op1=7 op2=5 // 7 <- i5
         493 ldi pos=33 op1=8 op2=6 // 8 <- i6
         494 ldi pos=38 op1=9 op2=7 // 9 <- i7
         495 ldi pos=42 op1=10 op2=8 // 10 <- i8
         496 ldi pos=47 op1=11 op2=9 // 11 <- i9
         497 ldi pos=51 op1=12 op2=10 // 12 <- i10
         498 ldi pos=57 op1=13 op2=11 // 13 <- i11
         499 ldi pos=62 op1=14 op2=12 // 14 <- i12
         500 ldi pos=67 op1=15 op2=13 // 15 <- i13
         501 and pos=65 pos2=62 pos3=67 op1=14 op2=14 op3=15 // 14 <- 14 op 15
         502 xor pos=60 pos2=57 pos3=65 op1=13 op2=13 op3=14 // 13 <- 13 op 14
         503 and pos=54 pos2=51 pos3=60 op1=12 op2=12 op3=13 // 12 <- 12 op 13
         504 xor pos=49 pos2=47 pos3=54 op1=11 op2=11 op3=12 // 11 <- 11 op 12
         505 and pos=44 pos2=42 pos3=49 op1=10 op2=10 op3=11 // 10 <- 10 op 11
         506 xor pos=40 pos2=38 pos3=44 op1=9 op2=9 op3=10 // 9 <- 9 op 10
         507 and pos=35 pos2=33 pos3=40 op1=8 op2=8 op3=9 // 8 <- 8 op 9
         508 xor pos=31 pos2=29 pos3=35 op1=7 op2=7 op3=8 // 7 <- 7 op 8
         509 and pos=26 pos2=24 pos3=31 op1=6 op2=6 op3=7 // 6 <- 6 op 7
         510 xor pos=22 pos2=20 pos3=26 op1=5 op2=5 op3=6 // 5 <- 5 op 6
         511 and pos=17 pos2=15 pos3=22 op1=4 op2=4 op3=5 // 4 <- 4 op 5
         512 xor pos=13 pos2=11 pos3=17 op1=2 op2=3 op3=4 // 2 <- 3 op 4
         513 fun ln=147 pos=12 op1=3 decl=229 // int_earley_parse
         514 var pos=30 op1=4 decl=221 // grammar
         515 move pos=39 op1=5 op2=0 rhs_decl=247 // 5 (tokens) <- 0
         516 move pos=47 op1=6 op2=1 rhs_decl=248 // 6 (error_fun) <- 1
         517 call pos=29 op1=3 op2=3 // call (start=3) (npars=3)
         518 ret pos=5 op1=3
         519 fbend pos=47 block=487

       520 fun ln=150 pos=13 op1=2 decl=230 // int_earley_create_grammar
       521 call pos=39 op1=2 op2=0 // call (start=2) (npars=0)
       522 move pos=11 op1=1 op2=2 rhs_decl=221 // 1 (grammar) <- 2
       523 fbend pos=13 block=419
     250 fdecl ln=153 pos=13 ident=file ident_num=145 decl_scope=0 fblock=524
     524 fblock pos=18 next=525 fdecl=250 class_p=1 scope=0 vars_num=1 tvars_num=2 ext_life_p=1 // ident=file
       251 vdecl ln=154 pos=12 ident=file_ptr ident_num=146 decl_scope=524 var_num=0

       525 class ln=155 pos=9 op1=1 decl=57 // callop
       526 lds ln=156 pos=6 op1=2 str="File can be created only by functions open or popen" // 2 <- string
       527 call pos=5 op1=1 op2=1 // call (start=1) (npars=1)
       528 throw ln=155 pos=3 op1=1
       529 fbend ln=156 pos=59 block=524
     252 vdecl ln=157 pos=5 ident=stdin ident_num=147 decl_scope=0 var_num=7
     253 vdecl ln=158 pos=5 ident=stdout ident_num=148 decl_scope=0 var_num=8
     254 vdecl ln=159 pos=5 ident=stderr ident_num=149 decl_scope=0 var_num=9
     255 fdecl ln=160 pos=5 ident=max ident_num=150 decl_scope=0 fblock=530
     530 fblock pos=9 fdecl=255 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=max

       531 fbend pos=9 block=530
     256 fdecl pos=16 ident=min ident_num=151 decl_scope=0 fblock=532
     532 fblock pos=20 fdecl=256 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=min

       533 fbend pos=20 block=532
     257 fdecl ln=161 pos=5 ident=tolower ident_num=152 decl_scope=0 fblock=534
     534 fblock pos=13 fdecl=257 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=tolower

       535 fbend pos=13 block=534
     258 fdecl pos=20 ident=toupper ident_num=153 decl_scope=0 fblock=536
     536 fblock pos=28 fdecl=258 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=toupper

       537 fbend pos=28 block=536
     259 fdecl pos=35 ident=translit ident_num=154 decl_scope=0 fblock=538
     538 fblock pos=44 fdecl=259 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=translit

       539 fbend pos=44 block=538
     260 fdecl ln=162 pos=5 ident=eltype ident_num=155 decl_scope=0 fblock=540
     540 fblock pos=12 fdecl=260 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=eltype

       541 fbend pos=12 block=540
     261 fdecl ln=163 pos=5 ident=keys ident_num=156 decl_scope=0 fblock=542
     542 fblock pos=10 fdecl=261 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=keys

       543 fbend pos=10 block=542
     262 fdecl ln=164 pos=5 ident=closure ident_num=157 decl_scope=0 fblock=544
     544 fblock pos=13 fdecl=262 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=closure

       545 fbend pos=13 block=544
     263 fdecl pos=20 ident=context ident_num=158 decl_scope=0 fblock=546
     546 fblock pos=28 fdecl=263 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=context

       547 fbend pos=28 block=546
     264 fdecl pos=35 ident=inside ident_num=159 decl_scope=0 fblock=548
     548 fblock pos=42 fdecl=264 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=inside

       549 fbend pos=42 block=548
     265 fdecl pos=49 ident=isa ident_num=160 decl_scope=0 fblock=550
     550 fblock pos=53 fdecl=265 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=isa

       551 fbend pos=53 block=550
     266 fdecl ln=165 pos=5 ident=subv ident_num=161 decl_scope=0 fblock=552
     552 fblock pos=10 fdecl=266 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=subv

       553 fbend pos=10 block=552
     267 fdecl pos=17 ident=cmpv ident_num=162 decl_scope=0 fblock=554
     554 fblock pos=22 fdecl=267 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=cmpv

       555 fbend pos=22 block=554
     268 fdecl pos=29 ident=del ident_num=163 decl_scope=0 fblock=556
     556 fblock pos=33 fdecl=268 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=del

       557 fbend pos=33 block=556
     269 fdecl pos=40 ident=ins ident_num=164 decl_scope=0 fblock=558
     558 fblock pos=44 fdecl=269 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=ins

       559 fbend pos=44 block=558
     270 fdecl pos=52 ident=insv ident_num=165 decl_scope=0 fblock=560
     560 fblock pos=57 fdecl=270 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=insv

       561 fbend pos=57 block=560
     271 fdecl ln=166 pos=5 ident=rev ident_num=166 decl_scope=0 fblock=562
     562 fblock pos=9 fdecl=271 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=rev

       563 fbend pos=9 block=562
     272 fdecl pos=16 ident=sort ident_num=167 decl_scope=0 fblock=564
     564 fblock pos=21 fdecl=272 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=sort

       565 fbend pos=21 block=564
     273 fdecl ln=167 pos=5 ident=sqrt ident_num=168 decl_scope=0 fblock=566
     566 fblock pos=10 fdecl=273 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=sqrt

       567 fbend pos=10 block=566
     274 fdecl pos=17 ident=exp ident_num=169 decl_scope=0 fblock=568
     568 fblock pos=21 fdecl=274 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=exp

       569 fbend pos=21 block=568
     275 fdecl pos=28 ident=log ident_num=170 decl_scope=0 fblock=570
     570 fblock pos=32 fdecl=275 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=log

       571 fbend pos=32 block=570
     276 fdecl pos=39 ident=log10 ident_num=171 decl_scope=0 fblock=572
     572 fblock pos=45 fdecl=276 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=log10

       573 fbend pos=45 block=572
     277 fdecl pos=52 ident=pow ident_num=172 decl_scope=0 fblock=574
     574 fblock pos=56 fdecl=277 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=pow

       575 fbend pos=56 block=574
     278 fdecl ln=168 pos=5 ident=sin ident_num=173 decl_scope=0 fblock=576
     576 fblock pos=9 fdecl=278 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=sin

       577 fbend pos=9 block=576
     279 fdecl pos=16 ident=cos ident_num=174 decl_scope=0 fblock=578
     578 fblock pos=20 fdecl=279 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=cos

       579 fbend pos=20 block=578
     280 fdecl pos=27 ident=atan2 ident_num=175 decl_scope=0 fblock=580
     580 fblock pos=33 fdecl=280 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=atan2

       581 fbend pos=33 block=580
     281 fdecl ln=169 pos=5 ident=match ident_num=176 decl_scope=0 fblock=582
     582 fblock pos=11 fdecl=281 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=match

       583 fbend pos=11 block=582
     282 fdecl pos=18 ident=gmatch ident_num=177 decl_scope=0 fblock=584
     584 fblock pos=25 fdecl=282 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=gmatch

       585 fbend pos=25 block=584
     283 fdecl pos=32 ident=sub ident_num=178 decl_scope=0 fblock=586
     586 fblock pos=36 fdecl=283 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=sub

       587 fbend pos=36 block=586
     284 fdecl pos=43 ident=gsub ident_num=179 decl_scope=0 fblock=588
     588 fblock pos=48 fdecl=284 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=gsub

       589 fbend pos=48 block=588
     285 fdecl ln=170 pos=5 ident=split ident_num=180 decl_scope=0 fblock=590
     590 fblock pos=11 fdecl=285 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=split

       591 fbend pos=11 block=590
     286 vdecl pos=18 ident=split_regex ident_num=181 decl_scope=0 var_num=10
     287 fdecl ln=171 pos=5 ident=srand ident_num=182 decl_scope=0 fblock=592
     592 fblock pos=11 fdecl=287 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=srand

       593 fbend pos=11 block=592
     288 fdecl pos=18 ident=rand ident_num=183 decl_scope=0 fblock=594
     594 fblock pos=23 fdecl=288 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=rand

       595 fbend pos=23 block=594
     289 fdecl ln=172 pos=5 ident=__process_errno__ ident_num=184 decl_scope=0 fblock=596
     596 fblock pos=23 fdecl=289 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=__process_errno__

       597 fbend pos=23 block=596
     290 fdecl ln=173 pos=5 ident=readdir ident_num=185 decl_scope=0 fblock=598
     598 fblock pos=13 fdecl=290 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=readdir

       599 fbend pos=13 block=598
     291 fdecl pos=20 ident=ftype ident_num=186 decl_scope=0 fblock=600
     600 fblock pos=26 fdecl=291 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=ftype

       601 fbend pos=26 block=600
     292 fdecl ln=174 pos=5 ident=fuidn ident_num=187 decl_scope=0 fblock=602
     602 fblock pos=11 fdecl=292 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fuidn

       603 fbend pos=11 block=602
     293 fdecl pos=18 ident=fgrpn ident_num=188 decl_scope=0 fblock=604
     604 fblock pos=24 fdecl=293 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fgrpn

       605 fbend pos=24 block=604
     294 fdecl pos=31 ident=fsize ident_num=189 decl_scope=0 fblock=606
     606 fblock pos=37 fdecl=294 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fsize

       607 fbend pos=37 block=606
     295 fdecl ln=175 pos=5 ident=fatime ident_num=190 decl_scope=0 fblock=608
     608 fblock pos=12 fdecl=295 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fatime

       609 fbend pos=12 block=608
     296 fdecl pos=19 ident=fmtime ident_num=191 decl_scope=0 fblock=610
     610 fblock pos=26 fdecl=296 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fmtime

       611 fbend pos=26 block=610
     297 fdecl pos=33 ident=fctime ident_num=192 decl_scope=0 fblock=612
     612 fblock pos=40 fdecl=297 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fctime

       613 fbend pos=40 block=612
     298 fdecl ln=176 pos=5 ident=fumode ident_num=193 decl_scope=0 fblock=614
     614 fblock pos=12 fdecl=298 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fumode

       615 fbend pos=12 block=614
     299 fdecl pos=19 ident=fgmode ident_num=194 decl_scope=0 fblock=616
     616 fblock pos=26 fdecl=299 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fgmode

       617 fbend pos=26 block=616
     300 fdecl pos=33 ident=fomode ident_num=195 decl_scope=0 fblock=618
     618 fblock pos=40 fdecl=300 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fomode

       619 fbend pos=40 block=618
     301 fdecl ln=177 pos=5 ident=time ident_num=196 decl_scope=0 fblock=620
     620 fblock pos=10 fdecl=301 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=time

       621 fbend pos=10 block=620
     302 fdecl ln=178 pos=5 ident=strtime ident_num=197 decl_scope=0 fblock=622
     622 fblock pos=13 fdecl=302 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=strtime

       623 fbend pos=13 block=622
     303 vdecl pos=20 ident=time_format ident_num=198 decl_scope=0 var_num=11
     304 fdecl ln=179 pos=5 ident=clock ident_num=199 decl_scope=0 fblock=624
     624 fblock pos=11 fdecl=304 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=clock

       625 fbend pos=11 block=624
     305 fdecl ln=180 pos=5 ident=gc ident_num=200 decl_scope=0 fblock=626
     626 fblock pos=8 fdecl=305 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=gc

       627 fbend pos=8 block=626
     306 fdecl ln=181 pos=5 ident=rename ident_num=201 decl_scope=0 fblock=628
     628 fblock pos=12 fdecl=306 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=rename

       629 fbend pos=12 block=628
     307 fdecl pos=19 ident=remove ident_num=202 decl_scope=0 fblock=630
     630 fblock pos=26 fdecl=307 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=remove

       631 fbend pos=26 block=630
     308 fdecl ln=182 pos=5 ident=mkdir ident_num=203 decl_scope=0 fblock=632
     632 fblock pos=11 fdecl=308 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=mkdir

       633 fbend pos=11 block=632
     309 fdecl pos=18 ident=rmdir ident_num=204 decl_scope=0 fblock=634
     634 fblock pos=24 fdecl=309 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=rmdir

       635 fbend pos=24 block=634
     310 fdecl ln=183 pos=5 ident=getcwd ident_num=205 decl_scope=0 fblock=636
     636 fblock pos=12 fdecl=310 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=getcwd

       637 fbend pos=12 block=636
     311 fdecl pos=19 ident=chdir ident_num=206 decl_scope=0 fblock=638
     638 fblock pos=25 fdecl=311 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=chdir

       639 fbend pos=25 block=638
     312 fdecl ln=184 pos=5 ident=chumod ident_num=207 decl_scope=0 fblock=640
     640 fblock pos=12 fdecl=312 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=chumod

       641 fbend pos=12 block=640
     313 fdecl pos=19 ident=chgmod ident_num=208 decl_scope=0 fblock=642
     642 fblock pos=26 fdecl=313 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=chgmod

       643 fbend pos=26 block=642
     314 fdecl pos=33 ident=chomod ident_num=209 decl_scope=0 fblock=644
     644 fblock pos=40 fdecl=314 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=chomod

       645 fbend pos=40 block=644
     315 fdecl pos=47 ident=isatty ident_num=210 decl_scope=0 fblock=646
     646 fblock pos=54 fdecl=315 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=isatty

       647 fbend pos=54 block=646
     316 fdecl ln=185 pos=5 ident=open ident_num=211 decl_scope=0 fblock=648
     648 fblock pos=10 fdecl=316 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=open

       649 fbend pos=10 block=648
     317 fdecl pos=17 ident=close ident_num=212 decl_scope=0 fblock=650
     650 fblock pos=23 fdecl=317 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=close

       651 fbend pos=23 block=650
     318 fdecl pos=30 ident=flush ident_num=213 decl_scope=0 fblock=652
     652 fblock pos=36 fdecl=318 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=flush

       653 fbend pos=36 block=652
     319 fdecl ln=186 pos=5 ident=popen ident_num=214 decl_scope=0 fblock=654
     654 fblock pos=11 fdecl=319 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=popen

       655 fbend pos=11 block=654
     320 fdecl pos=18 ident=pclose ident_num=215 decl_scope=0 fblock=656
     656 fblock pos=25 fdecl=320 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=pclose

       657 fbend pos=25 block=656
     321 fdecl ln=187 pos=5 ident=tell ident_num=216 decl_scope=0 fblock=658
     658 fblock pos=10 fdecl=321 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=tell

       659 fbend pos=10 block=658
     322 fdecl pos=17 ident=seek ident_num=217 decl_scope=0 fblock=660
     660 fblock pos=22 fdecl=322 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=seek

       661 fbend pos=22 block=660
     323 fdecl ln=188 pos=5 ident=put ident_num=218 decl_scope=0 fblock=662
     662 fblock pos=9 fdecl=323 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=put

       663 fbend pos=9 block=662
     324 fdecl pos=16 ident=putln ident_num=219 decl_scope=0 fblock=664
     664 fblock pos=22 fdecl=324 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=putln

       665 fbend pos=22 block=664
     325 fdecl ln=189 pos=5 ident=fput ident_num=220 decl_scope=0 fblock=666
     666 fblock pos=10 fdecl=325 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fput

       667 fbend pos=10 block=666
     326 fdecl pos=17 ident=fputln ident_num=221 decl_scope=0 fblock=668
     668 fblock pos=24 fdecl=326 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fputln

       669 fbend pos=24 block=668
     327 fdecl pos=31 ident=sput ident_num=222 decl_scope=0 fblock=670
     670 fblock pos=36 fdecl=327 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=sput

       671 fbend pos=36 block=670
     328 fdecl pos=43 ident=sputln ident_num=223 decl_scope=0 fblock=672
     672 fblock pos=50 fdecl=328 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=sputln

       673 fbend pos=50 block=672
     329 fdecl ln=190 pos=5 ident=putf ident_num=224 decl_scope=0 fblock=674
     674 fblock pos=10 fdecl=329 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=putf

       675 fbend pos=10 block=674
     330 fdecl pos=17 ident=fputf ident_num=225 decl_scope=0 fblock=676
     676 fblock pos=23 fdecl=330 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fputf

       677 fbend pos=23 block=676
     331 fdecl pos=30 ident=sputf ident_num=226 decl_scope=0 fblock=678
     678 fblock pos=36 fdecl=331 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=sputf

       679 fbend pos=36 block=678
     332 fdecl ln=191 pos=5 ident=print ident_num=227 decl_scope=0 fblock=680
     680 fblock pos=11 fdecl=332 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=print

       681 fbend pos=11 block=680
     333 fdecl pos=18 ident=println ident_num=228 decl_scope=0 fblock=682
     682 fblock pos=26 fdecl=333 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=println

       683 fbend pos=26 block=682
     334 fdecl ln=192 pos=5 ident=fprint ident_num=229 decl_scope=0 fblock=684
     684 fblock pos=12 fdecl=334 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fprint

       685 fbend pos=12 block=684
     335 fdecl pos=19 ident=fprintln ident_num=230 decl_scope=0 fblock=686
     686 fblock pos=28 fdecl=335 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fprintln

       687 fbend pos=28 block=686
     336 fdecl pos=35 ident=sprint ident_num=231 decl_scope=0 fblock=688
     688 fblock pos=42 fdecl=336 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=sprint

       689 fbend pos=42 block=688
     337 fdecl pos=49 ident=sprintln ident_num=232 decl_scope=0 fblock=690
     690 fblock pos=58 fdecl=337 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=sprintln

       691 fbend pos=58 block=690
     338 fdecl ln=193 pos=5 ident=get ident_num=233 decl_scope=0 fblock=692
     692 fblock pos=9 fdecl=338 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=get

       693 fbend pos=9 block=692
     339 fdecl pos=16 ident=getln ident_num=234 decl_scope=0 fblock=694
     694 fblock pos=22 fdecl=339 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=getln

       695 fbend pos=22 block=694
     340 fdecl pos=29 ident=getf ident_num=235 decl_scope=0 fblock=696
     696 fblock pos=34 fdecl=340 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=getf

       697 fbend pos=34 block=696
     341 fdecl ln=194 pos=5 ident=fget ident_num=236 decl_scope=0 fblock=698
     698 fblock pos=10 fdecl=341 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fget

       699 fbend pos=10 block=698
     342 fdecl pos=17 ident=fgetln ident_num=237 decl_scope=0 fblock=700
     700 fblock pos=24 fdecl=342 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fgetln

       701 fbend pos=24 block=700
     343 fdecl pos=31 ident=fgetf ident_num=238 decl_scope=0 fblock=702
     702 fblock pos=37 fdecl=343 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fgetf

       703 fbend pos=37 block=702
     344 fdecl ln=195 pos=5 ident=scan ident_num=239 decl_scope=0 fblock=704
     704 fblock pos=10 fdecl=344 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=scan

       705 fbend pos=10 block=704
     345 fdecl pos=17 ident=scanln ident_num=240 decl_scope=0 fblock=706
     706 fblock pos=24 fdecl=345 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=scanln

       707 fbend pos=24 block=706
     346 fdecl pos=31 ident=fscan ident_num=241 decl_scope=0 fblock=708
     708 fblock pos=37 fdecl=346 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fscan

       709 fbend pos=37 block=708
     347 fdecl pos=44 ident=fscanln ident_num=242 decl_scope=0 fblock=710
     710 fblock pos=52 fdecl=347 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fscanln

       711 fbend pos=52 block=710
     348 fdecl ln=196 pos=5 ident=getpid ident_num=243 decl_scope=0 fblock=712
     712 fblock pos=12 fdecl=348 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=getpid

       713 fbend pos=12 block=712
     349 fdecl pos=19 ident=getun ident_num=244 decl_scope=0 fblock=714
     714 fblock pos=25 fdecl=349 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=getun

       715 fbend pos=25 block=714
     350 fdecl pos=32 ident=geteun ident_num=245 decl_scope=0 fblock=716
     716 fblock pos=39 fdecl=350 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=geteun

       717 fbend pos=39 block=716
     351 fdecl ln=197 pos=5 ident=getgn ident_num=246 decl_scope=0 fblock=718
     718 fblock pos=11 fdecl=351 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=getgn

       719 fbend pos=11 block=718
     352 fdecl pos=18 ident=getegn ident_num=247 decl_scope=0 fblock=720
     720 fblock pos=25 fdecl=352 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=getegn

       721 fbend pos=25 block=720
     353 fdecl pos=32 ident=getgroups ident_num=248 decl_scope=0 fblock=722
     722 fblock pos=42 fdecl=353 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=getgroups

       723 fbend pos=42 block=722
     354 fdecl ln=198 pos=5 ident=system ident_num=249 decl_scope=0 fblock=724
     724 fblock pos=12 fdecl=354 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=system

       725 fbend pos=12 block=724
     355 fdecl ln=199 pos=5 ident=exit ident_num=250 decl_scope=0 fblock=726
     726 fblock pos=10 fdecl=355 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=exit

       727 fbend pos=10 block=726
     356 fdecl ln=200 pos=5 ident=fold ident_num=251 decl_scope=0 fblock=728
     728 fblock pos=10 fdecl=356 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=fold

       729 fbend pos=10 block=728
     357 fdecl pos=17 ident=filter ident_num=252 decl_scope=0 fblock=730
     730 fblock pos=24 fdecl=357 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=filter

       731 fbend pos=24 block=730
     358 fdecl pos=31 ident=map ident_num=253 decl_scope=0 fblock=732
     732 fblock pos=35 fdecl=358 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=map

       733 fbend pos=35 block=732
     359 fdecl ln=201 pos=5 ident=transpose ident_num=254 decl_scope=0 fblock=734
     734 fblock pos=15 fdecl=359 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=transpose

       735 fbend pos=15 block=734
     360 fdecl ln=202 pos=5 ident=__init__ ident_num=255 decl_scope=0 fblock=736
     736 fblock pos=14 fdecl=360 fun_p=1 scope=0 vars_num=0 tvars_num=0 // ident=__init__

       737 fbend pos=14 block=736
//-----------------------test.d---------------------------
     361 vdecl fn="test.d" ln=1 pos=5 ident=SieveSize ident_num=256 decl_scope=0 var_num=12
     362 vdecl pos=16 ident=i ident_num=257 decl_scope=0 var_num=13
     363 vdecl pos=19 ident=prime ident_num=258 decl_scope=0 var_num=14
     364 vdecl pos=26 ident=k ident_num=259 decl_scope=0 var_num=15
     365 vdecl pos=29 ident=count ident_num=260 decl_scope=0 var_num=16
     366 vdecl pos=36 ident=flags ident_num=261 decl_scope=0 var_num=17

//-----------------------<environment>----------------------------
     738 class fn="<environment>" ln=108 pos=17 op1=18 decl=212 // anode
     739 lds pos=24 op1=19 str="$nil" // 19 <- string
     740 ldnil pos=32 op1=20 // 20 <- nil
     741 call pos=23 op1=18 op2=2 // call (start=18) (npars=2)
     742 move pos=15 op1=5 op2=18 rhs_decl=217 // 5 (nil_anode) <- 18
     743 class ln=109 pos=19 op1=18 decl=212 // anode
     744 lds pos=26 op1=19 str="$error" // 19 <- string
     745 ldnil pos=36 op1=20 // 20 <- nil
     746 call pos=25 op1=18 op2=2 // call (start=18) (npars=2)
     747 move pos=17 op1=6 op2=18 rhs_decl=218 // 6 (error_anode) <- 18
     748 lds ln=170 pos=32 op1=10 str="[ \t]+" // 10 <- string
     749 lds ln=178 pos=34 op1=11 str="%a %b %d %H:%M:%S %Z %Y" // 11 <- string
     750 ibcall ln=202 pos=25 cfblock=736 op1=18 op2=0
//-----------------------test.d----------------------------
     751 ldi fn="test.d" ln=2 pos=13 op1=12 op2=8190 // 12 <- i8190
     752 addi ln=4 pos=20 pos2=10 pos3=22 op1=18 op2=12 op3=1 // 18 <- 12 + i1
     753 ldi pos=26 op1=19 op2=0 // 19 <- i0
     754 vec pos=9 op1=17 op2=18 op3=1 // 17 <- [els=18, nparts=1]
     755 ldi ln=5 pos=9 op1=16 op2=0 // 16 <- i0
     756 ldi ln=6 pos=10 next=760 op1=13 op2=0 // 13 <- i0
     757 ldi ln=7 pos=14 op1=18 op2=1 // 18 <- i1
     758 stvt pos=12 pos2=8 op1=17 op2=13 op3=18
     759 btleinc ln=6 pos=15 next=761 op1=13 binc_inc=1 bcmp_op2=12 bcmp_res=18 pc=757 // goto 757 if 18 <- (13 += i1) cmp 12
     760 btle pos=15 op1=13 bcmp_op2=12 bcmp_res=18 pc=757 // goto 757 if 18 <- 13 cmp 12
     761 ldi ln=8 pos=10 next=776 op1=13 op2=0 // 13 <- i0
     762 ind ln=9 pos=12 op1=18 op2=17 op3=13 // 18 <- 17[13]
     763 lconv pos=12 op1=18 op2=18 // 18 <- 18
     764 bf pos=12 op1=18 pc=775 // goto 775 unless 18
     765 add ln=11 pos=17 pos2=15 pos3=19 op1=18 op2=13 op3=13 // 18 <- 13 op 13
     766 addi pos=21 pos2=17 pos3=23 op1=14 op2=18 op3=3 // 14 <- 18 + i3
     767 add ln=12 pos=13 pos2=11 pos3=15 next=772 op1=15 op2=13 op3=14 // 15 <- 13 op 14
     768 btle ln=15 pos=21 next=774 op1=15 bcmp_op2=12 bcmp_res=18 pc=769 // goto 769 if 18 <- 15 cmp 12
     769 ldi ln=17 pos=22 op1=18 op2=0 // 18 <- i0
     770 stvt pos=20 pos2=16 op1=17 op2=15 op3=18
     771 add ln=18 pos=13 pos2=11 op1=15 op2=15 op3=14 // 15 <- 15 op 14
     772 ldi ln=13 pos=13 op1=18 op2=1 // 18 <- i1
     773 bt pos=13 op1=18 pc=768 // goto 768 if 18
     774 addi ln=20 pos=12 pos2=7 op1=16 op2=16 op3=1 // 16 <- 16 + i1
     775 btleinc ln=8 pos=15 next=777 op1=13 binc_inc=1 bcmp_op2=12 bcmp_res=18 pc=762 // goto 762 if 18 <- (13 += i1) cmp 12
     776 btle pos=15 op1=13 bcmp_op2=12 bcmp_res=18 pc=762 // goto 762 if 18 <- 13 cmp 12
     777 move ln=23 pos=10 op1=18 op2=16 rhs_decl=365 // 18 (count) <- 16
     778 ibcall pos=9 cfblock=682 op1=18 op2=1
     779 bend pos=10 block=0
OUTPUT584
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 585.
if test $result = ok -a $start_test_number -le 585; then
	echo test 585: Read/write dump
        cat >$test_file <<'TEST585'
class node (item, left, right) {}

fun BottomUpTree (item, depth) {
  if (depth <= 0) return item;
  var i = item + item;

  depth--;
  return node (item, BottomUpTree (i - 1, depth), BottomUpTree (i, depth));
}

fun ItemCheck (tree) {
  return (type (tree) != obj
	  ? tree : tree.item + ItemCheck (tree.left) - ItemCheck (tree.right));
}

var N = int (#argv < 1 ? 0 : argv [0]);
var mindepth = 4, maxdepth = max (N, mindepth + 2);
var stretchdepth = maxdepth + 1, stretchtree = BottomUpTree (0, stretchdepth);

putf ("stretch tree of depth %d\t  check: %d\n", stretchdepth,
      ItemCheck (stretchtree));

var i, depth, longlivedtree = BottomUpTree (0, maxdepth);

for (depth = mindepth; depth <= maxdepth; depth += 2) {
  var iterations = 1 << (maxdepth - depth + mindepth), check = 0;

  for (i = 0; i < iterations; i++)
    check += (ItemCheck (BottomUpTree (1, depth))
	      + ItemCheck (BottomUpTree (-1, depth)));
  putf ("%d\t  trees of depth %d\t  check: %d\n", iterations*2, depth, check);
}

putf ("long lived tree of depth %d\t  check: %d\n",
      maxdepth, ItemCheck (longlivedtree));
TEST585
        echo '      ' $DINO -d $test_file ">$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
            echo '      ' $DINO -d -i "$stdout" ">$ftemp2"
            if $DINO -d -i "$stdout" > "$ftemp2" 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if $CMP $stdout $ftemp2; then
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
        else
                result=fail
        fi
fi

# Test 586.
if test $result = ok -a $start_test_number -le 586; then
	echo test 586: Different vector binary operations: 1
        cat >$test_file <<'TEST586'
var i, two = 2, three = 3, m = -32;
for (i = 0; i < 2; i++) {
  var v1 = [10:two], v2 = [10:three], v3 = [10:m], v4 = [5:tab [two], 5:tab [three]], t=tab[two];
  println ("+", v1[:] + v2[:]);
  println ("-", v1[:] - v2[:]);
  println ("*", v1[:] * v2[:]);
  println ("<<", v1[:] << v2[:]);
  println (">>", v3[:] >> v2[:]);
  println (">>>", v1[:] >>> v2[:]);
  println ("&", v1[:] & v2[:]);
  println ("^", v1[:] ^ v2[:]);
  println ("|", v1[:] | v2[:]);
  println ("@", v1[:] @ v2[:]);
  println ("in", v1[:] in v4[:]);
  println ("==", v1[:] == v2[:]);
  println ("!=", v1[:] != v2[:]);
  println ("===", v1[:] === v2[:]);
  println ("!==", v1[:] !== v2[:]);
  println ("<=", v1[:] <= v2[:]);
  println ("<", v1[:] < v2[:]);
  println (">=", v1[:] >= v2[:]);
  println (">", v1[:] > v2[:]);
  putln ("--------------------------------");
 
  println ("+", v1[:] + three);
  println ("-", v1[:] - three);
  println ("*", v1[:] * three);
  println ("<<", v1[:] << three);
  println (">>", v3[:] >> three);
  println (">>>", v1[:] >>> three);
  println ("&", v1[:] & three);
  println ("^", v1[:] ^ three);
  println ("|", v1[:] | three);
  println ("@", v1[:] @ three);
  println ("in", v1[:] in t);
  println ("==", v1[:] == three);
  println ("!=", v1[:] != three);
  println ("===", v1[:] === three);
  println ("!==", v1[:] !== three);
  println ("<=", v1[:] <= three);
  println ("<", v1[:] < three);
  println (">=", v1[:] >= three);
  println (">", v1[:] > three);
  putln ("--------------------------------");
  
  println ("+", two + v2[:]);
  println ("-", two - v2[:]);
  println ("*", two * v2[:]);
  println ("<<", two << v2[:]);
  println (">>", m >> v2[:]);
  println (">>>", two >>> v2[:]);
  println ("&", two & v2[:]);
  println ("^", two ^ v2[:]);
  println ("|", two | v2[:]);
  println ("@", two @ v2[:]);
  println ("in", two in v4[:]);
  println ("==", two == v2[:]);
  println ("!=", two != v2[:]);
  println ("===", two === v2[:]);
  println ("!==", two !== v2[:]);
  println ("<=", two <= v2[:]);
  println ("<", two < v2[:]);
  println (">=", two >= v2[:]);
  println (">", two > v2[:]);
  putln ("--------------------------------\n");
  two = 2.0; three = 3.0; m = -32.0;
}
TEST586
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT586' && $CMP $stdout $ftemp2; then
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

OUTPUT586
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 587.
if test $result = ok -a $start_test_number -le 587; then
	echo test 587: Different vector binary operations: 2
        cat >$test_file <<'TEST587'
var i, two = 2, three = 3, m = -32;
for (i = 0; i < 2; i++) {
  var v1 = [10:two, nil], v2 = [10:three], v3 = [10:m, nil];
  var v4 = [5:tab [two], 5:tab [three]], t=tab [two];

  println ("+", v1[0:10] + v2[:]);
  println ("-", v1[0:10] - v2[:]);
  println ("*", v1[0:10] * v2[:]);
  println ("<<", v1[0:10] << v2[:]);
  println (">>", v3[0:10] >> v2[:]);
  println (">>>", v1[0:10] >>> v2[:]);
  println ("&", v1[0:10] & v2[:]);
  println ("^", v1[0:10] ^ v2[:]);
  println ("|", v1[0:10] | v2[:]);
  println ("@", v1[0:10] @ v2[:]);
  println ("in", v1[0:10] in v4[:]);
  println ("==", v1[0:10] == v2[:]);
  println ("!=", v1[0:10] != v2[:]);
  println ("===", v1[0:10] === v2[:]);
  println ("!==", v1[0:10] !== v2[:]);
  println ("<", v1[0:10] < v2[:]);
  println (">", v1[0:10] > v2[:]);
  println ("<=", v1[0:10] <= v2[:]);
  println (">=", v1[0:10] >= v2[:]);
  putln ("--------------------------------");
  
  println ("+", v1[0:10] + 3);
  println ("-", v1[0:10] - 3);
  println ("*", v1[0:10] * 3);
  println ("<<", v1[0:10] << 3);
  println (">>", v3[0:10] >> 3);
  println (">>>", v1[0:10] >>> 3);
  println ("&", v1[0:10] & 3);
  println ("^", v1[0:10] ^ 3);
  println ("|", v1[0:10] | 3);
  println ("@", v1[0:10] @ 3);
  println ("in", v1[0:10] in t);
  println ("==", v1[0:10] == 3);
  println ("!=", v1[0:10] != 3);
  println ("===", v1[0:10] === 3);
  println ("!==", v1[0:10] !== 3);
  println ("<", v1[0:10] < 3);
  println (">", v1[0:10] > 3);
  println ("<=", v1[0:10] <= 3);
  println (">=", v1[0:10] >= 3);
  putln ("--------------------------------\n");
  two = 2.0; three = 3.0; m = -32.0;
}
TEST587
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT587' && $CMP $stdout $ftemp2; then
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

OUTPUT587
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 588.
if test $result = ok -a $start_test_number -le 588; then
	echo test 588: Different vector binary operations: 3
        cat >$test_file <<'TEST588'
var i, two = 2, three = 3, m = -32;
for (i = 0; i < 2; i++) {
  var v1 = [10:two, nil], v2 = [10:three], v3 = [10:m, nil];
  var v4 = [5:tab [two], 5:tab [three]], t=tab [two];

  println ("+", v1[0:10] + v2[:]);
  println ("-", v1[0:10] - v2[:]);
  println ("*", v1[0:10] * v2[:]);
  println ("<<", v1[0:10] << v2[:]);
  println (">>", v3[0:10] >> v2[:]);
  println (">>>", v1[0:10] >>> v2[:]);
  println ("&", v1[0:10] & v2[:]);
  println ("^", v1[0:10] ^ v2[:]);
  println ("|", v1[0:10] | v2[:]);
  println ("@", v1[0:10] @ v2[:]);
  println ("in", v1[0:10] in v4[:]);
  println ("==", v1[0:10] == v2[:]);
  println ("!=", v1[0:10] != v2[:]);
  println ("===", v1[0:10] === v2[:]);
  println ("!==", v1[0:10] !== v2[:]);
  println ("<", v1[0:10] < v2[:]);
  println (">", v1[0:10] > v2[:]);
  println ("<=", v1[0:10] <= v2[:]);
  println (">=", v1[0:10] >= v2[:]);
  putln ("--------------------------------");
  
  println ("+", v1[0:10] + three);
  println ("-", v1[0:10] - three);
  println ("*", v1[0:10] * three);
  println ("<<", v1[0:10] << three);
  println (">>", v3[0:10] >> three);
  println (">>>", v1[0:10] >>> three);
  println ("&", v1[0:10] & three);
  println ("^", v1[0:10] ^ three);
  println ("|", v1[0:10] | three);
  println ("@", v1[0:10] @ three);
  println ("in", v1[0:10] in t);
  println ("==", v1[0:10] == three);
  println ("!=", v1[0:10] != three);
  println ("===", v1[0:10] === three);
  println ("!==", v1[0:10] !== three);
  println ("<", v1[0:10] < three);
  println (">", v1[0:10] > three);
  println ("<=", v1[0:10] <= three);
  println (">=", v1[0:10] >= three);
  putln ("--------------------------------\n");
  two = 2.0; three = 3.0; m = -32.0;
}
TEST588
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT588' && $CMP $stdout $ftemp2; then
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

OUTPUT588
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 589.
if test $result = ok -a $start_test_number -le 589; then
	echo test 589: Different vector binary operations: 4
        cat >$test_file <<'TEST589'
var i, two = 2, three = 3, m = -32;
for (i = 0; i < 2; i++) {
  var v1 = [10:two, nil], v2 = [10:three, 0.5], v3 = [10:m, nil];
  var v4 = [5:tab [two], 5:tab [three]], t=tab [two];

  println ("+", v1[0:10] + v2[:10]);
  println ("-", v1[0:10] - v2[:10]);
  println ("*", v1[0:10] * v2[:10]);
  println ("<<", v1[0:10] << v2[:10]);
  println (">>", v3[0:10] >> v2[:10]);
  println (">>>", v1[0:10] >>> v2[:10]);
  println ("&", v1[0:10] & v2[:10]);
  println ("^", v1[0:10] ^ v2[:10]);
  println ("|", v1[0:10] | v2[:10]);
  println ("@", v1[0:10] @ v2[:10]);
  println ("in", v1[0:10] in v4[:10]);
  println ("==", v1[0:10] == v2[:10]);
  println ("!=", v1[0:10] != v2[:10]);
  println ("===", v1[0:10] === v2[:10]);
  println ("!==", v1[0:10] !== v2[:10]);
  println ("<", v1[0:10] < v2[:10]);
  println (">", v1[0:10] > v2[:10]);
  println ("<=", v1[0:10] <= v2[:10]);
  println (">=", v1[0:10] >= v2[:10]);
  putln ("--------------------------------");

  println ("+", two + v2[:10]);
  println ("-", two - v2[:10]);
  println ("*", two * v2[:10]);
  println ("<<", two << v2[:10]);
  println (">>", m >> v2[:10]);
  println (">>>", two >>> v2[:10]);
  println ("&", two & v2[:10]);
  println ("^", two ^ v2[:10]);
  println ("|", two | v2[:10]);
  println ("@", two @ v2[:10]);
  println ("in", three in v4[0:10]);
  println ("==", two == v2[:10]);
  println ("!=", two != v2[:10]);
  println ("===", two === v2[:10]);
  println ("!==", two !== v2[:10]);
  println ("<", two < v2[:10]);
  println (">", two > v2[:10]);
  println ("<=", two <= v2[:10]);
  println (">=", two >= v2[:10]);
  putln ("--------------------------------\n");
  two = 2.0; three = 3.0; m = -32.0;
}
TEST589
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT589' && $CMP $stdout $ftemp2; then
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[0, 0, 0, 0, 0, 1, 1, 1, 1, 1]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"+"[5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
"-"[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
"*"[6, 6, 6, 6, 6, 6, 6, 6, 6, 6]
"<<"[16, 16, 16, 16, 16, 16, 16, 16, 16, 16]
">>"[-4, -4, -4, -4, -4, -4, -4, -4, -4, -4]
">>>"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"&"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"^"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"|"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
"@"["23", "23", "23", "23", "23", "23", "23", "23", "23", "23"]
"in"[0, 0, 0, 0, 0, 1, 1, 1, 1, 1]
"=="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"==="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"!=="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"<"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"<="[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
">="[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

OUTPUT589
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 590.
if test $result = ok -a $start_test_number -le 590; then
	echo test 590: Different vector binary operations: 5
        cat >$test_file <<'TEST590'
var i, two = 2, four = 4;
for (i = 0; i < 2; i++) {
  var v1 = [10:two], v2 = [10:four];
  println ("/", v1[:] / v2[:]);
  println ("%", v1[:] % v2[:]);
  println ("/", v2[:] / v1[:]);
  println ("%", v2[:] % v1[:]);
  putln ("--------------------------------");
 
  println ("/", v1[:] / four);
  println ("%", v1[:] % four);
  println ("/", v2[:] / two);
  println ("%", v2[:] % two);
  putln ("--------------------------------");
  
  println ("/", two / v2[:]);
  println ("%", two % v2[:]);
  println ("/", four / v2[:]);
  println ("%", four % v2[:]);
  putln ("--------------------------------");

  v1 = [10:two, nil]; v2 = [10:four];
  println ("/", v1[0:10] / v2[:]);
  println ("%", v1[0:10] % v2[:]);
  println ("/", v2[:] / v1[0:10]);
  println ("%", v2[:] % v1[0:10]);
  putln ("--------------------------------");
  
  println ("/", v1[0:10] / 4);
  println ("%", v1[0:10] % 4);
  println ("/", 4 / v1[0:10]);
  println ("%", 4 % v1[0:10]);
  putln ("--------------------------------");

  v1 = [10:two, nil]; v2 = [10:four, 0.5];
  println ("/", v1[0:10] / v2[:10]);
  println ("%", v1[0:10] % v2[:10]);
  println ("/", four / v2[:10]);
  println ("%", four % v2[:10]);
  putln ("--------------------------------\n");

  two = 2.0; four = 4.0;
}
TEST590
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT590' && $CMP $stdout $ftemp2; then
"/"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

"/"[0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------
"/"[0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
"%"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"/"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
"%"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------------------

OUTPUT590
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 591.
if test $result = ok -a $start_test_number -le 591; then
	echo test 591: Different vector fold operations
        cat >$test_file <<'TEST591'
var i, v1 = [10:2];
for (i = 0; i < 4; i++) {
  println (".+", .+v1[0:10]);
  println (".*", .*v1[0:10]);
  println (".&", .&v1[0:10]);
  println (".^", .^v1[0:10]);
  println (".|", .|v1[0:10]);
  putln ("--------------------------------");

  if (i == 0)
    v1 = [10:2, nil];
  else if (i == 1)
    v1 = [10:2.5, nil];
  else
    v1 = [5:2.0, 5:2, nil];
}

v1 = [];
println (".+", .+v1[:]);
println (".*", .*v1[:]);
println (".&", .&v1[:]);
println (".^", .^v1[:]);
println (".|", .|v1[:]);
TEST591
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT591' && $CMP $stdout $ftemp2; then
".+"20
".*"1024
".&"2
".^"0
".|"2
--------------------------------
".+"20
".*"1024
".&"2
".^"0
".|"2
--------------------------------
".+"25
".*"9536.74
".&"2
".^"0
".|"2
--------------------------------
".+"20
".*"1024
".&"2
".^"0
".|"2
--------------------------------
".+"0
".*"1
".&"-1
".^"0
".|"0
OUTPUT591
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 592.
if test $result = ok -a $start_test_number -le 592; then
	echo test 592: Different vector unary operations
        cat >$test_file <<'TEST592'
var i, two = 2;
for (i = 0; i < 2; i++) {
  var v1 = [10:two];
  println ("+", +v1[:]);
  println ("-", -v1[:]);
  println ("!", !v1[:]);
  println ("~", ~v1[:]);
  println ("#", #v1[:]);
  putln ("--------------------------------");
  two = 2.3;
}
TEST592
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT592' && $CMP $stdout $ftemp2; then
"+"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"-"[-2, -2, -2, -2, -2, -2, -2, -2, -2, -2]
"!"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"~"[-3, -3, -3, -3, -3, -3, -3, -3, -3, -3]
"#"[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
--------------------------------
"+"[2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3]
"-"[-2.3, -2.3, -2.3, -2.3, -2.3, -2.3, -2.3, -2.3, -2.3, -2.3]
"!"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
"~"[-3, -3, -3, -3, -3, -3, -3, -3, -3, -3]
"#"[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
--------------------------------
OUTPUT592
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 593.
if test $result = ok -a $start_test_number -le 593; then
	echo test 593: Different vector unary operations 2
        cat >$test_file <<'TEST593'
var i, v = [4:[5:1]];
for (i = 1; i < #v; i++) put (v[i-1] === v[i]);
putln ();
v[:] = new v[:];
println (v);
for (i = 1; i < #v; i++) put (v[i-1] === v[i]);
putln ();
println (v);
TEST593
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT593' && $CMP $stdout $ftemp2; then
111
[[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]
000
[[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]
OUTPUT593
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 594.
if test $result = ok -a $start_test_number -le 594; then
	echo test 594: Different vector unary operations 3
        cat >$test_file <<'TEST594'
var i, two = 2;
for (i = 0; i < 2; i++) {
  var v1 = [10:two];
  println ("type()", type (v1[:]));
  println ("char()", char (v1[:]));
  println ("int()", int (v1[:]));
  println ("float()", float (v1[:]));
  putln ("--------------------------------");
  two = 2.3;
}
TEST594
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT594' && $CMP $stdout $ftemp2; then
"type()"[int, int, int, int, int, int, int, int, int, int]
"char()""\2\2\2\2\2\2\2\2\2\2"
"int()"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"float()"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
--------------------------------
"type()"[float, float, float, float, float, float, float, float, float, float]
"char()""\2\2\2\2\2\2\2\2\2\2"
"int()"[2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
"float()"[2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3, 2.3]
--------------------------------
OUTPUT594
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 595.
if test $result = ok -a $start_test_number -le 595; then
	echo test 595: Eltype of vector of fun and class
        cat >$test_file <<'TEST595'
fun f {}
class c {}
val v = [f, c];
println (eltype (v));

val v = [c, c];
println (eltype (v));
TEST595
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT595' && $CMP $stdout $ftemp2; then
nil
class
OUTPUT595
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 596
if test $result = ok -a $start_test_number -le 596; then
	echo test 596: Different vector unary operations 5
        cat >$test_file <<'TEST596'
var i, v = [4:[5:1]];
v[:] = final v[:];
println (v);
v[0][0] = 2;
println (v);
TEST596
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT596' && $CMP $stderr $ftemp2; then
test.d:4:5: run time error - attempt to modify immutable vector
OUTPUT596
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT596-2' && $CMP $stdout $ftemp2; then
[[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]
OUTPUT596-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 597.
if test $result = ok -a $start_test_number -le 597; then
	echo test 597: A bug with extended life block
        cat >$test_file <<'TEST597'
var o = nil;
thread t {class tc {}; o = tc ();}
fun f {class fc {};return fc();}
fun main {
  var one, two;
  one = context (f()); t (); wait (o != nil); two = context (o);
  println (one, two);
}
main ();
TEST597
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT597' && $CMP $ftemp $ftemp2; then
stack f()stack t()
OUTPUT597
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 598.
if test $result = ok -a $start_test_number -le 598; then
	echo test 598: Different vector unary operations 6
        cat >$test_file <<'TEST598'
var i, two = 2, v1 = [5:"ab"];
for (i = 0; i < 2; i++) {
  println ("vec()", vec (v1[:]));
  println ("tab()", tab (v1[:]));
  putln ("--------------------------------");
  v1 = [tab [1:2], tab [3:4], tab [5:6]];
}
TEST598
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT598' && $CMP $stdout $ftemp2; then
"vec()"["ab", "ab", "ab", "ab", "ab"]
"tab()"[tab [0:'a', 1:'b'], tab [0:'a', 1:'b'], tab [0:'a', 1:'b'], tab [0:'a', 1:'b'], tab [0:'a', 1:'b']]
--------------------------------
"vec()"[[1, 2], [3, 4], [5, 6]]
"tab()"[tab [1:2], tab [3:4], tab [5:6]]
--------------------------------
OUTPUT598
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 599.
if test $result = ok -a $start_test_number -le 599; then
	echo test 599: Different format vector operations
        cat >$test_file <<'TEST599'
var v1=[1.2, 2.3, 3.4, 4.5], v2=["%.3e", "%.5e", "%g", "%+g"];
println (vec (v1[:], "%g"));
println (vec (4.5, v2[:]));
println (vec (v1[:], v2[:]));
TEST599
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT599' && $CMP $stdout $ftemp2; then
["1.2", "2.3", "3.4", "4.5"]
["4.500e+00", "4.50000e+00", "4.5", "+4.5"]
["1.200e+00", "2.30000e+00", "3.4", "+4.5"]
OUTPUT599
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 600.
if test $result = ok -a $start_test_number -le 600; then
	echo test 600: Different slice assignments
        cat >$test_file <<'TEST600'
var m = new [5:[7:1]];
m[::2][::3]=5;
println (m);
TEST600
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT600' && $CMP $stdout $ftemp2; then
[[5, 1, 1, 5, 1, 1, 5], [5, 1, 1, 5, 1, 1, 5], [5, 1, 1, 5, 1, 1, 5], [5, 1, 1, 5, 1, 1, 5], [5, 1, 1, 5, 1, 1, 5]]
OUTPUT600
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 601.
if test $result = ok -a $start_test_number -le 601; then
	echo test 601: Different slice assignments 2
        cat >$test_file <<'TEST601'
var i,v=[20:0], r=[30:0];
for (i = 0; i < #r; i++)r[i]=i;
v[5:15:2] = r[1:6];
println (v);
v=[20:0.5];
v[5:15:2] = r[1:6];
println (v);
TEST601
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT601' && $CMP $stdout $ftemp2; then
[0, 0, 0, 0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0]
[0.5, 0.5, 0.5, 0.5, 0.5, 1, 0.5, 2, 0.5, 3, 0.5, 4, 0.5, 5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
OUTPUT601
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 602.
if test $result = ok -a $start_test_number -le 602; then
	echo test 602: Different slice assignments 3
        cat >$test_file <<'TEST602'
var i, r=[30:0];
for (i = 0; i < #r; i++)r[i]=i;
r[:] = r[::-1];
println (r);
TEST602
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT602' && $CMP $stdout $ftemp2; then
[29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
OUTPUT602
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 603.
if test $result = ok -a $start_test_number -le 603; then
	echo test 603: Different slice assignments 4
        cat >$test_file <<'TEST603'
var r = 5, perm1=[10:0], i, t;
for (i = 0; i < 10; i++) perm1[i] = i;

println (r, perm1);
t = perm1[0]; perm1[0:r-1] = perm1[1:r]; perm1[r-1] = t;
println (perm1);
TEST603
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT603' && $CMP $stdout $ftemp2; then
5[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[1, 2, 3, 4, 0, 5, 6, 7, 8, 9]
OUTPUT603
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 604
if test $result = ok -a $start_test_number -le 604; then
	echo test 604: Wrong slice assignment
        cat >$test_file <<'TEST604'
var i, r=[30:0];
for (i = 0; i < #r; i++)r[i]=i;
r[1:5] = r[2:5];
println (r);
TEST604
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT604' && $CMP $stderr $ftemp2; then
test.d:3:2: run time error - different lengths of slices 4 vs 3 (dimension = 1)
OUTPUT604
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT604-2' && $CMP $stdout $ftemp2; then
OUTPUT604-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 605.
if test $result = ok -a $start_test_number -le 605; then
	echo test 605: Anonymous func/class/thread
        cat >$test_file <<'TEST605'
putln (fun (a,b) {return a < b ? a : b;} (3, 5));
fun (a,b) {putln (a > b ? a : b);} (3, 5);
var o = class (c) {};
putln (o (42).c);
thread {put ("Wait... "); wait (o==nil); putln ("Continue");} ();
o = nil;
TEST605
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT605' && $CMP $stdout $ftemp2; then
3
5
42
Wait... Continue
OUTPUT605
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 606.
if test $result = ok -a $start_test_number -le 606; then
	echo test 606: Fold function
        cat >$test_file <<'TEST606'
var v = [1,2,3,4];
println (fold (fun (a, b) {return a + b;}, v[:], 0));
println (fold (fun (a, b) {return a * b;}, v[:], 1));
var f = fold;
println (f (fun (a, b) {return a * b;}, v[:], 1));
TEST606
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT606' && $CMP $stdout $ftemp2; then
10
24
24
OUTPUT606
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 607
if test $result = ok -a $start_test_number -le 607; then
	echo test 607: Wrong fold argument
        cat >$test_file <<'TEST607'
var v = [1,2,3,4];
println (fold (fun (a, b) {return a + b;}, nil, 0));
TEST607
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT607' && $CMP $stderr $ftemp2; then
test.d:2:15: run time error - invalid parameter type of `fold'
OUTPUT607
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT607-2' && $CMP $stdout $ftemp2; then
OUTPUT607-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 608.
if test $result = ok -a $start_test_number -le 608; then
	echo test 608: Filter function
        cat >$test_file <<'TEST608'
var i, v = [0, 1, -2, 3, -4];
println (filter (fun (a) {return a > 0;}, v));
v = [[0, 1, -2, 3, -4], [5, -6, 7, -8, 9]];
println (filter (fun (a) {return a > 0;}, v, 2));
for (i = 0; i < 1000; i++) {
  v = [[0, 1.1, -2, 3, -4], [5, -6.1, 7, -8, 9]];
  v = filter (fun (a) {if (i % 100) gc ();return a > 0;}, v, 2);
}
println (v);
TEST608
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT608' && $CMP $stdout $ftemp2; then
[1, 3]
[[1, 3], [5, 7, 9]]
[[1.1, 3], [5, 7, 9]]
OUTPUT608
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 609
if test $result = ok -a $start_test_number -le 609; then
	echo test 609: Wrong filter argument
        cat >$test_file <<'TEST609'
var v = [0, 1, -2, 3, -4];
println (filter (fun (a) {return a > 0;}, nil));
TEST609
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT609' && $CMP $stderr $ftemp2; then
test.d:2:17: run time error - invalid parameter type of `filter'
OUTPUT609
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT609-2' && $CMP $stdout $ftemp2; then
OUTPUT609-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 610
if test $result = ok -a $start_test_number -le 610; then
	echo test 610: Another wrong filter argument
        cat >$test_file <<'TEST610'
var v = [[0, 1, -2, 3, -4], [5, -6, 7, -8, 9]];
println (filter (fun (a) {return a > 0;}, v));
TEST610
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT610' && $CMP $stderr $ftemp2; then
test.d:2:36: run time error - invalid types of operands of operator ">"
OUTPUT610
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT610-2' && $CMP $stdout $ftemp2; then
OUTPUT610-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 611
if test $result = ok -a $start_test_number -le 611; then
	echo test 611: Wrong filter function result
        cat >$test_file <<'TEST611'
var v = [[0, 1, -2, 3, -4], [5, -6, 7, -8, 9]];
println (filter (fun (a) {return nil;}, v, 2));
TEST611
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT611' && $CMP $stderr $ftemp2; then
test.d:2:17: run time error - invalid function result used by function `filter'
OUTPUT611
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT611-2' && $CMP $stdout $ftemp2; then
OUTPUT611-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 612.
if test $result = ok -a $start_test_number -le 612; then
	echo test 612: Map function
        cat >$test_file <<'TEST612'
var i, v = [[0, 1, -2, 3, -4], [5, -6, 7, -8, 9]];
println (map (fun (a) {return a < 0 ? nil : a;}, v, 2));
for (i = 0; i < 1000; i++) {
  v = [[0, 1.1, -2, 3, -4], [5, -6.1, 7, -8, 9]];
  v = map (fun (a) {if (i % 100) gc ();return a < 0 ? 0 : a;}, v, 2);
}
println (v);
TEST612
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT612' && $CMP $stdout $ftemp2; then
[[0, 1, nil, 3, nil], [5, nil, 7, nil, 9]]
[[0, 1.1, 0, 3, 0], [5, 0, 7, 0, 9]]
OUTPUT612
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 613
if test $result = ok -a $start_test_number -le 613; then
	echo test 613: Wrong map argument
        cat >$test_file <<'TEST613'
var v = [0, 1, -2, 3, -4];
println (map (fun (a) {return a > 0;}, nil));
TEST613
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT613' && $CMP $stderr $ftemp2; then
test.d:2:14: run time error - invalid parameter type of `map'
OUTPUT613
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT613-2' && $CMP $stdout $ftemp2; then
OUTPUT613-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 614
if test $result = ok -a $start_test_number -le 614; then
	echo test 614: Another wrong map argument
        cat >$test_file <<'TEST614'
var v = [[0, 1, -2, 3, -4], [5, -6, 7, -8, 9]];
println (map (fun (a) {return a > 0;}, v));
TEST614
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT614' && $CMP $stderr $ftemp2; then
test.d:2:33: run time error - invalid types of operands of operator ">"
OUTPUT614
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT614-2' && $CMP $stdout $ftemp2; then
OUTPUT614-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 615.
if test $result = ok -a $start_test_number -le 615; then
	echo test 615: addi generation
        cat >$test_file <<'TEST615'
for (var i = 0; i < 1000; i--);
TEST615
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep addi $stdout
                if fgrep addi $stdout > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 616.
if test $result = ok -a $start_test_number -le 616; then
	echo test 616: addi generation
        cat >$test_file <<'TEST616'
var i = 0;
i++;
i+=2;
i=i+3;
i=4+i;
TEST616
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' expr '`' fgrep addi $stdout '|wc -l`' = 4
                if expr `fgrep " addi" $stdout|wc -l` = 4 > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 617.
if test $result = ok -a $start_test_number -le 617; then
	echo test 617: btcmp generation
        cat >$test_file <<'TEST617'
var i = 0, k = 0;
for (;i!=k;);
for (;i==k;);
for (;i<=k;);
for (;i<k;);
for (;i>=k;);
for (;i>k;);
TEST617
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep btne $stdout '&&' fgrep bteq $stdout '&&' fgrep btle $stdout '&&' fgrep btlt $stdout '&&' fgrep btge $stdout '&&' fgrep btgt $stdout
                if (fgrep btne $stdout && fgrep bteq $stdout && fgrep btle $stdout && fgrep btlt $stdout && fgrep btge $stdout && fgrep btgt $stdout) > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 618.
if test $result = ok -a $start_test_number -le 618; then
	echo test 618: addi with neg. constant generation
        cat >$test_file <<'TEST618'
var i = 0;
i--;
i-=2;
i=i-3;
i=4-i;
TEST618
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' expr '`fgrep addi' $stdout '|wc -l`' = 3
                if expr `fgrep " addi" $stdout|wc -l` = 3 > /dev/null ; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 619.
if test $result = ok -a $start_test_number -le 619; then
	echo test 619: no addi generation for slices
        cat >$test_file <<'TEST619'
var i = [10:0];
i[:]++;
i[:]=i[:]+1;
TEST619
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep -v addi $stdout
                if fgrep -v addi $stdout > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 620.
if test $result = ok -a $start_test_number -le 620; then
	echo test 620: btcmpinc generation
        cat >$test_file <<'TEST620'
var i = 0, k = 10, n= 1;
for (;i!=k;i++)n++;
for (;i==k;i++)n++;
for (;i<=k;i++)n++;
for (;i<k;i++)n++;
for (;i>=k;i++)n++;
for (;i>k;i++)n++;
TEST620
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep btneinc $stdout '&&' fgrep bteqinc $stdout '&&' fgrep btleinc $stdout '&&' fgrep btltinc $stdout '&&' fgrep btgeinc $stdout '&&' fgrep btgtinc $stdout
                if (fgrep btneinc $stdout && fgrep bteqinc $stdout && fgrep btleinc $stdout && fgrep btltinc $stdout && fgrep btgeinc $stdout && fgrep btgtinc $stdout) > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 621.
if test $result = ok -a $start_test_number -le 621; then
	echo test 621: bfcmp generation
        cat >$test_file <<'TEST621'
var i=1, b=5, n=0;
if (i < b) n++;else n--;
TEST621
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep btge $stdout
                if fgrep btge $stdout > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 622.
if test $result = ok -a $start_test_number -le 622; then
	echo test 622: Call tail optimization
        cat >$test_file <<'TEST622'
fun even;
fun odd (n) {
  if (n == 0) return 0;
  return even (n - 1);
}

fun even (n) {
  if (n == 0) return 1;
  return odd (n - 1);
}

putln ("odd  (10000000) = ", odd (10000000));
putln ("even (10000000) = ", even (10000000));
TEST622
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT622' && $CMP $stdout $ftemp2; then
odd  (10000000) = 0
even (10000000) = 1
OUTPUT622
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 623.
if test $result = ok -a $start_test_number -le 623; then
	echo test 623: Immediate call generation
        cat >$test_file <<'TEST623'
fun f {
  fun h {
  }
  fun g {
     h ();
  }
  g ();
}
fun e {
  f();
}
TEST623
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep  $stdout itcall '&&' fgrep citcall $stdout '&&' fgrep titcall $stdout
                if (fgrep itcall $stdout && fgrep citcall $stdout && fgrep titcall $stdout) > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 624.
if test $result = ok -a $start_test_number -le 624; then
	echo test 624: Branch and compare with immediate generation
        cat >$test_file <<'TEST624'
var i = 0;
if (i < 1) i++;
if (i > 1) i++;
if (i <= 1) i++;
if (i >= 1) i++;
if (i == 1) i++;
if (i != 1) i++;
if (2 < i) i++;
if (2 > i) i++;
if (2 <= i) i++;
if (2 >= i) i++;
if (2 == i) i++;
if (2 != i) i++;
TEST624
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' expr '`' egrep "'btgei|btlei|btgti|btlti|btnei|bteqi'" $stdout '| wc -l`' = 12
                if expr `egrep 'btgei|btlei|btgti|btlti|btnei|bteqi' $stdout | wc -l` = 12 > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 625.
if test $result = ok -a $start_test_number -le 625; then
	echo test 625: Compare with immediate generation
        cat >$test_file <<'TEST625'
var i = 0;
i = i < 1;
i = i > 1;
i = i <= 1;
i = i >= 1;
i = i == 1;
i = i != 1;
i = 2 < i;
i = 2 > i;
i = 2 <= i;
i = 2 >= i;
i = 2 == i;
i = 2 != i;
TEST625
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' expr '`' egrep "'gei|lei|gti|lti|nei|eqi'" $stdout '| wc -l`' = 12
                if expr `egrep 'gei|lei|gti|lti|nei|eqi' $stdout | wc -l` = 12 > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 626
if test $result = ok -a $start_test_number -le 626; then
	echo test 626: Too few actuals
        cat >$test_file <<'TEST626'
fun f (a, b) {
}

f(1);
TEST626
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT626' && $CMP $stderr $ftemp2; then
test.d:4:2: run time error - too few actual parameters for `f'
OUTPUT626
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT626-2' && $CMP $stdout $ftemp2; then
OUTPUT626-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 627
if test $result = ok -a $start_test_number -le 627; then
	echo test 627: Too many actuals
        cat >$test_file <<'TEST627'
fun f {
}

f(1);
TEST627
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT627' && $CMP $stderr $ftemp2; then
test.d:4:2: run time error - too many actual parameters for `f'
OUTPUT627
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT627-2' && $CMP $stdout $ftemp2; then
OUTPUT627-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 628
if test $result = ok -a $start_test_number -le 628; then
	echo test 628: Too few actuals when ... is present
        cat >$test_file <<'TEST628'
fun f (a, ...) {
}

f ();
TEST628
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT628' && $CMP $stderr $ftemp2; then
test.d:4:3: run time error - too few actual parameters for `f'
OUTPUT628
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT628-2' && $CMP $stdout $ftemp2; then
OUTPUT628-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 629
if test $result = ok -a $start_test_number -le 629; then
	echo test 629: Undefined comparison values
        cat >$test_file <<'TEST629'
var i;
println (i == 10);
TEST629
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT629' && $CMP $stderr $ftemp2; then
test.d:2:12: run time error - invalid types of operands of operator "==" or "!="
OUTPUT629
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT629-2' && $CMP $stdout $ftemp2; then
OUTPUT629-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 630
if test $result = ok -a $start_test_number -le 630; then
	echo test 630: Undefined identity values
        cat >$test_file <<'TEST630'
var i;
println (i !== 10);
TEST630
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT630' && $CMP $stderr $ftemp2; then
test.d:2:12: run time error - invalid types of operands of operator "===" or "!=="
OUTPUT630
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT630-2' && $CMP $stdout $ftemp2; then
OUTPUT630-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 631
if test $result = ok -a $start_test_number -le 631; then
	echo test 631: Undefined local values
        cat >$test_file <<'TEST631'
var i, j = i;
TEST631
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT631' && $CMP $stderr $ftemp2; then
test.d:1:10: run time error - undefined `i' value access
OUTPUT631
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT631-2' && $CMP $stdout $ftemp2; then
OUTPUT631-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 632
if test $result = ok -a $start_test_number -le 632; then
	echo test 632: Undefined object values
        cat >$test_file <<'TEST632'
class c { var i;}
println (c().i);
TEST632
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT632' && $CMP $stderr $ftemp2; then
test.d:2:13: run time error - undefined `i' value access
OUTPUT632
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT632-2' && $CMP $stdout $ftemp2; then
OUTPUT632-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 633
if test $result = ok -a $start_test_number -le 633; then
	echo test 633: Undefined global values
        cat >$test_file <<'TEST633'
var i;
fun f {
  return i;
}

f();
TEST633
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT633' && $CMP $stderr $ftemp2; then
test.d:3:3: run time error - undefined `i' value access
OUTPUT633
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT633-2' && $CMP $stdout $ftemp2; then
OUTPUT633-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 634
if test $result = ok -a $start_test_number -le 634; then
	echo test 634: This not in func/block
        cat >$test_file <<'TEST634'
var i = this;
TEST634
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT634' && $CMP $stderr $ftemp2; then
test.d:1:9: this is not in function or class
OUTPUT634
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT634-2' && $CMP $stdout $ftemp2; then
OUTPUT634-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 635.
if test $result = ok -a $start_test_number -le 635; then
	echo test 635: This in func/class
        cat >$test_file <<'TEST635'
var i; fun f {i = this;}
class c {i = this;}
thread t {i = this;}
TEST635
        echo '      ' $DINO $test_file "2>$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT635' && $CMP $stdout $ftemp2; then
OUTPUT635
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 636.
if test $result = ok -a $start_test_number -le 636; then
	echo test 636: Correct this value in func/class
        cat >$test_file <<'TEST636'
var i; fun f {i = this;} f (); putln (inside (i, f));
class c {i = this;} c (); putln (inside (i, c));
var s = 0; fun t {i = this; s = 1;} t (); wait (s == 1); putln (inside (i, t));
class c1 {} class c2 {use c1; i=this;} c2 (); putln (isa (i, c1));
TEST636
        echo '      ' $DINO $test_file "2>$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT636' && $CMP $stdout $ftemp2; then
1
1
1
1
OUTPUT636
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 637.
if test $result = ok -a $start_test_number -le 637; then
	echo test 637: Condition generation of if or for statements
        cat >$test_file <<'TEST637'
val i = 1, j = 2, k = 3;
if (i < j && j < k) putln();
if (i < j || j < k) putln();
if (! (i < j)) putln ();

for (;i < j && j < k;) putln();
for (;i < j || j < k;) putln();
for (;! (i < j);) putln ();

if (1) putln ();
if (!1) putln ();
TEST637
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep -v lconv $stdout '&&' fgrep -v brfs $stdout '&&' fgrep -v brts $stdout
                if (fgrep -v lconv $stdout && fgrep -v brfs $stdout && fgrep -v brts $stdout) > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 638.
if test $result = ok -a $start_test_number -le 638; then
	echo test 638: Condition generation result
        cat >$test_file <<'TEST638'
var i = 1, j = 2, k = 3;
i = i < j && j < k;
i = i < j || j < k;
i = ! (i < j);
TEST638
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' fgrep lconv $stdout '&&' fgrep brfs $stdout '&&' fgrep brts $stdout '&&' fgrep not $stdout
                if (fgrep lconv $stdout && fgrep brfs $stdout && fgrep brts $stdout && fgrep not $stdout) > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 639.
if test $result = ok -a $start_test_number -le 639; then
	echo test 639: Transpose function: expected results
        cat >$test_file <<'TEST639'
var m=[[1]];
println (transpose(m));
m=[[1,2],[3,4]];
println (transpose(m));
m=[[1,2,3],[4,5,6]];
println (transpose(m));
m=[[1,2]];
println (transpose(m));
m=[[1],[2]];
println (transpose(m));
m=[[1],['a']];
println (transpose(m));
TEST639
        echo '      ' $DINO $test_file "2>$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT639' && $CMP $stdout $ftemp2; then
[[1]]
[[1, 3], [2, 4]]
[[1, 4], [2, 5], [3, 6]]
[[1], [2]]
[[1, 2]]
[[1, 'a']]
OUTPUT639
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 640
if test $result = ok -a $start_test_number -le 640; then
	echo test 640: Transpose function: not vector
        cat >$test_file <<'TEST640'
var m=1;
println (transpose(m));
TEST640
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT640' && $CMP $stderr $ftemp2; then
test.d:2:19: run time error - invalid parameter type of `transpose'
OUTPUT640
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT640-2' && $CMP $stdout $ftemp2; then
OUTPUT640-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 641
if test $result = ok -a $start_test_number -le 641; then
	echo test 641: Transpose function: empty vector
        cat >$test_file <<'TEST641'
val m=[];
println (transpose(m));
TEST641
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT641' && $CMP $stderr $ftemp2; then
test.d:2:19: run time error - wrong matrix form for matrix operation `transpose'
OUTPUT641
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT641-2' && $CMP $stdout $ftemp2; then
OUTPUT641-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 642
if test $result = ok -a $start_test_number -le 642; then
	echo test 642: Transpose function: different row lengths
        cat >$test_file <<'TEST642'
val m=[[1],[2,3]];
println (transpose(m));
TEST642
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT642' && $CMP $stderr $ftemp2; then
test.d:2:19: run time error - wrong matrix form for matrix operation `transpose'
OUTPUT642
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT642-2' && $CMP $stdout $ftemp2; then
OUTPUT642-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 643
if test $result = ok -a $start_test_number -le 643; then
	echo test 643: Transpose function: empty row
        cat >$test_file <<'TEST643'
val m=[[]];
println (transpose(m));
TEST643
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT643' && $CMP $stderr $ftemp2; then
test.d:2:19: run time error - wrong matrix form for matrix operation `transpose'
OUTPUT643
                    echo '      ' $CMP - $stdout
                    if cat >$ftemp2 <<'OUTPUT643-2' && $CMP $stdout $ftemp2; then
OUTPUT643-2
                          result=ok
                    else
                          result=fail
                    fi
                else
                        result=fail
                fi
        fi
fi

# Test 644.
if test $result = ok -a $start_test_number -le 644; then
	echo test 644: REPL correct program
        cat >$test_file <<'TEST644'
fun fact (x)
{
  if (x <= 1)
    return 1;
  return x * fact (x-1);
}

var i, x, n = 3;

for (i = 0; i < n; i++)
  x = fact (12);

putln (x);
TEST644
        echo '      ' $DINO "<" $test_file "2>&1 | fgrep -v version >$stdout"
        if $DINO < $test_file 2>&1 | fgrep -v version >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT644' && $CMP $stdout $ftemp2; then
Use "exit(<int>);" or Ctrl-D to exit
dino>     |     |     |     |     | dino> dino> dino> dino>     | dino> dino> 479001600
dino> 
OUTPUT644
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 645.
if test $result = ok -a $start_test_number -le 645; then
	echo test 645: REPL syntax error
        cat >$test_file <<'TEST645'
val ;
putln ("Right");
val ;
putln ("Right again");
TEST645
        echo '      ' $DINO "<" $test_file "2>&1 | fgrep -v version >$stdout"
        if $DINO < $test_file 2>&1 | fgrep -v version >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT645' && $CMP $stdout $ftemp2; then
Use "exit(<int>);" or Ctrl-D to exit
dino>       val ;
          ^
      syntax error
dino> Right
dino>       val ;
          ^
      syntax error
dino> Right again
dino> 
OUTPUT645
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 646.
if test $result = ok -a $start_test_number -le 646; then
	echo test 646: REPL context error
        cat >$test_file <<'TEST646'
final fun f;
fun f{}
putln ("Right");
final fun f;
fun f{}
putln ("Right again");
throw 1;
putln ("One more: right");
TEST646
        echo '      ' $DINO "<" $test_file "2>&1 | fgrep -v version >$stdout"
        if $DINO < $test_file 2>&1 | fgrep -v version >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT646' && $CMP $stdout $ftemp2; then
Use "exit(<int>);" or Ctrl-D to exit
dino> dino>       fun f{}
          ^
      forward and matched decls of `f' have different access/final attributes
      final fun f;
                ^
      (previous declaration of identifier `f')
dino> Right
dino> dino>       fun f{}
          ^
      forward and matched decls of `f' have different access/final attributes
      final fun f;
                ^
      (previous declaration of identifier `f')
dino> Right again
dino>       throw 1;
      ^
      invalid type of throw-expr
dino> One more: right
dino> 
OUTPUT646
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 647.
if test $result = ok -a $start_test_number -le 647; then
	echo test 647: REPL eval error
        cat >$test_file <<'TEST647'
val i = 5/0;
putln ("Right");
val i = 5/0;
putln ("Right again");
val i = 5/0;
putln ("One more: right");
TEST647
        echo '      ' $DINO "<" $test_file "2>&1 | fgrep -v version >$stdout"
        if $DINO < $test_file 2>&1 | fgrep -v version >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT647' && $CMP $stdout $ftemp2; then
Use "exit(<int>);" or Ctrl-D to exit
dino>       val i = 5/0;
               ^
      floating point exception
dino> Right
dino>       val i = 5/0;
               ^
      floating point exception
dino> Right again
dino>       val i = 5/0;
               ^
      floating point exception
dino> One more: right
dino> 
OUTPUT647
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 648.
if test $result = ok -a $start_test_number -le 648; then
	echo test 648: REPL printing
        cat >$test_file <<'TEST648'
fun fact (x) {
  if (x <= 1) {
    x;
    return 1;
  }
  return x * fact (x-1);
}

var i, x, n = 2;
for (i = 0; i < n; i++)
  fact (8);
TEST648
        echo '      ' $DINO "<" $test_file "2>&1 | fgrep -v version >$stdout"
        if $DINO < $test_file 2>&1 | fgrep -v version >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT648' && $CMP $stdout $ftemp2; then
Use "exit(<int>);" or Ctrl-D to exit
dino>     |     |     |     |     |     | dino> dino> dino>     | 1
40320
1
40320
dino> 
OUTPUT648
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 649.
if test $result = ok -a $start_test_number -le 649; then
	echo test 649: REPL printing long vectors and tables
        cat >$test_file <<'TEST649'
[49:1, 50: 2.0];
[100:1];
tab [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50];
TEST649
        echo '      ' $DINO "<" $test_file "2>&1 | fgrep -v version >$stdout"
        if $DINO < $test_file 2>&1 | fgrep -v version >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT649' && $CMP $stdout $ftemp2; then
Use "exit(<int>);" or Ctrl-D to exit
dino> [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, ...]
dino> [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...]
dino> tab [0:nil, 1:nil, 2:nil, 3:nil, 4:nil, 5:nil, 6:nil, 7:nil, 8:nil, 9:nil, 10:nil, 11:nil, 12:nil, 13:nil, 14:nil, 15:nil, 16:nil, 17:nil, 18:nil, 19:nil, 20:nil, 21:nil, 22:nil, 23:nil, 24:nil, 25:nil, 26:nil, 27:nil, 28:nil, 29:nil, 30:nil, 31:nil, 32:nil, 33:nil, 34:nil, 35:nil, 36:nil, 37:nil, 38:nil, 39:nil, 40:nil, 41:nil, 42:nil, 43:nil, 44:nil, 45:nil, 46:nil, 47:nil, 48:nil, 49:nil, ...]
dino> 
OUTPUT649
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 650.
if test $result = ok -a $start_test_number -le 650; then
	echo test 650: Integer format printing
        cat >$test_file <<'TEST650'
fun err {putln ("badformat");}
put ("#0- +d: "); try {putf ("->%#0- +d<-\n",-4);} catch (invfmt) {err ();}
put ("#0- +d: "); try {putf ("->%#0- +d<-\n",0);} catch (invfmt) {err ();}
put ("#0- +d: "); try {putf ("->%#0- +d<-\n",4);} catch (invfmt) {err ();}
put ("0- +d: "); try {putf ("->%0- +d<-\n",-4);} catch (invfmt) {err ();}
put ("0- +d: "); try {putf ("->%0- +d<-\n",0);} catch (invfmt) {err ();}
put ("0- +d: "); try {putf ("->%0- +d<-\n",4);} catch (invfmt) {err ();}
put ("#- +d: "); try {putf ("->%#- +d<-\n",-4);} catch (invfmt) {err ();}
put ("#- +d: "); try {putf ("->%#- +d<-\n",0);} catch (invfmt) {err ();}
put ("#- +d: "); try {putf ("->%#- +d<-\n",4);} catch (invfmt) {err ();}
put ("- +d: "); try {putf ("->%- +d<-\n",-4);} catch (invfmt) {err ();}
put ("- +d: "); try {putf ("->%- +d<-\n",0);} catch (invfmt) {err ();}
put ("- +d: "); try {putf ("->%- +d<-\n",4);} catch (invfmt) {err ();}
put ("#0 +d: "); try {putf ("->%#0 +d<-\n",-4);} catch (invfmt) {err ();}
put ("#0 +d: "); try {putf ("->%#0 +d<-\n",0);} catch (invfmt) {err ();}
put ("#0 +d: "); try {putf ("->%#0 +d<-\n",4);} catch (invfmt) {err ();}
put ("0 +d: "); try {putf ("->%0 +d<-\n",-4);} catch (invfmt) {err ();}
put ("0 +d: "); try {putf ("->%0 +d<-\n",0);} catch (invfmt) {err ();}
put ("0 +d: "); try {putf ("->%0 +d<-\n",4);} catch (invfmt) {err ();}
put ("# +d: "); try {putf ("->%# +d<-\n",-4);} catch (invfmt) {err ();}
put ("# +d: "); try {putf ("->%# +d<-\n",0);} catch (invfmt) {err ();}
put ("# +d: "); try {putf ("->%# +d<-\n",4);} catch (invfmt) {err ();}
put (" +d: "); try {putf ("->% +d<-\n",-4);} catch (invfmt) {err ();}
put (" +d: "); try {putf ("->% +d<-\n",0);} catch (invfmt) {err ();}
put (" +d: "); try {putf ("->% +d<-\n",4);} catch (invfmt) {err ();}
put ("#0-+d: "); try {putf ("->%#0-+d<-\n",-4);} catch (invfmt) {err ();}
put ("#0-+d: "); try {putf ("->%#0-+d<-\n",0);} catch (invfmt) {err ();}
put ("#0-+d: "); try {putf ("->%#0-+d<-\n",4);} catch (invfmt) {err ();}
put ("0-+d: "); try {putf ("->%0-+d<-\n",-4);} catch (invfmt) {err ();}
put ("0-+d: "); try {putf ("->%0-+d<-\n",0);} catch (invfmt) {err ();}
put ("0-+d: "); try {putf ("->%0-+d<-\n",4);} catch (invfmt) {err ();}
put ("#-+d: "); try {putf ("->%#-+d<-\n",-4);} catch (invfmt) {err ();}
put ("#-+d: "); try {putf ("->%#-+d<-\n",0);} catch (invfmt) {err ();}
put ("#-+d: "); try {putf ("->%#-+d<-\n",4);} catch (invfmt) {err ();}
put ("-+d: "); try {putf ("->%-+d<-\n",-4);} catch (invfmt) {err ();}
put ("-+d: "); try {putf ("->%-+d<-\n",0);} catch (invfmt) {err ();}
put ("-+d: "); try {putf ("->%-+d<-\n",4);} catch (invfmt) {err ();}
put ("#0+d: "); try {putf ("->%#0+d<-\n",-4);} catch (invfmt) {err ();}
put ("#0+d: "); try {putf ("->%#0+d<-\n",0);} catch (invfmt) {err ();}
put ("#0+d: "); try {putf ("->%#0+d<-\n",4);} catch (invfmt) {err ();}
put ("0+d: "); try {putf ("->%0+d<-\n",-4);} catch (invfmt) {err ();}
put ("0+d: "); try {putf ("->%0+d<-\n",0);} catch (invfmt) {err ();}
put ("0+d: "); try {putf ("->%0+d<-\n",4);} catch (invfmt) {err ();}
put ("#+d: "); try {putf ("->%#+d<-\n",-4);} catch (invfmt) {err ();}
put ("#+d: "); try {putf ("->%#+d<-\n",0);} catch (invfmt) {err ();}
put ("#+d: "); try {putf ("->%#+d<-\n",4);} catch (invfmt) {err ();}
put ("+d: "); try {putf ("->%+d<-\n",-4);} catch (invfmt) {err ();}
put ("+d: "); try {putf ("->%+d<-\n",0);} catch (invfmt) {err ();}
put ("+d: "); try {putf ("->%+d<-\n",4);} catch (invfmt) {err ();}
put ("#0- d: "); try {putf ("->%#0- d<-\n",-4);} catch (invfmt) {err ();}
put ("#0- d: "); try {putf ("->%#0- d<-\n",0);} catch (invfmt) {err ();}
put ("#0- d: "); try {putf ("->%#0- d<-\n",4);} catch (invfmt) {err ();}
put ("0- d: "); try {putf ("->%0- d<-\n",-4);} catch (invfmt) {err ();}
put ("0- d: "); try {putf ("->%0- d<-\n",0);} catch (invfmt) {err ();}
put ("0- d: "); try {putf ("->%0- d<-\n",4);} catch (invfmt) {err ();}
put ("#- d: "); try {putf ("->%#- d<-\n",-4);} catch (invfmt) {err ();}
put ("#- d: "); try {putf ("->%#- d<-\n",0);} catch (invfmt) {err ();}
put ("#- d: "); try {putf ("->%#- d<-\n",4);} catch (invfmt) {err ();}
put ("- d: "); try {putf ("->%- d<-\n",-4);} catch (invfmt) {err ();}
put ("- d: "); try {putf ("->%- d<-\n",0);} catch (invfmt) {err ();}
put ("- d: "); try {putf ("->%- d<-\n",4);} catch (invfmt) {err ();}
put ("#0 d: "); try {putf ("->%#0 d<-\n",-4);} catch (invfmt) {err ();}
put ("#0 d: "); try {putf ("->%#0 d<-\n",0);} catch (invfmt) {err ();}
put ("#0 d: "); try {putf ("->%#0 d<-\n",4);} catch (invfmt) {err ();}
put ("0 d: "); try {putf ("->%0 d<-\n",-4);} catch (invfmt) {err ();}
put ("0 d: "); try {putf ("->%0 d<-\n",0);} catch (invfmt) {err ();}
put ("0 d: "); try {putf ("->%0 d<-\n",4);} catch (invfmt) {err ();}
put ("# d: "); try {putf ("->%# d<-\n",-4);} catch (invfmt) {err ();}
put ("# d: "); try {putf ("->%# d<-\n",0);} catch (invfmt) {err ();}
put ("# d: "); try {putf ("->%# d<-\n",4);} catch (invfmt) {err ();}
put (" d: "); try {putf ("->% d<-\n",-4);} catch (invfmt) {err ();}
put (" d: "); try {putf ("->% d<-\n",0);} catch (invfmt) {err ();}
put (" d: "); try {putf ("->% d<-\n",4);} catch (invfmt) {err ();}
put ("#0-d: "); try {putf ("->%#0-d<-\n",-4);} catch (invfmt) {err ();}
put ("#0-d: "); try {putf ("->%#0-d<-\n",0);} catch (invfmt) {err ();}
put ("#0-d: "); try {putf ("->%#0-d<-\n",4);} catch (invfmt) {err ();}
put ("0-d: "); try {putf ("->%0-d<-\n",-4);} catch (invfmt) {err ();}
put ("0-d: "); try {putf ("->%0-d<-\n",0);} catch (invfmt) {err ();}
put ("0-d: "); try {putf ("->%0-d<-\n",4);} catch (invfmt) {err ();}
put ("#-d: "); try {putf ("->%#-d<-\n",-4);} catch (invfmt) {err ();}
put ("#-d: "); try {putf ("->%#-d<-\n",0);} catch (invfmt) {err ();}
put ("#-d: "); try {putf ("->%#-d<-\n",4);} catch (invfmt) {err ();}
put ("-d: "); try {putf ("->%-d<-\n",-4);} catch (invfmt) {err ();}
put ("-d: "); try {putf ("->%-d<-\n",0);} catch (invfmt) {err ();}
put ("-d: "); try {putf ("->%-d<-\n",4);} catch (invfmt) {err ();}
put ("#0d: "); try {putf ("->%#0d<-\n",-4);} catch (invfmt) {err ();}
put ("#0d: "); try {putf ("->%#0d<-\n",0);} catch (invfmt) {err ();}
put ("#0d: "); try {putf ("->%#0d<-\n",4);} catch (invfmt) {err ();}
put ("0d: "); try {putf ("->%0d<-\n",-4);} catch (invfmt) {err ();}
put ("0d: "); try {putf ("->%0d<-\n",0);} catch (invfmt) {err ();}
put ("0d: "); try {putf ("->%0d<-\n",4);} catch (invfmt) {err ();}
put ("#d: "); try {putf ("->%#d<-\n",-4);} catch (invfmt) {err ();}
put ("#d: "); try {putf ("->%#d<-\n",0);} catch (invfmt) {err ();}
put ("#d: "); try {putf ("->%#d<-\n",4);} catch (invfmt) {err ();}
put ("d: "); try {putf ("->%d<-\n",-4);} catch (invfmt) {err ();}
put ("d: "); try {putf ("->%d<-\n",0);} catch (invfmt) {err ();}
put ("d: "); try {putf ("->%d<-\n",4);} catch (invfmt) {err ();}
put ("#0- +o: "); try {putf ("->%#0- +o<-\n",-4);} catch (invfmt) {err ();}
put ("#0- +o: "); try {putf ("->%#0- +o<-\n",0);} catch (invfmt) {err ();}
put ("#0- +o: "); try {putf ("->%#0- +o<-\n",4);} catch (invfmt) {err ();}
put ("0- +o: "); try {putf ("->%0- +o<-\n",-4);} catch (invfmt) {err ();}
put ("0- +o: "); try {putf ("->%0- +o<-\n",0);} catch (invfmt) {err ();}
put ("0- +o: "); try {putf ("->%0- +o<-\n",4);} catch (invfmt) {err ();}
put ("#- +o: "); try {putf ("->%#- +o<-\n",-4);} catch (invfmt) {err ();}
put ("#- +o: "); try {putf ("->%#- +o<-\n",0);} catch (invfmt) {err ();}
put ("#- +o: "); try {putf ("->%#- +o<-\n",4);} catch (invfmt) {err ();}
put ("- +o: "); try {putf ("->%- +o<-\n",-4);} catch (invfmt) {err ();}
put ("- +o: "); try {putf ("->%- +o<-\n",0);} catch (invfmt) {err ();}
put ("- +o: "); try {putf ("->%- +o<-\n",4);} catch (invfmt) {err ();}
put ("#0 +o: "); try {putf ("->%#0 +o<-\n",-4);} catch (invfmt) {err ();}
put ("#0 +o: "); try {putf ("->%#0 +o<-\n",0);} catch (invfmt) {err ();}
put ("#0 +o: "); try {putf ("->%#0 +o<-\n",4);} catch (invfmt) {err ();}
put ("0 +o: "); try {putf ("->%0 +o<-\n",-4);} catch (invfmt) {err ();}
put ("0 +o: "); try {putf ("->%0 +o<-\n",0);} catch (invfmt) {err ();}
put ("0 +o: "); try {putf ("->%0 +o<-\n",4);} catch (invfmt) {err ();}
put ("# +o: "); try {putf ("->%# +o<-\n",-4);} catch (invfmt) {err ();}
put ("# +o: "); try {putf ("->%# +o<-\n",0);} catch (invfmt) {err ();}
put ("# +o: "); try {putf ("->%# +o<-\n",4);} catch (invfmt) {err ();}
put (" +o: "); try {putf ("->% +o<-\n",-4);} catch (invfmt) {err ();}
put (" +o: "); try {putf ("->% +o<-\n",0);} catch (invfmt) {err ();}
put (" +o: "); try {putf ("->% +o<-\n",4);} catch (invfmt) {err ();}
put ("#0-+o: "); try {putf ("->%#0-+o<-\n",-4);} catch (invfmt) {err ();}
put ("#0-+o: "); try {putf ("->%#0-+o<-\n",0);} catch (invfmt) {err ();}
put ("#0-+o: "); try {putf ("->%#0-+o<-\n",4);} catch (invfmt) {err ();}
put ("0-+o: "); try {putf ("->%0-+o<-\n",-4);} catch (invfmt) {err ();}
put ("0-+o: "); try {putf ("->%0-+o<-\n",0);} catch (invfmt) {err ();}
put ("0-+o: "); try {putf ("->%0-+o<-\n",4);} catch (invfmt) {err ();}
put ("#-+o: "); try {putf ("->%#-+o<-\n",-4);} catch (invfmt) {err ();}
put ("#-+o: "); try {putf ("->%#-+o<-\n",0);} catch (invfmt) {err ();}
put ("#-+o: "); try {putf ("->%#-+o<-\n",4);} catch (invfmt) {err ();}
put ("-+o: "); try {putf ("->%-+o<-\n",-4);} catch (invfmt) {err ();}
put ("-+o: "); try {putf ("->%-+o<-\n",0);} catch (invfmt) {err ();}
put ("-+o: "); try {putf ("->%-+o<-\n",4);} catch (invfmt) {err ();}
put ("#0+o: "); try {putf ("->%#0+o<-\n",-4);} catch (invfmt) {err ();}
put ("#0+o: "); try {putf ("->%#0+o<-\n",0);} catch (invfmt) {err ();}
put ("#0+o: "); try {putf ("->%#0+o<-\n",4);} catch (invfmt) {err ();}
put ("0+o: "); try {putf ("->%0+o<-\n",-4);} catch (invfmt) {err ();}
put ("0+o: "); try {putf ("->%0+o<-\n",0);} catch (invfmt) {err ();}
put ("0+o: "); try {putf ("->%0+o<-\n",4);} catch (invfmt) {err ();}
put ("#+o: "); try {putf ("->%#+o<-\n",-4);} catch (invfmt) {err ();}
put ("#+o: "); try {putf ("->%#+o<-\n",0);} catch (invfmt) {err ();}
put ("#+o: "); try {putf ("->%#+o<-\n",4);} catch (invfmt) {err ();}
put ("+o: "); try {putf ("->%+o<-\n",-4);} catch (invfmt) {err ();}
put ("+o: "); try {putf ("->%+o<-\n",0);} catch (invfmt) {err ();}
put ("+o: "); try {putf ("->%+o<-\n",4);} catch (invfmt) {err ();}
put ("#0- o: "); try {putf ("->%#0- o<-\n",-4);} catch (invfmt) {err ();}
put ("#0- o: "); try {putf ("->%#0- o<-\n",0);} catch (invfmt) {err ();}
put ("#0- o: "); try {putf ("->%#0- o<-\n",4);} catch (invfmt) {err ();}
put ("0- o: "); try {putf ("->%0- o<-\n",-4);} catch (invfmt) {err ();}
put ("0- o: "); try {putf ("->%0- o<-\n",0);} catch (invfmt) {err ();}
put ("0- o: "); try {putf ("->%0- o<-\n",4);} catch (invfmt) {err ();}
put ("#- o: "); try {putf ("->%#- o<-\n",-4);} catch (invfmt) {err ();}
put ("#- o: "); try {putf ("->%#- o<-\n",0);} catch (invfmt) {err ();}
put ("#- o: "); try {putf ("->%#- o<-\n",4);} catch (invfmt) {err ();}
put ("- o: "); try {putf ("->%- o<-\n",-4);} catch (invfmt) {err ();}
put ("- o: "); try {putf ("->%- o<-\n",0);} catch (invfmt) {err ();}
put ("- o: "); try {putf ("->%- o<-\n",4);} catch (invfmt) {err ();}
put ("#0 o: "); try {putf ("->%#0 o<-\n",-4);} catch (invfmt) {err ();}
put ("#0 o: "); try {putf ("->%#0 o<-\n",0);} catch (invfmt) {err ();}
put ("#0 o: "); try {putf ("->%#0 o<-\n",4);} catch (invfmt) {err ();}
put ("0 o: "); try {putf ("->%0 o<-\n",-4);} catch (invfmt) {err ();}
put ("0 o: "); try {putf ("->%0 o<-\n",0);} catch (invfmt) {err ();}
put ("0 o: "); try {putf ("->%0 o<-\n",4);} catch (invfmt) {err ();}
put ("# o: "); try {putf ("->%# o<-\n",-4);} catch (invfmt) {err ();}
put ("# o: "); try {putf ("->%# o<-\n",0);} catch (invfmt) {err ();}
put ("# o: "); try {putf ("->%# o<-\n",4);} catch (invfmt) {err ();}
put (" o: "); try {putf ("->% o<-\n",-4);} catch (invfmt) {err ();}
put (" o: "); try {putf ("->% o<-\n",0);} catch (invfmt) {err ();}
put (" o: "); try {putf ("->% o<-\n",4);} catch (invfmt) {err ();}
put ("#0-o: "); try {putf ("->%#0-o<-\n",-4);} catch (invfmt) {err ();}
put ("#0-o: "); try {putf ("->%#0-o<-\n",0);} catch (invfmt) {err ();}
put ("#0-o: "); try {putf ("->%#0-o<-\n",4);} catch (invfmt) {err ();}
put ("0-o: "); try {putf ("->%0-o<-\n",-4);} catch (invfmt) {err ();}
put ("0-o: "); try {putf ("->%0-o<-\n",0);} catch (invfmt) {err ();}
put ("0-o: "); try {putf ("->%0-o<-\n",4);} catch (invfmt) {err ();}
put ("#-o: "); try {putf ("->%#-o<-\n",-4);} catch (invfmt) {err ();}
put ("#-o: "); try {putf ("->%#-o<-\n",0);} catch (invfmt) {err ();}
put ("#-o: "); try {putf ("->%#-o<-\n",4);} catch (invfmt) {err ();}
put ("-o: "); try {putf ("->%-o<-\n",-4);} catch (invfmt) {err ();}
put ("-o: "); try {putf ("->%-o<-\n",0);} catch (invfmt) {err ();}
put ("-o: "); try {putf ("->%-o<-\n",4);} catch (invfmt) {err ();}
put ("#0o: "); try {putf ("->%#0o<-\n",-4);} catch (invfmt) {err ();}
put ("#0o: "); try {putf ("->%#0o<-\n",0);} catch (invfmt) {err ();}
put ("#0o: "); try {putf ("->%#0o<-\n",4);} catch (invfmt) {err ();}
put ("0o: "); try {putf ("->%0o<-\n",-4);} catch (invfmt) {err ();}
put ("0o: "); try {putf ("->%0o<-\n",0);} catch (invfmt) {err ();}
put ("0o: "); try {putf ("->%0o<-\n",4);} catch (invfmt) {err ();}
put ("#o: "); try {putf ("->%#o<-\n",-4);} catch (invfmt) {err ();}
put ("#o: "); try {putf ("->%#o<-\n",0);} catch (invfmt) {err ();}
put ("#o: "); try {putf ("->%#o<-\n",4);} catch (invfmt) {err ();}
put ("o: "); try {putf ("->%o<-\n",-4);} catch (invfmt) {err ();}
put ("o: "); try {putf ("->%o<-\n",0);} catch (invfmt) {err ();}
put ("o: "); try {putf ("->%o<-\n",4);} catch (invfmt) {err ();}
put ("#0- +x: "); try {putf ("->%#0- +x<-\n",-4);} catch (invfmt) {err ();}
put ("#0- +x: "); try {putf ("->%#0- +x<-\n",0);} catch (invfmt) {err ();}
put ("#0- +x: "); try {putf ("->%#0- +x<-\n",4);} catch (invfmt) {err ();}
put ("0- +x: "); try {putf ("->%0- +x<-\n",-4);} catch (invfmt) {err ();}
put ("0- +x: "); try {putf ("->%0- +x<-\n",0);} catch (invfmt) {err ();}
put ("0- +x: "); try {putf ("->%0- +x<-\n",4);} catch (invfmt) {err ();}
put ("#- +x: "); try {putf ("->%#- +x<-\n",-4);} catch (invfmt) {err ();}
put ("#- +x: "); try {putf ("->%#- +x<-\n",0);} catch (invfmt) {err ();}
put ("#- +x: "); try {putf ("->%#- +x<-\n",4);} catch (invfmt) {err ();}
put ("- +x: "); try {putf ("->%- +x<-\n",-4);} catch (invfmt) {err ();}
put ("- +x: "); try {putf ("->%- +x<-\n",0);} catch (invfmt) {err ();}
put ("- +x: "); try {putf ("->%- +x<-\n",4);} catch (invfmt) {err ();}
put ("#0 +x: "); try {putf ("->%#0 +x<-\n",-4);} catch (invfmt) {err ();}
put ("#0 +x: "); try {putf ("->%#0 +x<-\n",0);} catch (invfmt) {err ();}
put ("#0 +x: "); try {putf ("->%#0 +x<-\n",4);} catch (invfmt) {err ();}
put ("0 +x: "); try {putf ("->%0 +x<-\n",-4);} catch (invfmt) {err ();}
put ("0 +x: "); try {putf ("->%0 +x<-\n",0);} catch (invfmt) {err ();}
put ("0 +x: "); try {putf ("->%0 +x<-\n",4);} catch (invfmt) {err ();}
put ("# +x: "); try {putf ("->%# +x<-\n",-4);} catch (invfmt) {err ();}
put ("# +x: "); try {putf ("->%# +x<-\n",0);} catch (invfmt) {err ();}
put ("# +x: "); try {putf ("->%# +x<-\n",4);} catch (invfmt) {err ();}
put (" +x: "); try {putf ("->% +x<-\n",-4);} catch (invfmt) {err ();}
put (" +x: "); try {putf ("->% +x<-\n",0);} catch (invfmt) {err ();}
put (" +x: "); try {putf ("->% +x<-\n",4);} catch (invfmt) {err ();}
put ("#0-+x: "); try {putf ("->%#0-+x<-\n",-4);} catch (invfmt) {err ();}
put ("#0-+x: "); try {putf ("->%#0-+x<-\n",0);} catch (invfmt) {err ();}
put ("#0-+x: "); try {putf ("->%#0-+x<-\n",4);} catch (invfmt) {err ();}
put ("0-+x: "); try {putf ("->%0-+x<-\n",-4);} catch (invfmt) {err ();}
put ("0-+x: "); try {putf ("->%0-+x<-\n",0);} catch (invfmt) {err ();}
put ("0-+x: "); try {putf ("->%0-+x<-\n",4);} catch (invfmt) {err ();}
put ("#-+x: "); try {putf ("->%#-+x<-\n",-4);} catch (invfmt) {err ();}
put ("#-+x: "); try {putf ("->%#-+x<-\n",0);} catch (invfmt) {err ();}
put ("#-+x: "); try {putf ("->%#-+x<-\n",4);} catch (invfmt) {err ();}
put ("-+x: "); try {putf ("->%-+x<-\n",-4);} catch (invfmt) {err ();}
put ("-+x: "); try {putf ("->%-+x<-\n",0);} catch (invfmt) {err ();}
put ("-+x: "); try {putf ("->%-+x<-\n",4);} catch (invfmt) {err ();}
put ("#0+x: "); try {putf ("->%#0+x<-\n",-4);} catch (invfmt) {err ();}
put ("#0+x: "); try {putf ("->%#0+x<-\n",0);} catch (invfmt) {err ();}
put ("#0+x: "); try {putf ("->%#0+x<-\n",4);} catch (invfmt) {err ();}
put ("0+x: "); try {putf ("->%0+x<-\n",-4);} catch (invfmt) {err ();}
put ("0+x: "); try {putf ("->%0+x<-\n",0);} catch (invfmt) {err ();}
put ("0+x: "); try {putf ("->%0+x<-\n",4);} catch (invfmt) {err ();}
put ("#+x: "); try {putf ("->%#+x<-\n",-4);} catch (invfmt) {err ();}
put ("#+x: "); try {putf ("->%#+x<-\n",0);} catch (invfmt) {err ();}
put ("#+x: "); try {putf ("->%#+x<-\n",4);} catch (invfmt) {err ();}
put ("+x: "); try {putf ("->%+x<-\n",-4);} catch (invfmt) {err ();}
put ("+x: "); try {putf ("->%+x<-\n",0);} catch (invfmt) {err ();}
put ("+x: "); try {putf ("->%+x<-\n",4);} catch (invfmt) {err ();}
put ("#0- x: "); try {putf ("->%#0- x<-\n",-4);} catch (invfmt) {err ();}
put ("#0- x: "); try {putf ("->%#0- x<-\n",0);} catch (invfmt) {err ();}
put ("#0- x: "); try {putf ("->%#0- x<-\n",4);} catch (invfmt) {err ();}
put ("0- x: "); try {putf ("->%0- x<-\n",-4);} catch (invfmt) {err ();}
put ("0- x: "); try {putf ("->%0- x<-\n",0);} catch (invfmt) {err ();}
put ("0- x: "); try {putf ("->%0- x<-\n",4);} catch (invfmt) {err ();}
put ("#- x: "); try {putf ("->%#- x<-\n",-4);} catch (invfmt) {err ();}
put ("#- x: "); try {putf ("->%#- x<-\n",0);} catch (invfmt) {err ();}
put ("#- x: "); try {putf ("->%#- x<-\n",4);} catch (invfmt) {err ();}
put ("- x: "); try {putf ("->%- x<-\n",-4);} catch (invfmt) {err ();}
put ("- x: "); try {putf ("->%- x<-\n",0);} catch (invfmt) {err ();}
put ("- x: "); try {putf ("->%- x<-\n",4);} catch (invfmt) {err ();}
put ("#0 x: "); try {putf ("->%#0 x<-\n",-4);} catch (invfmt) {err ();}
put ("#0 x: "); try {putf ("->%#0 x<-\n",0);} catch (invfmt) {err ();}
put ("#0 x: "); try {putf ("->%#0 x<-\n",4);} catch (invfmt) {err ();}
put ("0 x: "); try {putf ("->%0 x<-\n",-4);} catch (invfmt) {err ();}
put ("0 x: "); try {putf ("->%0 x<-\n",0);} catch (invfmt) {err ();}
put ("0 x: "); try {putf ("->%0 x<-\n",4);} catch (invfmt) {err ();}
put ("# x: "); try {putf ("->%# x<-\n",-4);} catch (invfmt) {err ();}
put ("# x: "); try {putf ("->%# x<-\n",0);} catch (invfmt) {err ();}
put ("# x: "); try {putf ("->%# x<-\n",4);} catch (invfmt) {err ();}
put (" x: "); try {putf ("->% x<-\n",-4);} catch (invfmt) {err ();}
put (" x: "); try {putf ("->% x<-\n",0);} catch (invfmt) {err ();}
put (" x: "); try {putf ("->% x<-\n",4);} catch (invfmt) {err ();}
put ("#0-x: "); try {putf ("->%#0-x<-\n",-4);} catch (invfmt) {err ();}
put ("#0-x: "); try {putf ("->%#0-x<-\n",0);} catch (invfmt) {err ();}
put ("#0-x: "); try {putf ("->%#0-x<-\n",4);} catch (invfmt) {err ();}
put ("0-x: "); try {putf ("->%0-x<-\n",-4);} catch (invfmt) {err ();}
put ("0-x: "); try {putf ("->%0-x<-\n",0);} catch (invfmt) {err ();}
put ("0-x: "); try {putf ("->%0-x<-\n",4);} catch (invfmt) {err ();}
put ("#-x: "); try {putf ("->%#-x<-\n",-4);} catch (invfmt) {err ();}
put ("#-x: "); try {putf ("->%#-x<-\n",0);} catch (invfmt) {err ();}
put ("#-x: "); try {putf ("->%#-x<-\n",4);} catch (invfmt) {err ();}
put ("-x: "); try {putf ("->%-x<-\n",-4);} catch (invfmt) {err ();}
put ("-x: "); try {putf ("->%-x<-\n",0);} catch (invfmt) {err ();}
put ("-x: "); try {putf ("->%-x<-\n",4);} catch (invfmt) {err ();}
put ("#0x: "); try {putf ("->%#0x<-\n",-4);} catch (invfmt) {err ();}
put ("#0x: "); try {putf ("->%#0x<-\n",0);} catch (invfmt) {err ();}
put ("#0x: "); try {putf ("->%#0x<-\n",4);} catch (invfmt) {err ();}
put ("0x: "); try {putf ("->%0x<-\n",-4);} catch (invfmt) {err ();}
put ("0x: "); try {putf ("->%0x<-\n",0);} catch (invfmt) {err ();}
put ("0x: "); try {putf ("->%0x<-\n",4);} catch (invfmt) {err ();}
put ("#x: "); try {putf ("->%#x<-\n",-4);} catch (invfmt) {err ();}
put ("#x: "); try {putf ("->%#x<-\n",0);} catch (invfmt) {err ();}
put ("#x: "); try {putf ("->%#x<-\n",4);} catch (invfmt) {err ();}
put ("x: "); try {putf ("->%x<-\n",-4);} catch (invfmt) {err ();}
put ("x: "); try {putf ("->%x<-\n",0);} catch (invfmt) {err ();}
put ("x: "); try {putf ("->%x<-\n",4);} catch (invfmt) {err ();}
put ("#0- +X: "); try {putf ("->%#0- +X<-\n",-4);} catch (invfmt) {err ();}
put ("#0- +X: "); try {putf ("->%#0- +X<-\n",0);} catch (invfmt) {err ();}
put ("#0- +X: "); try {putf ("->%#0- +X<-\n",4);} catch (invfmt) {err ();}
put ("0- +X: "); try {putf ("->%0- +X<-\n",-4);} catch (invfmt) {err ();}
put ("0- +X: "); try {putf ("->%0- +X<-\n",0);} catch (invfmt) {err ();}
put ("0- +X: "); try {putf ("->%0- +X<-\n",4);} catch (invfmt) {err ();}
put ("#- +X: "); try {putf ("->%#- +X<-\n",-4);} catch (invfmt) {err ();}
put ("#- +X: "); try {putf ("->%#- +X<-\n",0);} catch (invfmt) {err ();}
put ("#- +X: "); try {putf ("->%#- +X<-\n",4);} catch (invfmt) {err ();}
put ("- +X: "); try {putf ("->%- +X<-\n",-4);} catch (invfmt) {err ();}
put ("- +X: "); try {putf ("->%- +X<-\n",0);} catch (invfmt) {err ();}
put ("- +X: "); try {putf ("->%- +X<-\n",4);} catch (invfmt) {err ();}
put ("#0 +X: "); try {putf ("->%#0 +X<-\n",-4);} catch (invfmt) {err ();}
put ("#0 +X: "); try {putf ("->%#0 +X<-\n",0);} catch (invfmt) {err ();}
put ("#0 +X: "); try {putf ("->%#0 +X<-\n",4);} catch (invfmt) {err ();}
put ("0 +X: "); try {putf ("->%0 +X<-\n",-4);} catch (invfmt) {err ();}
put ("0 +X: "); try {putf ("->%0 +X<-\n",0);} catch (invfmt) {err ();}
put ("0 +X: "); try {putf ("->%0 +X<-\n",4);} catch (invfmt) {err ();}
put ("# +X: "); try {putf ("->%# +X<-\n",-4);} catch (invfmt) {err ();}
put ("# +X: "); try {putf ("->%# +X<-\n",0);} catch (invfmt) {err ();}
put ("# +X: "); try {putf ("->%# +X<-\n",4);} catch (invfmt) {err ();}
put (" +X: "); try {putf ("->% +X<-\n",-4);} catch (invfmt) {err ();}
put (" +X: "); try {putf ("->% +X<-\n",0);} catch (invfmt) {err ();}
put (" +X: "); try {putf ("->% +X<-\n",4);} catch (invfmt) {err ();}
put ("#0-+X: "); try {putf ("->%#0-+X<-\n",-4);} catch (invfmt) {err ();}
put ("#0-+X: "); try {putf ("->%#0-+X<-\n",0);} catch (invfmt) {err ();}
put ("#0-+X: "); try {putf ("->%#0-+X<-\n",4);} catch (invfmt) {err ();}
put ("0-+X: "); try {putf ("->%0-+X<-\n",-4);} catch (invfmt) {err ();}
put ("0-+X: "); try {putf ("->%0-+X<-\n",0);} catch (invfmt) {err ();}
put ("0-+X: "); try {putf ("->%0-+X<-\n",4);} catch (invfmt) {err ();}
put ("#-+X: "); try {putf ("->%#-+X<-\n",-4);} catch (invfmt) {err ();}
put ("#-+X: "); try {putf ("->%#-+X<-\n",0);} catch (invfmt) {err ();}
put ("#-+X: "); try {putf ("->%#-+X<-\n",4);} catch (invfmt) {err ();}
put ("-+X: "); try {putf ("->%-+X<-\n",-4);} catch (invfmt) {err ();}
put ("-+X: "); try {putf ("->%-+X<-\n",0);} catch (invfmt) {err ();}
put ("-+X: "); try {putf ("->%-+X<-\n",4);} catch (invfmt) {err ();}
put ("#0+X: "); try {putf ("->%#0+X<-\n",-4);} catch (invfmt) {err ();}
put ("#0+X: "); try {putf ("->%#0+X<-\n",0);} catch (invfmt) {err ();}
put ("#0+X: "); try {putf ("->%#0+X<-\n",4);} catch (invfmt) {err ();}
put ("0+X: "); try {putf ("->%0+X<-\n",-4);} catch (invfmt) {err ();}
put ("0+X: "); try {putf ("->%0+X<-\n",0);} catch (invfmt) {err ();}
put ("0+X: "); try {putf ("->%0+X<-\n",4);} catch (invfmt) {err ();}
put ("#+X: "); try {putf ("->%#+X<-\n",-4);} catch (invfmt) {err ();}
put ("#+X: "); try {putf ("->%#+X<-\n",0);} catch (invfmt) {err ();}
put ("#+X: "); try {putf ("->%#+X<-\n",4);} catch (invfmt) {err ();}
put ("+X: "); try {putf ("->%+X<-\n",-4);} catch (invfmt) {err ();}
put ("+X: "); try {putf ("->%+X<-\n",0);} catch (invfmt) {err ();}
put ("+X: "); try {putf ("->%+X<-\n",4);} catch (invfmt) {err ();}
put ("#0- X: "); try {putf ("->%#0- X<-\n",-4);} catch (invfmt) {err ();}
put ("#0- X: "); try {putf ("->%#0- X<-\n",0);} catch (invfmt) {err ();}
put ("#0- X: "); try {putf ("->%#0- X<-\n",4);} catch (invfmt) {err ();}
put ("0- X: "); try {putf ("->%0- X<-\n",-4);} catch (invfmt) {err ();}
put ("0- X: "); try {putf ("->%0- X<-\n",0);} catch (invfmt) {err ();}
put ("0- X: "); try {putf ("->%0- X<-\n",4);} catch (invfmt) {err ();}
put ("#- X: "); try {putf ("->%#- X<-\n",-4);} catch (invfmt) {err ();}
put ("#- X: "); try {putf ("->%#- X<-\n",0);} catch (invfmt) {err ();}
put ("#- X: "); try {putf ("->%#- X<-\n",4);} catch (invfmt) {err ();}
put ("- X: "); try {putf ("->%- X<-\n",-4);} catch (invfmt) {err ();}
put ("- X: "); try {putf ("->%- X<-\n",0);} catch (invfmt) {err ();}
put ("- X: "); try {putf ("->%- X<-\n",4);} catch (invfmt) {err ();}
put ("#0 X: "); try {putf ("->%#0 X<-\n",-4);} catch (invfmt) {err ();}
put ("#0 X: "); try {putf ("->%#0 X<-\n",0);} catch (invfmt) {err ();}
put ("#0 X: "); try {putf ("->%#0 X<-\n",4);} catch (invfmt) {err ();}
put ("0 X: "); try {putf ("->%0 X<-\n",-4);} catch (invfmt) {err ();}
put ("0 X: "); try {putf ("->%0 X<-\n",0);} catch (invfmt) {err ();}
put ("0 X: "); try {putf ("->%0 X<-\n",4);} catch (invfmt) {err ();}
put ("# X: "); try {putf ("->%# X<-\n",-4);} catch (invfmt) {err ();}
put ("# X: "); try {putf ("->%# X<-\n",0);} catch (invfmt) {err ();}
put ("# X: "); try {putf ("->%# X<-\n",4);} catch (invfmt) {err ();}
put (" X: "); try {putf ("->% X<-\n",-4);} catch (invfmt) {err ();}
put (" X: "); try {putf ("->% X<-\n",0);} catch (invfmt) {err ();}
put (" X: "); try {putf ("->% X<-\n",4);} catch (invfmt) {err ();}
put ("#0-X: "); try {putf ("->%#0-X<-\n",-4);} catch (invfmt) {err ();}
put ("#0-X: "); try {putf ("->%#0-X<-\n",0);} catch (invfmt) {err ();}
put ("#0-X: "); try {putf ("->%#0-X<-\n",4);} catch (invfmt) {err ();}
put ("0-X: "); try {putf ("->%0-X<-\n",-4);} catch (invfmt) {err ();}
put ("0-X: "); try {putf ("->%0-X<-\n",0);} catch (invfmt) {err ();}
put ("0-X: "); try {putf ("->%0-X<-\n",4);} catch (invfmt) {err ();}
put ("#-X: "); try {putf ("->%#-X<-\n",-4);} catch (invfmt) {err ();}
put ("#-X: "); try {putf ("->%#-X<-\n",0);} catch (invfmt) {err ();}
put ("#-X: "); try {putf ("->%#-X<-\n",4);} catch (invfmt) {err ();}
put ("-X: "); try {putf ("->%-X<-\n",-4);} catch (invfmt) {err ();}
put ("-X: "); try {putf ("->%-X<-\n",0);} catch (invfmt) {err ();}
put ("-X: "); try {putf ("->%-X<-\n",4);} catch (invfmt) {err ();}
put ("#0X: "); try {putf ("->%#0X<-\n",-4);} catch (invfmt) {err ();}
put ("#0X: "); try {putf ("->%#0X<-\n",0);} catch (invfmt) {err ();}
put ("#0X: "); try {putf ("->%#0X<-\n",4);} catch (invfmt) {err ();}
put ("0X: "); try {putf ("->%0X<-\n",-4);} catch (invfmt) {err ();}
put ("0X: "); try {putf ("->%0X<-\n",0);} catch (invfmt) {err ();}
put ("0X: "); try {putf ("->%0X<-\n",4);} catch (invfmt) {err ();}
put ("#X: "); try {putf ("->%#X<-\n",-4);} catch (invfmt) {err ();}
put ("#X: "); try {putf ("->%#X<-\n",0);} catch (invfmt) {err ();}
put ("#X: "); try {putf ("->%#X<-\n",4);} catch (invfmt) {err ();}
put ("X: "); try {putf ("->%X<-\n",-4);} catch (invfmt) {err ();}
put ("X: "); try {putf ("->%X<-\n",0);} catch (invfmt) {err ();}
put ("X: "); try {putf ("->%X<-\n",4);} catch (invfmt) {err ();}
put ("#0- +0d: "); try {putf ("->%#0- +0d<-\n",-4);} catch (invfmt) {err ();}
put ("#0- +0d: "); try {putf ("->%#0- +0d<-\n",0);} catch (invfmt) {err ();}
put ("#0- +0d: "); try {putf ("->%#0- +0d<-\n",4);} catch (invfmt) {err ();}
put ("0- +0d: "); try {putf ("->%0- +0d<-\n",-4);} catch (invfmt) {err ();}
put ("0- +0d: "); try {putf ("->%0- +0d<-\n",0);} catch (invfmt) {err ();}
put ("0- +0d: "); try {putf ("->%0- +0d<-\n",4);} catch (invfmt) {err ();}
put ("#- +0d: "); try {putf ("->%#- +0d<-\n",-4);} catch (invfmt) {err ();}
put ("#- +0d: "); try {putf ("->%#- +0d<-\n",0);} catch (invfmt) {err ();}
put ("#- +0d: "); try {putf ("->%#- +0d<-\n",4);} catch (invfmt) {err ();}
put ("- +0d: "); try {putf ("->%- +0d<-\n",-4);} catch (invfmt) {err ();}
put ("- +0d: "); try {putf ("->%- +0d<-\n",0);} catch (invfmt) {err ();}
put ("- +0d: "); try {putf ("->%- +0d<-\n",4);} catch (invfmt) {err ();}
put ("#0 +0d: "); try {putf ("->%#0 +0d<-\n",-4);} catch (invfmt) {err ();}
put ("#0 +0d: "); try {putf ("->%#0 +0d<-\n",0);} catch (invfmt) {err ();}
put ("#0 +0d: "); try {putf ("->%#0 +0d<-\n",4);} catch (invfmt) {err ();}
put ("0 +0d: "); try {putf ("->%0 +0d<-\n",-4);} catch (invfmt) {err ();}
put ("0 +0d: "); try {putf ("->%0 +0d<-\n",0);} catch (invfmt) {err ();}
put ("0 +0d: "); try {putf ("->%0 +0d<-\n",4);} catch (invfmt) {err ();}
put ("# +0d: "); try {putf ("->%# +0d<-\n",-4);} catch (invfmt) {err ();}
put ("# +0d: "); try {putf ("->%# +0d<-\n",0);} catch (invfmt) {err ();}
put ("# +0d: "); try {putf ("->%# +0d<-\n",4);} catch (invfmt) {err ();}
put (" +0d: "); try {putf ("->% +0d<-\n",-4);} catch (invfmt) {err ();}
put (" +0d: "); try {putf ("->% +0d<-\n",0);} catch (invfmt) {err ();}
put (" +0d: "); try {putf ("->% +0d<-\n",4);} catch (invfmt) {err ();}
put ("#0-+0d: "); try {putf ("->%#0-+0d<-\n",-4);} catch (invfmt) {err ();}
put ("#0-+0d: "); try {putf ("->%#0-+0d<-\n",0);} catch (invfmt) {err ();}
put ("#0-+0d: "); try {putf ("->%#0-+0d<-\n",4);} catch (invfmt) {err ();}
put ("0-+0d: "); try {putf ("->%0-+0d<-\n",-4);} catch (invfmt) {err ();}
put ("0-+0d: "); try {putf ("->%0-+0d<-\n",0);} catch (invfmt) {err ();}
put ("0-+0d: "); try {putf ("->%0-+0d<-\n",4);} catch (invfmt) {err ();}
put ("#-+0d: "); try {putf ("->%#-+0d<-\n",-4);} catch (invfmt) {err ();}
put ("#-+0d: "); try {putf ("->%#-+0d<-\n",0);} catch (invfmt) {err ();}
put ("#-+0d: "); try {putf ("->%#-+0d<-\n",4);} catch (invfmt) {err ();}
put ("-+0d: "); try {putf ("->%-+0d<-\n",-4);} catch (invfmt) {err ();}
put ("-+0d: "); try {putf ("->%-+0d<-\n",0);} catch (invfmt) {err ();}
put ("-+0d: "); try {putf ("->%-+0d<-\n",4);} catch (invfmt) {err ();}
put ("#0+0d: "); try {putf ("->%#0+0d<-\n",-4);} catch (invfmt) {err ();}
put ("#0+0d: "); try {putf ("->%#0+0d<-\n",0);} catch (invfmt) {err ();}
put ("#0+0d: "); try {putf ("->%#0+0d<-\n",4);} catch (invfmt) {err ();}
put ("0+0d: "); try {putf ("->%0+0d<-\n",-4);} catch (invfmt) {err ();}
put ("0+0d: "); try {putf ("->%0+0d<-\n",0);} catch (invfmt) {err ();}
put ("0+0d: "); try {putf ("->%0+0d<-\n",4);} catch (invfmt) {err ();}
put ("#+0d: "); try {putf ("->%#+0d<-\n",-4);} catch (invfmt) {err ();}
put ("#+0d: "); try {putf ("->%#+0d<-\n",0);} catch (invfmt) {err ();}
put ("#+0d: "); try {putf ("->%#+0d<-\n",4);} catch (invfmt) {err ();}
put ("+0d: "); try {putf ("->%+0d<-\n",-4);} catch (invfmt) {err ();}
put ("+0d: "); try {putf ("->%+0d<-\n",0);} catch (invfmt) {err ();}
put ("+0d: "); try {putf ("->%+0d<-\n",4);} catch (invfmt) {err ();}
put ("#0- 0d: "); try {putf ("->%#0- 0d<-\n",-4);} catch (invfmt) {err ();}
put ("#0- 0d: "); try {putf ("->%#0- 0d<-\n",0);} catch (invfmt) {err ();}
put ("#0- 0d: "); try {putf ("->%#0- 0d<-\n",4);} catch (invfmt) {err ();}
put ("0- 0d: "); try {putf ("->%0- 0d<-\n",-4);} catch (invfmt) {err ();}
put ("0- 0d: "); try {putf ("->%0- 0d<-\n",0);} catch (invfmt) {err ();}
put ("0- 0d: "); try {putf ("->%0- 0d<-\n",4);} catch (invfmt) {err ();}
put ("#- 0d: "); try {putf ("->%#- 0d<-\n",-4);} catch (invfmt) {err ();}
put ("#- 0d: "); try {putf ("->%#- 0d<-\n",0);} catch (invfmt) {err ();}
put ("#- 0d: "); try {putf ("->%#- 0d<-\n",4);} catch (invfmt) {err ();}
put ("- 0d: "); try {putf ("->%- 0d<-\n",-4);} catch (invfmt) {err ();}
put ("- 0d: "); try {putf ("->%- 0d<-\n",0);} catch (invfmt) {err ();}
put ("- 0d: "); try {putf ("->%- 0d<-\n",4);} catch (invfmt) {err ();}
put ("#0 0d: "); try {putf ("->%#0 0d<-\n",-4);} catch (invfmt) {err ();}
put ("#0 0d: "); try {putf ("->%#0 0d<-\n",0);} catch (invfmt) {err ();}
put ("#0 0d: "); try {putf ("->%#0 0d<-\n",4);} catch (invfmt) {err ();}
put ("0 0d: "); try {putf ("->%0 0d<-\n",-4);} catch (invfmt) {err ();}
put ("0 0d: "); try {putf ("->%0 0d<-\n",0);} catch (invfmt) {err ();}
put ("0 0d: "); try {putf ("->%0 0d<-\n",4);} catch (invfmt) {err ();}
put ("# 0d: "); try {putf ("->%# 0d<-\n",-4);} catch (invfmt) {err ();}
put ("# 0d: "); try {putf ("->%# 0d<-\n",0);} catch (invfmt) {err ();}
put ("# 0d: "); try {putf ("->%# 0d<-\n",4);} catch (invfmt) {err ();}
put (" 0d: "); try {putf ("->% 0d<-\n",-4);} catch (invfmt) {err ();}
put (" 0d: "); try {putf ("->% 0d<-\n",0);} catch (invfmt) {err ();}
put (" 0d: "); try {putf ("->% 0d<-\n",4);} catch (invfmt) {err ();}
put ("#0-0d: "); try {putf ("->%#0-0d<-\n",-4);} catch (invfmt) {err ();}
put ("#0-0d: "); try {putf ("->%#0-0d<-\n",0);} catch (invfmt) {err ();}
put ("#0-0d: "); try {putf ("->%#0-0d<-\n",4);} catch (invfmt) {err ();}
put ("0-0d: "); try {putf ("->%0-0d<-\n",-4);} catch (invfmt) {err ();}
put ("0-0d: "); try {putf ("->%0-0d<-\n",0);} catch (invfmt) {err ();}
put ("0-0d: "); try {putf ("->%0-0d<-\n",4);} catch (invfmt) {err ();}
put ("#-0d: "); try {putf ("->%#-0d<-\n",-4);} catch (invfmt) {err ();}
put ("#-0d: "); try {putf ("->%#-0d<-\n",0);} catch (invfmt) {err ();}
put ("#-0d: "); try {putf ("->%#-0d<-\n",4);} catch (invfmt) {err ();}
put ("-0d: "); try {putf ("->%-0d<-\n",-4);} catch (invfmt) {err ();}
put ("-0d: "); try {putf ("->%-0d<-\n",0);} catch (invfmt) {err ();}
put ("-0d: "); try {putf ("->%-0d<-\n",4);} catch (invfmt) {err ();}
put ("#00d: "); try {putf ("->%#00d<-\n",-4);} catch (invfmt) {err ();}
put ("#00d: "); try {putf ("->%#00d<-\n",0);} catch (invfmt) {err ();}
put ("#00d: "); try {putf ("->%#00d<-\n",4);} catch (invfmt) {err ();}
put ("00d: "); try {putf ("->%00d<-\n",-4);} catch (invfmt) {err ();}
put ("00d: "); try {putf ("->%00d<-\n",0);} catch (invfmt) {err ();}
put ("00d: "); try {putf ("->%00d<-\n",4);} catch (invfmt) {err ();}
put ("#0d: "); try {putf ("->%#0d<-\n",-4);} catch (invfmt) {err ();}
put ("#0d: "); try {putf ("->%#0d<-\n",0);} catch (invfmt) {err ();}
put ("#0d: "); try {putf ("->%#0d<-\n",4);} catch (invfmt) {err ();}
put ("0d: "); try {putf ("->%0d<-\n",-4);} catch (invfmt) {err ();}
put ("0d: "); try {putf ("->%0d<-\n",0);} catch (invfmt) {err ();}
put ("0d: "); try {putf ("->%0d<-\n",4);} catch (invfmt) {err ();}
put ("#0- +0o: "); try {putf ("->%#0- +0o<-\n",-4);} catch (invfmt) {err ();}
put ("#0- +0o: "); try {putf ("->%#0- +0o<-\n",0);} catch (invfmt) {err ();}
put ("#0- +0o: "); try {putf ("->%#0- +0o<-\n",4);} catch (invfmt) {err ();}
put ("0- +0o: "); try {putf ("->%0- +0o<-\n",-4);} catch (invfmt) {err ();}
put ("0- +0o: "); try {putf ("->%0- +0o<-\n",0);} catch (invfmt) {err ();}
put ("0- +0o: "); try {putf ("->%0- +0o<-\n",4);} catch (invfmt) {err ();}
put ("#- +0o: "); try {putf ("->%#- +0o<-\n",-4);} catch (invfmt) {err ();}
put ("#- +0o: "); try {putf ("->%#- +0o<-\n",0);} catch (invfmt) {err ();}
put ("#- +0o: "); try {putf ("->%#- +0o<-\n",4);} catch (invfmt) {err ();}
put ("- +0o: "); try {putf ("->%- +0o<-\n",-4);} catch (invfmt) {err ();}
put ("- +0o: "); try {putf ("->%- +0o<-\n",0);} catch (invfmt) {err ();}
put ("- +0o: "); try {putf ("->%- +0o<-\n",4);} catch (invfmt) {err ();}
put ("#0 +0o: "); try {putf ("->%#0 +0o<-\n",-4);} catch (invfmt) {err ();}
put ("#0 +0o: "); try {putf ("->%#0 +0o<-\n",0);} catch (invfmt) {err ();}
put ("#0 +0o: "); try {putf ("->%#0 +0o<-\n",4);} catch (invfmt) {err ();}
put ("0 +0o: "); try {putf ("->%0 +0o<-\n",-4);} catch (invfmt) {err ();}
put ("0 +0o: "); try {putf ("->%0 +0o<-\n",0);} catch (invfmt) {err ();}
put ("0 +0o: "); try {putf ("->%0 +0o<-\n",4);} catch (invfmt) {err ();}
put ("# +0o: "); try {putf ("->%# +0o<-\n",-4);} catch (invfmt) {err ();}
put ("# +0o: "); try {putf ("->%# +0o<-\n",0);} catch (invfmt) {err ();}
put ("# +0o: "); try {putf ("->%# +0o<-\n",4);} catch (invfmt) {err ();}
put (" +0o: "); try {putf ("->% +0o<-\n",-4);} catch (invfmt) {err ();}
put (" +0o: "); try {putf ("->% +0o<-\n",0);} catch (invfmt) {err ();}
put (" +0o: "); try {putf ("->% +0o<-\n",4);} catch (invfmt) {err ();}
put ("#0-+0o: "); try {putf ("->%#0-+0o<-\n",-4);} catch (invfmt) {err ();}
put ("#0-+0o: "); try {putf ("->%#0-+0o<-\n",0);} catch (invfmt) {err ();}
put ("#0-+0o: "); try {putf ("->%#0-+0o<-\n",4);} catch (invfmt) {err ();}
put ("0-+0o: "); try {putf ("->%0-+0o<-\n",-4);} catch (invfmt) {err ();}
put ("0-+0o: "); try {putf ("->%0-+0o<-\n",0);} catch (invfmt) {err ();}
put ("0-+0o: "); try {putf ("->%0-+0o<-\n",4);} catch (invfmt) {err ();}
put ("#-+0o: "); try {putf ("->%#-+0o<-\n",-4);} catch (invfmt) {err ();}
put ("#-+0o: "); try {putf ("->%#-+0o<-\n",0);} catch (invfmt) {err ();}
put ("#-+0o: "); try {putf ("->%#-+0o<-\n",4);} catch (invfmt) {err ();}
put ("-+0o: "); try {putf ("->%-+0o<-\n",-4);} catch (invfmt) {err ();}
put ("-+0o: "); try {putf ("->%-+0o<-\n",0);} catch (invfmt) {err ();}
put ("-+0o: "); try {putf ("->%-+0o<-\n",4);} catch (invfmt) {err ();}
put ("#0+0o: "); try {putf ("->%#0+0o<-\n",-4);} catch (invfmt) {err ();}
put ("#0+0o: "); try {putf ("->%#0+0o<-\n",0);} catch (invfmt) {err ();}
put ("#0+0o: "); try {putf ("->%#0+0o<-\n",4);} catch (invfmt) {err ();}
put ("0+0o: "); try {putf ("->%0+0o<-\n",-4);} catch (invfmt) {err ();}
put ("0+0o: "); try {putf ("->%0+0o<-\n",0);} catch (invfmt) {err ();}
put ("0+0o: "); try {putf ("->%0+0o<-\n",4);} catch (invfmt) {err ();}
put ("#+0o: "); try {putf ("->%#+0o<-\n",-4);} catch (invfmt) {err ();}
put ("#+0o: "); try {putf ("->%#+0o<-\n",0);} catch (invfmt) {err ();}
put ("#+0o: "); try {putf ("->%#+0o<-\n",4);} catch (invfmt) {err ();}
put ("+0o: "); try {putf ("->%+0o<-\n",-4);} catch (invfmt) {err ();}
put ("+0o: "); try {putf ("->%+0o<-\n",0);} catch (invfmt) {err ();}
put ("+0o: "); try {putf ("->%+0o<-\n",4);} catch (invfmt) {err ();}
put ("#0- 0o: "); try {putf ("->%#0- 0o<-\n",-4);} catch (invfmt) {err ();}
put ("#0- 0o: "); try {putf ("->%#0- 0o<-\n",0);} catch (invfmt) {err ();}
put ("#0- 0o: "); try {putf ("->%#0- 0o<-\n",4);} catch (invfmt) {err ();}
put ("0- 0o: "); try {putf ("->%0- 0o<-\n",-4);} catch (invfmt) {err ();}
put ("0- 0o: "); try {putf ("->%0- 0o<-\n",0);} catch (invfmt) {err ();}
put ("0- 0o: "); try {putf ("->%0- 0o<-\n",4);} catch (invfmt) {err ();}
put ("#- 0o: "); try {putf ("->%#- 0o<-\n",-4);} catch (invfmt) {err ();}
put ("#- 0o: "); try {putf ("->%#- 0o<-\n",0);} catch (invfmt) {err ();}
put ("#- 0o: "); try {putf ("->%#- 0o<-\n",4);} catch (invfmt) {err ();}
put ("- 0o: "); try {putf ("->%- 0o<-\n",-4);} catch (invfmt) {err ();}
put ("- 0o: "); try {putf ("->%- 0o<-\n",0);} catch (invfmt) {err ();}
put ("- 0o: "); try {putf ("->%- 0o<-\n",4);} catch (invfmt) {err ();}
put ("#0 0o: "); try {putf ("->%#0 0o<-\n",-4);} catch (invfmt) {err ();}
put ("#0 0o: "); try {putf ("->%#0 0o<-\n",0);} catch (invfmt) {err ();}
put ("#0 0o: "); try {putf ("->%#0 0o<-\n",4);} catch (invfmt) {err ();}
put ("0 0o: "); try {putf ("->%0 0o<-\n",-4);} catch (invfmt) {err ();}
put ("0 0o: "); try {putf ("->%0 0o<-\n",0);} catch (invfmt) {err ();}
put ("0 0o: "); try {putf ("->%0 0o<-\n",4);} catch (invfmt) {err ();}
put ("# 0o: "); try {putf ("->%# 0o<-\n",-4);} catch (invfmt) {err ();}
put ("# 0o: "); try {putf ("->%# 0o<-\n",0);} catch (invfmt) {err ();}
put ("# 0o: "); try {putf ("->%# 0o<-\n",4);} catch (invfmt) {err ();}
put (" 0o: "); try {putf ("->% 0o<-\n",-4);} catch (invfmt) {err ();}
put (" 0o: "); try {putf ("->% 0o<-\n",0);} catch (invfmt) {err ();}
put (" 0o: "); try {putf ("->% 0o<-\n",4);} catch (invfmt) {err ();}
put ("#0-0o: "); try {putf ("->%#0-0o<-\n",-4);} catch (invfmt) {err ();}
put ("#0-0o: "); try {putf ("->%#0-0o<-\n",0);} catch (invfmt) {err ();}
put ("#0-0o: "); try {putf ("->%#0-0o<-\n",4);} catch (invfmt) {err ();}
put ("0-0o: "); try {putf ("->%0-0o<-\n",-4);} catch (invfmt) {err ();}
put ("0-0o: "); try {putf ("->%0-0o<-\n",0);} catch (invfmt) {err ();}
put ("0-0o: "); try {putf ("->%0-0o<-\n",4);} catch (invfmt) {err ();}
put ("#-0o: "); try {putf ("->%#-0o<-\n",-4);} catch (invfmt) {err ();}
put ("#-0o: "); try {putf ("->%#-0o<-\n",0);} catch (invfmt) {err ();}
put ("#-0o: "); try {putf ("->%#-0o<-\n",4);} catch (invfmt) {err ();}
put ("-0o: "); try {putf ("->%-0o<-\n",-4);} catch (invfmt) {err ();}
put ("-0o: "); try {putf ("->%-0o<-\n",0);} catch (invfmt) {err ();}
put ("-0o: "); try {putf ("->%-0o<-\n",4);} catch (invfmt) {err ();}
put ("#00o: "); try {putf ("->%#00o<-\n",-4);} catch (invfmt) {err ();}
put ("#00o: "); try {putf ("->%#00o<-\n",0);} catch (invfmt) {err ();}
put ("#00o: "); try {putf ("->%#00o<-\n",4);} catch (invfmt) {err ();}
put ("00o: "); try {putf ("->%00o<-\n",-4);} catch (invfmt) {err ();}
put ("00o: "); try {putf ("->%00o<-\n",0);} catch (invfmt) {err ();}
put ("00o: "); try {putf ("->%00o<-\n",4);} catch (invfmt) {err ();}
put ("#0o: "); try {putf ("->%#0o<-\n",-4);} catch (invfmt) {err ();}
put ("#0o: "); try {putf ("->%#0o<-\n",0);} catch (invfmt) {err ();}
put ("#0o: "); try {putf ("->%#0o<-\n",4);} catch (invfmt) {err ();}
put ("0o: "); try {putf ("->%0o<-\n",-4);} catch (invfmt) {err ();}
put ("0o: "); try {putf ("->%0o<-\n",0);} catch (invfmt) {err ();}
put ("0o: "); try {putf ("->%0o<-\n",4);} catch (invfmt) {err ();}
put ("#0- +0x: "); try {putf ("->%#0- +0x<-\n",-4);} catch (invfmt) {err ();}
put ("#0- +0x: "); try {putf ("->%#0- +0x<-\n",0);} catch (invfmt) {err ();}
put ("#0- +0x: "); try {putf ("->%#0- +0x<-\n",4);} catch (invfmt) {err ();}
put ("0- +0x: "); try {putf ("->%0- +0x<-\n",-4);} catch (invfmt) {err ();}
put ("0- +0x: "); try {putf ("->%0- +0x<-\n",0);} catch (invfmt) {err ();}
put ("0- +0x: "); try {putf ("->%0- +0x<-\n",4);} catch (invfmt) {err ();}
put ("#- +0x: "); try {putf ("->%#- +0x<-\n",-4);} catch (invfmt) {err ();}
put ("#- +0x: "); try {putf ("->%#- +0x<-\n",0);} catch (invfmt) {err ();}
put ("#- +0x: "); try {putf ("->%#- +0x<-\n",4);} catch (invfmt) {err ();}
put ("- +0x: "); try {putf ("->%- +0x<-\n",-4);} catch (invfmt) {err ();}
put ("- +0x: "); try {putf ("->%- +0x<-\n",0);} catch (invfmt) {err ();}
put ("- +0x: "); try {putf ("->%- +0x<-\n",4);} catch (invfmt) {err ();}
put ("#0 +0x: "); try {putf ("->%#0 +0x<-\n",-4);} catch (invfmt) {err ();}
put ("#0 +0x: "); try {putf ("->%#0 +0x<-\n",0);} catch (invfmt) {err ();}
put ("#0 +0x: "); try {putf ("->%#0 +0x<-\n",4);} catch (invfmt) {err ();}
put ("0 +0x: "); try {putf ("->%0 +0x<-\n",-4);} catch (invfmt) {err ();}
put ("0 +0x: "); try {putf ("->%0 +0x<-\n",0);} catch (invfmt) {err ();}
put ("0 +0x: "); try {putf ("->%0 +0x<-\n",4);} catch (invfmt) {err ();}
put ("# +0x: "); try {putf ("->%# +0x<-\n",-4);} catch (invfmt) {err ();}
put ("# +0x: "); try {putf ("->%# +0x<-\n",0);} catch (invfmt) {err ();}
put ("# +0x: "); try {putf ("->%# +0x<-\n",4);} catch (invfmt) {err ();}
put (" +0x: "); try {putf ("->% +0x<-\n",-4);} catch (invfmt) {err ();}
put (" +0x: "); try {putf ("->% +0x<-\n",0);} catch (invfmt) {err ();}
put (" +0x: "); try {putf ("->% +0x<-\n",4);} catch (invfmt) {err ();}
put ("#0-+0x: "); try {putf ("->%#0-+0x<-\n",-4);} catch (invfmt) {err ();}
put ("#0-+0x: "); try {putf ("->%#0-+0x<-\n",0);} catch (invfmt) {err ();}
put ("#0-+0x: "); try {putf ("->%#0-+0x<-\n",4);} catch (invfmt) {err ();}
put ("0-+0x: "); try {putf ("->%0-+0x<-\n",-4);} catch (invfmt) {err ();}
put ("0-+0x: "); try {putf ("->%0-+0x<-\n",0);} catch (invfmt) {err ();}
put ("0-+0x: "); try {putf ("->%0-+0x<-\n",4);} catch (invfmt) {err ();}
put ("#-+0x: "); try {putf ("->%#-+0x<-\n",-4);} catch (invfmt) {err ();}
put ("#-+0x: "); try {putf ("->%#-+0x<-\n",0);} catch (invfmt) {err ();}
put ("#-+0x: "); try {putf ("->%#-+0x<-\n",4);} catch (invfmt) {err ();}
put ("-+0x: "); try {putf ("->%-+0x<-\n",-4);} catch (invfmt) {err ();}
put ("-+0x: "); try {putf ("->%-+0x<-\n",0);} catch (invfmt) {err ();}
put ("-+0x: "); try {putf ("->%-+0x<-\n",4);} catch (invfmt) {err ();}
put ("#0+0x: "); try {putf ("->%#0+0x<-\n",-4);} catch (invfmt) {err ();}
put ("#0+0x: "); try {putf ("->%#0+0x<-\n",0);} catch (invfmt) {err ();}
put ("#0+0x: "); try {putf ("->%#0+0x<-\n",4);} catch (invfmt) {err ();}
put ("0+0x: "); try {putf ("->%0+0x<-\n",-4);} catch (invfmt) {err ();}
put ("0+0x: "); try {putf ("->%0+0x<-\n",0);} catch (invfmt) {err ();}
put ("0+0x: "); try {putf ("->%0+0x<-\n",4);} catch (invfmt) {err ();}
put ("#+0x: "); try {putf ("->%#+0x<-\n",-4);} catch (invfmt) {err ();}
put ("#+0x: "); try {putf ("->%#+0x<-\n",0);} catch (invfmt) {err ();}
put ("#+0x: "); try {putf ("->%#+0x<-\n",4);} catch (invfmt) {err ();}
put ("+0x: "); try {putf ("->%+0x<-\n",-4);} catch (invfmt) {err ();}
put ("+0x: "); try {putf ("->%+0x<-\n",0);} catch (invfmt) {err ();}
put ("+0x: "); try {putf ("->%+0x<-\n",4);} catch (invfmt) {err ();}
put ("#0- 0x: "); try {putf ("->%#0- 0x<-\n",-4);} catch (invfmt) {err ();}
put ("#0- 0x: "); try {putf ("->%#0- 0x<-\n",0);} catch (invfmt) {err ();}
put ("#0- 0x: "); try {putf ("->%#0- 0x<-\n",4);} catch (invfmt) {err ();}
put ("0- 0x: "); try {putf ("->%0- 0x<-\n",-4);} catch (invfmt) {err ();}
put ("0- 0x: "); try {putf ("->%0- 0x<-\n",0);} catch (invfmt) {err ();}
put ("0- 0x: "); try {putf ("->%0- 0x<-\n",4);} catch (invfmt) {err ();}
put ("#- 0x: "); try {putf ("->%#- 0x<-\n",-4);} catch (invfmt) {err ();}
put ("#- 0x: "); try {putf ("->%#- 0x<-\n",0);} catch (invfmt) {err ();}
put ("#- 0x: "); try {putf ("->%#- 0x<-\n",4);} catch (invfmt) {err ();}
put ("- 0x: "); try {putf ("->%- 0x<-\n",-4);} catch (invfmt) {err ();}
put ("- 0x: "); try {putf ("->%- 0x<-\n",0);} catch (invfmt) {err ();}
put ("- 0x: "); try {putf ("->%- 0x<-\n",4);} catch (invfmt) {err ();}
put ("#0 0x: "); try {putf ("->%#0 0x<-\n",-4);} catch (invfmt) {err ();}
put ("#0 0x: "); try {putf ("->%#0 0x<-\n",0);} catch (invfmt) {err ();}
put ("#0 0x: "); try {putf ("->%#0 0x<-\n",4);} catch (invfmt) {err ();}
put ("0 0x: "); try {putf ("->%0 0x<-\n",-4);} catch (invfmt) {err ();}
put ("0 0x: "); try {putf ("->%0 0x<-\n",0);} catch (invfmt) {err ();}
put ("0 0x: "); try {putf ("->%0 0x<-\n",4);} catch (invfmt) {err ();}
put ("# 0x: "); try {putf ("->%# 0x<-\n",-4);} catch (invfmt) {err ();}
put ("# 0x: "); try {putf ("->%# 0x<-\n",0);} catch (invfmt) {err ();}
put ("# 0x: "); try {putf ("->%# 0x<-\n",4);} catch (invfmt) {err ();}
put (" 0x: "); try {putf ("->% 0x<-\n",-4);} catch (invfmt) {err ();}
put (" 0x: "); try {putf ("->% 0x<-\n",0);} catch (invfmt) {err ();}
put (" 0x: "); try {putf ("->% 0x<-\n",4);} catch (invfmt) {err ();}
put ("#0-0x: "); try {putf ("->%#0-0x<-\n",-4);} catch (invfmt) {err ();}
put ("#0-0x: "); try {putf ("->%#0-0x<-\n",0);} catch (invfmt) {err ();}
put ("#0-0x: "); try {putf ("->%#0-0x<-\n",4);} catch (invfmt) {err ();}
put ("0-0x: "); try {putf ("->%0-0x<-\n",-4);} catch (invfmt) {err ();}
put ("0-0x: "); try {putf ("->%0-0x<-\n",0);} catch (invfmt) {err ();}
put ("0-0x: "); try {putf ("->%0-0x<-\n",4);} catch (invfmt) {err ();}
put ("#-0x: "); try {putf ("->%#-0x<-\n",-4);} catch (invfmt) {err ();}
put ("#-0x: "); try {putf ("->%#-0x<-\n",0);} catch (invfmt) {err ();}
put ("#-0x: "); try {putf ("->%#-0x<-\n",4);} catch (invfmt) {err ();}
put ("-0x: "); try {putf ("->%-0x<-\n",-4);} catch (invfmt) {err ();}
put ("-0x: "); try {putf ("->%-0x<-\n",0);} catch (invfmt) {err ();}
put ("-0x: "); try {putf ("->%-0x<-\n",4);} catch (invfmt) {err ();}
put ("#00x: "); try {putf ("->%#00x<-\n",-4);} catch (invfmt) {err ();}
put ("#00x: "); try {putf ("->%#00x<-\n",0);} catch (invfmt) {err ();}
put ("#00x: "); try {putf ("->%#00x<-\n",4);} catch (invfmt) {err ();}
put ("00x: "); try {putf ("->%00x<-\n",-4);} catch (invfmt) {err ();}
put ("00x: "); try {putf ("->%00x<-\n",0);} catch (invfmt) {err ();}
put ("00x: "); try {putf ("->%00x<-\n",4);} catch (invfmt) {err ();}
put ("#0x: "); try {putf ("->%#0x<-\n",-4);} catch (invfmt) {err ();}
put ("#0x: "); try {putf ("->%#0x<-\n",0);} catch (invfmt) {err ();}
put ("#0x: "); try {putf ("->%#0x<-\n",4);} catch (invfmt) {err ();}
put ("0x: "); try {putf ("->%0x<-\n",-4);} catch (invfmt) {err ();}
put ("0x: "); try {putf ("->%0x<-\n",0);} catch (invfmt) {err ();}
put ("0x: "); try {putf ("->%0x<-\n",4);} catch (invfmt) {err ();}
put ("#0- +0X: "); try {putf ("->%#0- +0X<-\n",-4);} catch (invfmt) {err ();}
put ("#0- +0X: "); try {putf ("->%#0- +0X<-\n",0);} catch (invfmt) {err ();}
put ("#0- +0X: "); try {putf ("->%#0- +0X<-\n",4);} catch (invfmt) {err ();}
put ("0- +0X: "); try {putf ("->%0- +0X<-\n",-4);} catch (invfmt) {err ();}
put ("0- +0X: "); try {putf ("->%0- +0X<-\n",0);} catch (invfmt) {err ();}
put ("0- +0X: "); try {putf ("->%0- +0X<-\n",4);} catch (invfmt) {err ();}
put ("#- +0X: "); try {putf ("->%#- +0X<-\n",-4);} catch (invfmt) {err ();}
put ("#- +0X: "); try {putf ("->%#- +0X<-\n",0);} catch (invfmt) {err ();}
put ("#- +0X: "); try {putf ("->%#- +0X<-\n",4);} catch (invfmt) {err ();}
put ("- +0X: "); try {putf ("->%- +0X<-\n",-4);} catch (invfmt) {err ();}
put ("- +0X: "); try {putf ("->%- +0X<-\n",0);} catch (invfmt) {err ();}
put ("- +0X: "); try {putf ("->%- +0X<-\n",4);} catch (invfmt) {err ();}
put ("#0 +0X: "); try {putf ("->%#0 +0X<-\n",-4);} catch (invfmt) {err ();}
put ("#0 +0X: "); try {putf ("->%#0 +0X<-\n",0);} catch (invfmt) {err ();}
put ("#0 +0X: "); try {putf ("->%#0 +0X<-\n",4);} catch (invfmt) {err ();}
put ("0 +0X: "); try {putf ("->%0 +0X<-\n",-4);} catch (invfmt) {err ();}
put ("0 +0X: "); try {putf ("->%0 +0X<-\n",0);} catch (invfmt) {err ();}
put ("0 +0X: "); try {putf ("->%0 +0X<-\n",4);} catch (invfmt) {err ();}
put ("# +0X: "); try {putf ("->%# +0X<-\n",-4);} catch (invfmt) {err ();}
put ("# +0X: "); try {putf ("->%# +0X<-\n",0);} catch (invfmt) {err ();}
put ("# +0X: "); try {putf ("->%# +0X<-\n",4);} catch (invfmt) {err ();}
put (" +0X: "); try {putf ("->% +0X<-\n",-4);} catch (invfmt) {err ();}
put (" +0X: "); try {putf ("->% +0X<-\n",0);} catch (invfmt) {err ();}
put (" +0X: "); try {putf ("->% +0X<-\n",4);} catch (invfmt) {err ();}
put ("#0-+0X: "); try {putf ("->%#0-+0X<-\n",-4);} catch (invfmt) {err ();}
put ("#0-+0X: "); try {putf ("->%#0-+0X<-\n",0);} catch (invfmt) {err ();}
put ("#0-+0X: "); try {putf ("->%#0-+0X<-\n",4);} catch (invfmt) {err ();}
put ("0-+0X: "); try {putf ("->%0-+0X<-\n",-4);} catch (invfmt) {err ();}
put ("0-+0X: "); try {putf ("->%0-+0X<-\n",0);} catch (invfmt) {err ();}
put ("0-+0X: "); try {putf ("->%0-+0X<-\n",4);} catch (invfmt) {err ();}
put ("#-+0X: "); try {putf ("->%#-+0X<-\n",-4);} catch (invfmt) {err ();}
put ("#-+0X: "); try {putf ("->%#-+0X<-\n",0);} catch (invfmt) {err ();}
put ("#-+0X: "); try {putf ("->%#-+0X<-\n",4);} catch (invfmt) {err ();}
put ("-+0X: "); try {putf ("->%-+0X<-\n",-4);} catch (invfmt) {err ();}
put ("-+0X: "); try {putf ("->%-+0X<-\n",0);} catch (invfmt) {err ();}
put ("-+0X: "); try {putf ("->%-+0X<-\n",4);} catch (invfmt) {err ();}
put ("#0+0X: "); try {putf ("->%#0+0X<-\n",-4);} catch (invfmt) {err ();}
put ("#0+0X: "); try {putf ("->%#0+0X<-\n",0);} catch (invfmt) {err ();}
put ("#0+0X: "); try {putf ("->%#0+0X<-\n",4);} catch (invfmt) {err ();}
put ("0+0X: "); try {putf ("->%0+0X<-\n",-4);} catch (invfmt) {err ();}
put ("0+0X: "); try {putf ("->%0+0X<-\n",0);} catch (invfmt) {err ();}
put ("0+0X: "); try {putf ("->%0+0X<-\n",4);} catch (invfmt) {err ();}
put ("#+0X: "); try {putf ("->%#+0X<-\n",-4);} catch (invfmt) {err ();}
put ("#+0X: "); try {putf ("->%#+0X<-\n",0);} catch (invfmt) {err ();}
put ("#+0X: "); try {putf ("->%#+0X<-\n",4);} catch (invfmt) {err ();}
put ("+0X: "); try {putf ("->%+0X<-\n",-4);} catch (invfmt) {err ();}
put ("+0X: "); try {putf ("->%+0X<-\n",0);} catch (invfmt) {err ();}
put ("+0X: "); try {putf ("->%+0X<-\n",4);} catch (invfmt) {err ();}
put ("#0- 0X: "); try {putf ("->%#0- 0X<-\n",-4);} catch (invfmt) {err ();}
put ("#0- 0X: "); try {putf ("->%#0- 0X<-\n",0);} catch (invfmt) {err ();}
put ("#0- 0X: "); try {putf ("->%#0- 0X<-\n",4);} catch (invfmt) {err ();}
put ("0- 0X: "); try {putf ("->%0- 0X<-\n",-4);} catch (invfmt) {err ();}
put ("0- 0X: "); try {putf ("->%0- 0X<-\n",0);} catch (invfmt) {err ();}
put ("0- 0X: "); try {putf ("->%0- 0X<-\n",4);} catch (invfmt) {err ();}
put ("#- 0X: "); try {putf ("->%#- 0X<-\n",-4);} catch (invfmt) {err ();}
put ("#- 0X: "); try {putf ("->%#- 0X<-\n",0);} catch (invfmt) {err ();}
put ("#- 0X: "); try {putf ("->%#- 0X<-\n",4);} catch (invfmt) {err ();}
put ("- 0X: "); try {putf ("->%- 0X<-\n",-4);} catch (invfmt) {err ();}
put ("- 0X: "); try {putf ("->%- 0X<-\n",0);} catch (invfmt) {err ();}
put ("- 0X: "); try {putf ("->%- 0X<-\n",4);} catch (invfmt) {err ();}
put ("#0 0X: "); try {putf ("->%#0 0X<-\n",-4);} catch (invfmt) {err ();}
put ("#0 0X: "); try {putf ("->%#0 0X<-\n",0);} catch (invfmt) {err ();}
put ("#0 0X: "); try {putf ("->%#0 0X<-\n",4);} catch (invfmt) {err ();}
put ("0 0X: "); try {putf ("->%0 0X<-\n",-4);} catch (invfmt) {err ();}
put ("0 0X: "); try {putf ("->%0 0X<-\n",0);} catch (invfmt) {err ();}
put ("0 0X: "); try {putf ("->%0 0X<-\n",4);} catch (invfmt) {err ();}
put ("# 0X: "); try {putf ("->%# 0X<-\n",-4);} catch (invfmt) {err ();}
put ("# 0X: "); try {putf ("->%# 0X<-\n",0);} catch (invfmt) {err ();}
put ("# 0X: "); try {putf ("->%# 0X<-\n",4);} catch (invfmt) {err ();}
put (" 0X: "); try {putf ("->% 0X<-\n",-4);} catch (invfmt) {err ();}
put (" 0X: "); try {putf ("->% 0X<-\n",0);} catch (invfmt) {err ();}
put (" 0X: "); try {putf ("->% 0X<-\n",4);} catch (invfmt) {err ();}
put ("#0-0X: "); try {putf ("->%#0-0X<-\n",-4);} catch (invfmt) {err ();}
put ("#0-0X: "); try {putf ("->%#0-0X<-\n",0);} catch (invfmt) {err ();}
put ("#0-0X: "); try {putf ("->%#0-0X<-\n",4);} catch (invfmt) {err ();}
put ("0-0X: "); try {putf ("->%0-0X<-\n",-4);} catch (invfmt) {err ();}
put ("0-0X: "); try {putf ("->%0-0X<-\n",0);} catch (invfmt) {err ();}
put ("0-0X: "); try {putf ("->%0-0X<-\n",4);} catch (invfmt) {err ();}
put ("#-0X: "); try {putf ("->%#-0X<-\n",-4);} catch (invfmt) {err ();}
put ("#-0X: "); try {putf ("->%#-0X<-\n",0);} catch (invfmt) {err ();}
put ("#-0X: "); try {putf ("->%#-0X<-\n",4);} catch (invfmt) {err ();}
put ("-0X: "); try {putf ("->%-0X<-\n",-4);} catch (invfmt) {err ();}
put ("-0X: "); try {putf ("->%-0X<-\n",0);} catch (invfmt) {err ();}
put ("-0X: "); try {putf ("->%-0X<-\n",4);} catch (invfmt) {err ();}
put ("#00X: "); try {putf ("->%#00X<-\n",-4);} catch (invfmt) {err ();}
put ("#00X: "); try {putf ("->%#00X<-\n",0);} catch (invfmt) {err ();}
put ("#00X: "); try {putf ("->%#00X<-\n",4);} catch (invfmt) {err ();}
put ("00X: "); try {putf ("->%00X<-\n",-4);} catch (invfmt) {err ();}
put ("00X: "); try {putf ("->%00X<-\n",0);} catch (invfmt) {err ();}
put ("00X: "); try {putf ("->%00X<-\n",4);} catch (invfmt) {err ();}
put ("#0X: "); try {putf ("->%#0X<-\n",-4);} catch (invfmt) {err ();}
put ("#0X: "); try {putf ("->%#0X<-\n",0);} catch (invfmt) {err ();}
put ("#0X: "); try {putf ("->%#0X<-\n",4);} catch (invfmt) {err ();}
put ("0X: "); try {putf ("->%0X<-\n",-4);} catch (invfmt) {err ();}
put ("0X: "); try {putf ("->%0X<-\n",0);} catch (invfmt) {err ();}
put ("0X: "); try {putf ("->%0X<-\n",4);} catch (invfmt) {err ();}
put ("#0- +10d: "); try {putf ("->%#0- +10d<-\n",-4);} catch (invfmt) {err ();}
put ("#0- +10d: "); try {putf ("->%#0- +10d<-\n",0);} catch (invfmt) {err ();}
put ("#0- +10d: "); try {putf ("->%#0- +10d<-\n",4);} catch (invfmt) {err ();}
put ("0- +10d: "); try {putf ("->%0- +10d<-\n",-4);} catch (invfmt) {err ();}
put ("0- +10d: "); try {putf ("->%0- +10d<-\n",0);} catch (invfmt) {err ();}
put ("0- +10d: "); try {putf ("->%0- +10d<-\n",4);} catch (invfmt) {err ();}
put ("#- +10d: "); try {putf ("->%#- +10d<-\n",-4);} catch (invfmt) {err ();}
put ("#- +10d: "); try {putf ("->%#- +10d<-\n",0);} catch (invfmt) {err ();}
put ("#- +10d: "); try {putf ("->%#- +10d<-\n",4);} catch (invfmt) {err ();}
put ("- +10d: "); try {putf ("->%- +10d<-\n",-4);} catch (invfmt) {err ();}
put ("- +10d: "); try {putf ("->%- +10d<-\n",0);} catch (invfmt) {err ();}
put ("- +10d: "); try {putf ("->%- +10d<-\n",4);} catch (invfmt) {err ();}
put ("#0 +10d: "); try {putf ("->%#0 +10d<-\n",-4);} catch (invfmt) {err ();}
put ("#0 +10d: "); try {putf ("->%#0 +10d<-\n",0);} catch (invfmt) {err ();}
put ("#0 +10d: "); try {putf ("->%#0 +10d<-\n",4);} catch (invfmt) {err ();}
put ("0 +10d: "); try {putf ("->%0 +10d<-\n",-4);} catch (invfmt) {err ();}
put ("0 +10d: "); try {putf ("->%0 +10d<-\n",0);} catch (invfmt) {err ();}
put ("0 +10d: "); try {putf ("->%0 +10d<-\n",4);} catch (invfmt) {err ();}
put ("# +10d: "); try {putf ("->%# +10d<-\n",-4);} catch (invfmt) {err ();}
put ("# +10d: "); try {putf ("->%# +10d<-\n",0);} catch (invfmt) {err ();}
put ("# +10d: "); try {putf ("->%# +10d<-\n",4);} catch (invfmt) {err ();}
put (" +10d: "); try {putf ("->% +10d<-\n",-4);} catch (invfmt) {err ();}
put (" +10d: "); try {putf ("->% +10d<-\n",0);} catch (invfmt) {err ();}
put (" +10d: "); try {putf ("->% +10d<-\n",4);} catch (invfmt) {err ();}
put ("#0-+10d: "); try {putf ("->%#0-+10d<-\n",-4);} catch (invfmt) {err ();}
put ("#0-+10d: "); try {putf ("->%#0-+10d<-\n",0);} catch (invfmt) {err ();}
put ("#0-+10d: "); try {putf ("->%#0-+10d<-\n",4);} catch (invfmt) {err ();}
put ("0-+10d: "); try {putf ("->%0-+10d<-\n",-4);} catch (invfmt) {err ();}
put ("0-+10d: "); try {putf ("->%0-+10d<-\n",0);} catch (invfmt) {err ();}
put ("0-+10d: "); try {putf ("->%0-+10d<-\n",4);} catch (invfmt) {err ();}
put ("#-+10d: "); try {putf ("->%#-+10d<-\n",-4);} catch (invfmt) {err ();}
put ("#-+10d: "); try {putf ("->%#-+10d<-\n",0);} catch (invfmt) {err ();}
put ("#-+10d: "); try {putf ("->%#-+10d<-\n",4);} catch (invfmt) {err ();}
put ("-+10d: "); try {putf ("->%-+10d<-\n",-4);} catch (invfmt) {err ();}
put ("-+10d: "); try {putf ("->%-+10d<-\n",0);} catch (invfmt) {err ();}
put ("-+10d: "); try {putf ("->%-+10d<-\n",4);} catch (invfmt) {err ();}
put ("#0+10d: "); try {putf ("->%#0+10d<-\n",-4);} catch (invfmt) {err ();}
put ("#0+10d: "); try {putf ("->%#0+10d<-\n",0);} catch (invfmt) {err ();}
put ("#0+10d: "); try {putf ("->%#0+10d<-\n",4);} catch (invfmt) {err ();}
put ("0+10d: "); try {putf ("->%0+10d<-\n",-4);} catch (invfmt) {err ();}
put ("0+10d: "); try {putf ("->%0+10d<-\n",0);} catch (invfmt) {err ();}
put ("0+10d: "); try {putf ("->%0+10d<-\n",4);} catch (invfmt) {err ();}
put ("#+10d: "); try {putf ("->%#+10d<-\n",-4);} catch (invfmt) {err ();}
put ("#+10d: "); try {putf ("->%#+10d<-\n",0);} catch (invfmt) {err ();}
put ("#+10d: "); try {putf ("->%#+10d<-\n",4);} catch (invfmt) {err ();}
put ("+10d: "); try {putf ("->%+10d<-\n",-4);} catch (invfmt) {err ();}
put ("+10d: "); try {putf ("->%+10d<-\n",0);} catch (invfmt) {err ();}
put ("+10d: "); try {putf ("->%+10d<-\n",4);} catch (invfmt) {err ();}
put ("#0- 10d: "); try {putf ("->%#0- 10d<-\n",-4);} catch (invfmt) {err ();}
put ("#0- 10d: "); try {putf ("->%#0- 10d<-\n",0);} catch (invfmt) {err ();}
put ("#0- 10d: "); try {putf ("->%#0- 10d<-\n",4);} catch (invfmt) {err ();}
put ("0- 10d: "); try {putf ("->%0- 10d<-\n",-4);} catch (invfmt) {err ();}
put ("0- 10d: "); try {putf ("->%0- 10d<-\n",0);} catch (invfmt) {err ();}
put ("0- 10d: "); try {putf ("->%0- 10d<-\n",4);} catch (invfmt) {err ();}
put ("#- 10d: "); try {putf ("->%#- 10d<-\n",-4);} catch (invfmt) {err ();}
put ("#- 10d: "); try {putf ("->%#- 10d<-\n",0);} catch (invfmt) {err ();}
put ("#- 10d: "); try {putf ("->%#- 10d<-\n",4);} catch (invfmt) {err ();}
put ("- 10d: "); try {putf ("->%- 10d<-\n",-4);} catch (invfmt) {err ();}
put ("- 10d: "); try {putf ("->%- 10d<-\n",0);} catch (invfmt) {err ();}
put ("- 10d: "); try {putf ("->%- 10d<-\n",4);} catch (invfmt) {err ();}
put ("#0 10d: "); try {putf ("->%#0 10d<-\n",-4);} catch (invfmt) {err ();}
put ("#0 10d: "); try {putf ("->%#0 10d<-\n",0);} catch (invfmt) {err ();}
put ("#0 10d: "); try {putf ("->%#0 10d<-\n",4);} catch (invfmt) {err ();}
put ("0 10d: "); try {putf ("->%0 10d<-\n",-4);} catch (invfmt) {err ();}
put ("0 10d: "); try {putf ("->%0 10d<-\n",0);} catch (invfmt) {err ();}
put ("0 10d: "); try {putf ("->%0 10d<-\n",4);} catch (invfmt) {err ();}
put ("# 10d: "); try {putf ("->%# 10d<-\n",-4);} catch (invfmt) {err ();}
put ("# 10d: "); try {putf ("->%# 10d<-\n",0);} catch (invfmt) {err ();}
put ("# 10d: "); try {putf ("->%# 10d<-\n",4);} catch (invfmt) {err ();}
put (" 10d: "); try {putf ("->% 10d<-\n",-4);} catch (invfmt) {err ();}
put (" 10d: "); try {putf ("->% 10d<-\n",0);} catch (invfmt) {err ();}
put (" 10d: "); try {putf ("->% 10d<-\n",4);} catch (invfmt) {err ();}
put ("#0-10d: "); try {putf ("->%#0-10d<-\n",-4);} catch (invfmt) {err ();}
put ("#0-10d: "); try {putf ("->%#0-10d<-\n",0);} catch (invfmt) {err ();}
put ("#0-10d: "); try {putf ("->%#0-10d<-\n",4);} catch (invfmt) {err ();}
put ("0-10d: "); try {putf ("->%0-10d<-\n",-4);} catch (invfmt) {err ();}
put ("0-10d: "); try {putf ("->%0-10d<-\n",0);} catch (invfmt) {err ();}
put ("0-10d: "); try {putf ("->%0-10d<-\n",4);} catch (invfmt) {err ();}
put ("#-10d: "); try {putf ("->%#-10d<-\n",-4);} catch (invfmt) {err ();}
put ("#-10d: "); try {putf ("->%#-10d<-\n",0);} catch (invfmt) {err ();}
put ("#-10d: "); try {putf ("->%#-10d<-\n",4);} catch (invfmt) {err ();}
put ("-10d: "); try {putf ("->%-10d<-\n",-4);} catch (invfmt) {err ();}
put ("-10d: "); try {putf ("->%-10d<-\n",0);} catch (invfmt) {err ();}
put ("-10d: "); try {putf ("->%-10d<-\n",4);} catch (invfmt) {err ();}
put ("#010d: "); try {putf ("->%#010d<-\n",-4);} catch (invfmt) {err ();}
put ("#010d: "); try {putf ("->%#010d<-\n",0);} catch (invfmt) {err ();}
put ("#010d: "); try {putf ("->%#010d<-\n",4);} catch (invfmt) {err ();}
put ("010d: "); try {putf ("->%010d<-\n",-4);} catch (invfmt) {err ();}
put ("010d: "); try {putf ("->%010d<-\n",0);} catch (invfmt) {err ();}
put ("010d: "); try {putf ("->%010d<-\n",4);} catch (invfmt) {err ();}
put ("#10d: "); try {putf ("->%#10d<-\n",-4);} catch (invfmt) {err ();}
put ("#10d: "); try {putf ("->%#10d<-\n",0);} catch (invfmt) {err ();}
put ("#10d: "); try {putf ("->%#10d<-\n",4);} catch (invfmt) {err ();}
put ("10d: "); try {putf ("->%10d<-\n",-4);} catch (invfmt) {err ();}
put ("10d: "); try {putf ("->%10d<-\n",0);} catch (invfmt) {err ();}
put ("10d: "); try {putf ("->%10d<-\n",4);} catch (invfmt) {err ();}
put ("#0- +10o: "); try {putf ("->%#0- +10o<-\n",-4);} catch (invfmt) {err ();}
put ("#0- +10o: "); try {putf ("->%#0- +10o<-\n",0);} catch (invfmt) {err ();}
put ("#0- +10o: "); try {putf ("->%#0- +10o<-\n",4);} catch (invfmt) {err ();}
put ("0- +10o: "); try {putf ("->%0- +10o<-\n",-4);} catch (invfmt) {err ();}
put ("0- +10o: "); try {putf ("->%0- +10o<-\n",0);} catch (invfmt) {err ();}
put ("0- +10o: "); try {putf ("->%0- +10o<-\n",4);} catch (invfmt) {err ();}
put ("#- +10o: "); try {putf ("->%#- +10o<-\n",-4);} catch (invfmt) {err ();}
put ("#- +10o: "); try {putf ("->%#- +10o<-\n",0);} catch (invfmt) {err ();}
put ("#- +10o: "); try {putf ("->%#- +10o<-\n",4);} catch (invfmt) {err ();}
put ("- +10o: "); try {putf ("->%- +10o<-\n",-4);} catch (invfmt) {err ();}
put ("- +10o: "); try {putf ("->%- +10o<-\n",0);} catch (invfmt) {err ();}
put ("- +10o: "); try {putf ("->%- +10o<-\n",4);} catch (invfmt) {err ();}
put ("#0 +10o: "); try {putf ("->%#0 +10o<-\n",-4);} catch (invfmt) {err ();}
put ("#0 +10o: "); try {putf ("->%#0 +10o<-\n",0);} catch (invfmt) {err ();}
put ("#0 +10o: "); try {putf ("->%#0 +10o<-\n",4);} catch (invfmt) {err ();}
put ("0 +10o: "); try {putf ("->%0 +10o<-\n",-4);} catch (invfmt) {err ();}
put ("0 +10o: "); try {putf ("->%0 +10o<-\n",0);} catch (invfmt) {err ();}
put ("0 +10o: "); try {putf ("->%0 +10o<-\n",4);} catch (invfmt) {err ();}
put ("# +10o: "); try {putf ("->%# +10o<-\n",-4);} catch (invfmt) {err ();}
put ("# +10o: "); try {putf ("->%# +10o<-\n",0);} catch (invfmt) {err ();}
put ("# +10o: "); try {putf ("->%# +10o<-\n",4);} catch (invfmt) {err ();}
put (" +10o: "); try {putf ("->% +10o<-\n",-4);} catch (invfmt) {err ();}
put (" +10o: "); try {putf ("->% +10o<-\n",0);} catch (invfmt) {err ();}
put (" +10o: "); try {putf ("->% +10o<-\n",4);} catch (invfmt) {err ();}
put ("#0-+10o: "); try {putf ("->%#0-+10o<-\n",-4);} catch (invfmt) {err ();}
put ("#0-+10o: "); try {putf ("->%#0-+10o<-\n",0);} catch (invfmt) {err ();}
put ("#0-+10o: "); try {putf ("->%#0-+10o<-\n",4);} catch (invfmt) {err ();}
put ("0-+10o: "); try {putf ("->%0-+10o<-\n",-4);} catch (invfmt) {err ();}
put ("0-+10o: "); try {putf ("->%0-+10o<-\n",0);} catch (invfmt) {err ();}
put ("0-+10o: "); try {putf ("->%0-+10o<-\n",4);} catch (invfmt) {err ();}
put ("#-+10o: "); try {putf ("->%#-+10o<-\n",-4);} catch (invfmt) {err ();}
put ("#-+10o: "); try {putf ("->%#-+10o<-\n",0);} catch (invfmt) {err ();}
put ("#-+10o: "); try {putf ("->%#-+10o<-\n",4);} catch (invfmt) {err ();}
put ("-+10o: "); try {putf ("->%-+10o<-\n",-4);} catch (invfmt) {err ();}
put ("-+10o: "); try {putf ("->%-+10o<-\n",0);} catch (invfmt) {err ();}
put ("-+10o: "); try {putf ("->%-+10o<-\n",4);} catch (invfmt) {err ();}
put ("#0+10o: "); try {putf ("->%#0+10o<-\n",-4);} catch (invfmt) {err ();}
put ("#0+10o: "); try {putf ("->%#0+10o<-\n",0);} catch (invfmt) {err ();}
put ("#0+10o: "); try {putf ("->%#0+10o<-\n",4);} catch (invfmt) {err ();}
put ("0+10o: "); try {putf ("->%0+10o<-\n",-4);} catch (invfmt) {err ();}
put ("0+10o: "); try {putf ("->%0+10o<-\n",0);} catch (invfmt) {err ();}
put ("0+10o: "); try {putf ("->%0+10o<-\n",4);} catch (invfmt) {err ();}
put ("#+10o: "); try {putf ("->%#+10o<-\n",-4);} catch (invfmt) {err ();}
put ("#+10o: "); try {putf ("->%#+10o<-\n",0);} catch (invfmt) {err ();}
put ("#+10o: "); try {putf ("->%#+10o<-\n",4);} catch (invfmt) {err ();}
put ("+10o: "); try {putf ("->%+10o<-\n",-4);} catch (invfmt) {err ();}
put ("+10o: "); try {putf ("->%+10o<-\n",0);} catch (invfmt) {err ();}
put ("+10o: "); try {putf ("->%+10o<-\n",4);} catch (invfmt) {err ();}
put ("#0- 10o: "); try {putf ("->%#0- 10o<-\n",-4);} catch (invfmt) {err ();}
put ("#0- 10o: "); try {putf ("->%#0- 10o<-\n",0);} catch (invfmt) {err ();}
put ("#0- 10o: "); try {putf ("->%#0- 10o<-\n",4);} catch (invfmt) {err ();}
put ("0- 10o: "); try {putf ("->%0- 10o<-\n",-4);} catch (invfmt) {err ();}
put ("0- 10o: "); try {putf ("->%0- 10o<-\n",0);} catch (invfmt) {err ();}
put ("0- 10o: "); try {putf ("->%0- 10o<-\n",4);} catch (invfmt) {err ();}
put ("#- 10o: "); try {putf ("->%#- 10o<-\n",-4);} catch (invfmt) {err ();}
put ("#- 10o: "); try {putf ("->%#- 10o<-\n",0);} catch (invfmt) {err ();}
put ("#- 10o: "); try {putf ("->%#- 10o<-\n",4);} catch (invfmt) {err ();}
put ("- 10o: "); try {putf ("->%- 10o<-\n",-4);} catch (invfmt) {err ();}
put ("- 10o: "); try {putf ("->%- 10o<-\n",0);} catch (invfmt) {err ();}
put ("- 10o: "); try {putf ("->%- 10o<-\n",4);} catch (invfmt) {err ();}
put ("#0 10o: "); try {putf ("->%#0 10o<-\n",-4);} catch (invfmt) {err ();}
put ("#0 10o: "); try {putf ("->%#0 10o<-\n",0);} catch (invfmt) {err ();}
put ("#0 10o: "); try {putf ("->%#0 10o<-\n",4);} catch (invfmt) {err ();}
put ("0 10o: "); try {putf ("->%0 10o<-\n",-4);} catch (invfmt) {err ();}
put ("0 10o: "); try {putf ("->%0 10o<-\n",0);} catch (invfmt) {err ();}
put ("0 10o: "); try {putf ("->%0 10o<-\n",4);} catch (invfmt) {err ();}
put ("# 10o: "); try {putf ("->%# 10o<-\n",-4);} catch (invfmt) {err ();}
put ("# 10o: "); try {putf ("->%# 10o<-\n",0);} catch (invfmt) {err ();}
put ("# 10o: "); try {putf ("->%# 10o<-\n",4);} catch (invfmt) {err ();}
put (" 10o: "); try {putf ("->% 10o<-\n",-4);} catch (invfmt) {err ();}
put (" 10o: "); try {putf ("->% 10o<-\n",0);} catch (invfmt) {err ();}
put (" 10o: "); try {putf ("->% 10o<-\n",4);} catch (invfmt) {err ();}
put ("#0-10o: "); try {putf ("->%#0-10o<-\n",-4);} catch (invfmt) {err ();}
put ("#0-10o: "); try {putf ("->%#0-10o<-\n",0);} catch (invfmt) {err ();}
put ("#0-10o: "); try {putf ("->%#0-10o<-\n",4);} catch (invfmt) {err ();}
put ("0-10o: "); try {putf ("->%0-10o<-\n",-4);} catch (invfmt) {err ();}
put ("0-10o: "); try {putf ("->%0-10o<-\n",0);} catch (invfmt) {err ();}
put ("0-10o: "); try {putf ("->%0-10o<-\n",4);} catch (invfmt) {err ();}
put ("#-10o: "); try {putf ("->%#-10o<-\n",-4);} catch (invfmt) {err ();}
put ("#-10o: "); try {putf ("->%#-10o<-\n",0);} catch (invfmt) {err ();}
put ("#-10o: "); try {putf ("->%#-10o<-\n",4);} catch (invfmt) {err ();}
put ("-10o: "); try {putf ("->%-10o<-\n",-4);} catch (invfmt) {err ();}
put ("-10o: "); try {putf ("->%-10o<-\n",0);} catch (invfmt) {err ();}
put ("-10o: "); try {putf ("->%-10o<-\n",4);} catch (invfmt) {err ();}
put ("#010o: "); try {putf ("->%#010o<-\n",-4);} catch (invfmt) {err ();}
put ("#010o: "); try {putf ("->%#010o<-\n",0);} catch (invfmt) {err ();}
put ("#010o: "); try {putf ("->%#010o<-\n",4);} catch (invfmt) {err ();}
put ("010o: "); try {putf ("->%010o<-\n",-4);} catch (invfmt) {err ();}
put ("010o: "); try {putf ("->%010o<-\n",0);} catch (invfmt) {err ();}
put ("010o: "); try {putf ("->%010o<-\n",4);} catch (invfmt) {err ();}
put ("#10o: "); try {putf ("->%#10o<-\n",-4);} catch (invfmt) {err ();}
put ("#10o: "); try {putf ("->%#10o<-\n",0);} catch (invfmt) {err ();}
put ("#10o: "); try {putf ("->%#10o<-\n",4);} catch (invfmt) {err ();}
put ("10o: "); try {putf ("->%10o<-\n",-4);} catch (invfmt) {err ();}
put ("10o: "); try {putf ("->%10o<-\n",0);} catch (invfmt) {err ();}
put ("10o: "); try {putf ("->%10o<-\n",4);} catch (invfmt) {err ();}
put ("#0- +10x: "); try {putf ("->%#0- +10x<-\n",-4);} catch (invfmt) {err ();}
put ("#0- +10x: "); try {putf ("->%#0- +10x<-\n",0);} catch (invfmt) {err ();}
put ("#0- +10x: "); try {putf ("->%#0- +10x<-\n",4);} catch (invfmt) {err ();}
put ("0- +10x: "); try {putf ("->%0- +10x<-\n",-4);} catch (invfmt) {err ();}
put ("0- +10x: "); try {putf ("->%0- +10x<-\n",0);} catch (invfmt) {err ();}
put ("0- +10x: "); try {putf ("->%0- +10x<-\n",4);} catch (invfmt) {err ();}
put ("#- +10x: "); try {putf ("->%#- +10x<-\n",-4);} catch (invfmt) {err ();}
put ("#- +10x: "); try {putf ("->%#- +10x<-\n",0);} catch (invfmt) {err ();}
put ("#- +10x: "); try {putf ("->%#- +10x<-\n",4);} catch (invfmt) {err ();}
put ("- +10x: "); try {putf ("->%- +10x<-\n",-4);} catch (invfmt) {err ();}
put ("- +10x: "); try {putf ("->%- +10x<-\n",0);} catch (invfmt) {err ();}
put ("- +10x: "); try {putf ("->%- +10x<-\n",4);} catch (invfmt) {err ();}
put ("#0 +10x: "); try {putf ("->%#0 +10x<-\n",-4);} catch (invfmt) {err ();}
put ("#0 +10x: "); try {putf ("->%#0 +10x<-\n",0);} catch (invfmt) {err ();}
put ("#0 +10x: "); try {putf ("->%#0 +10x<-\n",4);} catch (invfmt) {err ();}
put ("0 +10x: "); try {putf ("->%0 +10x<-\n",-4);} catch (invfmt) {err ();}
put ("0 +10x: "); try {putf ("->%0 +10x<-\n",0);} catch (invfmt) {err ();}
put ("0 +10x: "); try {putf ("->%0 +10x<-\n",4);} catch (invfmt) {err ();}
put ("# +10x: "); try {putf ("->%# +10x<-\n",-4);} catch (invfmt) {err ();}
put ("# +10x: "); try {putf ("->%# +10x<-\n",0);} catch (invfmt) {err ();}
put ("# +10x: "); try {putf ("->%# +10x<-\n",4);} catch (invfmt) {err ();}
put (" +10x: "); try {putf ("->% +10x<-\n",-4);} catch (invfmt) {err ();}
put (" +10x: "); try {putf ("->% +10x<-\n",0);} catch (invfmt) {err ();}
put (" +10x: "); try {putf ("->% +10x<-\n",4);} catch (invfmt) {err ();}
put ("#0-+10x: "); try {putf ("->%#0-+10x<-\n",-4);} catch (invfmt) {err ();}
put ("#0-+10x: "); try {putf ("->%#0-+10x<-\n",0);} catch (invfmt) {err ();}
put ("#0-+10x: "); try {putf ("->%#0-+10x<-\n",4);} catch (invfmt) {err ();}
put ("0-+10x: "); try {putf ("->%0-+10x<-\n",-4);} catch (invfmt) {err ();}
put ("0-+10x: "); try {putf ("->%0-+10x<-\n",0);} catch (invfmt) {err ();}
put ("0-+10x: "); try {putf ("->%0-+10x<-\n",4);} catch (invfmt) {err ();}
put ("#-+10x: "); try {putf ("->%#-+10x<-\n",-4);} catch (invfmt) {err ();}
put ("#-+10x: "); try {putf ("->%#-+10x<-\n",0);} catch (invfmt) {err ();}
put ("#-+10x: "); try {putf ("->%#-+10x<-\n",4);} catch (invfmt) {err ();}
put ("-+10x: "); try {putf ("->%-+10x<-\n",-4);} catch (invfmt) {err ();}
put ("-+10x: "); try {putf ("->%-+10x<-\n",0);} catch (invfmt) {err ();}
put ("-+10x: "); try {putf ("->%-+10x<-\n",4);} catch (invfmt) {err ();}
put ("#0+10x: "); try {putf ("->%#0+10x<-\n",-4);} catch (invfmt) {err ();}
put ("#0+10x: "); try {putf ("->%#0+10x<-\n",0);} catch (invfmt) {err ();}
put ("#0+10x: "); try {putf ("->%#0+10x<-\n",4);} catch (invfmt) {err ();}
put ("0+10x: "); try {putf ("->%0+10x<-\n",-4);} catch (invfmt) {err ();}
put ("0+10x: "); try {putf ("->%0+10x<-\n",0);} catch (invfmt) {err ();}
put ("0+10x: "); try {putf ("->%0+10x<-\n",4);} catch (invfmt) {err ();}
put ("#+10x: "); try {putf ("->%#+10x<-\n",-4);} catch (invfmt) {err ();}
put ("#+10x: "); try {putf ("->%#+10x<-\n",0);} catch (invfmt) {err ();}
put ("#+10x: "); try {putf ("->%#+10x<-\n",4);} catch (invfmt) {err ();}
put ("+10x: "); try {putf ("->%+10x<-\n",-4);} catch (invfmt) {err ();}
put ("+10x: "); try {putf ("->%+10x<-\n",0);} catch (invfmt) {err ();}
put ("+10x: "); try {putf ("->%+10x<-\n",4);} catch (invfmt) {err ();}
put ("#0- 10x: "); try {putf ("->%#0- 10x<-\n",-4);} catch (invfmt) {err ();}
put ("#0- 10x: "); try {putf ("->%#0- 10x<-\n",0);} catch (invfmt) {err ();}
put ("#0- 10x: "); try {putf ("->%#0- 10x<-\n",4);} catch (invfmt) {err ();}
put ("0- 10x: "); try {putf ("->%0- 10x<-\n",-4);} catch (invfmt) {err ();}
put ("0- 10x: "); try {putf ("->%0- 10x<-\n",0);} catch (invfmt) {err ();}
put ("0- 10x: "); try {putf ("->%0- 10x<-\n",4);} catch (invfmt) {err ();}
put ("#- 10x: "); try {putf ("->%#- 10x<-\n",-4);} catch (invfmt) {err ();}
put ("#- 10x: "); try {putf ("->%#- 10x<-\n",0);} catch (invfmt) {err ();}
put ("#- 10x: "); try {putf ("->%#- 10x<-\n",4);} catch (invfmt) {err ();}
put ("- 10x: "); try {putf ("->%- 10x<-\n",-4);} catch (invfmt) {err ();}
put ("- 10x: "); try {putf ("->%- 10x<-\n",0);} catch (invfmt) {err ();}
put ("- 10x: "); try {putf ("->%- 10x<-\n",4);} catch (invfmt) {err ();}
put ("#0 10x: "); try {putf ("->%#0 10x<-\n",-4);} catch (invfmt) {err ();}
put ("#0 10x: "); try {putf ("->%#0 10x<-\n",0);} catch (invfmt) {err ();}
put ("#0 10x: "); try {putf ("->%#0 10x<-\n",4);} catch (invfmt) {err ();}
put ("0 10x: "); try {putf ("->%0 10x<-\n",-4);} catch (invfmt) {err ();}
put ("0 10x: "); try {putf ("->%0 10x<-\n",0);} catch (invfmt) {err ();}
put ("0 10x: "); try {putf ("->%0 10x<-\n",4);} catch (invfmt) {err ();}
put ("# 10x: "); try {putf ("->%# 10x<-\n",-4);} catch (invfmt) {err ();}
put ("# 10x: "); try {putf ("->%# 10x<-\n",0);} catch (invfmt) {err ();}
put ("# 10x: "); try {putf ("->%# 10x<-\n",4);} catch (invfmt) {err ();}
put (" 10x: "); try {putf ("->% 10x<-\n",-4);} catch (invfmt) {err ();}
put (" 10x: "); try {putf ("->% 10x<-\n",0);} catch (invfmt) {err ();}
put (" 10x: "); try {putf ("->% 10x<-\n",4);} catch (invfmt) {err ();}
put ("#0-10x: "); try {putf ("->%#0-10x<-\n",-4);} catch (invfmt) {err ();}
put ("#0-10x: "); try {putf ("->%#0-10x<-\n",0);} catch (invfmt) {err ();}
put ("#0-10x: "); try {putf ("->%#0-10x<-\n",4);} catch (invfmt) {err ();}
put ("0-10x: "); try {putf ("->%0-10x<-\n",-4);} catch (invfmt) {err ();}
put ("0-10x: "); try {putf ("->%0-10x<-\n",0);} catch (invfmt) {err ();}
put ("0-10x: "); try {putf ("->%0-10x<-\n",4);} catch (invfmt) {err ();}
put ("#-10x: "); try {putf ("->%#-10x<-\n",-4);} catch (invfmt) {err ();}
put ("#-10x: "); try {putf ("->%#-10x<-\n",0);} catch (invfmt) {err ();}
put ("#-10x: "); try {putf ("->%#-10x<-\n",4);} catch (invfmt) {err ();}
put ("-10x: "); try {putf ("->%-10x<-\n",-4);} catch (invfmt) {err ();}
put ("-10x: "); try {putf ("->%-10x<-\n",0);} catch (invfmt) {err ();}
put ("-10x: "); try {putf ("->%-10x<-\n",4);} catch (invfmt) {err ();}
put ("#010x: "); try {putf ("->%#010x<-\n",-4);} catch (invfmt) {err ();}
put ("#010x: "); try {putf ("->%#010x<-\n",0);} catch (invfmt) {err ();}
put ("#010x: "); try {putf ("->%#010x<-\n",4);} catch (invfmt) {err ();}
put ("010x: "); try {putf ("->%010x<-\n",-4);} catch (invfmt) {err ();}
put ("010x: "); try {putf ("->%010x<-\n",0);} catch (invfmt) {err ();}
put ("010x: "); try {putf ("->%010x<-\n",4);} catch (invfmt) {err ();}
put ("#10x: "); try {putf ("->%#10x<-\n",-4);} catch (invfmt) {err ();}
put ("#10x: "); try {putf ("->%#10x<-\n",0);} catch (invfmt) {err ();}
put ("#10x: "); try {putf ("->%#10x<-\n",4);} catch (invfmt) {err ();}
put ("10x: "); try {putf ("->%10x<-\n",-4);} catch (invfmt) {err ();}
put ("10x: "); try {putf ("->%10x<-\n",0);} catch (invfmt) {err ();}
put ("10x: "); try {putf ("->%10x<-\n",4);} catch (invfmt) {err ();}
put ("#0- +10X: "); try {putf ("->%#0- +10X<-\n",-4);} catch (invfmt) {err ();}
put ("#0- +10X: "); try {putf ("->%#0- +10X<-\n",0);} catch (invfmt) {err ();}
put ("#0- +10X: "); try {putf ("->%#0- +10X<-\n",4);} catch (invfmt) {err ();}
put ("0- +10X: "); try {putf ("->%0- +10X<-\n",-4);} catch (invfmt) {err ();}
put ("0- +10X: "); try {putf ("->%0- +10X<-\n",0);} catch (invfmt) {err ();}
put ("0- +10X: "); try {putf ("->%0- +10X<-\n",4);} catch (invfmt) {err ();}
put ("#- +10X: "); try {putf ("->%#- +10X<-\n",-4);} catch (invfmt) {err ();}
put ("#- +10X: "); try {putf ("->%#- +10X<-\n",0);} catch (invfmt) {err ();}
put ("#- +10X: "); try {putf ("->%#- +10X<-\n",4);} catch (invfmt) {err ();}
put ("- +10X: "); try {putf ("->%- +10X<-\n",-4);} catch (invfmt) {err ();}
put ("- +10X: "); try {putf ("->%- +10X<-\n",0);} catch (invfmt) {err ();}
put ("- +10X: "); try {putf ("->%- +10X<-\n",4);} catch (invfmt) {err ();}
put ("#0 +10X: "); try {putf ("->%#0 +10X<-\n",-4);} catch (invfmt) {err ();}
put ("#0 +10X: "); try {putf ("->%#0 +10X<-\n",0);} catch (invfmt) {err ();}
put ("#0 +10X: "); try {putf ("->%#0 +10X<-\n",4);} catch (invfmt) {err ();}
put ("0 +10X: "); try {putf ("->%0 +10X<-\n",-4);} catch (invfmt) {err ();}
put ("0 +10X: "); try {putf ("->%0 +10X<-\n",0);} catch (invfmt) {err ();}
put ("0 +10X: "); try {putf ("->%0 +10X<-\n",4);} catch (invfmt) {err ();}
put ("# +10X: "); try {putf ("->%# +10X<-\n",-4);} catch (invfmt) {err ();}
put ("# +10X: "); try {putf ("->%# +10X<-\n",0);} catch (invfmt) {err ();}
put ("# +10X: "); try {putf ("->%# +10X<-\n",4);} catch (invfmt) {err ();}
put (" +10X: "); try {putf ("->% +10X<-\n",-4);} catch (invfmt) {err ();}
put (" +10X: "); try {putf ("->% +10X<-\n",0);} catch (invfmt) {err ();}
put (" +10X: "); try {putf ("->% +10X<-\n",4);} catch (invfmt) {err ();}
put ("#0-+10X: "); try {putf ("->%#0-+10X<-\n",-4);} catch (invfmt) {err ();}
put ("#0-+10X: "); try {putf ("->%#0-+10X<-\n",0);} catch (invfmt) {err ();}
put ("#0-+10X: "); try {putf ("->%#0-+10X<-\n",4);} catch (invfmt) {err ();}
put ("0-+10X: "); try {putf ("->%0-+10X<-\n",-4);} catch (invfmt) {err ();}
put ("0-+10X: "); try {putf ("->%0-+10X<-\n",0);} catch (invfmt) {err ();}
put ("0-+10X: "); try {putf ("->%0-+10X<-\n",4);} catch (invfmt) {err ();}
put ("#-+10X: "); try {putf ("->%#-+10X<-\n",-4);} catch (invfmt) {err ();}
put ("#-+10X: "); try {putf ("->%#-+10X<-\n",0);} catch (invfmt) {err ();}
put ("#-+10X: "); try {putf ("->%#-+10X<-\n",4);} catch (invfmt) {err ();}
put ("-+10X: "); try {putf ("->%-+10X<-\n",-4);} catch (invfmt) {err ();}
put ("-+10X: "); try {putf ("->%-+10X<-\n",0);} catch (invfmt) {err ();}
put ("-+10X: "); try {putf ("->%-+10X<-\n",4);} catch (invfmt) {err ();}
put ("#0+10X: "); try {putf ("->%#0+10X<-\n",-4);} catch (invfmt) {err ();}
put ("#0+10X: "); try {putf ("->%#0+10X<-\n",0);} catch (invfmt) {err ();}
put ("#0+10X: "); try {putf ("->%#0+10X<-\n",4);} catch (invfmt) {err ();}
put ("0+10X: "); try {putf ("->%0+10X<-\n",-4);} catch (invfmt) {err ();}
put ("0+10X: "); try {putf ("->%0+10X<-\n",0);} catch (invfmt) {err ();}
put ("0+10X: "); try {putf ("->%0+10X<-\n",4);} catch (invfmt) {err ();}
put ("#+10X: "); try {putf ("->%#+10X<-\n",-4);} catch (invfmt) {err ();}
put ("#+10X: "); try {putf ("->%#+10X<-\n",0);} catch (invfmt) {err ();}
put ("#+10X: "); try {putf ("->%#+10X<-\n",4);} catch (invfmt) {err ();}
put ("+10X: "); try {putf ("->%+10X<-\n",-4);} catch (invfmt) {err ();}
put ("+10X: "); try {putf ("->%+10X<-\n",0);} catch (invfmt) {err ();}
put ("+10X: "); try {putf ("->%+10X<-\n",4);} catch (invfmt) {err ();}
put ("#0- 10X: "); try {putf ("->%#0- 10X<-\n",-4);} catch (invfmt) {err ();}
put ("#0- 10X: "); try {putf ("->%#0- 10X<-\n",0);} catch (invfmt) {err ();}
put ("#0- 10X: "); try {putf ("->%#0- 10X<-\n",4);} catch (invfmt) {err ();}
put ("0- 10X: "); try {putf ("->%0- 10X<-\n",-4);} catch (invfmt) {err ();}
put ("0- 10X: "); try {putf ("->%0- 10X<-\n",0);} catch (invfmt) {err ();}
put ("0- 10X: "); try {putf ("->%0- 10X<-\n",4);} catch (invfmt) {err ();}
put ("#- 10X: "); try {putf ("->%#- 10X<-\n",-4);} catch (invfmt) {err ();}
put ("#- 10X: "); try {putf ("->%#- 10X<-\n",0);} catch (invfmt) {err ();}
put ("#- 10X: "); try {putf ("->%#- 10X<-\n",4);} catch (invfmt) {err ();}
put ("- 10X: "); try {putf ("->%- 10X<-\n",-4);} catch (invfmt) {err ();}
put ("- 10X: "); try {putf ("->%- 10X<-\n",0);} catch (invfmt) {err ();}
put ("- 10X: "); try {putf ("->%- 10X<-\n",4);} catch (invfmt) {err ();}
put ("#0 10X: "); try {putf ("->%#0 10X<-\n",-4);} catch (invfmt) {err ();}
put ("#0 10X: "); try {putf ("->%#0 10X<-\n",0);} catch (invfmt) {err ();}
put ("#0 10X: "); try {putf ("->%#0 10X<-\n",4);} catch (invfmt) {err ();}
put ("0 10X: "); try {putf ("->%0 10X<-\n",-4);} catch (invfmt) {err ();}
put ("0 10X: "); try {putf ("->%0 10X<-\n",0);} catch (invfmt) {err ();}
put ("0 10X: "); try {putf ("->%0 10X<-\n",4);} catch (invfmt) {err ();}
put ("# 10X: "); try {putf ("->%# 10X<-\n",-4);} catch (invfmt) {err ();}
put ("# 10X: "); try {putf ("->%# 10X<-\n",0);} catch (invfmt) {err ();}
put ("# 10X: "); try {putf ("->%# 10X<-\n",4);} catch (invfmt) {err ();}
put (" 10X: "); try {putf ("->% 10X<-\n",-4);} catch (invfmt) {err ();}
put (" 10X: "); try {putf ("->% 10X<-\n",0);} catch (invfmt) {err ();}
put (" 10X: "); try {putf ("->% 10X<-\n",4);} catch (invfmt) {err ();}
put ("#0-10X: "); try {putf ("->%#0-10X<-\n",-4);} catch (invfmt) {err ();}
put ("#0-10X: "); try {putf ("->%#0-10X<-\n",0);} catch (invfmt) {err ();}
put ("#0-10X: "); try {putf ("->%#0-10X<-\n",4);} catch (invfmt) {err ();}
put ("0-10X: "); try {putf ("->%0-10X<-\n",-4);} catch (invfmt) {err ();}
put ("0-10X: "); try {putf ("->%0-10X<-\n",0);} catch (invfmt) {err ();}
put ("0-10X: "); try {putf ("->%0-10X<-\n",4);} catch (invfmt) {err ();}
put ("#-10X: "); try {putf ("->%#-10X<-\n",-4);} catch (invfmt) {err ();}
put ("#-10X: "); try {putf ("->%#-10X<-\n",0);} catch (invfmt) {err ();}
put ("#-10X: "); try {putf ("->%#-10X<-\n",4);} catch (invfmt) {err ();}
put ("-10X: "); try {putf ("->%-10X<-\n",-4);} catch (invfmt) {err ();}
put ("-10X: "); try {putf ("->%-10X<-\n",0);} catch (invfmt) {err ();}
put ("-10X: "); try {putf ("->%-10X<-\n",4);} catch (invfmt) {err ();}
put ("#010X: "); try {putf ("->%#010X<-\n",-4);} catch (invfmt) {err ();}
put ("#010X: "); try {putf ("->%#010X<-\n",0);} catch (invfmt) {err ();}
put ("#010X: "); try {putf ("->%#010X<-\n",4);} catch (invfmt) {err ();}
put ("010X: "); try {putf ("->%010X<-\n",-4);} catch (invfmt) {err ();}
put ("010X: "); try {putf ("->%010X<-\n",0);} catch (invfmt) {err ();}
put ("010X: "); try {putf ("->%010X<-\n",4);} catch (invfmt) {err ();}
put ("#10X: "); try {putf ("->%#10X<-\n",-4);} catch (invfmt) {err ();}
put ("#10X: "); try {putf ("->%#10X<-\n",0);} catch (invfmt) {err ();}
put ("#10X: "); try {putf ("->%#10X<-\n",4);} catch (invfmt) {err ();}
put ("10X: "); try {putf ("->%10X<-\n",-4);} catch (invfmt) {err ();}
put ("10X: "); try {putf ("->%10X<-\n",0);} catch (invfmt) {err ();}
put ("10X: "); try {putf ("->%10X<-\n",4);} catch (invfmt) {err ();}
TEST650
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT650' && $CMP $stdout $ftemp2; then
#0- +d: badformat
#0- +d: badformat
#0- +d: badformat
0- +d: ->-4<-
0- +d: ->+0<-
0- +d: ->+4<-
#- +d: badformat
#- +d: badformat
#- +d: badformat
- +d: ->-4<-
- +d: ->+0<-
- +d: ->+4<-
#0 +d: badformat
#0 +d: badformat
#0 +d: badformat
0 +d: ->-4<-
0 +d: ->+0<-
0 +d: ->+4<-
# +d: badformat
# +d: badformat
# +d: badformat
 +d: ->-4<-
 +d: ->+0<-
 +d: ->+4<-
#0-+d: badformat
#0-+d: badformat
#0-+d: badformat
0-+d: ->-4<-
0-+d: ->+0<-
0-+d: ->+4<-
#-+d: badformat
#-+d: badformat
#-+d: badformat
-+d: ->-4<-
-+d: ->+0<-
-+d: ->+4<-
#0+d: badformat
#0+d: badformat
#0+d: badformat
0+d: ->-4<-
0+d: ->+0<-
0+d: ->+4<-
#+d: badformat
#+d: badformat
#+d: badformat
+d: ->-4<-
+d: ->+0<-
+d: ->+4<-
#0- d: badformat
#0- d: badformat
#0- d: badformat
0- d: ->-4<-
0- d: -> 0<-
0- d: -> 4<-
#- d: badformat
#- d: badformat
#- d: badformat
- d: ->-4<-
- d: -> 0<-
- d: -> 4<-
#0 d: badformat
#0 d: badformat
#0 d: badformat
0 d: ->-4<-
0 d: -> 0<-
0 d: -> 4<-
# d: badformat
# d: badformat
# d: badformat
 d: ->-4<-
 d: -> 0<-
 d: -> 4<-
#0-d: badformat
#0-d: badformat
#0-d: badformat
0-d: ->-4<-
0-d: ->0<-
0-d: ->4<-
#-d: badformat
#-d: badformat
#-d: badformat
-d: ->-4<-
-d: ->0<-
-d: ->4<-
#0d: badformat
#0d: badformat
#0d: badformat
0d: ->-4<-
0d: ->0<-
0d: ->4<-
#d: badformat
#d: badformat
#d: badformat
d: ->-4<-
d: ->0<-
d: ->4<-
#0- +o: badformat
#0- +o: badformat
#0- +o: badformat
0- +o: badformat
0- +o: badformat
0- +o: badformat
#- +o: badformat
#- +o: badformat
#- +o: badformat
- +o: badformat
- +o: badformat
- +o: badformat
#0 +o: badformat
#0 +o: badformat
#0 +o: badformat
0 +o: badformat
0 +o: badformat
0 +o: badformat
# +o: badformat
# +o: badformat
# +o: badformat
 +o: badformat
 +o: badformat
 +o: badformat
#0-+o: badformat
#0-+o: badformat
#0-+o: badformat
0-+o: badformat
0-+o: badformat
0-+o: badformat
#-+o: badformat
#-+o: badformat
#-+o: badformat
-+o: badformat
-+o: badformat
-+o: badformat
#0+o: badformat
#0+o: badformat
#0+o: badformat
0+o: badformat
0+o: badformat
0+o: badformat
#+o: badformat
#+o: badformat
#+o: badformat
+o: badformat
+o: badformat
+o: badformat
#0- o: badformat
#0- o: badformat
#0- o: badformat
0- o: badformat
0- o: badformat
0- o: badformat
#- o: badformat
#- o: badformat
#- o: badformat
- o: badformat
- o: badformat
- o: badformat
#0 o: badformat
#0 o: badformat
#0 o: badformat
0 o: badformat
0 o: badformat
0 o: badformat
# o: badformat
# o: badformat
# o: badformat
 o: badformat
 o: badformat
 o: badformat
#0-o: ->037777777774<-
#0-o: ->0<-
#0-o: ->04<-
0-o: ->37777777774<-
0-o: ->0<-
0-o: ->4<-
#-o: ->037777777774<-
#-o: ->0<-
#-o: ->04<-
-o: ->37777777774<-
-o: ->0<-
-o: ->4<-
#0o: ->037777777774<-
#0o: ->0<-
#0o: ->04<-
0o: ->37777777774<-
0o: ->0<-
0o: ->4<-
#o: ->037777777774<-
#o: ->0<-
#o: ->04<-
o: ->37777777774<-
o: ->0<-
o: ->4<-
#0- +x: badformat
#0- +x: badformat
#0- +x: badformat
0- +x: badformat
0- +x: badformat
0- +x: badformat
#- +x: badformat
#- +x: badformat
#- +x: badformat
- +x: badformat
- +x: badformat
- +x: badformat
#0 +x: badformat
#0 +x: badformat
#0 +x: badformat
0 +x: badformat
0 +x: badformat
0 +x: badformat
# +x: badformat
# +x: badformat
# +x: badformat
 +x: badformat
 +x: badformat
 +x: badformat
#0-+x: badformat
#0-+x: badformat
#0-+x: badformat
0-+x: badformat
0-+x: badformat
0-+x: badformat
#-+x: badformat
#-+x: badformat
#-+x: badformat
-+x: badformat
-+x: badformat
-+x: badformat
#0+x: badformat
#0+x: badformat
#0+x: badformat
0+x: badformat
0+x: badformat
0+x: badformat
#+x: badformat
#+x: badformat
#+x: badformat
+x: badformat
+x: badformat
+x: badformat
#0- x: badformat
#0- x: badformat
#0- x: badformat
0- x: badformat
0- x: badformat
0- x: badformat
#- x: badformat
#- x: badformat
#- x: badformat
- x: badformat
- x: badformat
- x: badformat
#0 x: badformat
#0 x: badformat
#0 x: badformat
0 x: badformat
0 x: badformat
0 x: badformat
# x: badformat
# x: badformat
# x: badformat
 x: badformat
 x: badformat
 x: badformat
#0-x: ->0xfffffffc<-
#0-x: ->0<-
#0-x: ->0x4<-
0-x: ->fffffffc<-
0-x: ->0<-
0-x: ->4<-
#-x: ->0xfffffffc<-
#-x: ->0<-
#-x: ->0x4<-
-x: ->fffffffc<-
-x: ->0<-
-x: ->4<-
#0x: ->0xfffffffc<-
#0x: ->0<-
#0x: ->0x4<-
0x: ->fffffffc<-
0x: ->0<-
0x: ->4<-
#x: ->0xfffffffc<-
#x: ->0<-
#x: ->0x4<-
x: ->fffffffc<-
x: ->0<-
x: ->4<-
#0- +X: badformat
#0- +X: badformat
#0- +X: badformat
0- +X: badformat
0- +X: badformat
0- +X: badformat
#- +X: badformat
#- +X: badformat
#- +X: badformat
- +X: badformat
- +X: badformat
- +X: badformat
#0 +X: badformat
#0 +X: badformat
#0 +X: badformat
0 +X: badformat
0 +X: badformat
0 +X: badformat
# +X: badformat
# +X: badformat
# +X: badformat
 +X: badformat
 +X: badformat
 +X: badformat
#0-+X: badformat
#0-+X: badformat
#0-+X: badformat
0-+X: badformat
0-+X: badformat
0-+X: badformat
#-+X: badformat
#-+X: badformat
#-+X: badformat
-+X: badformat
-+X: badformat
-+X: badformat
#0+X: badformat
#0+X: badformat
#0+X: badformat
0+X: badformat
0+X: badformat
0+X: badformat
#+X: badformat
#+X: badformat
#+X: badformat
+X: badformat
+X: badformat
+X: badformat
#0- X: badformat
#0- X: badformat
#0- X: badformat
0- X: badformat
0- X: badformat
0- X: badformat
#- X: badformat
#- X: badformat
#- X: badformat
- X: badformat
- X: badformat
- X: badformat
#0 X: badformat
#0 X: badformat
#0 X: badformat
0 X: badformat
0 X: badformat
0 X: badformat
# X: badformat
# X: badformat
# X: badformat
 X: badformat
 X: badformat
 X: badformat
#0-X: ->0XFFFFFFFC<-
#0-X: ->0<-
#0-X: ->0X4<-
0-X: ->FFFFFFFC<-
0-X: ->0<-
0-X: ->4<-
#-X: ->0XFFFFFFFC<-
#-X: ->0<-
#-X: ->0X4<-
-X: ->FFFFFFFC<-
-X: ->0<-
-X: ->4<-
#0X: ->0XFFFFFFFC<-
#0X: ->0<-
#0X: ->0X4<-
0X: ->FFFFFFFC<-
0X: ->0<-
0X: ->4<-
#X: ->0XFFFFFFFC<-
#X: ->0<-
#X: ->0X4<-
X: ->FFFFFFFC<-
X: ->0<-
X: ->4<-
#0- +0d: badformat
#0- +0d: badformat
#0- +0d: badformat
0- +0d: ->-4<-
0- +0d: ->+0<-
0- +0d: ->+4<-
#- +0d: badformat
#- +0d: badformat
#- +0d: badformat
- +0d: ->-4<-
- +0d: ->+0<-
- +0d: ->+4<-
#0 +0d: badformat
#0 +0d: badformat
#0 +0d: badformat
0 +0d: ->-4<-
0 +0d: ->+0<-
0 +0d: ->+4<-
# +0d: badformat
# +0d: badformat
# +0d: badformat
 +0d: ->-4<-
 +0d: ->+0<-
 +0d: ->+4<-
#0-+0d: badformat
#0-+0d: badformat
#0-+0d: badformat
0-+0d: ->-4<-
0-+0d: ->+0<-
0-+0d: ->+4<-
#-+0d: badformat
#-+0d: badformat
#-+0d: badformat
-+0d: ->-4<-
-+0d: ->+0<-
-+0d: ->+4<-
#0+0d: badformat
#0+0d: badformat
#0+0d: badformat
0+0d: ->-4<-
0+0d: ->+0<-
0+0d: ->+4<-
#+0d: badformat
#+0d: badformat
#+0d: badformat
+0d: ->-4<-
+0d: ->+0<-
+0d: ->+4<-
#0- 0d: badformat
#0- 0d: badformat
#0- 0d: badformat
0- 0d: ->-4<-
0- 0d: -> 0<-
0- 0d: -> 4<-
#- 0d: badformat
#- 0d: badformat
#- 0d: badformat
- 0d: ->-4<-
- 0d: -> 0<-
- 0d: -> 4<-
#0 0d: badformat
#0 0d: badformat
#0 0d: badformat
0 0d: ->-4<-
0 0d: -> 0<-
0 0d: -> 4<-
# 0d: badformat
# 0d: badformat
# 0d: badformat
 0d: ->-4<-
 0d: -> 0<-
 0d: -> 4<-
#0-0d: badformat
#0-0d: badformat
#0-0d: badformat
0-0d: ->-4<-
0-0d: ->0<-
0-0d: ->4<-
#-0d: badformat
#-0d: badformat
#-0d: badformat
-0d: ->-4<-
-0d: ->0<-
-0d: ->4<-
#00d: badformat
#00d: badformat
#00d: badformat
00d: ->-4<-
00d: ->0<-
00d: ->4<-
#0d: badformat
#0d: badformat
#0d: badformat
0d: ->-4<-
0d: ->0<-
0d: ->4<-
#0- +0o: badformat
#0- +0o: badformat
#0- +0o: badformat
0- +0o: badformat
0- +0o: badformat
0- +0o: badformat
#- +0o: badformat
#- +0o: badformat
#- +0o: badformat
- +0o: badformat
- +0o: badformat
- +0o: badformat
#0 +0o: badformat
#0 +0o: badformat
#0 +0o: badformat
0 +0o: badformat
0 +0o: badformat
0 +0o: badformat
# +0o: badformat
# +0o: badformat
# +0o: badformat
 +0o: badformat
 +0o: badformat
 +0o: badformat
#0-+0o: badformat
#0-+0o: badformat
#0-+0o: badformat
0-+0o: badformat
0-+0o: badformat
0-+0o: badformat
#-+0o: badformat
#-+0o: badformat
#-+0o: badformat
-+0o: badformat
-+0o: badformat
-+0o: badformat
#0+0o: badformat
#0+0o: badformat
#0+0o: badformat
0+0o: badformat
0+0o: badformat
0+0o: badformat
#+0o: badformat
#+0o: badformat
#+0o: badformat
+0o: badformat
+0o: badformat
+0o: badformat
#0- 0o: badformat
#0- 0o: badformat
#0- 0o: badformat
0- 0o: badformat
0- 0o: badformat
0- 0o: badformat
#- 0o: badformat
#- 0o: badformat
#- 0o: badformat
- 0o: badformat
- 0o: badformat
- 0o: badformat
#0 0o: badformat
#0 0o: badformat
#0 0o: badformat
0 0o: badformat
0 0o: badformat
0 0o: badformat
# 0o: badformat
# 0o: badformat
# 0o: badformat
 0o: badformat
 0o: badformat
 0o: badformat
#0-0o: ->037777777774<-
#0-0o: ->0<-
#0-0o: ->04<-
0-0o: ->37777777774<-
0-0o: ->0<-
0-0o: ->4<-
#-0o: ->037777777774<-
#-0o: ->0<-
#-0o: ->04<-
-0o: ->37777777774<-
-0o: ->0<-
-0o: ->4<-
#00o: ->037777777774<-
#00o: ->0<-
#00o: ->04<-
00o: ->37777777774<-
00o: ->0<-
00o: ->4<-
#0o: ->037777777774<-
#0o: ->0<-
#0o: ->04<-
0o: ->37777777774<-
0o: ->0<-
0o: ->4<-
#0- +0x: badformat
#0- +0x: badformat
#0- +0x: badformat
0- +0x: badformat
0- +0x: badformat
0- +0x: badformat
#- +0x: badformat
#- +0x: badformat
#- +0x: badformat
- +0x: badformat
- +0x: badformat
- +0x: badformat
#0 +0x: badformat
#0 +0x: badformat
#0 +0x: badformat
0 +0x: badformat
0 +0x: badformat
0 +0x: badformat
# +0x: badformat
# +0x: badformat
# +0x: badformat
 +0x: badformat
 +0x: badformat
 +0x: badformat
#0-+0x: badformat
#0-+0x: badformat
#0-+0x: badformat
0-+0x: badformat
0-+0x: badformat
0-+0x: badformat
#-+0x: badformat
#-+0x: badformat
#-+0x: badformat
-+0x: badformat
-+0x: badformat
-+0x: badformat
#0+0x: badformat
#0+0x: badformat
#0+0x: badformat
0+0x: badformat
0+0x: badformat
0+0x: badformat
#+0x: badformat
#+0x: badformat
#+0x: badformat
+0x: badformat
+0x: badformat
+0x: badformat
#0- 0x: badformat
#0- 0x: badformat
#0- 0x: badformat
0- 0x: badformat
0- 0x: badformat
0- 0x: badformat
#- 0x: badformat
#- 0x: badformat
#- 0x: badformat
- 0x: badformat
- 0x: badformat
- 0x: badformat
#0 0x: badformat
#0 0x: badformat
#0 0x: badformat
0 0x: badformat
0 0x: badformat
0 0x: badformat
# 0x: badformat
# 0x: badformat
# 0x: badformat
 0x: badformat
 0x: badformat
 0x: badformat
#0-0x: ->0xfffffffc<-
#0-0x: ->0<-
#0-0x: ->0x4<-
0-0x: ->fffffffc<-
0-0x: ->0<-
0-0x: ->4<-
#-0x: ->0xfffffffc<-
#-0x: ->0<-
#-0x: ->0x4<-
-0x: ->fffffffc<-
-0x: ->0<-
-0x: ->4<-
#00x: ->0xfffffffc<-
#00x: ->0<-
#00x: ->0x4<-
00x: ->fffffffc<-
00x: ->0<-
00x: ->4<-
#0x: ->0xfffffffc<-
#0x: ->0<-
#0x: ->0x4<-
0x: ->fffffffc<-
0x: ->0<-
0x: ->4<-
#0- +0X: badformat
#0- +0X: badformat
#0- +0X: badformat
0- +0X: badformat
0- +0X: badformat
0- +0X: badformat
#- +0X: badformat
#- +0X: badformat
#- +0X: badformat
- +0X: badformat
- +0X: badformat
- +0X: badformat
#0 +0X: badformat
#0 +0X: badformat
#0 +0X: badformat
0 +0X: badformat
0 +0X: badformat
0 +0X: badformat
# +0X: badformat
# +0X: badformat
# +0X: badformat
 +0X: badformat
 +0X: badformat
 +0X: badformat
#0-+0X: badformat
#0-+0X: badformat
#0-+0X: badformat
0-+0X: badformat
0-+0X: badformat
0-+0X: badformat
#-+0X: badformat
#-+0X: badformat
#-+0X: badformat
-+0X: badformat
-+0X: badformat
-+0X: badformat
#0+0X: badformat
#0+0X: badformat
#0+0X: badformat
0+0X: badformat
0+0X: badformat
0+0X: badformat
#+0X: badformat
#+0X: badformat
#+0X: badformat
+0X: badformat
+0X: badformat
+0X: badformat
#0- 0X: badformat
#0- 0X: badformat
#0- 0X: badformat
0- 0X: badformat
0- 0X: badformat
0- 0X: badformat
#- 0X: badformat
#- 0X: badformat
#- 0X: badformat
- 0X: badformat
- 0X: badformat
- 0X: badformat
#0 0X: badformat
#0 0X: badformat
#0 0X: badformat
0 0X: badformat
0 0X: badformat
0 0X: badformat
# 0X: badformat
# 0X: badformat
# 0X: badformat
 0X: badformat
 0X: badformat
 0X: badformat
#0-0X: ->0XFFFFFFFC<-
#0-0X: ->0<-
#0-0X: ->0X4<-
0-0X: ->FFFFFFFC<-
0-0X: ->0<-
0-0X: ->4<-
#-0X: ->0XFFFFFFFC<-
#-0X: ->0<-
#-0X: ->0X4<-
-0X: ->FFFFFFFC<-
-0X: ->0<-
-0X: ->4<-
#00X: ->0XFFFFFFFC<-
#00X: ->0<-
#00X: ->0X4<-
00X: ->FFFFFFFC<-
00X: ->0<-
00X: ->4<-
#0X: ->0XFFFFFFFC<-
#0X: ->0<-
#0X: ->0X4<-
0X: ->FFFFFFFC<-
0X: ->0<-
0X: ->4<-
#0- +10d: badformat
#0- +10d: badformat
#0- +10d: badformat
0- +10d: ->-4        <-
0- +10d: ->+0        <-
0- +10d: ->+4        <-
#- +10d: badformat
#- +10d: badformat
#- +10d: badformat
- +10d: ->-4        <-
- +10d: ->+0        <-
- +10d: ->+4        <-
#0 +10d: badformat
#0 +10d: badformat
#0 +10d: badformat
0 +10d: ->-000000004<-
0 +10d: ->+000000000<-
0 +10d: ->+000000004<-
# +10d: badformat
# +10d: badformat
# +10d: badformat
 +10d: ->        -4<-
 +10d: ->        +0<-
 +10d: ->        +4<-
#0-+10d: badformat
#0-+10d: badformat
#0-+10d: badformat
0-+10d: ->-4        <-
0-+10d: ->+0        <-
0-+10d: ->+4        <-
#-+10d: badformat
#-+10d: badformat
#-+10d: badformat
-+10d: ->-4        <-
-+10d: ->+0        <-
-+10d: ->+4        <-
#0+10d: badformat
#0+10d: badformat
#0+10d: badformat
0+10d: ->-000000004<-
0+10d: ->+000000000<-
0+10d: ->+000000004<-
#+10d: badformat
#+10d: badformat
#+10d: badformat
+10d: ->        -4<-
+10d: ->        +0<-
+10d: ->        +4<-
#0- 10d: badformat
#0- 10d: badformat
#0- 10d: badformat
0- 10d: ->-4        <-
0- 10d: -> 0        <-
0- 10d: -> 4        <-
#- 10d: badformat
#- 10d: badformat
#- 10d: badformat
- 10d: ->-4        <-
- 10d: -> 0        <-
- 10d: -> 4        <-
#0 10d: badformat
#0 10d: badformat
#0 10d: badformat
0 10d: ->-000000004<-
0 10d: -> 000000000<-
0 10d: -> 000000004<-
# 10d: badformat
# 10d: badformat
# 10d: badformat
 10d: ->        -4<-
 10d: ->         0<-
 10d: ->         4<-
#0-10d: badformat
#0-10d: badformat
#0-10d: badformat
0-10d: ->-4        <-
0-10d: ->0         <-
0-10d: ->4         <-
#-10d: badformat
#-10d: badformat
#-10d: badformat
-10d: ->-4        <-
-10d: ->0         <-
-10d: ->4         <-
#010d: badformat
#010d: badformat
#010d: badformat
010d: ->-000000004<-
010d: ->0000000000<-
010d: ->0000000004<-
#10d: badformat
#10d: badformat
#10d: badformat
10d: ->        -4<-
10d: ->         0<-
10d: ->         4<-
#0- +10o: badformat
#0- +10o: badformat
#0- +10o: badformat
0- +10o: badformat
0- +10o: badformat
0- +10o: badformat
#- +10o: badformat
#- +10o: badformat
#- +10o: badformat
- +10o: badformat
- +10o: badformat
- +10o: badformat
#0 +10o: badformat
#0 +10o: badformat
#0 +10o: badformat
0 +10o: badformat
0 +10o: badformat
0 +10o: badformat
# +10o: badformat
# +10o: badformat
# +10o: badformat
 +10o: badformat
 +10o: badformat
 +10o: badformat
#0-+10o: badformat
#0-+10o: badformat
#0-+10o: badformat
0-+10o: badformat
0-+10o: badformat
0-+10o: badformat
#-+10o: badformat
#-+10o: badformat
#-+10o: badformat
-+10o: badformat
-+10o: badformat
-+10o: badformat
#0+10o: badformat
#0+10o: badformat
#0+10o: badformat
0+10o: badformat
0+10o: badformat
0+10o: badformat
#+10o: badformat
#+10o: badformat
#+10o: badformat
+10o: badformat
+10o: badformat
+10o: badformat
#0- 10o: badformat
#0- 10o: badformat
#0- 10o: badformat
0- 10o: badformat
0- 10o: badformat
0- 10o: badformat
#- 10o: badformat
#- 10o: badformat
#- 10o: badformat
- 10o: badformat
- 10o: badformat
- 10o: badformat
#0 10o: badformat
#0 10o: badformat
#0 10o: badformat
0 10o: badformat
0 10o: badformat
0 10o: badformat
# 10o: badformat
# 10o: badformat
# 10o: badformat
 10o: badformat
 10o: badformat
 10o: badformat
#0-10o: ->037777777774<-
#0-10o: ->0         <-
#0-10o: ->04        <-
0-10o: ->37777777774<-
0-10o: ->0         <-
0-10o: ->4         <-
#-10o: ->037777777774<-
#-10o: ->0         <-
#-10o: ->04        <-
-10o: ->37777777774<-
-10o: ->0         <-
-10o: ->4         <-
#010o: ->037777777774<-
#010o: ->0000000000<-
#010o: ->0000000004<-
010o: ->37777777774<-
010o: ->0000000000<-
010o: ->0000000004<-
#10o: ->037777777774<-
#10o: ->         0<-
#10o: ->        04<-
10o: ->37777777774<-
10o: ->         0<-
10o: ->         4<-
#0- +10x: badformat
#0- +10x: badformat
#0- +10x: badformat
0- +10x: badformat
0- +10x: badformat
0- +10x: badformat
#- +10x: badformat
#- +10x: badformat
#- +10x: badformat
- +10x: badformat
- +10x: badformat
- +10x: badformat
#0 +10x: badformat
#0 +10x: badformat
#0 +10x: badformat
0 +10x: badformat
0 +10x: badformat
0 +10x: badformat
# +10x: badformat
# +10x: badformat
# +10x: badformat
 +10x: badformat
 +10x: badformat
 +10x: badformat
#0-+10x: badformat
#0-+10x: badformat
#0-+10x: badformat
0-+10x: badformat
0-+10x: badformat
0-+10x: badformat
#-+10x: badformat
#-+10x: badformat
#-+10x: badformat
-+10x: badformat
-+10x: badformat
-+10x: badformat
#0+10x: badformat
#0+10x: badformat
#0+10x: badformat
0+10x: badformat
0+10x: badformat
0+10x: badformat
#+10x: badformat
#+10x: badformat
#+10x: badformat
+10x: badformat
+10x: badformat
+10x: badformat
#0- 10x: badformat
#0- 10x: badformat
#0- 10x: badformat
0- 10x: badformat
0- 10x: badformat
0- 10x: badformat
#- 10x: badformat
#- 10x: badformat
#- 10x: badformat
- 10x: badformat
- 10x: badformat
- 10x: badformat
#0 10x: badformat
#0 10x: badformat
#0 10x: badformat
0 10x: badformat
0 10x: badformat
0 10x: badformat
# 10x: badformat
# 10x: badformat
# 10x: badformat
 10x: badformat
 10x: badformat
 10x: badformat
#0-10x: ->0xfffffffc<-
#0-10x: ->0         <-
#0-10x: ->0x4       <-
0-10x: ->fffffffc  <-
0-10x: ->0         <-
0-10x: ->4         <-
#-10x: ->0xfffffffc<-
#-10x: ->0         <-
#-10x: ->0x4       <-
-10x: ->fffffffc  <-
-10x: ->0         <-
-10x: ->4         <-
#010x: ->0xfffffffc<-
#010x: ->0000000000<-
#010x: ->0x00000004<-
010x: ->00fffffffc<-
010x: ->0000000000<-
010x: ->0000000004<-
#10x: ->0xfffffffc<-
#10x: ->         0<-
#10x: ->       0x4<-
10x: ->  fffffffc<-
10x: ->         0<-
10x: ->         4<-
#0- +10X: badformat
#0- +10X: badformat
#0- +10X: badformat
0- +10X: badformat
0- +10X: badformat
0- +10X: badformat
#- +10X: badformat
#- +10X: badformat
#- +10X: badformat
- +10X: badformat
- +10X: badformat
- +10X: badformat
#0 +10X: badformat
#0 +10X: badformat
#0 +10X: badformat
0 +10X: badformat
0 +10X: badformat
0 +10X: badformat
# +10X: badformat
# +10X: badformat
# +10X: badformat
 +10X: badformat
 +10X: badformat
 +10X: badformat
#0-+10X: badformat
#0-+10X: badformat
#0-+10X: badformat
0-+10X: badformat
0-+10X: badformat
0-+10X: badformat
#-+10X: badformat
#-+10X: badformat
#-+10X: badformat
-+10X: badformat
-+10X: badformat
-+10X: badformat
#0+10X: badformat
#0+10X: badformat
#0+10X: badformat
0+10X: badformat
0+10X: badformat
0+10X: badformat
#+10X: badformat
#+10X: badformat
#+10X: badformat
+10X: badformat
+10X: badformat
+10X: badformat
#0- 10X: badformat
#0- 10X: badformat
#0- 10X: badformat
0- 10X: badformat
0- 10X: badformat
0- 10X: badformat
#- 10X: badformat
#- 10X: badformat
#- 10X: badformat
- 10X: badformat
- 10X: badformat
- 10X: badformat
#0 10X: badformat
#0 10X: badformat
#0 10X: badformat
0 10X: badformat
0 10X: badformat
0 10X: badformat
# 10X: badformat
# 10X: badformat
# 10X: badformat
 10X: badformat
 10X: badformat
 10X: badformat
#0-10X: ->0XFFFFFFFC<-
#0-10X: ->0         <-
#0-10X: ->0X4       <-
0-10X: ->FFFFFFFC  <-
0-10X: ->0         <-
0-10X: ->4         <-
#-10X: ->0XFFFFFFFC<-
#-10X: ->0         <-
#-10X: ->0X4       <-
-10X: ->FFFFFFFC  <-
-10X: ->0         <-
-10X: ->4         <-
#010X: ->0XFFFFFFFC<-
#010X: ->0000000000<-
#010X: ->0X00000004<-
010X: ->00FFFFFFFC<-
010X: ->0000000000<-
010X: ->0000000004<-
#10X: ->0XFFFFFFFC<-
#10X: ->         0<-
#10X: ->       0X4<-
10X: ->  FFFFFFFC<-
10X: ->         0<-
10X: ->         4<-
OUTPUT650
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 651.
if test $result = ok -a $start_test_number -le 651; then
	echo test 651: Long format printing
        cat >$test_file <<'TEST651'
fun err {putln ("badformat");}
put ("#0- +d: "); try {putf ("->%#0- +d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- +d: "); try {putf ("->%#0- +d<-\n",0L);} catch (invfmt) {err ();}
put ("#0- +d: "); try {putf ("->%#0- +d<-\n",4L);} catch (invfmt) {err ();}
put ("0- +d: "); try {putf ("->%0- +d<-\n",-4L);} catch (invfmt) {err ();}
put ("0- +d: "); try {putf ("->%0- +d<-\n",0L);} catch (invfmt) {err ();}
put ("0- +d: "); try {putf ("->%0- +d<-\n",4L);} catch (invfmt) {err ();}
put ("#- +d: "); try {putf ("->%#- +d<-\n",-4L);} catch (invfmt) {err ();}
put ("#- +d: "); try {putf ("->%#- +d<-\n",0L);} catch (invfmt) {err ();}
put ("#- +d: "); try {putf ("->%#- +d<-\n",4L);} catch (invfmt) {err ();}
put ("- +d: "); try {putf ("->%- +d<-\n",-4L);} catch (invfmt) {err ();}
put ("- +d: "); try {putf ("->%- +d<-\n",0L);} catch (invfmt) {err ();}
put ("- +d: "); try {putf ("->%- +d<-\n",4L);} catch (invfmt) {err ();}
put ("#0 +d: "); try {putf ("->%#0 +d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 +d: "); try {putf ("->%#0 +d<-\n",0L);} catch (invfmt) {err ();}
put ("#0 +d: "); try {putf ("->%#0 +d<-\n",4L);} catch (invfmt) {err ();}
put ("0 +d: "); try {putf ("->%0 +d<-\n",-4L);} catch (invfmt) {err ();}
put ("0 +d: "); try {putf ("->%0 +d<-\n",0L);} catch (invfmt) {err ();}
put ("0 +d: "); try {putf ("->%0 +d<-\n",4L);} catch (invfmt) {err ();}
put ("# +d: "); try {putf ("->%# +d<-\n",-4L);} catch (invfmt) {err ();}
put ("# +d: "); try {putf ("->%# +d<-\n",0L);} catch (invfmt) {err ();}
put ("# +d: "); try {putf ("->%# +d<-\n",4L);} catch (invfmt) {err ();}
put (" +d: "); try {putf ("->% +d<-\n",-4L);} catch (invfmt) {err ();}
put (" +d: "); try {putf ("->% +d<-\n",0L);} catch (invfmt) {err ();}
put (" +d: "); try {putf ("->% +d<-\n",4L);} catch (invfmt) {err ();}
put ("#0-+d: "); try {putf ("->%#0-+d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-+d: "); try {putf ("->%#0-+d<-\n",0L);} catch (invfmt) {err ();}
put ("#0-+d: "); try {putf ("->%#0-+d<-\n",4L);} catch (invfmt) {err ();}
put ("0-+d: "); try {putf ("->%0-+d<-\n",-4L);} catch (invfmt) {err ();}
put ("0-+d: "); try {putf ("->%0-+d<-\n",0L);} catch (invfmt) {err ();}
put ("0-+d: "); try {putf ("->%0-+d<-\n",4L);} catch (invfmt) {err ();}
put ("#-+d: "); try {putf ("->%#-+d<-\n",-4L);} catch (invfmt) {err ();}
put ("#-+d: "); try {putf ("->%#-+d<-\n",0L);} catch (invfmt) {err ();}
put ("#-+d: "); try {putf ("->%#-+d<-\n",4L);} catch (invfmt) {err ();}
put ("-+d: "); try {putf ("->%-+d<-\n",-4L);} catch (invfmt) {err ();}
put ("-+d: "); try {putf ("->%-+d<-\n",0L);} catch (invfmt) {err ();}
put ("-+d: "); try {putf ("->%-+d<-\n",4L);} catch (invfmt) {err ();}
put ("#0+d: "); try {putf ("->%#0+d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0+d: "); try {putf ("->%#0+d<-\n",0L);} catch (invfmt) {err ();}
put ("#0+d: "); try {putf ("->%#0+d<-\n",4L);} catch (invfmt) {err ();}
put ("0+d: "); try {putf ("->%0+d<-\n",-4L);} catch (invfmt) {err ();}
put ("0+d: "); try {putf ("->%0+d<-\n",0L);} catch (invfmt) {err ();}
put ("0+d: "); try {putf ("->%0+d<-\n",4L);} catch (invfmt) {err ();}
put ("#+d: "); try {putf ("->%#+d<-\n",-4L);} catch (invfmt) {err ();}
put ("#+d: "); try {putf ("->%#+d<-\n",0L);} catch (invfmt) {err ();}
put ("#+d: "); try {putf ("->%#+d<-\n",4L);} catch (invfmt) {err ();}
put ("+d: "); try {putf ("->%+d<-\n",-4L);} catch (invfmt) {err ();}
put ("+d: "); try {putf ("->%+d<-\n",0L);} catch (invfmt) {err ();}
put ("+d: "); try {putf ("->%+d<-\n",4L);} catch (invfmt) {err ();}
put ("#0- d: "); try {putf ("->%#0- d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- d: "); try {putf ("->%#0- d<-\n",0L);} catch (invfmt) {err ();}
put ("#0- d: "); try {putf ("->%#0- d<-\n",4L);} catch (invfmt) {err ();}
put ("0- d: "); try {putf ("->%0- d<-\n",-4L);} catch (invfmt) {err ();}
put ("0- d: "); try {putf ("->%0- d<-\n",0L);} catch (invfmt) {err ();}
put ("0- d: "); try {putf ("->%0- d<-\n",4L);} catch (invfmt) {err ();}
put ("#- d: "); try {putf ("->%#- d<-\n",-4L);} catch (invfmt) {err ();}
put ("#- d: "); try {putf ("->%#- d<-\n",0L);} catch (invfmt) {err ();}
put ("#- d: "); try {putf ("->%#- d<-\n",4L);} catch (invfmt) {err ();}
put ("- d: "); try {putf ("->%- d<-\n",-4L);} catch (invfmt) {err ();}
put ("- d: "); try {putf ("->%- d<-\n",0L);} catch (invfmt) {err ();}
put ("- d: "); try {putf ("->%- d<-\n",4L);} catch (invfmt) {err ();}
put ("#0 d: "); try {putf ("->%#0 d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 d: "); try {putf ("->%#0 d<-\n",0L);} catch (invfmt) {err ();}
put ("#0 d: "); try {putf ("->%#0 d<-\n",4L);} catch (invfmt) {err ();}
put ("0 d: "); try {putf ("->%0 d<-\n",-4L);} catch (invfmt) {err ();}
put ("0 d: "); try {putf ("->%0 d<-\n",0L);} catch (invfmt) {err ();}
put ("0 d: "); try {putf ("->%0 d<-\n",4L);} catch (invfmt) {err ();}
put ("# d: "); try {putf ("->%# d<-\n",-4L);} catch (invfmt) {err ();}
put ("# d: "); try {putf ("->%# d<-\n",0L);} catch (invfmt) {err ();}
put ("# d: "); try {putf ("->%# d<-\n",4L);} catch (invfmt) {err ();}
put (" d: "); try {putf ("->% d<-\n",-4L);} catch (invfmt) {err ();}
put (" d: "); try {putf ("->% d<-\n",0L);} catch (invfmt) {err ();}
put (" d: "); try {putf ("->% d<-\n",4L);} catch (invfmt) {err ();}
put ("#0-d: "); try {putf ("->%#0-d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-d: "); try {putf ("->%#0-d<-\n",0L);} catch (invfmt) {err ();}
put ("#0-d: "); try {putf ("->%#0-d<-\n",4L);} catch (invfmt) {err ();}
put ("0-d: "); try {putf ("->%0-d<-\n",-4L);} catch (invfmt) {err ();}
put ("0-d: "); try {putf ("->%0-d<-\n",0L);} catch (invfmt) {err ();}
put ("0-d: "); try {putf ("->%0-d<-\n",4L);} catch (invfmt) {err ();}
put ("#-d: "); try {putf ("->%#-d<-\n",-4L);} catch (invfmt) {err ();}
put ("#-d: "); try {putf ("->%#-d<-\n",0L);} catch (invfmt) {err ();}
put ("#-d: "); try {putf ("->%#-d<-\n",4L);} catch (invfmt) {err ();}
put ("-d: "); try {putf ("->%-d<-\n",-4L);} catch (invfmt) {err ();}
put ("-d: "); try {putf ("->%-d<-\n",0L);} catch (invfmt) {err ();}
put ("-d: "); try {putf ("->%-d<-\n",4L);} catch (invfmt) {err ();}
put ("#0d: "); try {putf ("->%#0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0d: "); try {putf ("->%#0d<-\n",0L);} catch (invfmt) {err ();}
put ("#0d: "); try {putf ("->%#0d<-\n",4L);} catch (invfmt) {err ();}
put ("0d: "); try {putf ("->%0d<-\n",-4L);} catch (invfmt) {err ();}
put ("0d: "); try {putf ("->%0d<-\n",0L);} catch (invfmt) {err ();}
put ("0d: "); try {putf ("->%0d<-\n",4L);} catch (invfmt) {err ();}
put ("#d: "); try {putf ("->%#d<-\n",-4L);} catch (invfmt) {err ();}
put ("#d: "); try {putf ("->%#d<-\n",0L);} catch (invfmt) {err ();}
put ("#d: "); try {putf ("->%#d<-\n",4L);} catch (invfmt) {err ();}
put ("d: "); try {putf ("->%d<-\n",-4L);} catch (invfmt) {err ();}
put ("d: "); try {putf ("->%d<-\n",0L);} catch (invfmt) {err ();}
put ("d: "); try {putf ("->%d<-\n",4L);} catch (invfmt) {err ();}
put ("#0- +o: "); try {putf ("->%#0- +o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- +o: "); try {putf ("->%#0- +o<-\n",0L);} catch (invfmt) {err ();}
put ("#0- +o: "); try {putf ("->%#0- +o<-\n",4L);} catch (invfmt) {err ();}
put ("0- +o: "); try {putf ("->%0- +o<-\n",-4L);} catch (invfmt) {err ();}
put ("0- +o: "); try {putf ("->%0- +o<-\n",0L);} catch (invfmt) {err ();}
put ("0- +o: "); try {putf ("->%0- +o<-\n",4L);} catch (invfmt) {err ();}
put ("#- +o: "); try {putf ("->%#- +o<-\n",-4L);} catch (invfmt) {err ();}
put ("#- +o: "); try {putf ("->%#- +o<-\n",0L);} catch (invfmt) {err ();}
put ("#- +o: "); try {putf ("->%#- +o<-\n",4L);} catch (invfmt) {err ();}
put ("- +o: "); try {putf ("->%- +o<-\n",-4L);} catch (invfmt) {err ();}
put ("- +o: "); try {putf ("->%- +o<-\n",0L);} catch (invfmt) {err ();}
put ("- +o: "); try {putf ("->%- +o<-\n",4L);} catch (invfmt) {err ();}
put ("#0 +o: "); try {putf ("->%#0 +o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 +o: "); try {putf ("->%#0 +o<-\n",0L);} catch (invfmt) {err ();}
put ("#0 +o: "); try {putf ("->%#0 +o<-\n",4L);} catch (invfmt) {err ();}
put ("0 +o: "); try {putf ("->%0 +o<-\n",-4L);} catch (invfmt) {err ();}
put ("0 +o: "); try {putf ("->%0 +o<-\n",0L);} catch (invfmt) {err ();}
put ("0 +o: "); try {putf ("->%0 +o<-\n",4L);} catch (invfmt) {err ();}
put ("# +o: "); try {putf ("->%# +o<-\n",-4L);} catch (invfmt) {err ();}
put ("# +o: "); try {putf ("->%# +o<-\n",0L);} catch (invfmt) {err ();}
put ("# +o: "); try {putf ("->%# +o<-\n",4L);} catch (invfmt) {err ();}
put (" +o: "); try {putf ("->% +o<-\n",-4L);} catch (invfmt) {err ();}
put (" +o: "); try {putf ("->% +o<-\n",0L);} catch (invfmt) {err ();}
put (" +o: "); try {putf ("->% +o<-\n",4L);} catch (invfmt) {err ();}
put ("#0-+o: "); try {putf ("->%#0-+o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-+o: "); try {putf ("->%#0-+o<-\n",0L);} catch (invfmt) {err ();}
put ("#0-+o: "); try {putf ("->%#0-+o<-\n",4L);} catch (invfmt) {err ();}
put ("0-+o: "); try {putf ("->%0-+o<-\n",-4L);} catch (invfmt) {err ();}
put ("0-+o: "); try {putf ("->%0-+o<-\n",0L);} catch (invfmt) {err ();}
put ("0-+o: "); try {putf ("->%0-+o<-\n",4L);} catch (invfmt) {err ();}
put ("#-+o: "); try {putf ("->%#-+o<-\n",-4L);} catch (invfmt) {err ();}
put ("#-+o: "); try {putf ("->%#-+o<-\n",0L);} catch (invfmt) {err ();}
put ("#-+o: "); try {putf ("->%#-+o<-\n",4L);} catch (invfmt) {err ();}
put ("-+o: "); try {putf ("->%-+o<-\n",-4L);} catch (invfmt) {err ();}
put ("-+o: "); try {putf ("->%-+o<-\n",0L);} catch (invfmt) {err ();}
put ("-+o: "); try {putf ("->%-+o<-\n",4L);} catch (invfmt) {err ();}
put ("#0+o: "); try {putf ("->%#0+o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0+o: "); try {putf ("->%#0+o<-\n",0L);} catch (invfmt) {err ();}
put ("#0+o: "); try {putf ("->%#0+o<-\n",4L);} catch (invfmt) {err ();}
put ("0+o: "); try {putf ("->%0+o<-\n",-4L);} catch (invfmt) {err ();}
put ("0+o: "); try {putf ("->%0+o<-\n",0L);} catch (invfmt) {err ();}
put ("0+o: "); try {putf ("->%0+o<-\n",4L);} catch (invfmt) {err ();}
put ("#+o: "); try {putf ("->%#+o<-\n",-4L);} catch (invfmt) {err ();}
put ("#+o: "); try {putf ("->%#+o<-\n",0L);} catch (invfmt) {err ();}
put ("#+o: "); try {putf ("->%#+o<-\n",4L);} catch (invfmt) {err ();}
put ("+o: "); try {putf ("->%+o<-\n",-4L);} catch (invfmt) {err ();}
put ("+o: "); try {putf ("->%+o<-\n",0L);} catch (invfmt) {err ();}
put ("+o: "); try {putf ("->%+o<-\n",4L);} catch (invfmt) {err ();}
put ("#0- o: "); try {putf ("->%#0- o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- o: "); try {putf ("->%#0- o<-\n",0L);} catch (invfmt) {err ();}
put ("#0- o: "); try {putf ("->%#0- o<-\n",4L);} catch (invfmt) {err ();}
put ("0- o: "); try {putf ("->%0- o<-\n",-4L);} catch (invfmt) {err ();}
put ("0- o: "); try {putf ("->%0- o<-\n",0L);} catch (invfmt) {err ();}
put ("0- o: "); try {putf ("->%0- o<-\n",4L);} catch (invfmt) {err ();}
put ("#- o: "); try {putf ("->%#- o<-\n",-4L);} catch (invfmt) {err ();}
put ("#- o: "); try {putf ("->%#- o<-\n",0L);} catch (invfmt) {err ();}
put ("#- o: "); try {putf ("->%#- o<-\n",4L);} catch (invfmt) {err ();}
put ("- o: "); try {putf ("->%- o<-\n",-4L);} catch (invfmt) {err ();}
put ("- o: "); try {putf ("->%- o<-\n",0L);} catch (invfmt) {err ();}
put ("- o: "); try {putf ("->%- o<-\n",4L);} catch (invfmt) {err ();}
put ("#0 o: "); try {putf ("->%#0 o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 o: "); try {putf ("->%#0 o<-\n",0L);} catch (invfmt) {err ();}
put ("#0 o: "); try {putf ("->%#0 o<-\n",4L);} catch (invfmt) {err ();}
put ("0 o: "); try {putf ("->%0 o<-\n",-4L);} catch (invfmt) {err ();}
put ("0 o: "); try {putf ("->%0 o<-\n",0L);} catch (invfmt) {err ();}
put ("0 o: "); try {putf ("->%0 o<-\n",4L);} catch (invfmt) {err ();}
put ("# o: "); try {putf ("->%# o<-\n",-4L);} catch (invfmt) {err ();}
put ("# o: "); try {putf ("->%# o<-\n",0L);} catch (invfmt) {err ();}
put ("# o: "); try {putf ("->%# o<-\n",4L);} catch (invfmt) {err ();}
put (" o: "); try {putf ("->% o<-\n",-4L);} catch (invfmt) {err ();}
put (" o: "); try {putf ("->% o<-\n",0L);} catch (invfmt) {err ();}
put (" o: "); try {putf ("->% o<-\n",4L);} catch (invfmt) {err ();}
put ("#0-o: "); try {putf ("->%#0-o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-o: "); try {putf ("->%#0-o<-\n",0L);} catch (invfmt) {err ();}
put ("#0-o: "); try {putf ("->%#0-o<-\n",4L);} catch (invfmt) {err ();}
put ("0-o: "); try {putf ("->%0-o<-\n",-4L);} catch (invfmt) {err ();}
put ("0-o: "); try {putf ("->%0-o<-\n",0L);} catch (invfmt) {err ();}
put ("0-o: "); try {putf ("->%0-o<-\n",4L);} catch (invfmt) {err ();}
put ("#-o: "); try {putf ("->%#-o<-\n",-4L);} catch (invfmt) {err ();}
put ("#-o: "); try {putf ("->%#-o<-\n",0L);} catch (invfmt) {err ();}
put ("#-o: "); try {putf ("->%#-o<-\n",4L);} catch (invfmt) {err ();}
put ("-o: "); try {putf ("->%-o<-\n",-4L);} catch (invfmt) {err ();}
put ("-o: "); try {putf ("->%-o<-\n",0L);} catch (invfmt) {err ();}
put ("-o: "); try {putf ("->%-o<-\n",4L);} catch (invfmt) {err ();}
put ("#0o: "); try {putf ("->%#0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0o: "); try {putf ("->%#0o<-\n",0L);} catch (invfmt) {err ();}
put ("#0o: "); try {putf ("->%#0o<-\n",4L);} catch (invfmt) {err ();}
put ("0o: "); try {putf ("->%0o<-\n",-4L);} catch (invfmt) {err ();}
put ("0o: "); try {putf ("->%0o<-\n",0L);} catch (invfmt) {err ();}
put ("0o: "); try {putf ("->%0o<-\n",4L);} catch (invfmt) {err ();}
put ("#o: "); try {putf ("->%#o<-\n",-4L);} catch (invfmt) {err ();}
put ("#o: "); try {putf ("->%#o<-\n",0L);} catch (invfmt) {err ();}
put ("#o: "); try {putf ("->%#o<-\n",4L);} catch (invfmt) {err ();}
put ("o: "); try {putf ("->%o<-\n",-4L);} catch (invfmt) {err ();}
put ("o: "); try {putf ("->%o<-\n",0L);} catch (invfmt) {err ();}
put ("o: "); try {putf ("->%o<-\n",4L);} catch (invfmt) {err ();}
put ("#0- +x: "); try {putf ("->%#0- +x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- +x: "); try {putf ("->%#0- +x<-\n",0L);} catch (invfmt) {err ();}
put ("#0- +x: "); try {putf ("->%#0- +x<-\n",4L);} catch (invfmt) {err ();}
put ("0- +x: "); try {putf ("->%0- +x<-\n",-4L);} catch (invfmt) {err ();}
put ("0- +x: "); try {putf ("->%0- +x<-\n",0L);} catch (invfmt) {err ();}
put ("0- +x: "); try {putf ("->%0- +x<-\n",4L);} catch (invfmt) {err ();}
put ("#- +x: "); try {putf ("->%#- +x<-\n",-4L);} catch (invfmt) {err ();}
put ("#- +x: "); try {putf ("->%#- +x<-\n",0L);} catch (invfmt) {err ();}
put ("#- +x: "); try {putf ("->%#- +x<-\n",4L);} catch (invfmt) {err ();}
put ("- +x: "); try {putf ("->%- +x<-\n",-4L);} catch (invfmt) {err ();}
put ("- +x: "); try {putf ("->%- +x<-\n",0L);} catch (invfmt) {err ();}
put ("- +x: "); try {putf ("->%- +x<-\n",4L);} catch (invfmt) {err ();}
put ("#0 +x: "); try {putf ("->%#0 +x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 +x: "); try {putf ("->%#0 +x<-\n",0L);} catch (invfmt) {err ();}
put ("#0 +x: "); try {putf ("->%#0 +x<-\n",4L);} catch (invfmt) {err ();}
put ("0 +x: "); try {putf ("->%0 +x<-\n",-4L);} catch (invfmt) {err ();}
put ("0 +x: "); try {putf ("->%0 +x<-\n",0L);} catch (invfmt) {err ();}
put ("0 +x: "); try {putf ("->%0 +x<-\n",4L);} catch (invfmt) {err ();}
put ("# +x: "); try {putf ("->%# +x<-\n",-4L);} catch (invfmt) {err ();}
put ("# +x: "); try {putf ("->%# +x<-\n",0L);} catch (invfmt) {err ();}
put ("# +x: "); try {putf ("->%# +x<-\n",4L);} catch (invfmt) {err ();}
put (" +x: "); try {putf ("->% +x<-\n",-4L);} catch (invfmt) {err ();}
put (" +x: "); try {putf ("->% +x<-\n",0L);} catch (invfmt) {err ();}
put (" +x: "); try {putf ("->% +x<-\n",4L);} catch (invfmt) {err ();}
put ("#0-+x: "); try {putf ("->%#0-+x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-+x: "); try {putf ("->%#0-+x<-\n",0L);} catch (invfmt) {err ();}
put ("#0-+x: "); try {putf ("->%#0-+x<-\n",4L);} catch (invfmt) {err ();}
put ("0-+x: "); try {putf ("->%0-+x<-\n",-4L);} catch (invfmt) {err ();}
put ("0-+x: "); try {putf ("->%0-+x<-\n",0L);} catch (invfmt) {err ();}
put ("0-+x: "); try {putf ("->%0-+x<-\n",4L);} catch (invfmt) {err ();}
put ("#-+x: "); try {putf ("->%#-+x<-\n",-4L);} catch (invfmt) {err ();}
put ("#-+x: "); try {putf ("->%#-+x<-\n",0L);} catch (invfmt) {err ();}
put ("#-+x: "); try {putf ("->%#-+x<-\n",4L);} catch (invfmt) {err ();}
put ("-+x: "); try {putf ("->%-+x<-\n",-4L);} catch (invfmt) {err ();}
put ("-+x: "); try {putf ("->%-+x<-\n",0L);} catch (invfmt) {err ();}
put ("-+x: "); try {putf ("->%-+x<-\n",4L);} catch (invfmt) {err ();}
put ("#0+x: "); try {putf ("->%#0+x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0+x: "); try {putf ("->%#0+x<-\n",0L);} catch (invfmt) {err ();}
put ("#0+x: "); try {putf ("->%#0+x<-\n",4L);} catch (invfmt) {err ();}
put ("0+x: "); try {putf ("->%0+x<-\n",-4L);} catch (invfmt) {err ();}
put ("0+x: "); try {putf ("->%0+x<-\n",0L);} catch (invfmt) {err ();}
put ("0+x: "); try {putf ("->%0+x<-\n",4L);} catch (invfmt) {err ();}
put ("#+x: "); try {putf ("->%#+x<-\n",-4L);} catch (invfmt) {err ();}
put ("#+x: "); try {putf ("->%#+x<-\n",0L);} catch (invfmt) {err ();}
put ("#+x: "); try {putf ("->%#+x<-\n",4L);} catch (invfmt) {err ();}
put ("+x: "); try {putf ("->%+x<-\n",-4L);} catch (invfmt) {err ();}
put ("+x: "); try {putf ("->%+x<-\n",0L);} catch (invfmt) {err ();}
put ("+x: "); try {putf ("->%+x<-\n",4L);} catch (invfmt) {err ();}
put ("#0- x: "); try {putf ("->%#0- x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- x: "); try {putf ("->%#0- x<-\n",0L);} catch (invfmt) {err ();}
put ("#0- x: "); try {putf ("->%#0- x<-\n",4L);} catch (invfmt) {err ();}
put ("0- x: "); try {putf ("->%0- x<-\n",-4L);} catch (invfmt) {err ();}
put ("0- x: "); try {putf ("->%0- x<-\n",0L);} catch (invfmt) {err ();}
put ("0- x: "); try {putf ("->%0- x<-\n",4L);} catch (invfmt) {err ();}
put ("#- x: "); try {putf ("->%#- x<-\n",-4L);} catch (invfmt) {err ();}
put ("#- x: "); try {putf ("->%#- x<-\n",0L);} catch (invfmt) {err ();}
put ("#- x: "); try {putf ("->%#- x<-\n",4L);} catch (invfmt) {err ();}
put ("- x: "); try {putf ("->%- x<-\n",-4L);} catch (invfmt) {err ();}
put ("- x: "); try {putf ("->%- x<-\n",0L);} catch (invfmt) {err ();}
put ("- x: "); try {putf ("->%- x<-\n",4L);} catch (invfmt) {err ();}
put ("#0 x: "); try {putf ("->%#0 x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 x: "); try {putf ("->%#0 x<-\n",0L);} catch (invfmt) {err ();}
put ("#0 x: "); try {putf ("->%#0 x<-\n",4L);} catch (invfmt) {err ();}
put ("0 x: "); try {putf ("->%0 x<-\n",-4L);} catch (invfmt) {err ();}
put ("0 x: "); try {putf ("->%0 x<-\n",0L);} catch (invfmt) {err ();}
put ("0 x: "); try {putf ("->%0 x<-\n",4L);} catch (invfmt) {err ();}
put ("# x: "); try {putf ("->%# x<-\n",-4L);} catch (invfmt) {err ();}
put ("# x: "); try {putf ("->%# x<-\n",0L);} catch (invfmt) {err ();}
put ("# x: "); try {putf ("->%# x<-\n",4L);} catch (invfmt) {err ();}
put (" x: "); try {putf ("->% x<-\n",-4L);} catch (invfmt) {err ();}
put (" x: "); try {putf ("->% x<-\n",0L);} catch (invfmt) {err ();}
put (" x: "); try {putf ("->% x<-\n",4L);} catch (invfmt) {err ();}
put ("#0-x: "); try {putf ("->%#0-x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-x: "); try {putf ("->%#0-x<-\n",0L);} catch (invfmt) {err ();}
put ("#0-x: "); try {putf ("->%#0-x<-\n",4L);} catch (invfmt) {err ();}
put ("0-x: "); try {putf ("->%0-x<-\n",-4L);} catch (invfmt) {err ();}
put ("0-x: "); try {putf ("->%0-x<-\n",0L);} catch (invfmt) {err ();}
put ("0-x: "); try {putf ("->%0-x<-\n",4L);} catch (invfmt) {err ();}
put ("#-x: "); try {putf ("->%#-x<-\n",-4L);} catch (invfmt) {err ();}
put ("#-x: "); try {putf ("->%#-x<-\n",0L);} catch (invfmt) {err ();}
put ("#-x: "); try {putf ("->%#-x<-\n",4L);} catch (invfmt) {err ();}
put ("-x: "); try {putf ("->%-x<-\n",-4L);} catch (invfmt) {err ();}
put ("-x: "); try {putf ("->%-x<-\n",0L);} catch (invfmt) {err ();}
put ("-x: "); try {putf ("->%-x<-\n",4L);} catch (invfmt) {err ();}
put ("#0x: "); try {putf ("->%#0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0x: "); try {putf ("->%#0x<-\n",0L);} catch (invfmt) {err ();}
put ("#0x: "); try {putf ("->%#0x<-\n",4L);} catch (invfmt) {err ();}
put ("0x: "); try {putf ("->%0x<-\n",-4L);} catch (invfmt) {err ();}
put ("0x: "); try {putf ("->%0x<-\n",0L);} catch (invfmt) {err ();}
put ("0x: "); try {putf ("->%0x<-\n",4L);} catch (invfmt) {err ();}
put ("#x: "); try {putf ("->%#x<-\n",-4L);} catch (invfmt) {err ();}
put ("#x: "); try {putf ("->%#x<-\n",0L);} catch (invfmt) {err ();}
put ("#x: "); try {putf ("->%#x<-\n",4L);} catch (invfmt) {err ();}
put ("x: "); try {putf ("->%x<-\n",-4L);} catch (invfmt) {err ();}
put ("x: "); try {putf ("->%x<-\n",0L);} catch (invfmt) {err ();}
put ("x: "); try {putf ("->%x<-\n",4L);} catch (invfmt) {err ();}
put ("#0- +X: "); try {putf ("->%#0- +X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- +X: "); try {putf ("->%#0- +X<-\n",0L);} catch (invfmt) {err ();}
put ("#0- +X: "); try {putf ("->%#0- +X<-\n",4L);} catch (invfmt) {err ();}
put ("0- +X: "); try {putf ("->%0- +X<-\n",-4L);} catch (invfmt) {err ();}
put ("0- +X: "); try {putf ("->%0- +X<-\n",0L);} catch (invfmt) {err ();}
put ("0- +X: "); try {putf ("->%0- +X<-\n",4L);} catch (invfmt) {err ();}
put ("#- +X: "); try {putf ("->%#- +X<-\n",-4L);} catch (invfmt) {err ();}
put ("#- +X: "); try {putf ("->%#- +X<-\n",0L);} catch (invfmt) {err ();}
put ("#- +X: "); try {putf ("->%#- +X<-\n",4L);} catch (invfmt) {err ();}
put ("- +X: "); try {putf ("->%- +X<-\n",-4L);} catch (invfmt) {err ();}
put ("- +X: "); try {putf ("->%- +X<-\n",0L);} catch (invfmt) {err ();}
put ("- +X: "); try {putf ("->%- +X<-\n",4L);} catch (invfmt) {err ();}
put ("#0 +X: "); try {putf ("->%#0 +X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 +X: "); try {putf ("->%#0 +X<-\n",0L);} catch (invfmt) {err ();}
put ("#0 +X: "); try {putf ("->%#0 +X<-\n",4L);} catch (invfmt) {err ();}
put ("0 +X: "); try {putf ("->%0 +X<-\n",-4L);} catch (invfmt) {err ();}
put ("0 +X: "); try {putf ("->%0 +X<-\n",0L);} catch (invfmt) {err ();}
put ("0 +X: "); try {putf ("->%0 +X<-\n",4L);} catch (invfmt) {err ();}
put ("# +X: "); try {putf ("->%# +X<-\n",-4L);} catch (invfmt) {err ();}
put ("# +X: "); try {putf ("->%# +X<-\n",0L);} catch (invfmt) {err ();}
put ("# +X: "); try {putf ("->%# +X<-\n",4L);} catch (invfmt) {err ();}
put (" +X: "); try {putf ("->% +X<-\n",-4L);} catch (invfmt) {err ();}
put (" +X: "); try {putf ("->% +X<-\n",0L);} catch (invfmt) {err ();}
put (" +X: "); try {putf ("->% +X<-\n",4L);} catch (invfmt) {err ();}
put ("#0-+X: "); try {putf ("->%#0-+X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-+X: "); try {putf ("->%#0-+X<-\n",0L);} catch (invfmt) {err ();}
put ("#0-+X: "); try {putf ("->%#0-+X<-\n",4L);} catch (invfmt) {err ();}
put ("0-+X: "); try {putf ("->%0-+X<-\n",-4L);} catch (invfmt) {err ();}
put ("0-+X: "); try {putf ("->%0-+X<-\n",0L);} catch (invfmt) {err ();}
put ("0-+X: "); try {putf ("->%0-+X<-\n",4L);} catch (invfmt) {err ();}
put ("#-+X: "); try {putf ("->%#-+X<-\n",-4L);} catch (invfmt) {err ();}
put ("#-+X: "); try {putf ("->%#-+X<-\n",0L);} catch (invfmt) {err ();}
put ("#-+X: "); try {putf ("->%#-+X<-\n",4L);} catch (invfmt) {err ();}
put ("-+X: "); try {putf ("->%-+X<-\n",-4L);} catch (invfmt) {err ();}
put ("-+X: "); try {putf ("->%-+X<-\n",0L);} catch (invfmt) {err ();}
put ("-+X: "); try {putf ("->%-+X<-\n",4L);} catch (invfmt) {err ();}
put ("#0+X: "); try {putf ("->%#0+X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0+X: "); try {putf ("->%#0+X<-\n",0L);} catch (invfmt) {err ();}
put ("#0+X: "); try {putf ("->%#0+X<-\n",4L);} catch (invfmt) {err ();}
put ("0+X: "); try {putf ("->%0+X<-\n",-4L);} catch (invfmt) {err ();}
put ("0+X: "); try {putf ("->%0+X<-\n",0L);} catch (invfmt) {err ();}
put ("0+X: "); try {putf ("->%0+X<-\n",4L);} catch (invfmt) {err ();}
put ("#+X: "); try {putf ("->%#+X<-\n",-4L);} catch (invfmt) {err ();}
put ("#+X: "); try {putf ("->%#+X<-\n",0L);} catch (invfmt) {err ();}
put ("#+X: "); try {putf ("->%#+X<-\n",4L);} catch (invfmt) {err ();}
put ("+X: "); try {putf ("->%+X<-\n",-4L);} catch (invfmt) {err ();}
put ("+X: "); try {putf ("->%+X<-\n",0L);} catch (invfmt) {err ();}
put ("+X: "); try {putf ("->%+X<-\n",4L);} catch (invfmt) {err ();}
put ("#0- X: "); try {putf ("->%#0- X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- X: "); try {putf ("->%#0- X<-\n",0L);} catch (invfmt) {err ();}
put ("#0- X: "); try {putf ("->%#0- X<-\n",4L);} catch (invfmt) {err ();}
put ("0- X: "); try {putf ("->%0- X<-\n",-4L);} catch (invfmt) {err ();}
put ("0- X: "); try {putf ("->%0- X<-\n",0L);} catch (invfmt) {err ();}
put ("0- X: "); try {putf ("->%0- X<-\n",4L);} catch (invfmt) {err ();}
put ("#- X: "); try {putf ("->%#- X<-\n",-4L);} catch (invfmt) {err ();}
put ("#- X: "); try {putf ("->%#- X<-\n",0L);} catch (invfmt) {err ();}
put ("#- X: "); try {putf ("->%#- X<-\n",4L);} catch (invfmt) {err ();}
put ("- X: "); try {putf ("->%- X<-\n",-4L);} catch (invfmt) {err ();}
put ("- X: "); try {putf ("->%- X<-\n",0L);} catch (invfmt) {err ();}
put ("- X: "); try {putf ("->%- X<-\n",4L);} catch (invfmt) {err ();}
put ("#0 X: "); try {putf ("->%#0 X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 X: "); try {putf ("->%#0 X<-\n",0L);} catch (invfmt) {err ();}
put ("#0 X: "); try {putf ("->%#0 X<-\n",4L);} catch (invfmt) {err ();}
put ("0 X: "); try {putf ("->%0 X<-\n",-4L);} catch (invfmt) {err ();}
put ("0 X: "); try {putf ("->%0 X<-\n",0L);} catch (invfmt) {err ();}
put ("0 X: "); try {putf ("->%0 X<-\n",4L);} catch (invfmt) {err ();}
put ("# X: "); try {putf ("->%# X<-\n",-4L);} catch (invfmt) {err ();}
put ("# X: "); try {putf ("->%# X<-\n",0L);} catch (invfmt) {err ();}
put ("# X: "); try {putf ("->%# X<-\n",4L);} catch (invfmt) {err ();}
put (" X: "); try {putf ("->% X<-\n",-4L);} catch (invfmt) {err ();}
put (" X: "); try {putf ("->% X<-\n",0L);} catch (invfmt) {err ();}
put (" X: "); try {putf ("->% X<-\n",4L);} catch (invfmt) {err ();}
put ("#0-X: "); try {putf ("->%#0-X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-X: "); try {putf ("->%#0-X<-\n",0L);} catch (invfmt) {err ();}
put ("#0-X: "); try {putf ("->%#0-X<-\n",4L);} catch (invfmt) {err ();}
put ("0-X: "); try {putf ("->%0-X<-\n",-4L);} catch (invfmt) {err ();}
put ("0-X: "); try {putf ("->%0-X<-\n",0L);} catch (invfmt) {err ();}
put ("0-X: "); try {putf ("->%0-X<-\n",4L);} catch (invfmt) {err ();}
put ("#-X: "); try {putf ("->%#-X<-\n",-4L);} catch (invfmt) {err ();}
put ("#-X: "); try {putf ("->%#-X<-\n",0L);} catch (invfmt) {err ();}
put ("#-X: "); try {putf ("->%#-X<-\n",4L);} catch (invfmt) {err ();}
put ("-X: "); try {putf ("->%-X<-\n",-4L);} catch (invfmt) {err ();}
put ("-X: "); try {putf ("->%-X<-\n",0L);} catch (invfmt) {err ();}
put ("-X: "); try {putf ("->%-X<-\n",4L);} catch (invfmt) {err ();}
put ("#0X: "); try {putf ("->%#0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0X: "); try {putf ("->%#0X<-\n",0L);} catch (invfmt) {err ();}
put ("#0X: "); try {putf ("->%#0X<-\n",4L);} catch (invfmt) {err ();}
put ("0X: "); try {putf ("->%0X<-\n",-4L);} catch (invfmt) {err ();}
put ("0X: "); try {putf ("->%0X<-\n",0L);} catch (invfmt) {err ();}
put ("0X: "); try {putf ("->%0X<-\n",4L);} catch (invfmt) {err ();}
put ("#X: "); try {putf ("->%#X<-\n",-4L);} catch (invfmt) {err ();}
put ("#X: "); try {putf ("->%#X<-\n",0L);} catch (invfmt) {err ();}
put ("#X: "); try {putf ("->%#X<-\n",4L);} catch (invfmt) {err ();}
put ("X: "); try {putf ("->%X<-\n",-4L);} catch (invfmt) {err ();}
put ("X: "); try {putf ("->%X<-\n",0L);} catch (invfmt) {err ();}
put ("X: "); try {putf ("->%X<-\n",4L);} catch (invfmt) {err ();}
put ("#0- +0d: "); try {putf ("->%#0- +0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- +0d: "); try {putf ("->%#0- +0d<-\n",0L);} catch (invfmt) {err ();}
put ("#0- +0d: "); try {putf ("->%#0- +0d<-\n",4L);} catch (invfmt) {err ();}
put ("0- +0d: "); try {putf ("->%0- +0d<-\n",-4L);} catch (invfmt) {err ();}
put ("0- +0d: "); try {putf ("->%0- +0d<-\n",0L);} catch (invfmt) {err ();}
put ("0- +0d: "); try {putf ("->%0- +0d<-\n",4L);} catch (invfmt) {err ();}
put ("#- +0d: "); try {putf ("->%#- +0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#- +0d: "); try {putf ("->%#- +0d<-\n",0L);} catch (invfmt) {err ();}
put ("#- +0d: "); try {putf ("->%#- +0d<-\n",4L);} catch (invfmt) {err ();}
put ("- +0d: "); try {putf ("->%- +0d<-\n",-4L);} catch (invfmt) {err ();}
put ("- +0d: "); try {putf ("->%- +0d<-\n",0L);} catch (invfmt) {err ();}
put ("- +0d: "); try {putf ("->%- +0d<-\n",4L);} catch (invfmt) {err ();}
put ("#0 +0d: "); try {putf ("->%#0 +0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 +0d: "); try {putf ("->%#0 +0d<-\n",0L);} catch (invfmt) {err ();}
put ("#0 +0d: "); try {putf ("->%#0 +0d<-\n",4L);} catch (invfmt) {err ();}
put ("0 +0d: "); try {putf ("->%0 +0d<-\n",-4L);} catch (invfmt) {err ();}
put ("0 +0d: "); try {putf ("->%0 +0d<-\n",0L);} catch (invfmt) {err ();}
put ("0 +0d: "); try {putf ("->%0 +0d<-\n",4L);} catch (invfmt) {err ();}
put ("# +0d: "); try {putf ("->%# +0d<-\n",-4L);} catch (invfmt) {err ();}
put ("# +0d: "); try {putf ("->%# +0d<-\n",0L);} catch (invfmt) {err ();}
put ("# +0d: "); try {putf ("->%# +0d<-\n",4L);} catch (invfmt) {err ();}
put (" +0d: "); try {putf ("->% +0d<-\n",-4L);} catch (invfmt) {err ();}
put (" +0d: "); try {putf ("->% +0d<-\n",0L);} catch (invfmt) {err ();}
put (" +0d: "); try {putf ("->% +0d<-\n",4L);} catch (invfmt) {err ();}
put ("#0-+0d: "); try {putf ("->%#0-+0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-+0d: "); try {putf ("->%#0-+0d<-\n",0L);} catch (invfmt) {err ();}
put ("#0-+0d: "); try {putf ("->%#0-+0d<-\n",4L);} catch (invfmt) {err ();}
put ("0-+0d: "); try {putf ("->%0-+0d<-\n",-4L);} catch (invfmt) {err ();}
put ("0-+0d: "); try {putf ("->%0-+0d<-\n",0L);} catch (invfmt) {err ();}
put ("0-+0d: "); try {putf ("->%0-+0d<-\n",4L);} catch (invfmt) {err ();}
put ("#-+0d: "); try {putf ("->%#-+0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#-+0d: "); try {putf ("->%#-+0d<-\n",0L);} catch (invfmt) {err ();}
put ("#-+0d: "); try {putf ("->%#-+0d<-\n",4L);} catch (invfmt) {err ();}
put ("-+0d: "); try {putf ("->%-+0d<-\n",-4L);} catch (invfmt) {err ();}
put ("-+0d: "); try {putf ("->%-+0d<-\n",0L);} catch (invfmt) {err ();}
put ("-+0d: "); try {putf ("->%-+0d<-\n",4L);} catch (invfmt) {err ();}
put ("#0+0d: "); try {putf ("->%#0+0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0+0d: "); try {putf ("->%#0+0d<-\n",0L);} catch (invfmt) {err ();}
put ("#0+0d: "); try {putf ("->%#0+0d<-\n",4L);} catch (invfmt) {err ();}
put ("0+0d: "); try {putf ("->%0+0d<-\n",-4L);} catch (invfmt) {err ();}
put ("0+0d: "); try {putf ("->%0+0d<-\n",0L);} catch (invfmt) {err ();}
put ("0+0d: "); try {putf ("->%0+0d<-\n",4L);} catch (invfmt) {err ();}
put ("#+0d: "); try {putf ("->%#+0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#+0d: "); try {putf ("->%#+0d<-\n",0L);} catch (invfmt) {err ();}
put ("#+0d: "); try {putf ("->%#+0d<-\n",4L);} catch (invfmt) {err ();}
put ("+0d: "); try {putf ("->%+0d<-\n",-4L);} catch (invfmt) {err ();}
put ("+0d: "); try {putf ("->%+0d<-\n",0L);} catch (invfmt) {err ();}
put ("+0d: "); try {putf ("->%+0d<-\n",4L);} catch (invfmt) {err ();}
put ("#0- 0d: "); try {putf ("->%#0- 0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- 0d: "); try {putf ("->%#0- 0d<-\n",0L);} catch (invfmt) {err ();}
put ("#0- 0d: "); try {putf ("->%#0- 0d<-\n",4L);} catch (invfmt) {err ();}
put ("0- 0d: "); try {putf ("->%0- 0d<-\n",-4L);} catch (invfmt) {err ();}
put ("0- 0d: "); try {putf ("->%0- 0d<-\n",0L);} catch (invfmt) {err ();}
put ("0- 0d: "); try {putf ("->%0- 0d<-\n",4L);} catch (invfmt) {err ();}
put ("#- 0d: "); try {putf ("->%#- 0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#- 0d: "); try {putf ("->%#- 0d<-\n",0L);} catch (invfmt) {err ();}
put ("#- 0d: "); try {putf ("->%#- 0d<-\n",4L);} catch (invfmt) {err ();}
put ("- 0d: "); try {putf ("->%- 0d<-\n",-4L);} catch (invfmt) {err ();}
put ("- 0d: "); try {putf ("->%- 0d<-\n",0L);} catch (invfmt) {err ();}
put ("- 0d: "); try {putf ("->%- 0d<-\n",4L);} catch (invfmt) {err ();}
put ("#0 0d: "); try {putf ("->%#0 0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 0d: "); try {putf ("->%#0 0d<-\n",0L);} catch (invfmt) {err ();}
put ("#0 0d: "); try {putf ("->%#0 0d<-\n",4L);} catch (invfmt) {err ();}
put ("0 0d: "); try {putf ("->%0 0d<-\n",-4L);} catch (invfmt) {err ();}
put ("0 0d: "); try {putf ("->%0 0d<-\n",0L);} catch (invfmt) {err ();}
put ("0 0d: "); try {putf ("->%0 0d<-\n",4L);} catch (invfmt) {err ();}
put ("# 0d: "); try {putf ("->%# 0d<-\n",-4L);} catch (invfmt) {err ();}
put ("# 0d: "); try {putf ("->%# 0d<-\n",0L);} catch (invfmt) {err ();}
put ("# 0d: "); try {putf ("->%# 0d<-\n",4L);} catch (invfmt) {err ();}
put (" 0d: "); try {putf ("->% 0d<-\n",-4L);} catch (invfmt) {err ();}
put (" 0d: "); try {putf ("->% 0d<-\n",0L);} catch (invfmt) {err ();}
put (" 0d: "); try {putf ("->% 0d<-\n",4L);} catch (invfmt) {err ();}
put ("#0-0d: "); try {putf ("->%#0-0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-0d: "); try {putf ("->%#0-0d<-\n",0L);} catch (invfmt) {err ();}
put ("#0-0d: "); try {putf ("->%#0-0d<-\n",4L);} catch (invfmt) {err ();}
put ("0-0d: "); try {putf ("->%0-0d<-\n",-4L);} catch (invfmt) {err ();}
put ("0-0d: "); try {putf ("->%0-0d<-\n",0L);} catch (invfmt) {err ();}
put ("0-0d: "); try {putf ("->%0-0d<-\n",4L);} catch (invfmt) {err ();}
put ("#-0d: "); try {putf ("->%#-0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#-0d: "); try {putf ("->%#-0d<-\n",0L);} catch (invfmt) {err ();}
put ("#-0d: "); try {putf ("->%#-0d<-\n",4L);} catch (invfmt) {err ();}
put ("-0d: "); try {putf ("->%-0d<-\n",-4L);} catch (invfmt) {err ();}
put ("-0d: "); try {putf ("->%-0d<-\n",0L);} catch (invfmt) {err ();}
put ("-0d: "); try {putf ("->%-0d<-\n",4L);} catch (invfmt) {err ();}
put ("#00d: "); try {putf ("->%#00d<-\n",-4L);} catch (invfmt) {err ();}
put ("#00d: "); try {putf ("->%#00d<-\n",0L);} catch (invfmt) {err ();}
put ("#00d: "); try {putf ("->%#00d<-\n",4L);} catch (invfmt) {err ();}
put ("00d: "); try {putf ("->%00d<-\n",-4L);} catch (invfmt) {err ();}
put ("00d: "); try {putf ("->%00d<-\n",0L);} catch (invfmt) {err ();}
put ("00d: "); try {putf ("->%00d<-\n",4L);} catch (invfmt) {err ();}
put ("#0d: "); try {putf ("->%#0d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0d: "); try {putf ("->%#0d<-\n",0L);} catch (invfmt) {err ();}
put ("#0d: "); try {putf ("->%#0d<-\n",4L);} catch (invfmt) {err ();}
put ("0d: "); try {putf ("->%0d<-\n",-4L);} catch (invfmt) {err ();}
put ("0d: "); try {putf ("->%0d<-\n",0L);} catch (invfmt) {err ();}
put ("0d: "); try {putf ("->%0d<-\n",4L);} catch (invfmt) {err ();}
put ("#0- +0o: "); try {putf ("->%#0- +0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- +0o: "); try {putf ("->%#0- +0o<-\n",0L);} catch (invfmt) {err ();}
put ("#0- +0o: "); try {putf ("->%#0- +0o<-\n",4L);} catch (invfmt) {err ();}
put ("0- +0o: "); try {putf ("->%0- +0o<-\n",-4L);} catch (invfmt) {err ();}
put ("0- +0o: "); try {putf ("->%0- +0o<-\n",0L);} catch (invfmt) {err ();}
put ("0- +0o: "); try {putf ("->%0- +0o<-\n",4L);} catch (invfmt) {err ();}
put ("#- +0o: "); try {putf ("->%#- +0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#- +0o: "); try {putf ("->%#- +0o<-\n",0L);} catch (invfmt) {err ();}
put ("#- +0o: "); try {putf ("->%#- +0o<-\n",4L);} catch (invfmt) {err ();}
put ("- +0o: "); try {putf ("->%- +0o<-\n",-4L);} catch (invfmt) {err ();}
put ("- +0o: "); try {putf ("->%- +0o<-\n",0L);} catch (invfmt) {err ();}
put ("- +0o: "); try {putf ("->%- +0o<-\n",4L);} catch (invfmt) {err ();}
put ("#0 +0o: "); try {putf ("->%#0 +0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 +0o: "); try {putf ("->%#0 +0o<-\n",0L);} catch (invfmt) {err ();}
put ("#0 +0o: "); try {putf ("->%#0 +0o<-\n",4L);} catch (invfmt) {err ();}
put ("0 +0o: "); try {putf ("->%0 +0o<-\n",-4L);} catch (invfmt) {err ();}
put ("0 +0o: "); try {putf ("->%0 +0o<-\n",0L);} catch (invfmt) {err ();}
put ("0 +0o: "); try {putf ("->%0 +0o<-\n",4L);} catch (invfmt) {err ();}
put ("# +0o: "); try {putf ("->%# +0o<-\n",-4L);} catch (invfmt) {err ();}
put ("# +0o: "); try {putf ("->%# +0o<-\n",0L);} catch (invfmt) {err ();}
put ("# +0o: "); try {putf ("->%# +0o<-\n",4L);} catch (invfmt) {err ();}
put (" +0o: "); try {putf ("->% +0o<-\n",-4L);} catch (invfmt) {err ();}
put (" +0o: "); try {putf ("->% +0o<-\n",0L);} catch (invfmt) {err ();}
put (" +0o: "); try {putf ("->% +0o<-\n",4L);} catch (invfmt) {err ();}
put ("#0-+0o: "); try {putf ("->%#0-+0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-+0o: "); try {putf ("->%#0-+0o<-\n",0L);} catch (invfmt) {err ();}
put ("#0-+0o: "); try {putf ("->%#0-+0o<-\n",4L);} catch (invfmt) {err ();}
put ("0-+0o: "); try {putf ("->%0-+0o<-\n",-4L);} catch (invfmt) {err ();}
put ("0-+0o: "); try {putf ("->%0-+0o<-\n",0L);} catch (invfmt) {err ();}
put ("0-+0o: "); try {putf ("->%0-+0o<-\n",4L);} catch (invfmt) {err ();}
put ("#-+0o: "); try {putf ("->%#-+0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#-+0o: "); try {putf ("->%#-+0o<-\n",0L);} catch (invfmt) {err ();}
put ("#-+0o: "); try {putf ("->%#-+0o<-\n",4L);} catch (invfmt) {err ();}
put ("-+0o: "); try {putf ("->%-+0o<-\n",-4L);} catch (invfmt) {err ();}
put ("-+0o: "); try {putf ("->%-+0o<-\n",0L);} catch (invfmt) {err ();}
put ("-+0o: "); try {putf ("->%-+0o<-\n",4L);} catch (invfmt) {err ();}
put ("#0+0o: "); try {putf ("->%#0+0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0+0o: "); try {putf ("->%#0+0o<-\n",0L);} catch (invfmt) {err ();}
put ("#0+0o: "); try {putf ("->%#0+0o<-\n",4L);} catch (invfmt) {err ();}
put ("0+0o: "); try {putf ("->%0+0o<-\n",-4L);} catch (invfmt) {err ();}
put ("0+0o: "); try {putf ("->%0+0o<-\n",0L);} catch (invfmt) {err ();}
put ("0+0o: "); try {putf ("->%0+0o<-\n",4L);} catch (invfmt) {err ();}
put ("#+0o: "); try {putf ("->%#+0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#+0o: "); try {putf ("->%#+0o<-\n",0L);} catch (invfmt) {err ();}
put ("#+0o: "); try {putf ("->%#+0o<-\n",4L);} catch (invfmt) {err ();}
put ("+0o: "); try {putf ("->%+0o<-\n",-4L);} catch (invfmt) {err ();}
put ("+0o: "); try {putf ("->%+0o<-\n",0L);} catch (invfmt) {err ();}
put ("+0o: "); try {putf ("->%+0o<-\n",4L);} catch (invfmt) {err ();}
put ("#0- 0o: "); try {putf ("->%#0- 0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- 0o: "); try {putf ("->%#0- 0o<-\n",0L);} catch (invfmt) {err ();}
put ("#0- 0o: "); try {putf ("->%#0- 0o<-\n",4L);} catch (invfmt) {err ();}
put ("0- 0o: "); try {putf ("->%0- 0o<-\n",-4L);} catch (invfmt) {err ();}
put ("0- 0o: "); try {putf ("->%0- 0o<-\n",0L);} catch (invfmt) {err ();}
put ("0- 0o: "); try {putf ("->%0- 0o<-\n",4L);} catch (invfmt) {err ();}
put ("#- 0o: "); try {putf ("->%#- 0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#- 0o: "); try {putf ("->%#- 0o<-\n",0L);} catch (invfmt) {err ();}
put ("#- 0o: "); try {putf ("->%#- 0o<-\n",4L);} catch (invfmt) {err ();}
put ("- 0o: "); try {putf ("->%- 0o<-\n",-4L);} catch (invfmt) {err ();}
put ("- 0o: "); try {putf ("->%- 0o<-\n",0L);} catch (invfmt) {err ();}
put ("- 0o: "); try {putf ("->%- 0o<-\n",4L);} catch (invfmt) {err ();}
put ("#0 0o: "); try {putf ("->%#0 0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 0o: "); try {putf ("->%#0 0o<-\n",0L);} catch (invfmt) {err ();}
put ("#0 0o: "); try {putf ("->%#0 0o<-\n",4L);} catch (invfmt) {err ();}
put ("0 0o: "); try {putf ("->%0 0o<-\n",-4L);} catch (invfmt) {err ();}
put ("0 0o: "); try {putf ("->%0 0o<-\n",0L);} catch (invfmt) {err ();}
put ("0 0o: "); try {putf ("->%0 0o<-\n",4L);} catch (invfmt) {err ();}
put ("# 0o: "); try {putf ("->%# 0o<-\n",-4L);} catch (invfmt) {err ();}
put ("# 0o: "); try {putf ("->%# 0o<-\n",0L);} catch (invfmt) {err ();}
put ("# 0o: "); try {putf ("->%# 0o<-\n",4L);} catch (invfmt) {err ();}
put (" 0o: "); try {putf ("->% 0o<-\n",-4L);} catch (invfmt) {err ();}
put (" 0o: "); try {putf ("->% 0o<-\n",0L);} catch (invfmt) {err ();}
put (" 0o: "); try {putf ("->% 0o<-\n",4L);} catch (invfmt) {err ();}
put ("#0-0o: "); try {putf ("->%#0-0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-0o: "); try {putf ("->%#0-0o<-\n",0L);} catch (invfmt) {err ();}
put ("#0-0o: "); try {putf ("->%#0-0o<-\n",4L);} catch (invfmt) {err ();}
put ("0-0o: "); try {putf ("->%0-0o<-\n",-4L);} catch (invfmt) {err ();}
put ("0-0o: "); try {putf ("->%0-0o<-\n",0L);} catch (invfmt) {err ();}
put ("0-0o: "); try {putf ("->%0-0o<-\n",4L);} catch (invfmt) {err ();}
put ("#-0o: "); try {putf ("->%#-0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#-0o: "); try {putf ("->%#-0o<-\n",0L);} catch (invfmt) {err ();}
put ("#-0o: "); try {putf ("->%#-0o<-\n",4L);} catch (invfmt) {err ();}
put ("-0o: "); try {putf ("->%-0o<-\n",-4L);} catch (invfmt) {err ();}
put ("-0o: "); try {putf ("->%-0o<-\n",0L);} catch (invfmt) {err ();}
put ("-0o: "); try {putf ("->%-0o<-\n",4L);} catch (invfmt) {err ();}
put ("#00o: "); try {putf ("->%#00o<-\n",-4L);} catch (invfmt) {err ();}
put ("#00o: "); try {putf ("->%#00o<-\n",0L);} catch (invfmt) {err ();}
put ("#00o: "); try {putf ("->%#00o<-\n",4L);} catch (invfmt) {err ();}
put ("00o: "); try {putf ("->%00o<-\n",-4L);} catch (invfmt) {err ();}
put ("00o: "); try {putf ("->%00o<-\n",0L);} catch (invfmt) {err ();}
put ("00o: "); try {putf ("->%00o<-\n",4L);} catch (invfmt) {err ();}
put ("#0o: "); try {putf ("->%#0o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0o: "); try {putf ("->%#0o<-\n",0L);} catch (invfmt) {err ();}
put ("#0o: "); try {putf ("->%#0o<-\n",4L);} catch (invfmt) {err ();}
put ("0o: "); try {putf ("->%0o<-\n",-4L);} catch (invfmt) {err ();}
put ("0o: "); try {putf ("->%0o<-\n",0L);} catch (invfmt) {err ();}
put ("0o: "); try {putf ("->%0o<-\n",4L);} catch (invfmt) {err ();}
put ("#0- +0x: "); try {putf ("->%#0- +0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- +0x: "); try {putf ("->%#0- +0x<-\n",0L);} catch (invfmt) {err ();}
put ("#0- +0x: "); try {putf ("->%#0- +0x<-\n",4L);} catch (invfmt) {err ();}
put ("0- +0x: "); try {putf ("->%0- +0x<-\n",-4L);} catch (invfmt) {err ();}
put ("0- +0x: "); try {putf ("->%0- +0x<-\n",0L);} catch (invfmt) {err ();}
put ("0- +0x: "); try {putf ("->%0- +0x<-\n",4L);} catch (invfmt) {err ();}
put ("#- +0x: "); try {putf ("->%#- +0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#- +0x: "); try {putf ("->%#- +0x<-\n",0L);} catch (invfmt) {err ();}
put ("#- +0x: "); try {putf ("->%#- +0x<-\n",4L);} catch (invfmt) {err ();}
put ("- +0x: "); try {putf ("->%- +0x<-\n",-4L);} catch (invfmt) {err ();}
put ("- +0x: "); try {putf ("->%- +0x<-\n",0L);} catch (invfmt) {err ();}
put ("- +0x: "); try {putf ("->%- +0x<-\n",4L);} catch (invfmt) {err ();}
put ("#0 +0x: "); try {putf ("->%#0 +0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 +0x: "); try {putf ("->%#0 +0x<-\n",0L);} catch (invfmt) {err ();}
put ("#0 +0x: "); try {putf ("->%#0 +0x<-\n",4L);} catch (invfmt) {err ();}
put ("0 +0x: "); try {putf ("->%0 +0x<-\n",-4L);} catch (invfmt) {err ();}
put ("0 +0x: "); try {putf ("->%0 +0x<-\n",0L);} catch (invfmt) {err ();}
put ("0 +0x: "); try {putf ("->%0 +0x<-\n",4L);} catch (invfmt) {err ();}
put ("# +0x: "); try {putf ("->%# +0x<-\n",-4L);} catch (invfmt) {err ();}
put ("# +0x: "); try {putf ("->%# +0x<-\n",0L);} catch (invfmt) {err ();}
put ("# +0x: "); try {putf ("->%# +0x<-\n",4L);} catch (invfmt) {err ();}
put (" +0x: "); try {putf ("->% +0x<-\n",-4L);} catch (invfmt) {err ();}
put (" +0x: "); try {putf ("->% +0x<-\n",0L);} catch (invfmt) {err ();}
put (" +0x: "); try {putf ("->% +0x<-\n",4L);} catch (invfmt) {err ();}
put ("#0-+0x: "); try {putf ("->%#0-+0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-+0x: "); try {putf ("->%#0-+0x<-\n",0L);} catch (invfmt) {err ();}
put ("#0-+0x: "); try {putf ("->%#0-+0x<-\n",4L);} catch (invfmt) {err ();}
put ("0-+0x: "); try {putf ("->%0-+0x<-\n",-4L);} catch (invfmt) {err ();}
put ("0-+0x: "); try {putf ("->%0-+0x<-\n",0L);} catch (invfmt) {err ();}
put ("0-+0x: "); try {putf ("->%0-+0x<-\n",4L);} catch (invfmt) {err ();}
put ("#-+0x: "); try {putf ("->%#-+0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#-+0x: "); try {putf ("->%#-+0x<-\n",0L);} catch (invfmt) {err ();}
put ("#-+0x: "); try {putf ("->%#-+0x<-\n",4L);} catch (invfmt) {err ();}
put ("-+0x: "); try {putf ("->%-+0x<-\n",-4L);} catch (invfmt) {err ();}
put ("-+0x: "); try {putf ("->%-+0x<-\n",0L);} catch (invfmt) {err ();}
put ("-+0x: "); try {putf ("->%-+0x<-\n",4L);} catch (invfmt) {err ();}
put ("#0+0x: "); try {putf ("->%#0+0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0+0x: "); try {putf ("->%#0+0x<-\n",0L);} catch (invfmt) {err ();}
put ("#0+0x: "); try {putf ("->%#0+0x<-\n",4L);} catch (invfmt) {err ();}
put ("0+0x: "); try {putf ("->%0+0x<-\n",-4L);} catch (invfmt) {err ();}
put ("0+0x: "); try {putf ("->%0+0x<-\n",0L);} catch (invfmt) {err ();}
put ("0+0x: "); try {putf ("->%0+0x<-\n",4L);} catch (invfmt) {err ();}
put ("#+0x: "); try {putf ("->%#+0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#+0x: "); try {putf ("->%#+0x<-\n",0L);} catch (invfmt) {err ();}
put ("#+0x: "); try {putf ("->%#+0x<-\n",4L);} catch (invfmt) {err ();}
put ("+0x: "); try {putf ("->%+0x<-\n",-4L);} catch (invfmt) {err ();}
put ("+0x: "); try {putf ("->%+0x<-\n",0L);} catch (invfmt) {err ();}
put ("+0x: "); try {putf ("->%+0x<-\n",4L);} catch (invfmt) {err ();}
put ("#0- 0x: "); try {putf ("->%#0- 0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- 0x: "); try {putf ("->%#0- 0x<-\n",0L);} catch (invfmt) {err ();}
put ("#0- 0x: "); try {putf ("->%#0- 0x<-\n",4L);} catch (invfmt) {err ();}
put ("0- 0x: "); try {putf ("->%0- 0x<-\n",-4L);} catch (invfmt) {err ();}
put ("0- 0x: "); try {putf ("->%0- 0x<-\n",0L);} catch (invfmt) {err ();}
put ("0- 0x: "); try {putf ("->%0- 0x<-\n",4L);} catch (invfmt) {err ();}
put ("#- 0x: "); try {putf ("->%#- 0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#- 0x: "); try {putf ("->%#- 0x<-\n",0L);} catch (invfmt) {err ();}
put ("#- 0x: "); try {putf ("->%#- 0x<-\n",4L);} catch (invfmt) {err ();}
put ("- 0x: "); try {putf ("->%- 0x<-\n",-4L);} catch (invfmt) {err ();}
put ("- 0x: "); try {putf ("->%- 0x<-\n",0L);} catch (invfmt) {err ();}
put ("- 0x: "); try {putf ("->%- 0x<-\n",4L);} catch (invfmt) {err ();}
put ("#0 0x: "); try {putf ("->%#0 0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 0x: "); try {putf ("->%#0 0x<-\n",0L);} catch (invfmt) {err ();}
put ("#0 0x: "); try {putf ("->%#0 0x<-\n",4L);} catch (invfmt) {err ();}
put ("0 0x: "); try {putf ("->%0 0x<-\n",-4L);} catch (invfmt) {err ();}
put ("0 0x: "); try {putf ("->%0 0x<-\n",0L);} catch (invfmt) {err ();}
put ("0 0x: "); try {putf ("->%0 0x<-\n",4L);} catch (invfmt) {err ();}
put ("# 0x: "); try {putf ("->%# 0x<-\n",-4L);} catch (invfmt) {err ();}
put ("# 0x: "); try {putf ("->%# 0x<-\n",0L);} catch (invfmt) {err ();}
put ("# 0x: "); try {putf ("->%# 0x<-\n",4L);} catch (invfmt) {err ();}
put (" 0x: "); try {putf ("->% 0x<-\n",-4L);} catch (invfmt) {err ();}
put (" 0x: "); try {putf ("->% 0x<-\n",0L);} catch (invfmt) {err ();}
put (" 0x: "); try {putf ("->% 0x<-\n",4L);} catch (invfmt) {err ();}
put ("#0-0x: "); try {putf ("->%#0-0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-0x: "); try {putf ("->%#0-0x<-\n",0L);} catch (invfmt) {err ();}
put ("#0-0x: "); try {putf ("->%#0-0x<-\n",4L);} catch (invfmt) {err ();}
put ("0-0x: "); try {putf ("->%0-0x<-\n",-4L);} catch (invfmt) {err ();}
put ("0-0x: "); try {putf ("->%0-0x<-\n",0L);} catch (invfmt) {err ();}
put ("0-0x: "); try {putf ("->%0-0x<-\n",4L);} catch (invfmt) {err ();}
put ("#-0x: "); try {putf ("->%#-0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#-0x: "); try {putf ("->%#-0x<-\n",0L);} catch (invfmt) {err ();}
put ("#-0x: "); try {putf ("->%#-0x<-\n",4L);} catch (invfmt) {err ();}
put ("-0x: "); try {putf ("->%-0x<-\n",-4L);} catch (invfmt) {err ();}
put ("-0x: "); try {putf ("->%-0x<-\n",0L);} catch (invfmt) {err ();}
put ("-0x: "); try {putf ("->%-0x<-\n",4L);} catch (invfmt) {err ();}
put ("#00x: "); try {putf ("->%#00x<-\n",-4L);} catch (invfmt) {err ();}
put ("#00x: "); try {putf ("->%#00x<-\n",0L);} catch (invfmt) {err ();}
put ("#00x: "); try {putf ("->%#00x<-\n",4L);} catch (invfmt) {err ();}
put ("00x: "); try {putf ("->%00x<-\n",-4L);} catch (invfmt) {err ();}
put ("00x: "); try {putf ("->%00x<-\n",0L);} catch (invfmt) {err ();}
put ("00x: "); try {putf ("->%00x<-\n",4L);} catch (invfmt) {err ();}
put ("#0x: "); try {putf ("->%#0x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0x: "); try {putf ("->%#0x<-\n",0L);} catch (invfmt) {err ();}
put ("#0x: "); try {putf ("->%#0x<-\n",4L);} catch (invfmt) {err ();}
put ("0x: "); try {putf ("->%0x<-\n",-4L);} catch (invfmt) {err ();}
put ("0x: "); try {putf ("->%0x<-\n",0L);} catch (invfmt) {err ();}
put ("0x: "); try {putf ("->%0x<-\n",4L);} catch (invfmt) {err ();}
put ("#0- +0X: "); try {putf ("->%#0- +0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- +0X: "); try {putf ("->%#0- +0X<-\n",0L);} catch (invfmt) {err ();}
put ("#0- +0X: "); try {putf ("->%#0- +0X<-\n",4L);} catch (invfmt) {err ();}
put ("0- +0X: "); try {putf ("->%0- +0X<-\n",-4L);} catch (invfmt) {err ();}
put ("0- +0X: "); try {putf ("->%0- +0X<-\n",0L);} catch (invfmt) {err ();}
put ("0- +0X: "); try {putf ("->%0- +0X<-\n",4L);} catch (invfmt) {err ();}
put ("#- +0X: "); try {putf ("->%#- +0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#- +0X: "); try {putf ("->%#- +0X<-\n",0L);} catch (invfmt) {err ();}
put ("#- +0X: "); try {putf ("->%#- +0X<-\n",4L);} catch (invfmt) {err ();}
put ("- +0X: "); try {putf ("->%- +0X<-\n",-4L);} catch (invfmt) {err ();}
put ("- +0X: "); try {putf ("->%- +0X<-\n",0L);} catch (invfmt) {err ();}
put ("- +0X: "); try {putf ("->%- +0X<-\n",4L);} catch (invfmt) {err ();}
put ("#0 +0X: "); try {putf ("->%#0 +0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 +0X: "); try {putf ("->%#0 +0X<-\n",0L);} catch (invfmt) {err ();}
put ("#0 +0X: "); try {putf ("->%#0 +0X<-\n",4L);} catch (invfmt) {err ();}
put ("0 +0X: "); try {putf ("->%0 +0X<-\n",-4L);} catch (invfmt) {err ();}
put ("0 +0X: "); try {putf ("->%0 +0X<-\n",0L);} catch (invfmt) {err ();}
put ("0 +0X: "); try {putf ("->%0 +0X<-\n",4L);} catch (invfmt) {err ();}
put ("# +0X: "); try {putf ("->%# +0X<-\n",-4L);} catch (invfmt) {err ();}
put ("# +0X: "); try {putf ("->%# +0X<-\n",0L);} catch (invfmt) {err ();}
put ("# +0X: "); try {putf ("->%# +0X<-\n",4L);} catch (invfmt) {err ();}
put (" +0X: "); try {putf ("->% +0X<-\n",-4L);} catch (invfmt) {err ();}
put (" +0X: "); try {putf ("->% +0X<-\n",0L);} catch (invfmt) {err ();}
put (" +0X: "); try {putf ("->% +0X<-\n",4L);} catch (invfmt) {err ();}
put ("#0-+0X: "); try {putf ("->%#0-+0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-+0X: "); try {putf ("->%#0-+0X<-\n",0L);} catch (invfmt) {err ();}
put ("#0-+0X: "); try {putf ("->%#0-+0X<-\n",4L);} catch (invfmt) {err ();}
put ("0-+0X: "); try {putf ("->%0-+0X<-\n",-4L);} catch (invfmt) {err ();}
put ("0-+0X: "); try {putf ("->%0-+0X<-\n",0L);} catch (invfmt) {err ();}
put ("0-+0X: "); try {putf ("->%0-+0X<-\n",4L);} catch (invfmt) {err ();}
put ("#-+0X: "); try {putf ("->%#-+0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#-+0X: "); try {putf ("->%#-+0X<-\n",0L);} catch (invfmt) {err ();}
put ("#-+0X: "); try {putf ("->%#-+0X<-\n",4L);} catch (invfmt) {err ();}
put ("-+0X: "); try {putf ("->%-+0X<-\n",-4L);} catch (invfmt) {err ();}
put ("-+0X: "); try {putf ("->%-+0X<-\n",0L);} catch (invfmt) {err ();}
put ("-+0X: "); try {putf ("->%-+0X<-\n",4L);} catch (invfmt) {err ();}
put ("#0+0X: "); try {putf ("->%#0+0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0+0X: "); try {putf ("->%#0+0X<-\n",0L);} catch (invfmt) {err ();}
put ("#0+0X: "); try {putf ("->%#0+0X<-\n",4L);} catch (invfmt) {err ();}
put ("0+0X: "); try {putf ("->%0+0X<-\n",-4L);} catch (invfmt) {err ();}
put ("0+0X: "); try {putf ("->%0+0X<-\n",0L);} catch (invfmt) {err ();}
put ("0+0X: "); try {putf ("->%0+0X<-\n",4L);} catch (invfmt) {err ();}
put ("#+0X: "); try {putf ("->%#+0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#+0X: "); try {putf ("->%#+0X<-\n",0L);} catch (invfmt) {err ();}
put ("#+0X: "); try {putf ("->%#+0X<-\n",4L);} catch (invfmt) {err ();}
put ("+0X: "); try {putf ("->%+0X<-\n",-4L);} catch (invfmt) {err ();}
put ("+0X: "); try {putf ("->%+0X<-\n",0L);} catch (invfmt) {err ();}
put ("+0X: "); try {putf ("->%+0X<-\n",4L);} catch (invfmt) {err ();}
put ("#0- 0X: "); try {putf ("->%#0- 0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- 0X: "); try {putf ("->%#0- 0X<-\n",0L);} catch (invfmt) {err ();}
put ("#0- 0X: "); try {putf ("->%#0- 0X<-\n",4L);} catch (invfmt) {err ();}
put ("0- 0X: "); try {putf ("->%0- 0X<-\n",-4L);} catch (invfmt) {err ();}
put ("0- 0X: "); try {putf ("->%0- 0X<-\n",0L);} catch (invfmt) {err ();}
put ("0- 0X: "); try {putf ("->%0- 0X<-\n",4L);} catch (invfmt) {err ();}
put ("#- 0X: "); try {putf ("->%#- 0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#- 0X: "); try {putf ("->%#- 0X<-\n",0L);} catch (invfmt) {err ();}
put ("#- 0X: "); try {putf ("->%#- 0X<-\n",4L);} catch (invfmt) {err ();}
put ("- 0X: "); try {putf ("->%- 0X<-\n",-4L);} catch (invfmt) {err ();}
put ("- 0X: "); try {putf ("->%- 0X<-\n",0L);} catch (invfmt) {err ();}
put ("- 0X: "); try {putf ("->%- 0X<-\n",4L);} catch (invfmt) {err ();}
put ("#0 0X: "); try {putf ("->%#0 0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 0X: "); try {putf ("->%#0 0X<-\n",0L);} catch (invfmt) {err ();}
put ("#0 0X: "); try {putf ("->%#0 0X<-\n",4L);} catch (invfmt) {err ();}
put ("0 0X: "); try {putf ("->%0 0X<-\n",-4L);} catch (invfmt) {err ();}
put ("0 0X: "); try {putf ("->%0 0X<-\n",0L);} catch (invfmt) {err ();}
put ("0 0X: "); try {putf ("->%0 0X<-\n",4L);} catch (invfmt) {err ();}
put ("# 0X: "); try {putf ("->%# 0X<-\n",-4L);} catch (invfmt) {err ();}
put ("# 0X: "); try {putf ("->%# 0X<-\n",0L);} catch (invfmt) {err ();}
put ("# 0X: "); try {putf ("->%# 0X<-\n",4L);} catch (invfmt) {err ();}
put (" 0X: "); try {putf ("->% 0X<-\n",-4L);} catch (invfmt) {err ();}
put (" 0X: "); try {putf ("->% 0X<-\n",0L);} catch (invfmt) {err ();}
put (" 0X: "); try {putf ("->% 0X<-\n",4L);} catch (invfmt) {err ();}
put ("#0-0X: "); try {putf ("->%#0-0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-0X: "); try {putf ("->%#0-0X<-\n",0L);} catch (invfmt) {err ();}
put ("#0-0X: "); try {putf ("->%#0-0X<-\n",4L);} catch (invfmt) {err ();}
put ("0-0X: "); try {putf ("->%0-0X<-\n",-4L);} catch (invfmt) {err ();}
put ("0-0X: "); try {putf ("->%0-0X<-\n",0L);} catch (invfmt) {err ();}
put ("0-0X: "); try {putf ("->%0-0X<-\n",4L);} catch (invfmt) {err ();}
put ("#-0X: "); try {putf ("->%#-0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#-0X: "); try {putf ("->%#-0X<-\n",0L);} catch (invfmt) {err ();}
put ("#-0X: "); try {putf ("->%#-0X<-\n",4L);} catch (invfmt) {err ();}
put ("-0X: "); try {putf ("->%-0X<-\n",-4L);} catch (invfmt) {err ();}
put ("-0X: "); try {putf ("->%-0X<-\n",0L);} catch (invfmt) {err ();}
put ("-0X: "); try {putf ("->%-0X<-\n",4L);} catch (invfmt) {err ();}
put ("#00X: "); try {putf ("->%#00X<-\n",-4L);} catch (invfmt) {err ();}
put ("#00X: "); try {putf ("->%#00X<-\n",0L);} catch (invfmt) {err ();}
put ("#00X: "); try {putf ("->%#00X<-\n",4L);} catch (invfmt) {err ();}
put ("00X: "); try {putf ("->%00X<-\n",-4L);} catch (invfmt) {err ();}
put ("00X: "); try {putf ("->%00X<-\n",0L);} catch (invfmt) {err ();}
put ("00X: "); try {putf ("->%00X<-\n",4L);} catch (invfmt) {err ();}
put ("#0X: "); try {putf ("->%#0X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0X: "); try {putf ("->%#0X<-\n",0L);} catch (invfmt) {err ();}
put ("#0X: "); try {putf ("->%#0X<-\n",4L);} catch (invfmt) {err ();}
put ("0X: "); try {putf ("->%0X<-\n",-4L);} catch (invfmt) {err ();}
put ("0X: "); try {putf ("->%0X<-\n",0L);} catch (invfmt) {err ();}
put ("0X: "); try {putf ("->%0X<-\n",4L);} catch (invfmt) {err ();}
put ("#0- +10d: "); try {putf ("->%#0- +10d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- +10d: "); try {putf ("->%#0- +10d<-\n",0L);} catch (invfmt) {err ();}
put ("#0- +10d: "); try {putf ("->%#0- +10d<-\n",4L);} catch (invfmt) {err ();}
put ("0- +10d: "); try {putf ("->%0- +10d<-\n",-4L);} catch (invfmt) {err ();}
put ("0- +10d: "); try {putf ("->%0- +10d<-\n",0L);} catch (invfmt) {err ();}
put ("0- +10d: "); try {putf ("->%0- +10d<-\n",4L);} catch (invfmt) {err ();}
put ("#- +10d: "); try {putf ("->%#- +10d<-\n",-4L);} catch (invfmt) {err ();}
put ("#- +10d: "); try {putf ("->%#- +10d<-\n",0L);} catch (invfmt) {err ();}
put ("#- +10d: "); try {putf ("->%#- +10d<-\n",4L);} catch (invfmt) {err ();}
put ("- +10d: "); try {putf ("->%- +10d<-\n",-4L);} catch (invfmt) {err ();}
put ("- +10d: "); try {putf ("->%- +10d<-\n",0L);} catch (invfmt) {err ();}
put ("- +10d: "); try {putf ("->%- +10d<-\n",4L);} catch (invfmt) {err ();}
put ("#0 +10d: "); try {putf ("->%#0 +10d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 +10d: "); try {putf ("->%#0 +10d<-\n",0L);} catch (invfmt) {err ();}
put ("#0 +10d: "); try {putf ("->%#0 +10d<-\n",4L);} catch (invfmt) {err ();}
put ("0 +10d: "); try {putf ("->%0 +10d<-\n",-4L);} catch (invfmt) {err ();}
put ("0 +10d: "); try {putf ("->%0 +10d<-\n",0L);} catch (invfmt) {err ();}
put ("0 +10d: "); try {putf ("->%0 +10d<-\n",4L);} catch (invfmt) {err ();}
put ("# +10d: "); try {putf ("->%# +10d<-\n",-4L);} catch (invfmt) {err ();}
put ("# +10d: "); try {putf ("->%# +10d<-\n",0L);} catch (invfmt) {err ();}
put ("# +10d: "); try {putf ("->%# +10d<-\n",4L);} catch (invfmt) {err ();}
put (" +10d: "); try {putf ("->% +10d<-\n",-4L);} catch (invfmt) {err ();}
put (" +10d: "); try {putf ("->% +10d<-\n",0L);} catch (invfmt) {err ();}
put (" +10d: "); try {putf ("->% +10d<-\n",4L);} catch (invfmt) {err ();}
put ("#0-+10d: "); try {putf ("->%#0-+10d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-+10d: "); try {putf ("->%#0-+10d<-\n",0L);} catch (invfmt) {err ();}
put ("#0-+10d: "); try {putf ("->%#0-+10d<-\n",4L);} catch (invfmt) {err ();}
put ("0-+10d: "); try {putf ("->%0-+10d<-\n",-4L);} catch (invfmt) {err ();}
put ("0-+10d: "); try {putf ("->%0-+10d<-\n",0L);} catch (invfmt) {err ();}
put ("0-+10d: "); try {putf ("->%0-+10d<-\n",4L);} catch (invfmt) {err ();}
put ("#-+10d: "); try {putf ("->%#-+10d<-\n",-4L);} catch (invfmt) {err ();}
put ("#-+10d: "); try {putf ("->%#-+10d<-\n",0L);} catch (invfmt) {err ();}
put ("#-+10d: "); try {putf ("->%#-+10d<-\n",4L);} catch (invfmt) {err ();}
put ("-+10d: "); try {putf ("->%-+10d<-\n",-4L);} catch (invfmt) {err ();}
put ("-+10d: "); try {putf ("->%-+10d<-\n",0L);} catch (invfmt) {err ();}
put ("-+10d: "); try {putf ("->%-+10d<-\n",4L);} catch (invfmt) {err ();}
put ("#0+10d: "); try {putf ("->%#0+10d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0+10d: "); try {putf ("->%#0+10d<-\n",0L);} catch (invfmt) {err ();}
put ("#0+10d: "); try {putf ("->%#0+10d<-\n",4L);} catch (invfmt) {err ();}
put ("0+10d: "); try {putf ("->%0+10d<-\n",-4L);} catch (invfmt) {err ();}
put ("0+10d: "); try {putf ("->%0+10d<-\n",0L);} catch (invfmt) {err ();}
put ("0+10d: "); try {putf ("->%0+10d<-\n",4L);} catch (invfmt) {err ();}
put ("#+10d: "); try {putf ("->%#+10d<-\n",-4L);} catch (invfmt) {err ();}
put ("#+10d: "); try {putf ("->%#+10d<-\n",0L);} catch (invfmt) {err ();}
put ("#+10d: "); try {putf ("->%#+10d<-\n",4L);} catch (invfmt) {err ();}
put ("+10d: "); try {putf ("->%+10d<-\n",-4L);} catch (invfmt) {err ();}
put ("+10d: "); try {putf ("->%+10d<-\n",0L);} catch (invfmt) {err ();}
put ("+10d: "); try {putf ("->%+10d<-\n",4L);} catch (invfmt) {err ();}
put ("#0- 10d: "); try {putf ("->%#0- 10d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- 10d: "); try {putf ("->%#0- 10d<-\n",0L);} catch (invfmt) {err ();}
put ("#0- 10d: "); try {putf ("->%#0- 10d<-\n",4L);} catch (invfmt) {err ();}
put ("0- 10d: "); try {putf ("->%0- 10d<-\n",-4L);} catch (invfmt) {err ();}
put ("0- 10d: "); try {putf ("->%0- 10d<-\n",0L);} catch (invfmt) {err ();}
put ("0- 10d: "); try {putf ("->%0- 10d<-\n",4L);} catch (invfmt) {err ();}
put ("#- 10d: "); try {putf ("->%#- 10d<-\n",-4L);} catch (invfmt) {err ();}
put ("#- 10d: "); try {putf ("->%#- 10d<-\n",0L);} catch (invfmt) {err ();}
put ("#- 10d: "); try {putf ("->%#- 10d<-\n",4L);} catch (invfmt) {err ();}
put ("- 10d: "); try {putf ("->%- 10d<-\n",-4L);} catch (invfmt) {err ();}
put ("- 10d: "); try {putf ("->%- 10d<-\n",0L);} catch (invfmt) {err ();}
put ("- 10d: "); try {putf ("->%- 10d<-\n",4L);} catch (invfmt) {err ();}
put ("#0 10d: "); try {putf ("->%#0 10d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 10d: "); try {putf ("->%#0 10d<-\n",0L);} catch (invfmt) {err ();}
put ("#0 10d: "); try {putf ("->%#0 10d<-\n",4L);} catch (invfmt) {err ();}
put ("0 10d: "); try {putf ("->%0 10d<-\n",-4L);} catch (invfmt) {err ();}
put ("0 10d: "); try {putf ("->%0 10d<-\n",0L);} catch (invfmt) {err ();}
put ("0 10d: "); try {putf ("->%0 10d<-\n",4L);} catch (invfmt) {err ();}
put ("# 10d: "); try {putf ("->%# 10d<-\n",-4L);} catch (invfmt) {err ();}
put ("# 10d: "); try {putf ("->%# 10d<-\n",0L);} catch (invfmt) {err ();}
put ("# 10d: "); try {putf ("->%# 10d<-\n",4L);} catch (invfmt) {err ();}
put (" 10d: "); try {putf ("->% 10d<-\n",-4L);} catch (invfmt) {err ();}
put (" 10d: "); try {putf ("->% 10d<-\n",0L);} catch (invfmt) {err ();}
put (" 10d: "); try {putf ("->% 10d<-\n",4L);} catch (invfmt) {err ();}
put ("#0-10d: "); try {putf ("->%#0-10d<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-10d: "); try {putf ("->%#0-10d<-\n",0L);} catch (invfmt) {err ();}
put ("#0-10d: "); try {putf ("->%#0-10d<-\n",4L);} catch (invfmt) {err ();}
put ("0-10d: "); try {putf ("->%0-10d<-\n",-4L);} catch (invfmt) {err ();}
put ("0-10d: "); try {putf ("->%0-10d<-\n",0L);} catch (invfmt) {err ();}
put ("0-10d: "); try {putf ("->%0-10d<-\n",4L);} catch (invfmt) {err ();}
put ("#-10d: "); try {putf ("->%#-10d<-\n",-4L);} catch (invfmt) {err ();}
put ("#-10d: "); try {putf ("->%#-10d<-\n",0L);} catch (invfmt) {err ();}
put ("#-10d: "); try {putf ("->%#-10d<-\n",4L);} catch (invfmt) {err ();}
put ("-10d: "); try {putf ("->%-10d<-\n",-4L);} catch (invfmt) {err ();}
put ("-10d: "); try {putf ("->%-10d<-\n",0L);} catch (invfmt) {err ();}
put ("-10d: "); try {putf ("->%-10d<-\n",4L);} catch (invfmt) {err ();}
put ("#010d: "); try {putf ("->%#010d<-\n",-4L);} catch (invfmt) {err ();}
put ("#010d: "); try {putf ("->%#010d<-\n",0L);} catch (invfmt) {err ();}
put ("#010d: "); try {putf ("->%#010d<-\n",4L);} catch (invfmt) {err ();}
put ("010d: "); try {putf ("->%010d<-\n",-4L);} catch (invfmt) {err ();}
put ("010d: "); try {putf ("->%010d<-\n",0L);} catch (invfmt) {err ();}
put ("010d: "); try {putf ("->%010d<-\n",4L);} catch (invfmt) {err ();}
put ("#10d: "); try {putf ("->%#10d<-\n",-4L);} catch (invfmt) {err ();}
put ("#10d: "); try {putf ("->%#10d<-\n",0L);} catch (invfmt) {err ();}
put ("#10d: "); try {putf ("->%#10d<-\n",4L);} catch (invfmt) {err ();}
put ("10d: "); try {putf ("->%10d<-\n",-4L);} catch (invfmt) {err ();}
put ("10d: "); try {putf ("->%10d<-\n",0L);} catch (invfmt) {err ();}
put ("10d: "); try {putf ("->%10d<-\n",4L);} catch (invfmt) {err ();}
put ("#0- +10o: "); try {putf ("->%#0- +10o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- +10o: "); try {putf ("->%#0- +10o<-\n",0L);} catch (invfmt) {err ();}
put ("#0- +10o: "); try {putf ("->%#0- +10o<-\n",4L);} catch (invfmt) {err ();}
put ("0- +10o: "); try {putf ("->%0- +10o<-\n",-4L);} catch (invfmt) {err ();}
put ("0- +10o: "); try {putf ("->%0- +10o<-\n",0L);} catch (invfmt) {err ();}
put ("0- +10o: "); try {putf ("->%0- +10o<-\n",4L);} catch (invfmt) {err ();}
put ("#- +10o: "); try {putf ("->%#- +10o<-\n",-4L);} catch (invfmt) {err ();}
put ("#- +10o: "); try {putf ("->%#- +10o<-\n",0L);} catch (invfmt) {err ();}
put ("#- +10o: "); try {putf ("->%#- +10o<-\n",4L);} catch (invfmt) {err ();}
put ("- +10o: "); try {putf ("->%- +10o<-\n",-4L);} catch (invfmt) {err ();}
put ("- +10o: "); try {putf ("->%- +10o<-\n",0L);} catch (invfmt) {err ();}
put ("- +10o: "); try {putf ("->%- +10o<-\n",4L);} catch (invfmt) {err ();}
put ("#0 +10o: "); try {putf ("->%#0 +10o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 +10o: "); try {putf ("->%#0 +10o<-\n",0L);} catch (invfmt) {err ();}
put ("#0 +10o: "); try {putf ("->%#0 +10o<-\n",4L);} catch (invfmt) {err ();}
put ("0 +10o: "); try {putf ("->%0 +10o<-\n",-4L);} catch (invfmt) {err ();}
put ("0 +10o: "); try {putf ("->%0 +10o<-\n",0L);} catch (invfmt) {err ();}
put ("0 +10o: "); try {putf ("->%0 +10o<-\n",4L);} catch (invfmt) {err ();}
put ("# +10o: "); try {putf ("->%# +10o<-\n",-4L);} catch (invfmt) {err ();}
put ("# +10o: "); try {putf ("->%# +10o<-\n",0L);} catch (invfmt) {err ();}
put ("# +10o: "); try {putf ("->%# +10o<-\n",4L);} catch (invfmt) {err ();}
put (" +10o: "); try {putf ("->% +10o<-\n",-4L);} catch (invfmt) {err ();}
put (" +10o: "); try {putf ("->% +10o<-\n",0L);} catch (invfmt) {err ();}
put (" +10o: "); try {putf ("->% +10o<-\n",4L);} catch (invfmt) {err ();}
put ("#0-+10o: "); try {putf ("->%#0-+10o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-+10o: "); try {putf ("->%#0-+10o<-\n",0L);} catch (invfmt) {err ();}
put ("#0-+10o: "); try {putf ("->%#0-+10o<-\n",4L);} catch (invfmt) {err ();}
put ("0-+10o: "); try {putf ("->%0-+10o<-\n",-4L);} catch (invfmt) {err ();}
put ("0-+10o: "); try {putf ("->%0-+10o<-\n",0L);} catch (invfmt) {err ();}
put ("0-+10o: "); try {putf ("->%0-+10o<-\n",4L);} catch (invfmt) {err ();}
put ("#-+10o: "); try {putf ("->%#-+10o<-\n",-4L);} catch (invfmt) {err ();}
put ("#-+10o: "); try {putf ("->%#-+10o<-\n",0L);} catch (invfmt) {err ();}
put ("#-+10o: "); try {putf ("->%#-+10o<-\n",4L);} catch (invfmt) {err ();}
put ("-+10o: "); try {putf ("->%-+10o<-\n",-4L);} catch (invfmt) {err ();}
put ("-+10o: "); try {putf ("->%-+10o<-\n",0L);} catch (invfmt) {err ();}
put ("-+10o: "); try {putf ("->%-+10o<-\n",4L);} catch (invfmt) {err ();}
put ("#0+10o: "); try {putf ("->%#0+10o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0+10o: "); try {putf ("->%#0+10o<-\n",0L);} catch (invfmt) {err ();}
put ("#0+10o: "); try {putf ("->%#0+10o<-\n",4L);} catch (invfmt) {err ();}
put ("0+10o: "); try {putf ("->%0+10o<-\n",-4L);} catch (invfmt) {err ();}
put ("0+10o: "); try {putf ("->%0+10o<-\n",0L);} catch (invfmt) {err ();}
put ("0+10o: "); try {putf ("->%0+10o<-\n",4L);} catch (invfmt) {err ();}
put ("#+10o: "); try {putf ("->%#+10o<-\n",-4L);} catch (invfmt) {err ();}
put ("#+10o: "); try {putf ("->%#+10o<-\n",0L);} catch (invfmt) {err ();}
put ("#+10o: "); try {putf ("->%#+10o<-\n",4L);} catch (invfmt) {err ();}
put ("+10o: "); try {putf ("->%+10o<-\n",-4L);} catch (invfmt) {err ();}
put ("+10o: "); try {putf ("->%+10o<-\n",0L);} catch (invfmt) {err ();}
put ("+10o: "); try {putf ("->%+10o<-\n",4L);} catch (invfmt) {err ();}
put ("#0- 10o: "); try {putf ("->%#0- 10o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- 10o: "); try {putf ("->%#0- 10o<-\n",0L);} catch (invfmt) {err ();}
put ("#0- 10o: "); try {putf ("->%#0- 10o<-\n",4L);} catch (invfmt) {err ();}
put ("0- 10o: "); try {putf ("->%0- 10o<-\n",-4L);} catch (invfmt) {err ();}
put ("0- 10o: "); try {putf ("->%0- 10o<-\n",0L);} catch (invfmt) {err ();}
put ("0- 10o: "); try {putf ("->%0- 10o<-\n",4L);} catch (invfmt) {err ();}
put ("#- 10o: "); try {putf ("->%#- 10o<-\n",-4L);} catch (invfmt) {err ();}
put ("#- 10o: "); try {putf ("->%#- 10o<-\n",0L);} catch (invfmt) {err ();}
put ("#- 10o: "); try {putf ("->%#- 10o<-\n",4L);} catch (invfmt) {err ();}
put ("- 10o: "); try {putf ("->%- 10o<-\n",-4L);} catch (invfmt) {err ();}
put ("- 10o: "); try {putf ("->%- 10o<-\n",0L);} catch (invfmt) {err ();}
put ("- 10o: "); try {putf ("->%- 10o<-\n",4L);} catch (invfmt) {err ();}
put ("#0 10o: "); try {putf ("->%#0 10o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 10o: "); try {putf ("->%#0 10o<-\n",0L);} catch (invfmt) {err ();}
put ("#0 10o: "); try {putf ("->%#0 10o<-\n",4L);} catch (invfmt) {err ();}
put ("0 10o: "); try {putf ("->%0 10o<-\n",-4L);} catch (invfmt) {err ();}
put ("0 10o: "); try {putf ("->%0 10o<-\n",0L);} catch (invfmt) {err ();}
put ("0 10o: "); try {putf ("->%0 10o<-\n",4L);} catch (invfmt) {err ();}
put ("# 10o: "); try {putf ("->%# 10o<-\n",-4L);} catch (invfmt) {err ();}
put ("# 10o: "); try {putf ("->%# 10o<-\n",0L);} catch (invfmt) {err ();}
put ("# 10o: "); try {putf ("->%# 10o<-\n",4L);} catch (invfmt) {err ();}
put (" 10o: "); try {putf ("->% 10o<-\n",-4L);} catch (invfmt) {err ();}
put (" 10o: "); try {putf ("->% 10o<-\n",0L);} catch (invfmt) {err ();}
put (" 10o: "); try {putf ("->% 10o<-\n",4L);} catch (invfmt) {err ();}
put ("#0-10o: "); try {putf ("->%#0-10o<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-10o: "); try {putf ("->%#0-10o<-\n",0L);} catch (invfmt) {err ();}
put ("#0-10o: "); try {putf ("->%#0-10o<-\n",4L);} catch (invfmt) {err ();}
put ("0-10o: "); try {putf ("->%0-10o<-\n",-4L);} catch (invfmt) {err ();}
put ("0-10o: "); try {putf ("->%0-10o<-\n",0L);} catch (invfmt) {err ();}
put ("0-10o: "); try {putf ("->%0-10o<-\n",4L);} catch (invfmt) {err ();}
put ("#-10o: "); try {putf ("->%#-10o<-\n",-4L);} catch (invfmt) {err ();}
put ("#-10o: "); try {putf ("->%#-10o<-\n",0L);} catch (invfmt) {err ();}
put ("#-10o: "); try {putf ("->%#-10o<-\n",4L);} catch (invfmt) {err ();}
put ("-10o: "); try {putf ("->%-10o<-\n",-4L);} catch (invfmt) {err ();}
put ("-10o: "); try {putf ("->%-10o<-\n",0L);} catch (invfmt) {err ();}
put ("-10o: "); try {putf ("->%-10o<-\n",4L);} catch (invfmt) {err ();}
put ("#010o: "); try {putf ("->%#010o<-\n",-4L);} catch (invfmt) {err ();}
put ("#010o: "); try {putf ("->%#010o<-\n",0L);} catch (invfmt) {err ();}
put ("#010o: "); try {putf ("->%#010o<-\n",4L);} catch (invfmt) {err ();}
put ("010o: "); try {putf ("->%010o<-\n",-4L);} catch (invfmt) {err ();}
put ("010o: "); try {putf ("->%010o<-\n",0L);} catch (invfmt) {err ();}
put ("010o: "); try {putf ("->%010o<-\n",4L);} catch (invfmt) {err ();}
put ("#10o: "); try {putf ("->%#10o<-\n",-4L);} catch (invfmt) {err ();}
put ("#10o: "); try {putf ("->%#10o<-\n",0L);} catch (invfmt) {err ();}
put ("#10o: "); try {putf ("->%#10o<-\n",4L);} catch (invfmt) {err ();}
put ("10o: "); try {putf ("->%10o<-\n",-4L);} catch (invfmt) {err ();}
put ("10o: "); try {putf ("->%10o<-\n",0L);} catch (invfmt) {err ();}
put ("10o: "); try {putf ("->%10o<-\n",4L);} catch (invfmt) {err ();}
put ("#0- +10x: "); try {putf ("->%#0- +10x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- +10x: "); try {putf ("->%#0- +10x<-\n",0L);} catch (invfmt) {err ();}
put ("#0- +10x: "); try {putf ("->%#0- +10x<-\n",4L);} catch (invfmt) {err ();}
put ("0- +10x: "); try {putf ("->%0- +10x<-\n",-4L);} catch (invfmt) {err ();}
put ("0- +10x: "); try {putf ("->%0- +10x<-\n",0L);} catch (invfmt) {err ();}
put ("0- +10x: "); try {putf ("->%0- +10x<-\n",4L);} catch (invfmt) {err ();}
put ("#- +10x: "); try {putf ("->%#- +10x<-\n",-4L);} catch (invfmt) {err ();}
put ("#- +10x: "); try {putf ("->%#- +10x<-\n",0L);} catch (invfmt) {err ();}
put ("#- +10x: "); try {putf ("->%#- +10x<-\n",4L);} catch (invfmt) {err ();}
put ("- +10x: "); try {putf ("->%- +10x<-\n",-4L);} catch (invfmt) {err ();}
put ("- +10x: "); try {putf ("->%- +10x<-\n",0L);} catch (invfmt) {err ();}
put ("- +10x: "); try {putf ("->%- +10x<-\n",4L);} catch (invfmt) {err ();}
put ("#0 +10x: "); try {putf ("->%#0 +10x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 +10x: "); try {putf ("->%#0 +10x<-\n",0L);} catch (invfmt) {err ();}
put ("#0 +10x: "); try {putf ("->%#0 +10x<-\n",4L);} catch (invfmt) {err ();}
put ("0 +10x: "); try {putf ("->%0 +10x<-\n",-4L);} catch (invfmt) {err ();}
put ("0 +10x: "); try {putf ("->%0 +10x<-\n",0L);} catch (invfmt) {err ();}
put ("0 +10x: "); try {putf ("->%0 +10x<-\n",4L);} catch (invfmt) {err ();}
put ("# +10x: "); try {putf ("->%# +10x<-\n",-4L);} catch (invfmt) {err ();}
put ("# +10x: "); try {putf ("->%# +10x<-\n",0L);} catch (invfmt) {err ();}
put ("# +10x: "); try {putf ("->%# +10x<-\n",4L);} catch (invfmt) {err ();}
put (" +10x: "); try {putf ("->% +10x<-\n",-4L);} catch (invfmt) {err ();}
put (" +10x: "); try {putf ("->% +10x<-\n",0L);} catch (invfmt) {err ();}
put (" +10x: "); try {putf ("->% +10x<-\n",4L);} catch (invfmt) {err ();}
put ("#0-+10x: "); try {putf ("->%#0-+10x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-+10x: "); try {putf ("->%#0-+10x<-\n",0L);} catch (invfmt) {err ();}
put ("#0-+10x: "); try {putf ("->%#0-+10x<-\n",4L);} catch (invfmt) {err ();}
put ("0-+10x: "); try {putf ("->%0-+10x<-\n",-4L);} catch (invfmt) {err ();}
put ("0-+10x: "); try {putf ("->%0-+10x<-\n",0L);} catch (invfmt) {err ();}
put ("0-+10x: "); try {putf ("->%0-+10x<-\n",4L);} catch (invfmt) {err ();}
put ("#-+10x: "); try {putf ("->%#-+10x<-\n",-4L);} catch (invfmt) {err ();}
put ("#-+10x: "); try {putf ("->%#-+10x<-\n",0L);} catch (invfmt) {err ();}
put ("#-+10x: "); try {putf ("->%#-+10x<-\n",4L);} catch (invfmt) {err ();}
put ("-+10x: "); try {putf ("->%-+10x<-\n",-4L);} catch (invfmt) {err ();}
put ("-+10x: "); try {putf ("->%-+10x<-\n",0L);} catch (invfmt) {err ();}
put ("-+10x: "); try {putf ("->%-+10x<-\n",4L);} catch (invfmt) {err ();}
put ("#0+10x: "); try {putf ("->%#0+10x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0+10x: "); try {putf ("->%#0+10x<-\n",0L);} catch (invfmt) {err ();}
put ("#0+10x: "); try {putf ("->%#0+10x<-\n",4L);} catch (invfmt) {err ();}
put ("0+10x: "); try {putf ("->%0+10x<-\n",-4L);} catch (invfmt) {err ();}
put ("0+10x: "); try {putf ("->%0+10x<-\n",0L);} catch (invfmt) {err ();}
put ("0+10x: "); try {putf ("->%0+10x<-\n",4L);} catch (invfmt) {err ();}
put ("#+10x: "); try {putf ("->%#+10x<-\n",-4L);} catch (invfmt) {err ();}
put ("#+10x: "); try {putf ("->%#+10x<-\n",0L);} catch (invfmt) {err ();}
put ("#+10x: "); try {putf ("->%#+10x<-\n",4L);} catch (invfmt) {err ();}
put ("+10x: "); try {putf ("->%+10x<-\n",-4L);} catch (invfmt) {err ();}
put ("+10x: "); try {putf ("->%+10x<-\n",0L);} catch (invfmt) {err ();}
put ("+10x: "); try {putf ("->%+10x<-\n",4L);} catch (invfmt) {err ();}
put ("#0- 10x: "); try {putf ("->%#0- 10x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- 10x: "); try {putf ("->%#0- 10x<-\n",0L);} catch (invfmt) {err ();}
put ("#0- 10x: "); try {putf ("->%#0- 10x<-\n",4L);} catch (invfmt) {err ();}
put ("0- 10x: "); try {putf ("->%0- 10x<-\n",-4L);} catch (invfmt) {err ();}
put ("0- 10x: "); try {putf ("->%0- 10x<-\n",0L);} catch (invfmt) {err ();}
put ("0- 10x: "); try {putf ("->%0- 10x<-\n",4L);} catch (invfmt) {err ();}
put ("#- 10x: "); try {putf ("->%#- 10x<-\n",-4L);} catch (invfmt) {err ();}
put ("#- 10x: "); try {putf ("->%#- 10x<-\n",0L);} catch (invfmt) {err ();}
put ("#- 10x: "); try {putf ("->%#- 10x<-\n",4L);} catch (invfmt) {err ();}
put ("- 10x: "); try {putf ("->%- 10x<-\n",-4L);} catch (invfmt) {err ();}
put ("- 10x: "); try {putf ("->%- 10x<-\n",0L);} catch (invfmt) {err ();}
put ("- 10x: "); try {putf ("->%- 10x<-\n",4L);} catch (invfmt) {err ();}
put ("#0 10x: "); try {putf ("->%#0 10x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 10x: "); try {putf ("->%#0 10x<-\n",0L);} catch (invfmt) {err ();}
put ("#0 10x: "); try {putf ("->%#0 10x<-\n",4L);} catch (invfmt) {err ();}
put ("0 10x: "); try {putf ("->%0 10x<-\n",-4L);} catch (invfmt) {err ();}
put ("0 10x: "); try {putf ("->%0 10x<-\n",0L);} catch (invfmt) {err ();}
put ("0 10x: "); try {putf ("->%0 10x<-\n",4L);} catch (invfmt) {err ();}
put ("# 10x: "); try {putf ("->%# 10x<-\n",-4L);} catch (invfmt) {err ();}
put ("# 10x: "); try {putf ("->%# 10x<-\n",0L);} catch (invfmt) {err ();}
put ("# 10x: "); try {putf ("->%# 10x<-\n",4L);} catch (invfmt) {err ();}
put (" 10x: "); try {putf ("->% 10x<-\n",-4L);} catch (invfmt) {err ();}
put (" 10x: "); try {putf ("->% 10x<-\n",0L);} catch (invfmt) {err ();}
put (" 10x: "); try {putf ("->% 10x<-\n",4L);} catch (invfmt) {err ();}
put ("#0-10x: "); try {putf ("->%#0-10x<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-10x: "); try {putf ("->%#0-10x<-\n",0L);} catch (invfmt) {err ();}
put ("#0-10x: "); try {putf ("->%#0-10x<-\n",4L);} catch (invfmt) {err ();}
put ("0-10x: "); try {putf ("->%0-10x<-\n",-4L);} catch (invfmt) {err ();}
put ("0-10x: "); try {putf ("->%0-10x<-\n",0L);} catch (invfmt) {err ();}
put ("0-10x: "); try {putf ("->%0-10x<-\n",4L);} catch (invfmt) {err ();}
put ("#-10x: "); try {putf ("->%#-10x<-\n",-4L);} catch (invfmt) {err ();}
put ("#-10x: "); try {putf ("->%#-10x<-\n",0L);} catch (invfmt) {err ();}
put ("#-10x: "); try {putf ("->%#-10x<-\n",4L);} catch (invfmt) {err ();}
put ("-10x: "); try {putf ("->%-10x<-\n",-4L);} catch (invfmt) {err ();}
put ("-10x: "); try {putf ("->%-10x<-\n",0L);} catch (invfmt) {err ();}
put ("-10x: "); try {putf ("->%-10x<-\n",4L);} catch (invfmt) {err ();}
put ("#010x: "); try {putf ("->%#010x<-\n",-4L);} catch (invfmt) {err ();}
put ("#010x: "); try {putf ("->%#010x<-\n",0L);} catch (invfmt) {err ();}
put ("#010x: "); try {putf ("->%#010x<-\n",4L);} catch (invfmt) {err ();}
put ("010x: "); try {putf ("->%010x<-\n",-4L);} catch (invfmt) {err ();}
put ("010x: "); try {putf ("->%010x<-\n",0L);} catch (invfmt) {err ();}
put ("010x: "); try {putf ("->%010x<-\n",4L);} catch (invfmt) {err ();}
put ("#10x: "); try {putf ("->%#10x<-\n",-4L);} catch (invfmt) {err ();}
put ("#10x: "); try {putf ("->%#10x<-\n",0L);} catch (invfmt) {err ();}
put ("#10x: "); try {putf ("->%#10x<-\n",4L);} catch (invfmt) {err ();}
put ("10x: "); try {putf ("->%10x<-\n",-4L);} catch (invfmt) {err ();}
put ("10x: "); try {putf ("->%10x<-\n",0L);} catch (invfmt) {err ();}
put ("10x: "); try {putf ("->%10x<-\n",4L);} catch (invfmt) {err ();}
put ("#0- +10X: "); try {putf ("->%#0- +10X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- +10X: "); try {putf ("->%#0- +10X<-\n",0L);} catch (invfmt) {err ();}
put ("#0- +10X: "); try {putf ("->%#0- +10X<-\n",4L);} catch (invfmt) {err ();}
put ("0- +10X: "); try {putf ("->%0- +10X<-\n",-4L);} catch (invfmt) {err ();}
put ("0- +10X: "); try {putf ("->%0- +10X<-\n",0L);} catch (invfmt) {err ();}
put ("0- +10X: "); try {putf ("->%0- +10X<-\n",4L);} catch (invfmt) {err ();}
put ("#- +10X: "); try {putf ("->%#- +10X<-\n",-4L);} catch (invfmt) {err ();}
put ("#- +10X: "); try {putf ("->%#- +10X<-\n",0L);} catch (invfmt) {err ();}
put ("#- +10X: "); try {putf ("->%#- +10X<-\n",4L);} catch (invfmt) {err ();}
put ("- +10X: "); try {putf ("->%- +10X<-\n",-4L);} catch (invfmt) {err ();}
put ("- +10X: "); try {putf ("->%- +10X<-\n",0L);} catch (invfmt) {err ();}
put ("- +10X: "); try {putf ("->%- +10X<-\n",4L);} catch (invfmt) {err ();}
put ("#0 +10X: "); try {putf ("->%#0 +10X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 +10X: "); try {putf ("->%#0 +10X<-\n",0L);} catch (invfmt) {err ();}
put ("#0 +10X: "); try {putf ("->%#0 +10X<-\n",4L);} catch (invfmt) {err ();}
put ("0 +10X: "); try {putf ("->%0 +10X<-\n",-4L);} catch (invfmt) {err ();}
put ("0 +10X: "); try {putf ("->%0 +10X<-\n",0L);} catch (invfmt) {err ();}
put ("0 +10X: "); try {putf ("->%0 +10X<-\n",4L);} catch (invfmt) {err ();}
put ("# +10X: "); try {putf ("->%# +10X<-\n",-4L);} catch (invfmt) {err ();}
put ("# +10X: "); try {putf ("->%# +10X<-\n",0L);} catch (invfmt) {err ();}
put ("# +10X: "); try {putf ("->%# +10X<-\n",4L);} catch (invfmt) {err ();}
put (" +10X: "); try {putf ("->% +10X<-\n",-4L);} catch (invfmt) {err ();}
put (" +10X: "); try {putf ("->% +10X<-\n",0L);} catch (invfmt) {err ();}
put (" +10X: "); try {putf ("->% +10X<-\n",4L);} catch (invfmt) {err ();}
put ("#0-+10X: "); try {putf ("->%#0-+10X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-+10X: "); try {putf ("->%#0-+10X<-\n",0L);} catch (invfmt) {err ();}
put ("#0-+10X: "); try {putf ("->%#0-+10X<-\n",4L);} catch (invfmt) {err ();}
put ("0-+10X: "); try {putf ("->%0-+10X<-\n",-4L);} catch (invfmt) {err ();}
put ("0-+10X: "); try {putf ("->%0-+10X<-\n",0L);} catch (invfmt) {err ();}
put ("0-+10X: "); try {putf ("->%0-+10X<-\n",4L);} catch (invfmt) {err ();}
put ("#-+10X: "); try {putf ("->%#-+10X<-\n",-4L);} catch (invfmt) {err ();}
put ("#-+10X: "); try {putf ("->%#-+10X<-\n",0L);} catch (invfmt) {err ();}
put ("#-+10X: "); try {putf ("->%#-+10X<-\n",4L);} catch (invfmt) {err ();}
put ("-+10X: "); try {putf ("->%-+10X<-\n",-4L);} catch (invfmt) {err ();}
put ("-+10X: "); try {putf ("->%-+10X<-\n",0L);} catch (invfmt) {err ();}
put ("-+10X: "); try {putf ("->%-+10X<-\n",4L);} catch (invfmt) {err ();}
put ("#0+10X: "); try {putf ("->%#0+10X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0+10X: "); try {putf ("->%#0+10X<-\n",0L);} catch (invfmt) {err ();}
put ("#0+10X: "); try {putf ("->%#0+10X<-\n",4L);} catch (invfmt) {err ();}
put ("0+10X: "); try {putf ("->%0+10X<-\n",-4L);} catch (invfmt) {err ();}
put ("0+10X: "); try {putf ("->%0+10X<-\n",0L);} catch (invfmt) {err ();}
put ("0+10X: "); try {putf ("->%0+10X<-\n",4L);} catch (invfmt) {err ();}
put ("#+10X: "); try {putf ("->%#+10X<-\n",-4L);} catch (invfmt) {err ();}
put ("#+10X: "); try {putf ("->%#+10X<-\n",0L);} catch (invfmt) {err ();}
put ("#+10X: "); try {putf ("->%#+10X<-\n",4L);} catch (invfmt) {err ();}
put ("+10X: "); try {putf ("->%+10X<-\n",-4L);} catch (invfmt) {err ();}
put ("+10X: "); try {putf ("->%+10X<-\n",0L);} catch (invfmt) {err ();}
put ("+10X: "); try {putf ("->%+10X<-\n",4L);} catch (invfmt) {err ();}
put ("#0- 10X: "); try {putf ("->%#0- 10X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0- 10X: "); try {putf ("->%#0- 10X<-\n",0L);} catch (invfmt) {err ();}
put ("#0- 10X: "); try {putf ("->%#0- 10X<-\n",4L);} catch (invfmt) {err ();}
put ("0- 10X: "); try {putf ("->%0- 10X<-\n",-4L);} catch (invfmt) {err ();}
put ("0- 10X: "); try {putf ("->%0- 10X<-\n",0L);} catch (invfmt) {err ();}
put ("0- 10X: "); try {putf ("->%0- 10X<-\n",4L);} catch (invfmt) {err ();}
put ("#- 10X: "); try {putf ("->%#- 10X<-\n",-4L);} catch (invfmt) {err ();}
put ("#- 10X: "); try {putf ("->%#- 10X<-\n",0L);} catch (invfmt) {err ();}
put ("#- 10X: "); try {putf ("->%#- 10X<-\n",4L);} catch (invfmt) {err ();}
put ("- 10X: "); try {putf ("->%- 10X<-\n",-4L);} catch (invfmt) {err ();}
put ("- 10X: "); try {putf ("->%- 10X<-\n",0L);} catch (invfmt) {err ();}
put ("- 10X: "); try {putf ("->%- 10X<-\n",4L);} catch (invfmt) {err ();}
put ("#0 10X: "); try {putf ("->%#0 10X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0 10X: "); try {putf ("->%#0 10X<-\n",0L);} catch (invfmt) {err ();}
put ("#0 10X: "); try {putf ("->%#0 10X<-\n",4L);} catch (invfmt) {err ();}
put ("0 10X: "); try {putf ("->%0 10X<-\n",-4L);} catch (invfmt) {err ();}
put ("0 10X: "); try {putf ("->%0 10X<-\n",0L);} catch (invfmt) {err ();}
put ("0 10X: "); try {putf ("->%0 10X<-\n",4L);} catch (invfmt) {err ();}
put ("# 10X: "); try {putf ("->%# 10X<-\n",-4L);} catch (invfmt) {err ();}
put ("# 10X: "); try {putf ("->%# 10X<-\n",0L);} catch (invfmt) {err ();}
put ("# 10X: "); try {putf ("->%# 10X<-\n",4L);} catch (invfmt) {err ();}
put (" 10X: "); try {putf ("->% 10X<-\n",-4L);} catch (invfmt) {err ();}
put (" 10X: "); try {putf ("->% 10X<-\n",0L);} catch (invfmt) {err ();}
put (" 10X: "); try {putf ("->% 10X<-\n",4L);} catch (invfmt) {err ();}
put ("#0-10X: "); try {putf ("->%#0-10X<-\n",-4L);} catch (invfmt) {err ();}
put ("#0-10X: "); try {putf ("->%#0-10X<-\n",0L);} catch (invfmt) {err ();}
put ("#0-10X: "); try {putf ("->%#0-10X<-\n",4L);} catch (invfmt) {err ();}
put ("0-10X: "); try {putf ("->%0-10X<-\n",-4L);} catch (invfmt) {err ();}
put ("0-10X: "); try {putf ("->%0-10X<-\n",0L);} catch (invfmt) {err ();}
put ("0-10X: "); try {putf ("->%0-10X<-\n",4L);} catch (invfmt) {err ();}
put ("#-10X: "); try {putf ("->%#-10X<-\n",-4L);} catch (invfmt) {err ();}
put ("#-10X: "); try {putf ("->%#-10X<-\n",0L);} catch (invfmt) {err ();}
put ("#-10X: "); try {putf ("->%#-10X<-\n",4L);} catch (invfmt) {err ();}
put ("-10X: "); try {putf ("->%-10X<-\n",-4L);} catch (invfmt) {err ();}
put ("-10X: "); try {putf ("->%-10X<-\n",0L);} catch (invfmt) {err ();}
put ("-10X: "); try {putf ("->%-10X<-\n",4L);} catch (invfmt) {err ();}
put ("#010X: "); try {putf ("->%#010X<-\n",-4L);} catch (invfmt) {err ();}
put ("#010X: "); try {putf ("->%#010X<-\n",0L);} catch (invfmt) {err ();}
put ("#010X: "); try {putf ("->%#010X<-\n",4L);} catch (invfmt) {err ();}
put ("010X: "); try {putf ("->%010X<-\n",-4L);} catch (invfmt) {err ();}
put ("010X: "); try {putf ("->%010X<-\n",0L);} catch (invfmt) {err ();}
put ("010X: "); try {putf ("->%010X<-\n",4L);} catch (invfmt) {err ();}
put ("#10X: "); try {putf ("->%#10X<-\n",-4L);} catch (invfmt) {err ();}
put ("#10X: "); try {putf ("->%#10X<-\n",0L);} catch (invfmt) {err ();}
put ("#10X: "); try {putf ("->%#10X<-\n",4L);} catch (invfmt) {err ();}
put ("10X: "); try {putf ("->%10X<-\n",-4L);} catch (invfmt) {err ();}
put ("10X: "); try {putf ("->%10X<-\n",0L);} catch (invfmt) {err ();}
put ("10X: "); try {putf ("->%10X<-\n",4L);} catch (invfmt) {err ();}
TEST651
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT651' && $CMP $stdout $ftemp2; then
#0- +d: badformat
#0- +d: badformat
#0- +d: badformat
0- +d: ->-4<-
0- +d: ->+0<-
0- +d: ->+4<-
#- +d: badformat
#- +d: badformat
#- +d: badformat
- +d: ->-4<-
- +d: ->+0<-
- +d: ->+4<-
#0 +d: badformat
#0 +d: badformat
#0 +d: badformat
0 +d: ->-4<-
0 +d: ->+0<-
0 +d: ->+4<-
# +d: badformat
# +d: badformat
# +d: badformat
 +d: ->-4<-
 +d: ->+0<-
 +d: ->+4<-
#0-+d: badformat
#0-+d: badformat
#0-+d: badformat
0-+d: ->-4<-
0-+d: ->+0<-
0-+d: ->+4<-
#-+d: badformat
#-+d: badformat
#-+d: badformat
-+d: ->-4<-
-+d: ->+0<-
-+d: ->+4<-
#0+d: badformat
#0+d: badformat
#0+d: badformat
0+d: ->-4<-
0+d: ->+0<-
0+d: ->+4<-
#+d: badformat
#+d: badformat
#+d: badformat
+d: ->-4<-
+d: ->+0<-
+d: ->+4<-
#0- d: badformat
#0- d: badformat
#0- d: badformat
0- d: ->-4<-
0- d: -> 0<-
0- d: -> 4<-
#- d: badformat
#- d: badformat
#- d: badformat
- d: ->-4<-
- d: -> 0<-
- d: -> 4<-
#0 d: badformat
#0 d: badformat
#0 d: badformat
0 d: ->-4<-
0 d: -> 0<-
0 d: -> 4<-
# d: badformat
# d: badformat
# d: badformat
 d: ->-4<-
 d: -> 0<-
 d: -> 4<-
#0-d: badformat
#0-d: badformat
#0-d: badformat
0-d: ->-4<-
0-d: ->0<-
0-d: ->4<-
#-d: badformat
#-d: badformat
#-d: badformat
-d: ->-4<-
-d: ->0<-
-d: ->4<-
#0d: badformat
#0d: badformat
#0d: badformat
0d: ->-4<-
0d: ->0<-
0d: ->4<-
#d: badformat
#d: badformat
#d: badformat
d: ->-4<-
d: ->0<-
d: ->4<-
#0- +o: badformat
#0- +o: badformat
#0- +o: badformat
0- +o: badformat
0- +o: badformat
0- +o: badformat
#- +o: badformat
#- +o: badformat
#- +o: badformat
- +o: badformat
- +o: badformat
- +o: badformat
#0 +o: badformat
#0 +o: badformat
#0 +o: badformat
0 +o: badformat
0 +o: badformat
0 +o: badformat
# +o: badformat
# +o: badformat
# +o: badformat
 +o: badformat
 +o: badformat
 +o: badformat
#0-+o: badformat
#0-+o: badformat
#0-+o: badformat
0-+o: badformat
0-+o: badformat
0-+o: badformat
#-+o: badformat
#-+o: badformat
#-+o: badformat
-+o: badformat
-+o: badformat
-+o: badformat
#0+o: badformat
#0+o: badformat
#0+o: badformat
0+o: badformat
0+o: badformat
0+o: badformat
#+o: badformat
#+o: badformat
#+o: badformat
+o: badformat
+o: badformat
+o: badformat
#0- o: badformat
#0- o: badformat
#0- o: badformat
0- o: badformat
0- o: badformat
0- o: badformat
#- o: badformat
#- o: badformat
#- o: badformat
- o: badformat
- o: badformat
- o: badformat
#0 o: badformat
#0 o: badformat
#0 o: badformat
0 o: badformat
0 o: badformat
0 o: badformat
# o: badformat
# o: badformat
# o: badformat
 o: badformat
 o: badformat
 o: badformat
#0-o: ->-04<-
#0-o: ->0<-
#0-o: ->04<-
0-o: ->-4<-
0-o: ->0<-
0-o: ->4<-
#-o: ->-04<-
#-o: ->0<-
#-o: ->04<-
-o: ->-4<-
-o: ->0<-
-o: ->4<-
#0o: ->-04<-
#0o: ->0<-
#0o: ->04<-
0o: ->-4<-
0o: ->0<-
0o: ->4<-
#o: ->-04<-
#o: ->0<-
#o: ->04<-
o: ->-4<-
o: ->0<-
o: ->4<-
#0- +x: badformat
#0- +x: badformat
#0- +x: badformat
0- +x: badformat
0- +x: badformat
0- +x: badformat
#- +x: badformat
#- +x: badformat
#- +x: badformat
- +x: badformat
- +x: badformat
- +x: badformat
#0 +x: badformat
#0 +x: badformat
#0 +x: badformat
0 +x: badformat
0 +x: badformat
0 +x: badformat
# +x: badformat
# +x: badformat
# +x: badformat
 +x: badformat
 +x: badformat
 +x: badformat
#0-+x: badformat
#0-+x: badformat
#0-+x: badformat
0-+x: badformat
0-+x: badformat
0-+x: badformat
#-+x: badformat
#-+x: badformat
#-+x: badformat
-+x: badformat
-+x: badformat
-+x: badformat
#0+x: badformat
#0+x: badformat
#0+x: badformat
0+x: badformat
0+x: badformat
0+x: badformat
#+x: badformat
#+x: badformat
#+x: badformat
+x: badformat
+x: badformat
+x: badformat
#0- x: badformat
#0- x: badformat
#0- x: badformat
0- x: badformat
0- x: badformat
0- x: badformat
#- x: badformat
#- x: badformat
#- x: badformat
- x: badformat
- x: badformat
- x: badformat
#0 x: badformat
#0 x: badformat
#0 x: badformat
0 x: badformat
0 x: badformat
0 x: badformat
# x: badformat
# x: badformat
# x: badformat
 x: badformat
 x: badformat
 x: badformat
#0-x: ->-0x4<-
#0-x: ->0<-
#0-x: ->0x4<-
0-x: ->-4<-
0-x: ->0<-
0-x: ->4<-
#-x: ->-0x4<-
#-x: ->0<-
#-x: ->0x4<-
-x: ->-4<-
-x: ->0<-
-x: ->4<-
#0x: ->-0x4<-
#0x: ->0<-
#0x: ->0x4<-
0x: ->-4<-
0x: ->0<-
0x: ->4<-
#x: ->-0x4<-
#x: ->0<-
#x: ->0x4<-
x: ->-4<-
x: ->0<-
x: ->4<-
#0- +X: badformat
#0- +X: badformat
#0- +X: badformat
0- +X: badformat
0- +X: badformat
0- +X: badformat
#- +X: badformat
#- +X: badformat
#- +X: badformat
- +X: badformat
- +X: badformat
- +X: badformat
#0 +X: badformat
#0 +X: badformat
#0 +X: badformat
0 +X: badformat
0 +X: badformat
0 +X: badformat
# +X: badformat
# +X: badformat
# +X: badformat
 +X: badformat
 +X: badformat
 +X: badformat
#0-+X: badformat
#0-+X: badformat
#0-+X: badformat
0-+X: badformat
0-+X: badformat
0-+X: badformat
#-+X: badformat
#-+X: badformat
#-+X: badformat
-+X: badformat
-+X: badformat
-+X: badformat
#0+X: badformat
#0+X: badformat
#0+X: badformat
0+X: badformat
0+X: badformat
0+X: badformat
#+X: badformat
#+X: badformat
#+X: badformat
+X: badformat
+X: badformat
+X: badformat
#0- X: badformat
#0- X: badformat
#0- X: badformat
0- X: badformat
0- X: badformat
0- X: badformat
#- X: badformat
#- X: badformat
#- X: badformat
- X: badformat
- X: badformat
- X: badformat
#0 X: badformat
#0 X: badformat
#0 X: badformat
0 X: badformat
0 X: badformat
0 X: badformat
# X: badformat
# X: badformat
# X: badformat
 X: badformat
 X: badformat
 X: badformat
#0-X: ->-0X4<-
#0-X: ->0<-
#0-X: ->0X4<-
0-X: ->-4<-
0-X: ->0<-
0-X: ->4<-
#-X: ->-0X4<-
#-X: ->0<-
#-X: ->0X4<-
-X: ->-4<-
-X: ->0<-
-X: ->4<-
#0X: ->-0X4<-
#0X: ->0<-
#0X: ->0X4<-
0X: ->-4<-
0X: ->0<-
0X: ->4<-
#X: ->-0X4<-
#X: ->0<-
#X: ->0X4<-
X: ->-4<-
X: ->0<-
X: ->4<-
#0- +0d: badformat
#0- +0d: badformat
#0- +0d: badformat
0- +0d: ->-4<-
0- +0d: ->+0<-
0- +0d: ->+4<-
#- +0d: badformat
#- +0d: badformat
#- +0d: badformat
- +0d: ->-4<-
- +0d: ->+0<-
- +0d: ->+4<-
#0 +0d: badformat
#0 +0d: badformat
#0 +0d: badformat
0 +0d: ->-4<-
0 +0d: ->+0<-
0 +0d: ->+4<-
# +0d: badformat
# +0d: badformat
# +0d: badformat
 +0d: ->-4<-
 +0d: ->+0<-
 +0d: ->+4<-
#0-+0d: badformat
#0-+0d: badformat
#0-+0d: badformat
0-+0d: ->-4<-
0-+0d: ->+0<-
0-+0d: ->+4<-
#-+0d: badformat
#-+0d: badformat
#-+0d: badformat
-+0d: ->-4<-
-+0d: ->+0<-
-+0d: ->+4<-
#0+0d: badformat
#0+0d: badformat
#0+0d: badformat
0+0d: ->-4<-
0+0d: ->+0<-
0+0d: ->+4<-
#+0d: badformat
#+0d: badformat
#+0d: badformat
+0d: ->-4<-
+0d: ->+0<-
+0d: ->+4<-
#0- 0d: badformat
#0- 0d: badformat
#0- 0d: badformat
0- 0d: ->-4<-
0- 0d: -> 0<-
0- 0d: -> 4<-
#- 0d: badformat
#- 0d: badformat
#- 0d: badformat
- 0d: ->-4<-
- 0d: -> 0<-
- 0d: -> 4<-
#0 0d: badformat
#0 0d: badformat
#0 0d: badformat
0 0d: ->-4<-
0 0d: -> 0<-
0 0d: -> 4<-
# 0d: badformat
# 0d: badformat
# 0d: badformat
 0d: ->-4<-
 0d: -> 0<-
 0d: -> 4<-
#0-0d: badformat
#0-0d: badformat
#0-0d: badformat
0-0d: ->-4<-
0-0d: ->0<-
0-0d: ->4<-
#-0d: badformat
#-0d: badformat
#-0d: badformat
-0d: ->-4<-
-0d: ->0<-
-0d: ->4<-
#00d: badformat
#00d: badformat
#00d: badformat
00d: ->-4<-
00d: ->0<-
00d: ->4<-
#0d: badformat
#0d: badformat
#0d: badformat
0d: ->-4<-
0d: ->0<-
0d: ->4<-
#0- +0o: badformat
#0- +0o: badformat
#0- +0o: badformat
0- +0o: badformat
0- +0o: badformat
0- +0o: badformat
#- +0o: badformat
#- +0o: badformat
#- +0o: badformat
- +0o: badformat
- +0o: badformat
- +0o: badformat
#0 +0o: badformat
#0 +0o: badformat
#0 +0o: badformat
0 +0o: badformat
0 +0o: badformat
0 +0o: badformat
# +0o: badformat
# +0o: badformat
# +0o: badformat
 +0o: badformat
 +0o: badformat
 +0o: badformat
#0-+0o: badformat
#0-+0o: badformat
#0-+0o: badformat
0-+0o: badformat
0-+0o: badformat
0-+0o: badformat
#-+0o: badformat
#-+0o: badformat
#-+0o: badformat
-+0o: badformat
-+0o: badformat
-+0o: badformat
#0+0o: badformat
#0+0o: badformat
#0+0o: badformat
0+0o: badformat
0+0o: badformat
0+0o: badformat
#+0o: badformat
#+0o: badformat
#+0o: badformat
+0o: badformat
+0o: badformat
+0o: badformat
#0- 0o: badformat
#0- 0o: badformat
#0- 0o: badformat
0- 0o: badformat
0- 0o: badformat
0- 0o: badformat
#- 0o: badformat
#- 0o: badformat
#- 0o: badformat
- 0o: badformat
- 0o: badformat
- 0o: badformat
#0 0o: badformat
#0 0o: badformat
#0 0o: badformat
0 0o: badformat
0 0o: badformat
0 0o: badformat
# 0o: badformat
# 0o: badformat
# 0o: badformat
 0o: badformat
 0o: badformat
 0o: badformat
#0-0o: ->-04<-
#0-0o: ->0<-
#0-0o: ->04<-
0-0o: ->-4<-
0-0o: ->0<-
0-0o: ->4<-
#-0o: ->-04<-
#-0o: ->0<-
#-0o: ->04<-
-0o: ->-4<-
-0o: ->0<-
-0o: ->4<-
#00o: ->-04<-
#00o: ->0<-
#00o: ->04<-
00o: ->-4<-
00o: ->0<-
00o: ->4<-
#0o: ->-04<-
#0o: ->0<-
#0o: ->04<-
0o: ->-4<-
0o: ->0<-
0o: ->4<-
#0- +0x: badformat
#0- +0x: badformat
#0- +0x: badformat
0- +0x: badformat
0- +0x: badformat
0- +0x: badformat
#- +0x: badformat
#- +0x: badformat
#- +0x: badformat
- +0x: badformat
- +0x: badformat
- +0x: badformat
#0 +0x: badformat
#0 +0x: badformat
#0 +0x: badformat
0 +0x: badformat
0 +0x: badformat
0 +0x: badformat
# +0x: badformat
# +0x: badformat
# +0x: badformat
 +0x: badformat
 +0x: badformat
 +0x: badformat
#0-+0x: badformat
#0-+0x: badformat
#0-+0x: badformat
0-+0x: badformat
0-+0x: badformat
0-+0x: badformat
#-+0x: badformat
#-+0x: badformat
#-+0x: badformat
-+0x: badformat
-+0x: badformat
-+0x: badformat
#0+0x: badformat
#0+0x: badformat
#0+0x: badformat
0+0x: badformat
0+0x: badformat
0+0x: badformat
#+0x: badformat
#+0x: badformat
#+0x: badformat
+0x: badformat
+0x: badformat
+0x: badformat
#0- 0x: badformat
#0- 0x: badformat
#0- 0x: badformat
0- 0x: badformat
0- 0x: badformat
0- 0x: badformat
#- 0x: badformat
#- 0x: badformat
#- 0x: badformat
- 0x: badformat
- 0x: badformat
- 0x: badformat
#0 0x: badformat
#0 0x: badformat
#0 0x: badformat
0 0x: badformat
0 0x: badformat
0 0x: badformat
# 0x: badformat
# 0x: badformat
# 0x: badformat
 0x: badformat
 0x: badformat
 0x: badformat
#0-0x: ->-0x4<-
#0-0x: ->0<-
#0-0x: ->0x4<-
0-0x: ->-4<-
0-0x: ->0<-
0-0x: ->4<-
#-0x: ->-0x4<-
#-0x: ->0<-
#-0x: ->0x4<-
-0x: ->-4<-
-0x: ->0<-
-0x: ->4<-
#00x: ->-0x4<-
#00x: ->0<-
#00x: ->0x4<-
00x: ->-4<-
00x: ->0<-
00x: ->4<-
#0x: ->-0x4<-
#0x: ->0<-
#0x: ->0x4<-
0x: ->-4<-
0x: ->0<-
0x: ->4<-
#0- +0X: badformat
#0- +0X: badformat
#0- +0X: badformat
0- +0X: badformat
0- +0X: badformat
0- +0X: badformat
#- +0X: badformat
#- +0X: badformat
#- +0X: badformat
- +0X: badformat
- +0X: badformat
- +0X: badformat
#0 +0X: badformat
#0 +0X: badformat
#0 +0X: badformat
0 +0X: badformat
0 +0X: badformat
0 +0X: badformat
# +0X: badformat
# +0X: badformat
# +0X: badformat
 +0X: badformat
 +0X: badformat
 +0X: badformat
#0-+0X: badformat
#0-+0X: badformat
#0-+0X: badformat
0-+0X: badformat
0-+0X: badformat
0-+0X: badformat
#-+0X: badformat
#-+0X: badformat
#-+0X: badformat
-+0X: badformat
-+0X: badformat
-+0X: badformat
#0+0X: badformat
#0+0X: badformat
#0+0X: badformat
0+0X: badformat
0+0X: badformat
0+0X: badformat
#+0X: badformat
#+0X: badformat
#+0X: badformat
+0X: badformat
+0X: badformat
+0X: badformat
#0- 0X: badformat
#0- 0X: badformat
#0- 0X: badformat
0- 0X: badformat
0- 0X: badformat
0- 0X: badformat
#- 0X: badformat
#- 0X: badformat
#- 0X: badformat
- 0X: badformat
- 0X: badformat
- 0X: badformat
#0 0X: badformat
#0 0X: badformat
#0 0X: badformat
0 0X: badformat
0 0X: badformat
0 0X: badformat
# 0X: badformat
# 0X: badformat
# 0X: badformat
 0X: badformat
 0X: badformat
 0X: badformat
#0-0X: ->-0X4<-
#0-0X: ->0<-
#0-0X: ->0X4<-
0-0X: ->-4<-
0-0X: ->0<-
0-0X: ->4<-
#-0X: ->-0X4<-
#-0X: ->0<-
#-0X: ->0X4<-
-0X: ->-4<-
-0X: ->0<-
-0X: ->4<-
#00X: ->-0X4<-
#00X: ->0<-
#00X: ->0X4<-
00X: ->-4<-
00X: ->0<-
00X: ->4<-
#0X: ->-0X4<-
#0X: ->0<-
#0X: ->0X4<-
0X: ->-4<-
0X: ->0<-
0X: ->4<-
#0- +10d: badformat
#0- +10d: badformat
#0- +10d: badformat
0- +10d: ->-4        <-
0- +10d: ->+0        <-
0- +10d: ->+4        <-
#- +10d: badformat
#- +10d: badformat
#- +10d: badformat
- +10d: ->-4        <-
- +10d: ->+0        <-
- +10d: ->+4        <-
#0 +10d: badformat
#0 +10d: badformat
#0 +10d: badformat
0 +10d: ->-000000004<-
0 +10d: ->+000000000<-
0 +10d: ->+000000004<-
# +10d: badformat
# +10d: badformat
# +10d: badformat
 +10d: ->        -4<-
 +10d: ->        +0<-
 +10d: ->        +4<-
#0-+10d: badformat
#0-+10d: badformat
#0-+10d: badformat
0-+10d: ->-4        <-
0-+10d: ->+0        <-
0-+10d: ->+4        <-
#-+10d: badformat
#-+10d: badformat
#-+10d: badformat
-+10d: ->-4        <-
-+10d: ->+0        <-
-+10d: ->+4        <-
#0+10d: badformat
#0+10d: badformat
#0+10d: badformat
0+10d: ->-000000004<-
0+10d: ->+000000000<-
0+10d: ->+000000004<-
#+10d: badformat
#+10d: badformat
#+10d: badformat
+10d: ->        -4<-
+10d: ->        +0<-
+10d: ->        +4<-
#0- 10d: badformat
#0- 10d: badformat
#0- 10d: badformat
0- 10d: ->-4        <-
0- 10d: -> 0        <-
0- 10d: -> 4        <-
#- 10d: badformat
#- 10d: badformat
#- 10d: badformat
- 10d: ->-4        <-
- 10d: -> 0        <-
- 10d: -> 4        <-
#0 10d: badformat
#0 10d: badformat
#0 10d: badformat
0 10d: ->-000000004<-
0 10d: -> 000000000<-
0 10d: -> 000000004<-
# 10d: badformat
# 10d: badformat
# 10d: badformat
 10d: ->        -4<-
 10d: ->         0<-
 10d: ->         4<-
#0-10d: badformat
#0-10d: badformat
#0-10d: badformat
0-10d: ->-4        <-
0-10d: ->0         <-
0-10d: ->4         <-
#-10d: badformat
#-10d: badformat
#-10d: badformat
-10d: ->-4        <-
-10d: ->0         <-
-10d: ->4         <-
#010d: badformat
#010d: badformat
#010d: badformat
010d: ->-000000004<-
010d: ->0000000000<-
010d: ->0000000004<-
#10d: badformat
#10d: badformat
#10d: badformat
10d: ->        -4<-
10d: ->         0<-
10d: ->         4<-
#0- +10o: badformat
#0- +10o: badformat
#0- +10o: badformat
0- +10o: badformat
0- +10o: badformat
0- +10o: badformat
#- +10o: badformat
#- +10o: badformat
#- +10o: badformat
- +10o: badformat
- +10o: badformat
- +10o: badformat
#0 +10o: badformat
#0 +10o: badformat
#0 +10o: badformat
0 +10o: badformat
0 +10o: badformat
0 +10o: badformat
# +10o: badformat
# +10o: badformat
# +10o: badformat
 +10o: badformat
 +10o: badformat
 +10o: badformat
#0-+10o: badformat
#0-+10o: badformat
#0-+10o: badformat
0-+10o: badformat
0-+10o: badformat
0-+10o: badformat
#-+10o: badformat
#-+10o: badformat
#-+10o: badformat
-+10o: badformat
-+10o: badformat
-+10o: badformat
#0+10o: badformat
#0+10o: badformat
#0+10o: badformat
0+10o: badformat
0+10o: badformat
0+10o: badformat
#+10o: badformat
#+10o: badformat
#+10o: badformat
+10o: badformat
+10o: badformat
+10o: badformat
#0- 10o: badformat
#0- 10o: badformat
#0- 10o: badformat
0- 10o: badformat
0- 10o: badformat
0- 10o: badformat
#- 10o: badformat
#- 10o: badformat
#- 10o: badformat
- 10o: badformat
- 10o: badformat
- 10o: badformat
#0 10o: badformat
#0 10o: badformat
#0 10o: badformat
0 10o: badformat
0 10o: badformat
0 10o: badformat
# 10o: badformat
# 10o: badformat
# 10o: badformat
 10o: badformat
 10o: badformat
 10o: badformat
#0-10o: ->-04       <-
#0-10o: ->0         <-
#0-10o: ->04        <-
0-10o: ->-4        <-
0-10o: ->0         <-
0-10o: ->4         <-
#-10o: ->-04       <-
#-10o: ->0         <-
#-10o: ->04        <-
-10o: ->-4        <-
-10o: ->0         <-
-10o: ->4         <-
#010o: ->-000000004<-
#010o: ->0000000000<-
#010o: ->0000000004<-
010o: ->-000000004<-
010o: ->0000000000<-
010o: ->0000000004<-
#10o: ->       -04<-
#10o: ->         0<-
#10o: ->        04<-
10o: ->        -4<-
10o: ->         0<-
10o: ->         4<-
#0- +10x: badformat
#0- +10x: badformat
#0- +10x: badformat
0- +10x: badformat
0- +10x: badformat
0- +10x: badformat
#- +10x: badformat
#- +10x: badformat
#- +10x: badformat
- +10x: badformat
- +10x: badformat
- +10x: badformat
#0 +10x: badformat
#0 +10x: badformat
#0 +10x: badformat
0 +10x: badformat
0 +10x: badformat
0 +10x: badformat
# +10x: badformat
# +10x: badformat
# +10x: badformat
 +10x: badformat
 +10x: badformat
 +10x: badformat
#0-+10x: badformat
#0-+10x: badformat
#0-+10x: badformat
0-+10x: badformat
0-+10x: badformat
0-+10x: badformat
#-+10x: badformat
#-+10x: badformat
#-+10x: badformat
-+10x: badformat
-+10x: badformat
-+10x: badformat
#0+10x: badformat
#0+10x: badformat
#0+10x: badformat
0+10x: badformat
0+10x: badformat
0+10x: badformat
#+10x: badformat
#+10x: badformat
#+10x: badformat
+10x: badformat
+10x: badformat
+10x: badformat
#0- 10x: badformat
#0- 10x: badformat
#0- 10x: badformat
0- 10x: badformat
0- 10x: badformat
0- 10x: badformat
#- 10x: badformat
#- 10x: badformat
#- 10x: badformat
- 10x: badformat
- 10x: badformat
- 10x: badformat
#0 10x: badformat
#0 10x: badformat
#0 10x: badformat
0 10x: badformat
0 10x: badformat
0 10x: badformat
# 10x: badformat
# 10x: badformat
# 10x: badformat
 10x: badformat
 10x: badformat
 10x: badformat
#0-10x: ->-0x4      <-
#0-10x: ->0         <-
#0-10x: ->0x4       <-
0-10x: ->-4        <-
0-10x: ->0         <-
0-10x: ->4         <-
#-10x: ->-0x4      <-
#-10x: ->0         <-
#-10x: ->0x4       <-
-10x: ->-4        <-
-10x: ->0         <-
-10x: ->4         <-
#010x: ->-0x0000004<-
#010x: ->0000000000<-
#010x: ->0x00000004<-
010x: ->-000000004<-
010x: ->0000000000<-
010x: ->0000000004<-
#10x: ->      -0x4<-
#10x: ->         0<-
#10x: ->       0x4<-
10x: ->        -4<-
10x: ->         0<-
10x: ->         4<-
#0- +10X: badformat
#0- +10X: badformat
#0- +10X: badformat
0- +10X: badformat
0- +10X: badformat
0- +10X: badformat
#- +10X: badformat
#- +10X: badformat
#- +10X: badformat
- +10X: badformat
- +10X: badformat
- +10X: badformat
#0 +10X: badformat
#0 +10X: badformat
#0 +10X: badformat
0 +10X: badformat
0 +10X: badformat
0 +10X: badformat
# +10X: badformat
# +10X: badformat
# +10X: badformat
 +10X: badformat
 +10X: badformat
 +10X: badformat
#0-+10X: badformat
#0-+10X: badformat
#0-+10X: badformat
0-+10X: badformat
0-+10X: badformat
0-+10X: badformat
#-+10X: badformat
#-+10X: badformat
#-+10X: badformat
-+10X: badformat
-+10X: badformat
-+10X: badformat
#0+10X: badformat
#0+10X: badformat
#0+10X: badformat
0+10X: badformat
0+10X: badformat
0+10X: badformat
#+10X: badformat
#+10X: badformat
#+10X: badformat
+10X: badformat
+10X: badformat
+10X: badformat
#0- 10X: badformat
#0- 10X: badformat
#0- 10X: badformat
0- 10X: badformat
0- 10X: badformat
0- 10X: badformat
#- 10X: badformat
#- 10X: badformat
#- 10X: badformat
- 10X: badformat
- 10X: badformat
- 10X: badformat
#0 10X: badformat
#0 10X: badformat
#0 10X: badformat
0 10X: badformat
0 10X: badformat
0 10X: badformat
# 10X: badformat
# 10X: badformat
# 10X: badformat
 10X: badformat
 10X: badformat
 10X: badformat
#0-10X: ->-0X4      <-
#0-10X: ->0         <-
#0-10X: ->0X4       <-
0-10X: ->-4        <-
0-10X: ->0         <-
0-10X: ->4         <-
#-10X: ->-0X4      <-
#-10X: ->0         <-
#-10X: ->0X4       <-
-10X: ->-4        <-
-10X: ->0         <-
-10X: ->4         <-
#010X: ->-0X0000004<-
#010X: ->0000000000<-
#010X: ->0X00000004<-
010X: ->-000000004<-
010X: ->0000000000<-
010X: ->0000000004<-
#10X: ->      -0X4<-
#10X: ->         0<-
#10X: ->       0X4<-
10X: ->        -4<-
10X: ->         0<-
10X: ->         4<-
OUTPUT651
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 652.
if test $result = ok -a $start_test_number -le 652; then
	echo test 652: Long ops
        cat >$test_file <<'TEST652'
fun f (i, j) {
  println ("+", i + j);
  println ("-", i - j);
  println ("*", i * j);
  println ("/", i / j);
  println ("%", i % j);
  println ("==", i == j);
  println ("!=", i != j);
  println ("===", i === j);
  println ("!==", i !== j);
  println ("<=", i <= j);
  println ("<", i < j);
  println (">=", i >= j);
  println (">", i > j);
}

f (1, 2L);
f (1., 2L);
f ("1", 2L);
TEST652
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT652' && $CMP $stdout $ftemp2; then
"+"3l
"-"-1l
"*"2l
"/"0l
"%"1l
"=="0
"!="1
"==="0
"!=="1
"<="1
"<"1
">="0
">"0
"+"3
"-"-1
"*"2
"/"0.5
"%"1
"=="0
"!="1
"==="0
"!=="1
"<="1
"<"1
">="0
">"0
"+"3l
"-"-1l
"*"2l
"/"0l
"%"1l
"=="0
"!="1
"==="0
"!=="1
"<="1
"<"1
">="0
">"0
OUTPUT652
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 653.
if test $result = ok -a $start_test_number -le 653; then
	echo test 653: Long div / mod
        cat >$test_file <<'TEST653'
println (3L / 2);
println ((-3L) / 2);
println (3L / (-2));
println ((-3L) / (-2));
println (3L % 2);
println ((-3L) % 2);
println (3L % (-2));
println ((-3L) % (-2));
TEST653
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT653' && $CMP $stdout $ftemp2; then
1l
-1l
-1l
1l
1l
-1l
1l
-1l
OUTPUT653
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 654.
if test $result = ok -a $start_test_number -le 654; then
	echo test 654 Long division by zero
	cat >$test_file <<'TEST654'
println (3L / 0);
TEST654
	echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
	    if test `uname` = AIX && $CMP - $stderr <<'OUTPUT654'; then
OUTPUT654
		    result=ok
	    elif uname -a|fgrep Linux|fgrep ppc && $CMP - $stderr <<'OUTPUT654a'; then
OUTPUT654a
		    result=ok
	    elif uname -a|fgrep Linux|fgrep ia64 && $CMP - $stderr <<'OUTPUT654b'; then
OUTPUT654b
		    result=ok
	    else
		    result=fail
	    fi
	else
	    echo '      ' $CMP - $stderr
	    if cat >$ftemp2 <<'OUTPUT654-1' && $CMP $stderr $ftemp2; then
test.d:1:13: floating point exception
OUTPUT654-1
		    result=ok
	    else
                    result=fail
	    fi
        fi
fi

# Test 655.
if test $result = ok -a $start_test_number -le 655; then
	echo test 655 Long module by zero
	cat >$test_file <<'TEST655'
println (3L % 0);
TEST655
	echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
	    if test `uname` = AIX && $CMP - $stderr <<'OUTPUT655'; then
OUTPUT655
		    result=ok
	    elif uname -a|fgrep Linux|fgrep ppc && $CMP - $stderr <<'OUTPUT655a'; then
OUTPUT655a
		    result=ok
	    elif uname -a|fgrep Linux|fgrep ia64 && $CMP - $stderr <<'OUTPUT655b'; then
OUTPUT655b
		    result=ok
	    else
		    result=fail
	    fi
	else
	    echo '      ' $CMP - $stderr
	    if cat >$ftemp2 <<'OUTPUT655-1' && $CMP $stderr $ftemp2; then
test.d:1:13: floating point exception
OUTPUT655-1
		    result=ok
	    else
                    result=fail
	    fi
        fi
fi

# Test 656.
if test $result = ok -a $start_test_number -le 656; then
	echo test 656: Long vector ops
        cat >$test_file <<'TEST656'
var two = 2l, four = 4l;
var v1 = [10:two], v2 = [10:four];

  println ("+", v1[:] + v2[:]);
  println ("-", v1[:] - v2[:]);
  println ("+", v2[:] + v1[:]);
  println ("-", v2[:] - v1[:]);
  putln ("--------------------------------");
 
  println ("+", v1[:] + four);
  println ("-", v1[:] - four);
  println ("+", v2[:] + two);
  println ("-", v2[:] - two);
  putln ("--------------------------------");
  
  println ("+", two + v2[:]);
  println ("-", two - v2[:]);
  println ("+", four + v2[:]);
  println ("-", four - v2[:]);
  putln ("--------------------------------");

  println ("*", v1[:] * v2[:]);
  println ("*", v1[:] * four);
  println ("*", two * v2[:]);
  putln ("--------------------------------");

  println ("/", v1[:] / v2[:]);
  println ("%", v1[:] % v2[:]);
  println ("/", v2[:] / v1[:]);
  println ("%", v2[:] % v1[:]);
  putln ("--------------------------------");
 
  println ("/", v1[:] / four);
  println ("%", v1[:] % four);
  println ("/", v2[:] / two);
  println ("%", v2[:] % two);
  putln ("--------------------------------");
  
  println ("/", two / v2[:]);
  println ("%", two % v2[:]);
  println ("/", four / v2[:]);
  println ("%", four % v2[:]);
  putln ("--------------------------------");
TEST656
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT656' && $CMP $stdout $ftemp2; then
"+"[6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l]
"-"[-2l, -2l, -2l, -2l, -2l, -2l, -2l, -2l, -2l, -2l]
"+"[6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l]
"-"[2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l]
--------------------------------
"+"[6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l]
"-"[-2l, -2l, -2l, -2l, -2l, -2l, -2l, -2l, -2l, -2l]
"+"[6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l]
"-"[2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l]
--------------------------------
"+"[6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l, 6l]
"-"[-2l, -2l, -2l, -2l, -2l, -2l, -2l, -2l, -2l, -2l]
"+"[8l, 8l, 8l, 8l, 8l, 8l, 8l, 8l, 8l, 8l]
"-"[0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l]
--------------------------------
"*"[8l, 8l, 8l, 8l, 8l, 8l, 8l, 8l, 8l, 8l]
"*"[8l, 8l, 8l, 8l, 8l, 8l, 8l, 8l, 8l, 8l]
"*"[8l, 8l, 8l, 8l, 8l, 8l, 8l, 8l, 8l, 8l]
--------------------------------
"/"[0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l]
"%"[2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l]
"/"[2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l]
"%"[0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l]
--------------------------------
"/"[0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l]
"%"[2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l]
"/"[2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l]
"%"[0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l]
--------------------------------
"/"[0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l]
"%"[2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l, 2l]
"/"[1l, 1l, 1l, 1l, 1l, 1l, 1l, 1l, 1l, 1l]
"%"[0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l, 0l]
--------------------------------
OUTPUT656
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 657.
if test $result = ok -a $start_test_number -le 657; then
	echo test 657: Long vector ops
        cat >$test_file <<'TEST657'
var i, v1 = [10:2L];
for (i = 0; i < 4; i++) {
  println (".+", .+v1[0:10]);
  println (".*", .*v1[0:10]);
  putln ("--------------------------------");

  if (i == 0)
    v1 = [10:2, nil];
  else if (i == 1)
    v1 = [10:2.5, nil];
  else
    v1 = [5:2.0, 5:2, nil];
}

v1 = [];
println (".+", .+v1[:]);
println (".*", .*v1[:]);
TEST657
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT657' && $CMP $stdout $ftemp2; then
".+"20l
".*"1024l
--------------------------------
".+"20
".*"1024
--------------------------------
".+"25
".*"9536.74
--------------------------------
".+"20
".*"1024
--------------------------------
".+"0
".*"1
OUTPUT657
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 658.
if test $result = ok -a $start_test_number -le 658; then
	echo test 658: Long vector ops
        cat >$test_file <<'TEST658'
println (scan (), scanln ());
for (;1;)
{
  try {
    println (scanln ());
  } catch (eof) {putln ("eof"); break;}
    catch (invinput) {putln ("catch invalid input");}
}
TEST658
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1 <<'INPUT658'; then
102L10
[2l]
[2:2l]
[2:[2l]]
tab []
tab [10l, 2:"10"]
INPUT658
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT658' && $CMP $stdout $ftemp2; then
102l10
[2l]
[2l, 2l]
[[2l], [2l]]
tab []
tab [2:"10", 10l:10l]
eof
OUTPUT658
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 659.
if test $result = ok -a $start_test_number -le 659; then
	echo test 659: Bug with position in dump
        cat >$test_file <<'TEST659'
fun f {}
var i, n;
n = int (argv [0]);
for (i = 0; i < n; i++) f();
TEST659
        echo '      ' $DINO -d $test_file ">$ftemp"
        if $DINO -d $test_file >$ftemp; then
            echo '      ' $DINO -i $ftemp " 2>$stderr >$stdout"
            if $DINO -i $ftemp 2>$stderr >$stdout; then
               result=fail
            else
               echo '      ' $CMP - $stderr
               if cat >$ftemp2 <<'OUTPUT659' && $CMP $stderr $ftemp2; then
test.d:3:15: run time error - index is greater than array bound
OUTPUT659
                   echo '      ' $CMP - $stdout
                   if cat >$ftemp2 <<'OUTPUT659-2' && $CMP $stdout $ftemp2; then
OUTPUT659-2
                         result=ok
                   else
                         result=fail
                   fi
               else
                       result=fail
               fi
            fi
        else
            result=fail
        fi
fi

# Test 660.
if test $result = ok -a $start_test_number -le 660; then
	echo test 660: Octal and hex numbers
        cat >$test_file <<'TEST660'
println (010, 0x10, 10);
println (010l, 0x10l, 10l);
println (" 010 " + 0, " -0X10 " + 0, " +10 " + 0);
println (" 010l " + 0, " -0X10l " + 0, " +10l " + 0);
TEST660
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT660' && $CMP $stdout $ftemp2; then
81610
8l16l10l
8-1610
8l-16l0l
OUTPUT660
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 661.
if test $result = ok -a $start_test_number -le 661; then
	echo test 661: Wrong octal
        cat >$test_file <<'TEST661'
var i = 09;
TEST661
        echo '      ' $DINO $test_file " 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
           result=fail
        else
           echo '      ' $CMP - $stderr
           if cat >$ftemp2 <<'OUTPUT661' && $CMP $stderr $ftemp2; then
test.d:1:9: octal int with non-octal digit
OUTPUT661
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT661-2' && $CMP $stdout $ftemp2; then
OUTPUT661-2
                     result=ok
               else
                     result=fail
               fi
           else
                   result=fail
           fi
        fi
fi

# Test 662.
if test $result = ok -a $start_test_number -le 662; then
	echo test 662: Wrong float
        cat >$test_file <<'TEST662'
var i = 0x1a.0;
TEST662
        echo '      ' $DINO $test_file " 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
           result=fail
        else
           echo '      ' $CMP - $stderr
           if cat >$ftemp2 <<'OUTPUT662' && $CMP $stderr $ftemp2; then
test.d:1:9: float is not in decimal base
OUTPUT662
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT662-2' && $CMP $stdout $ftemp2; then
OUTPUT662-2
                     result=ok
               else
                     result=fail
               fi
           else
                   result=fail
           fi
        fi
fi

# Test 663.
if test $result = ok -a $start_test_number -le 663; then
	echo test 663: Wrong number
        cat >$test_file <<'TEST663'
var i = 1a;
TEST663
        echo '      ' $DINO $test_file " 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
           result=fail
        else
           echo '      ' $CMP - $stderr
           if cat >$ftemp2 <<'OUTPUT663' && $CMP $stderr $ftemp2; then
test.d:1:10: syntax error
OUTPUT663
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT663-2' && $CMP $stdout $ftemp2; then
OUTPUT663-2
                     result=ok
               else
                     result=fail
               fi
           else
                   result=fail
           fi
        fi
fi

# Test 664.
if test $result = ok -a $start_test_number -le 664; then
	echo test 664: Scanning numbers
        cat >$test_file <<'TEST664'
println (scan (), scanln ());
for (;1;)
{
  try {
    println (scanln ());
  } catch (eof) {putln ("eof"); break;}
    catch (invinput) {putln ("catch invalid input");}
}
TEST664
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1 <<'INPUT664'; then
-010L +0x10
09
1a
0x10.1
010e+1
INPUT664
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT664' && $CMP $stdout $ftemp2; then
-8l16
catch invalid input
1
catch invalid input
100
eof
OUTPUT664
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 665.
if test $result = ok -a $start_test_number -le 665; then
	echo test 665: string to number conversion
        cat >$test_file <<'TEST665'
println (" -010L " + 0);
println (" +0x10 " + 0);
try {println (" +09 " + 0);} catch (optype) {putln ("optypes");}
try {println (" 1a" + 0);} catch (optype) {putln ("optypes");}
try {println ("0x10.1" + 0);} catch (optype) {putln ("optypes");}
println ("010e+1" + 0);
try {println ("100000000000" + 0);} catch (syserror) {putln (e.msg);}
try {println ("10e+10000" + 0);} catch (syserror) {putln (e.msg);}
try {println ("10e-10000" + 0);} catch (syserror) {putln (e.msg);}
TEST665
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT665' && $CMP $stdout $ftemp2; then
-8l
16
optypes
optypes
optypes
100
system error - result too big (small): `string-to-int conversion'
system error - result too big (small): `string-to-float conversion'
system error - result too big (small): `string-to-float conversion'
OUTPUT665
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 666.
if test $result = ok -a $start_test_number -le 666; then
	echo test 666: Long min/max and sort
        cat >$test_file <<'TEST666'
println (min (10L, 1, -2l));
println (max (10L, 1, -2l));
println (min (10L, -5, -2l));
println (max (10L, 15, -2l));
println (min (10L, 1.5, -2l));
println (max (10L, 1.5, -2l));
println (min (10L, -5.5, -2l));
println (max (10L, 15.5, -2l));
println (sort ([10L, 5L, 2L, 7L]));
TEST666
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT666' && $CMP $stdout $ftemp2; then
-2l
10l
-5
15
-2l
10l
-5.5
15.5
[2l, 5l, 7l, 10l]
OUTPUT666
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 667.
if test $result = ok -a $start_test_number -le 667; then
	echo test 667: Long as logical and index
        cat >$test_file <<'TEST667'
var v = [1, 2];
println (v[1l]);
v[1l] = 4; println (v);
v[1l] += 5.5; println (v);
println (1l ? 0 : 2);
var c = 1l;
if (!c || c && c) println (1); else println (0);
var v = [2L:3];
println (v);
TEST667
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT667' && $CMP $stdout $ftemp2; then
2
[1, 4]
[1, 9.5]
0
1
[3, 3]
OUTPUT667
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 668.
if test $result = ok -a $start_test_number -le 668; then
	echo test 668: Non-variable in foreach value
        cat >$test_file <<'TEST668'
fun f {}
var i, t = tab [];
for (i, f: t);
TEST668
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT668' && $CMP $stderr $ftemp2; then
test.d:3:9: non variable in foreach-stmt value designator
OUTPUT668
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 669.
if test $result = ok -a $start_test_number -le 669; then
	echo test 669: Slice as index and value designator in foreach
        cat >$test_file <<'TEST669'
var iv = [10:1], vv = [10:2], t = tab[10:10];
for (iv[:], vv[1:2]: t);
TEST669
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT669' && $CMP $stderr $ftemp2; then
test.d:2:8: vector slice is used as foreach-stmt index_designator
test.d:2:15: vector slice is used as foreach-stmt value designator
OUTPUT669
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 670.
if test $result = ok -a $start_test_number -le 670; then
	echo test 670: Foreach with value variable
        cat >$test_file <<'TEST670'
var i, v, t = tab[1:"a", 10: "b", 100:"c"];
for (i, v: t) putln (i, ":", v);
putln (i, " ", v);
TEST670
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT670' && $CMP $stdout $ftemp2; then
1:a
10:b
100:c
100 c
OUTPUT670
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 671.
if test $result = ok -a $start_test_number -le 671; then
	echo test 671: Foreach with composite index and value variables
        cat >$test_file <<'TEST671'
var i=[1], v=tab[1], t = tab[1:"a", 10: "b", 100:"c"];
for (i[0], v[1]: t) putln (i[0], ":", v[1]);
putln (i[0], " ", v[1]);
class c (f) {};
var o = c ("n");
for (i[0], o.f: t) putln (i[0], ":", o.f);
putln (i[0], " ", o.f);
TEST671
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT671' && $CMP $stdout $ftemp2; then
1:a
10:b
100:c
100 c
1:a
10:b
100:c
100 c
OUTPUT671
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 672.
if test $result = ok -a $start_test_number -le 672; then
	echo test 672
        cat >$test_file <<'TEST672'
class c {
  val i;
}

class sc {
  use c former i later i;
  val i;
}
TEST672
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT672' && $CMP $stderr $ftemp2; then
test.d:6:16: repeated occurrence of identifier `i' in use items
test.d:6:24: (previous occurrence of identifier `i')
OUTPUT672
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 673.
if test $result = ok -a $start_test_number -le 673; then
	echo test 673
        cat >$test_file <<'TEST673'
class c {
  val i;
}

class sc {
  val i;
  use c former i, i;
}
TEST673
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT673' && $CMP $stderr $ftemp2; then
test.d:7:16: repeated occurrence of identifier `i' in use items
test.d:7:19: (previous occurrence of identifier `i')
OUTPUT673
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 674.
if test $result = ok -a $start_test_number -le 674; then
	echo test 674: A bug in conversion with cmpi ops
        cat >$test_file <<'TEST674'
if (1.30832+0.00898298 > 1) println (1);
if (1 < 1.30832+0.00898298) println (2);
if (1 != 1.30832+0.00898298) println (3);
if (1 == 1.30832+0.00898298) println (4);
TEST674
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT674' && $CMP $stdout $ftemp2; then
1
2
3
OUTPUT674
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 675.
if test $result = ok -a $start_test_number -le 675; then
	echo test 675: A bug in code generation of loop with continue
        cat >$test_file <<'TEST675'
for (var i =0; i <10;i++)continue;
putln (i);

var i, j = 1;
for (i =0; i <10;i++) {
  if (i < 4) continue;
  j *= 2;
}
putln (i, " ", j);
TEST675
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT675' && $CMP $stdout $ftemp2; then
10
10 64
OUTPUT675
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 676.
if test $result = ok -a $start_test_number -le 676; then
	echo test 676: Use with forward
        cat >$test_file <<'TEST676'
class c {
  fun i {putln ("c");}
}

class sc {
  use c later i;
  fun i;
  use c former i;
  fun i {putln ("sc");}
}

val osc = sc ();
osc.i ();
TEST676
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT676' && $CMP $stdout $ftemp2; then
sc
OUTPUT676
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 677.
if test $result = ok -a $start_test_number -le 677; then
	echo test 677  Two wrong uses
        cat >$test_file <<'TEST677'
class c {
  fun i {};
}

class c2 {
  fun i {};
}

class sc {
  use c;
  use c2;
}
TEST677
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT677' && $CMP $stderr $ftemp2; then
test.d:11:7: used decl redefines previous `i' and is not mentioned in former item
test.d:2:7: (previous declaration of identifier `i')
OUTPUT677
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 678.
if test $result = ok -a $start_test_number -le 678; then
	echo test 678  One right use and one wrong use
        cat >$test_file <<'TEST678'
class c {
  fun i {};
}

class sc {
  use c later i;
  fun i {};
  use c;
}
TEST678
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT678' && $CMP $stderr $ftemp2; then
test.d:8:7: used decl redefines previous `i' and is not mentioned in former item
test.d:7:7: (previous declaration of identifier `i')
OUTPUT678
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 679.
if test $result = ok -a $start_test_number -le 679; then
	echo test 679  One right use and one wrong use and forward
        cat >$test_file <<'TEST679'
class c {
  fun i {};
}

class sc {
  use c later i;
  fun i;
  use c;
}
TEST679
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT679' && $CMP $stderr $ftemp2; then
test.d:8:7: used decl redefines previous `i' and is not mentioned in former item
test.d:7:7: (previous declaration of identifier `i')
OUTPUT679
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 680.
if test $result = ok -a $start_test_number -le 680; then
	echo test 680: Two uses with forward without definition
        cat >$test_file <<'TEST680'
class c {
  fun i {};
}

class sc {
  use c later i;
  fun i;
  use c former i;
}
TEST680
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT680' && $CMP $stdout $ftemp2; then
OUTPUT680
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 681.
if test $result = ok -a $start_test_number -le 681; then
	echo test 681: Two uses with later
        cat >$test_file <<'TEST681'
class c {
  fun i {}
  fun c {put ("c -- "); i ();}
}

class c2 {
  fun i {};
  fun c2 {put ("c2 -- "); i ();}
}

class sc {
  use c later i;
  use c2 later i;
  fun i {putln ("sc");}
}

var osc = sc ();
osc.c ();
osc.c2 ();
TEST681
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT681' && $CMP $stdout $ftemp2; then
c -- sc
c2 -- sc
OUTPUT681
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 682.
if test $result = ok -a $start_test_number -le 682; then
	echo test 682: Two uses of one class
        cat >$test_file <<'TEST682'
class c {
  fun i {putln ("ic");}
  fun j {putln ("jc");}
}

class sc {
  use c later i;
  use c former j;
}

var osc = sc ();
osc.i ();
osc.j ();
TEST682
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT682' && $CMP $stdout $ftemp2; then
ic
jc
OUTPUT682
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 683.
if test $result = ok -a $start_test_number -le 683; then
	echo test 683: Func isa
        cat >$test_file <<'TEST683'
class a {
}

class b {
}

class c {
  use b;
  fun i {putln ("i");}
  fun c {put ("c -- "); i ();}
}

putln (isa (c, b));
putln (isa (c (), b));

putln (isa (c, a));
putln (isa (c (), a));
TEST683
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT683' && $CMP $stdout $ftemp2; then
1
1
0
0
OUTPUT683
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 684.
if test $result = ok -a $start_test_number -le 684; then
	echo test 684: wrong number of pars in isa
        cat >$test_file <<'TEST684'
isa ("");
TEST684
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT684' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of actual parameters for `isa'
OUTPUT684
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 684.
if test $result = ok -a $start_test_number -le 684; then
	echo test 684: wrong 1st par in isa
        cat >$test_file <<'TEST684'
class c {}
isa ("", c);
TEST684
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT684' && $CMP $stderr $ftemp2; then
test.d:2:5: run time error - invalid parameter type of `isa'
OUTPUT684
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 685.
if test $result = ok -a $start_test_number -le 685; then
	echo test 685: wrong 2nd par in isa
        cat >$test_file <<'TEST685'
class c {}
isa (c,"");
TEST685
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT685' && $CMP $stderr $ftemp2; then
test.d:2:5: run time error - invalid parameter type of `isa'
OUTPUT685
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 686.
if test $result = ok -a $start_test_number -le 686; then
	echo test 686: Removing out 0
        cat >$test_file <<'TEST686'
for (var i = 0; i < 1000; i++)
  if (i % 1000 == 3) break;
TEST686
        echo '      ' $DINO -d $test_file "2>$stdout"
        if $DINO -d $test_file 2>$stderr >$stdout; then
                echo '      ' expr '`' fgrep out $stdout '| fgrep op1=0 | wc -l`' = 0
                if expr `fgrep out $stdout | fgrep op1=0 | wc -l` = 0 > /dev/null; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 687.
if test $result = ok -a $start_test_number -le 687; then
	echo test 687: former with renaming
        cat >$test_file <<'TEST687'
class c {
  val v = 0;
  fun i {putln ("1c", v);}
  fun i {putln ("2c", v);}
}

class sc {
  val v = 1;
  fun i {putln ("sc", v);}
  use c former v, i (ic);
}

var osc = sc ();
osc.i();
osc.ic();
TEST687
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT687' && $CMP $stdout $ftemp2; then
sc1
2c1
OUTPUT687
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 688.
if test $result = ok -a $start_test_number -le 688; then
	echo test 688: former with renaming
        cat >$test_file <<'TEST688'
class c {
  val v = 0;
  fun i {putln ("1c", v);}
  fun i {putln ("2c", v);}
}

class sc {
  use c later v, i (ic);
  val v = 1;
  fun i {putln ("sc", v);}
}

var osc = sc ();
osc.i();
osc.ic();
TEST688
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT688' && $CMP $stdout $ftemp2; then
sc1
2c1
OUTPUT688
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 689.
if test $result = ok -a $start_test_number -le 689; then
	echo test 689: Non unique renamed decl with former
        cat >$test_file <<'TEST689'
class c {
  val v = 0;
  fun i {putln ("1c", v);}
  fun i {putln ("2c", v);}
}

class sc {
  val v = 1;
  fun i {putln ("sc", v);}
  fun ic {putln ("ic", v);}
  use c former v, i (ic);
}

var osc = sc ();
osc.i();
osc.ic();
TEST689
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT689' && $CMP $stderr $ftemp2; then
test.d:11:7: alias redefines previous `ic'
test.d:10:7: (previous declaration of identifier `ic')
test.d:11:7: alias redefines previous `ic'
test.d:10:7: (previous declaration of identifier `ic')
OUTPUT689
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 690.
if test $result = ok -a $start_test_number -le 690; then
	echo test 690: Non unique renamed decl with later
        cat >$test_file <<'TEST690'
class c {
  val v = 0;
  fun i {putln ("1c", v);}
  fun i {putln ("2c", v);}
}

class sc {
  use c later v, i (ic);
  val v = 1;
  fun i {putln ("sc", v);}
  fun ic {putln ("ic", v);}
}

var osc = sc ();
osc.i();
osc.ic();
TEST690
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT690' && $CMP $stderr $ftemp2; then
test.d:11:7: alias `ic' is redefined
test.d:8:21: (previous declaration of identifier `ic')
OUTPUT690
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 691.
if test $result = ok -a $start_test_number -le 691; then
	echo test 691: Another non unique renamed decl with former
        cat >$test_file <<'TEST691'
class c {
  val v = 0;
  fun i {putln ("1c", v);}
  fun i {putln ("2c", v);}
}

class sc {
  val v = 1;
  fun i {putln ("sc", v);}
  use c former v, i (ic);
  fun ic {putln ("ic", v);}
}

var osc = sc ();
osc.i();
osc.ic();
TEST691
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT691' && $CMP $stderr $ftemp2; then
test.d:11:7: alias `ic' is redefined
test.d:10:22: (previous declaration of identifier `ic')
OUTPUT691
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 692.
if test $result = ok -a $start_test_number -le 692; then
	echo test 692: Abstract fun call
        cat >$test_file <<'TEST692'
fun f;
f ();
TEST692
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT692' && $CMP $stderr $ftemp2; then
test.d:2:3: run time error - unfinished fun/class `f' call
OUTPUT692
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 693.
if test $result = ok -a $start_test_number -le 693; then
	echo test 693: Abstract method call
        cat >$test_file <<'TEST693'
class c {fun f;}
c ().f ();
TEST693
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT693' && $CMP $stderr $ftemp2; then
test.d:2:5: run time error - undefined class or function `f'
OUTPUT693
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 694.
if test $result = ok -a $start_test_number -le 694; then
	echo test 694: Abstract function access
        cat >$test_file <<'TEST694'
fun f;
val v = f;
TEST694
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT694' && $CMP $stderr $ftemp2; then
test.d:2:9: run time error - undefined class or function `f'
OUTPUT694
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 695.
if test $result = ok -a $start_test_number -le 695; then
	echo test 695: A bug for initialization with redifinition
        cat >$test_file <<'TEST695'
val a = 10, a = a + 10;
putln (a);
TEST695
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT695' && $CMP $stdout $ftemp2; then
20
OUTPUT695
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 696.
if test $result = ok -a $start_test_number -le 696; then
	echo test 696: An object
        cat >$test_file <<'TEST696'
obj a {
  fun p {putln ("obj");}
}

a.p ();
TEST696
        echo '      ' $DINO $test_file " >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT696' && $CMP $stdout $ftemp2; then
obj
OUTPUT696
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 697.
if test $result = ok -a $start_test_number -le 697; then
	echo test 697: JIT: from C to interpreter
        cat >$test_file <<'TEST697'
fun a {
  putln ("in a");
}

fun b ! {
  putln ("in b");
  a ();
  putln ("at b end");
}

b ();
putln ("end");
TEST697
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT697' && $CMP $stdout $ftemp2; then
in b
in a
at b end
end
OUTPUT697
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT697-2' && (fgrep 'Generated' $stderr | $CMP - $ftemp2); then
Generated C code functions - 1, their calls - 1
OUTPUT697-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 698.
if test $result = ok -a $start_test_number -le 698; then
	echo test 698: JIT: from interpreter to C
        cat >$test_file <<'TEST698'
fun a ! {
  putln ("in a");
}

fun b {
  putln ("in b");
  a ();
  putln ("at b end");
}

b ();
putln ("end");
TEST698
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT698' && $CMP $stdout $ftemp2; then
in b
in a
at b end
end
OUTPUT698
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT698-2' && (fgrep 'Generated' $stderr | $CMP - $ftemp2); then
Generated C code functions - 1, their calls - 1
OUTPUT698-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 699.
if test $result = ok -a $start_test_number -le 699; then
	echo test 699: JIT: from C to C
        cat >$test_file <<'TEST699'
fun a ! {
  putln ("in a");
}

fun b ! {
  putln ("in b");
  a ();
  putln ("at b end");
}

b ();
putln ("end");
TEST699
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT699' && $CMP $stdout $ftemp2; then
in b
in a
at b end
end
OUTPUT699
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT699-2' && (fgrep 'Generated' $stderr | $CMP - $ftemp2); then
Generated C code functions - 2, their calls - 2
OUTPUT699-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 700.
if test $result = ok -a $start_test_number -le 700; then
	echo test 700: JIT: Interpreter calls C with throw
        cat >$test_file <<'TEST700'
fun a ! {
  putln ("in a");
  throw except ();
}

fun b {
  putln ("in b");
  a ();
  putln ("at b end");
}

try {
  b ();
} catch (except) {putln ("except");}

putln ("end");
TEST700
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT700' && $CMP $stdout $ftemp2; then
in b
in a
except
end
OUTPUT700
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT700-2' && (fgrep 'Generated' $stderr | $CMP - $ftemp2); then
Generated C code functions - 1, their calls - 1
OUTPUT700-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 701.
if test $result = ok -a $start_test_number -le 701; then
	echo test 701: JIT: C calls interpreter with throw
        cat >$test_file <<'TEST701'
fun a {
  putln ("in a");
  throw except ();
}

fun b ! {
  putln ("in b");
  a ();
  putln ("at b end");
}

try {
  b ();
} catch (except) {putln ("except");}

putln ("end");
TEST701
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT701' && $CMP $stdout $ftemp2; then
in b
in a
except
end
OUTPUT701
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT701-2' && (fgrep 'Generated' $stderr | $CMP - $ftemp2); then
Generated C code functions - 1, their calls - 1
OUTPUT701-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 702.
if test $result = ok -a $start_test_number -le 702; then
	echo test 702: JIT: C calls C with throw
        cat >$test_file <<'TEST702'
fun a ! {
  putln ("in a");
  throw except ();
}

fun b ! {
  putln ("in b");
  a ();
  putln ("at b end");
}

try {
  b ();
} catch (except) {putln ("except");}

putln ("end");
TEST702
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT702' && $CMP $stdout $ftemp2; then
in b
in a
except
end
OUTPUT702
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT702-2' && (fgrep 'Generated' $stderr | $CMP - $ftemp2); then
Generated C code functions - 2, their calls - 2
OUTPUT702-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 703.
if test $result = ok -a $start_test_number -le 703; then
	echo test 703: JIT: Interpreter with try calls C with throw
        cat >$test_file <<'TEST703'
fun a ! {
  putln ("in a");
  throw except ();
}

fun b {
  putln ("in b");
  try {
    a ();
  } catch (except) {putln ("except");}
  putln ("at b end");
}

b ();
putln ("end");
TEST703
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT703' && $CMP $stdout $ftemp2; then
in b
in a
except
at b end
end
OUTPUT703
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT703-2' && (fgrep 'Generated' $stderr | $CMP - $ftemp2); then
Generated C code functions - 1, their calls - 1
OUTPUT703-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 704.
if test $result = ok -a $start_test_number -le 704; then
	echo test 704: JIT: C with try calls C with throw
        cat >$test_file <<'TEST704'
fun a ! {
  putln ("in a");
  throw except ();
}

fun b ! {
  putln ("in b");
  try {
    a ();
  } catch (except) {putln ("except");}
  putln ("at b end");
}

b ();
putln ("end");
TEST704
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT704' && $CMP $stdout $ftemp2; then
in b
in a
except
at b end
end
OUTPUT704
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT704-2' && (fgrep 'Generated' $stderr | $CMP - $ftemp2); then
Generated C code functions - 2, their calls - 2
OUTPUT704-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 705.
if test $result = ok -a $start_test_number -le 705; then
	echo test 705: JIT: C with try calls interpreter with throw
        cat >$test_file <<'TEST705'
fun a {
  putln ("in a");
  throw except ();
}

fun b ! {
  putln ("in b");
  try {
    a ();
  } catch (except) {putln ("except");}
  putln ("at b end");
}

b ();
putln ("end");
TEST705
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT705' && $CMP $stdout $ftemp2; then
in b
in a
except
at b end
end
OUTPUT705
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT705-2' && (fgrep 'Generated' $stderr | $CMP - $ftemp2); then
Generated C code functions - 1, their calls - 1
OUTPUT705-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 706.
if test $result = ok -a $start_test_number -le 706; then
	echo test 706: JIT: C calls interpreter with exception
        cat >$test_file <<'TEST706'
fun a {
  1/0;
}

fun b ! {
  putln ("in b");
  a ();
  putln ("at b end");
}

b ();
putln ("end");
TEST706
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
           result=fail
	else
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT706' && $CMP $stdout $ftemp2; then
in b
OUTPUT706
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT706-2' && $CMP $stderr $ftemp2; then
test.d:2:4: floating point exception
OUTPUT706-2
			result=ok
                    else
                        result=fail
                    fi
                else
                   result=fail
                fi
        fi
fi

# Test 707.
if test $result = ok -a $start_test_number -le 707; then
	echo test 707: JIT: Interpreter calls C with exception
        cat >$test_file <<'TEST707'
fun a ! {
  1/0;
}

fun b {
  putln ("in b");
  a ();
  putln ("at b end");
}

b ();
putln ("end");
TEST707
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
           result=fail
	else
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT707' && $CMP $stdout $ftemp2; then
in b
OUTPUT707
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT707-2' && $CMP $stderr $ftemp2; then
test.d:2:4: floating point exception
OUTPUT707-2
			result=ok
		    elif cat >$ftemp2 <<'OUTPUT707-3' && $CMP $stderr $ftemp2; then
test.d:7:5: floating point exception
OUTPUT707-3
			result=ok
                    else
                        result=fail
                    fi
                else
                   result=fail
                fi
        fi
fi

# Test 708.
if test $result = ok -a $start_test_number -le 708; then
	echo test 708: JIT: C calls C with exception
        cat >$test_file <<'TEST708'
fun a ! {
  1/0;
}

fun b ! {
  putln ("in b");
  a ();
  putln ("at b end");
}

b ();
putln ("end");
TEST708
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
           result=fail
	else
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT708' && $CMP $stdout $ftemp2; then
in b
OUTPUT708
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT708-2' && $CMP $stderr $ftemp2; then
test.d:2:4: floating point exception
OUTPUT708-2
			result=ok
		    elif cat >$ftemp2 <<'OUTPUT708-3' && $CMP $stderr $ftemp2; then
test.d:7:5: floating point exception
OUTPUT708-3
			result=ok
                    else
                        result=fail
                    fi
                else
                   result=fail
                fi
        fi
fi

# Test 709.
if test $result = ok -a $start_test_number -le 709; then
	echo test 709: JIT: C calls interpreter with GC
        cat >$test_file <<'TEST709'
fun a {
  gc ();
}

fun b ! {
  putln ("in b");
  try {
    a ();
  } catch (except) {putln ("except");}
  putln ("at b end");
}

b ();
putln ("end");
TEST709
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT709' && $CMP $stdout $ftemp2; then
in b
at b end
end
OUTPUT709
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT709-2' && (fgrep 'Generated' $stderr | $CMP - $ftemp2); then
Generated C code functions - 1, their calls - 1
OUTPUT709-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 710.
if test $result = ok -a $start_test_number -le 710; then
	echo test 710: JIT: Interpreter calls C with GC
        cat >$test_file <<'TEST710'
fun a ! {
  gc ();
}

fun b {
  putln ("in b");
  try {
    a ();
  } catch (except) {putln ("except");}
  putln ("at b end");
}

b ();
putln ("end");
TEST710
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT710' && $CMP $stdout $ftemp2; then
in b
at b end
end
OUTPUT710
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT710-2' && (fgrep 'Generated' $stderr | $CMP - $ftemp2); then
Generated C code functions - 1, their calls - 1
OUTPUT710-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 711.
if test $result = ok -a $start_test_number -le 711; then
	echo test 711: JIT: C calls C with GC
        cat >$test_file <<'TEST711'
fun a ! {
  gc ();
}

fun b ! {
  putln ("in b");
  try {
    a ();
  } catch (except) {putln ("except");}
  putln ("at b end");
}

b ();
putln ("end");
TEST711
        echo '      ' $DINO -s $test_file " >$stdout 2>$stderr"
        if $DINO -s $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT711' && $CMP $stdout $ftemp2; then
in b
at b end
end
OUTPUT711
                    echo '      ' $CMP $stderr $ftemp2
		    if cat >$ftemp2 <<'OUTPUT711-2' && (fgrep 'Generated' $stderr | $CMP - $ftemp2); then
Generated C code functions - 2, their calls - 2
OUTPUT711-2
			result=ok
                    else
                        result=fail
                    fi
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Final message

if test $result = ok; then
        echo $script_file: it is all ok
        rm -f $test_file $test_file_1 $stderr a.out $stdout $ftemp $ftemp2
	rm -rf $tempdir
        exit 0
else
        echo '***' $script_file:test is failed
        echo '   '  see files $test_file, $stdout, $test_file_1, $stderr, $ftemp, $ftemp2, $tempdir
        exit 1
fi
