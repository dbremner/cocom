#!/bin/sh

#
# Script to test of DINO.
#
# Copyright (C) 1997-2007 Vladimir Makarov.
# 
# Written by Vladimir Makarov <vmakarov@users.sourceforge.net>
# 
# This file is part of interpreter of DINO.
# 
# This is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
# 
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with GNU CC; see the file COPYING.  If not, write to the Free
# Software Foundation, 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.
#
#
# Usage: dino.tst [start_test_number [build by MSVC]] 
#
# The script outputs self-explanatory messages and returns zero exit code if 
# it is all ok.
#

DINO=./dino
script_file=$0
test_file=test.d
test_file_1=test1.d
stderr=_stderr.out
stdout=_stdout.out
ftemp=_temp.out
ftemp2=_temp2.out
tempdir=__tempdir
result=ok

if uname | fgrep CYGWIN; then
   CMP="eval sh -c 'tr -d \\\\r <\$0 >__tmp && mv __tmp \$0 && tr -d \\\\r <\$1 >__tmp && mv __tmp \$1 && cmp \$0 \$1'"
   SCMP="eval sh -c 'tr -d \\\\r <\$0 >__tmp && mv __tmp \$0 && cmp \$0 \$1'"
else
   CMP=cmp
   SCMP=cmp
fi

if test x$1 = x
then
    start_test_number=1
else
    if expr $1 + 0 >/dev/null
    then
        start_test_number=`expr $1 + 0`
    else
        echo $script_file:invalid argument $1 2>&1
        exit 1
    fi
fi

if test x$2 = x
then
    msvc=
else
    msvc=yes
fi

# Test 1.
if test $result = ok -a $start_test_number -le 1; then
	echo test 1
        cat >$test_file <<'TEST1'
var i;
i = 0;
i++;
TEST1
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        else
                result=fail
        fi
fi


# Test 2.
if test $result = ok -a $start_test_number -le 2; then
	echo test 2
        cat >$test_file <<'TEST2'
var i;
for (i = 0; i < 100000; i++);
TEST2
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        else
                result=fail
        fi
fi

# Test 3.
if test $result = ok -a $start_test_number -le 3; then
	echo test 3
        cat >$test_file <<'TEST3'
func f (){}
var i;
for (i = 0; i < 100000;i++)
 f ();
TEST3
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        else
                result=fail
        fi
fi

# Test 4.
if test $result = ok -a $start_test_number -le 4; then
	echo test 4
        cat >$test_file <<'TEST4'
func f() {
  {
    return 10;
  }
}

var i;
i = f ();
println (i);
TEST4
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT4' && $CMP $stdout $ftemp2; then
10
OUTPUT4
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 5.
if test $result = ok -a $start_test_number -le 5; then
	echo test 5
        cat >$test_file <<'TEST5'
func f () {}
class c () {}

putln ("0:", "abc" === "abc");
putln ("1:", 'c' === 'c');
putln ("1:", 10 === 10);
putln ("1:", 10.5 === 10.5);
	   
putln ("1:", f === f);
putln ("0:", f === c);
putln ("1:", c === c);
putln ("0:", c() === c());
	   
putln ("0:", 10 === "10");
putln ("0:", 10.5 === "10.5");
putln ("0:", 'c' === "c");

var op;
op = "abc";
putln ("0:", op === "abc");
op = 'c';
putln ("1:", op === 'c');
op = 10;
putln ("1:", op === 10);
op = 10.5;
putln ("1:", op === 10.5);

op = f;
putln ("1:", op === f);
putln ("0:", f === c);
op = c();
putln ("0:", op === c());
putln ("1:", op === op);

op = 10;
putln ("0:", op === "10");
op = 10.5;
putln ("0:", op === "10.5");
op = 'c';
putln ("0:", op === "c");
op = "abc";
putln ("0:", op === "abc");
TEST5
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT5' && $CMP $stdout $ftemp2; then
0:0
1:1
1:1
1:1
1:1
0:0
1:1
0:0
0:0
0:0
0:0
0:0
1:1
1:1
1:1
1:1
0:0
0:0
1:1
0:0
0:0
0:0
0:0
OUTPUT5
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 6.
if test $result = ok -a $start_test_number -le 6; then
	echo test 6
        cat >$test_file <<'TEST6'
func f () {}
putln ("0:", f === 10);
TEST6
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT6' && $CMP $stdout $ftemp2; then
0:0
OUTPUT6
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 7.
if test $result = ok -a $start_test_number -le 7; then
	echo test 7
        cat >$test_file <<'TEST7'
class c () {}
putln ("0:", c === 10);
TEST7
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT7' && $CMP $stdout $ftemp2; then
0:0
OUTPUT7
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 8.
if test $result = ok -a $start_test_number -le 8; then
	echo test 8
        cat >$test_file <<'TEST8'
class c () {}
putln ("0:", c () === 10);
TEST8
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT8' && $CMP $stdout $ftemp2; then
0:0
OUTPUT8
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 9.
if test $result = ok -a $start_test_number -le 9; then
	echo test 9
        cat >$test_file <<'TEST9'
var i;
putln ("1:", i == nil);
putln ("0:", i != nil);
putln ("1:", i === nil);
putln ("0:", i !== nil);
func f () {}
putln ("1:", f () == nil);
func g () {return;}
putln ("1:", f () == nil);
var t;
t = {"e"};
putln ("1:", t{"e"} == nil);
TEST9
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT9' && $CMP $stdout $ftemp2; then
1:1
0:0
1:1
0:0
1:1
1:1
1:1
OUTPUT9
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 10.
if test $result = ok -a $start_test_number -le 10; then
	echo test 10
        cat >$test_file <<'TEST10'
var i;
i = 10 + "aaa";
i = 10 @ "aaa";
i = 10 == "aaa";
TEST10
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST10-1'; then
test.d:2:8: system error - invalid argument: `string-to-float conversion'
TEST10-1
                result=ok
        else
                result=fail
        fi
fi

# Test 11.
if test $result = ok -a $start_test_number -le 11; then
	echo test 11
        cat >$test_file <<'TEST11'
func f() {putln ("eval false");return 0;}
func t() {putln ("eval true");return 1;}

var i;
putln ("++test false and true");
i = f() && t ();
putln ("++test true and true");
i = t() && t ();
putln ("++test true or true");
i = t() || t ();
putln ("++test false or true");
i = f() || t ();
putln ("++conditional: f ? t : f");
i = f() ? t () : f ();
putln ("++conditional: t ? t : f");
i = t() ? t () : f ();
TEST11
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT11' && $CMP $stdout $ftemp2; then
++test false and true
eval false
++test true and true
eval true
eval true
++test true or true
eval true
++test false or true
eval false
eval true
++conditional: f ? t : f
eval false
eval false
++conditional: t ? t : f
eval true
eval true
OUTPUT11
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 12.
if test $result = ok -a $start_test_number -le 12; then
	echo test 12
        cat >$test_file <<'TEST12'
func fact (x)
{
  if (x <= 1)
    return 1;
  return x * fact (x-1);
}

var i, x;

for (i = 0; i < 1000; i++)
  x = fact (12);

putln (x);
TEST12
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT12' && $CMP $stdout $ftemp2; then
479001600
OUTPUT12
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 13.
if test $result = ok -a $start_test_number -le 13; then
	echo test 13
        cat >$test_file <<'TEST13'
putln ("length of abcd - ", #"abcd");
TEST13
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT13' && $CMP $stdout $ftemp2; then
length of abcd - 4
OUTPUT13
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 14.
if test $result = ok -a $start_test_number -le 14; then
	echo test 14
        cat >$test_file <<'TEST14'
var s, ns, t;
s = "aaaa";
ns = new s;
ns[1] = "b";
println (s,ns);

s = {"a"};
ns = new s;
ns{"a"} = "b";
println (s,ns);

s = ['a'];
t = {s:"a"};
ns = new s;
ns[0] = 'b';
println (s, ns);

class c()
{
  var i;
}
var o, no;
o = final c ();
no = new o;
no.i = 10;
println (o.i, no.i);

s = "10" @ new "10";
s[0] = 'c';
TEST14
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT14' && $CMP $stdout $ftemp2; then
"aaaa"['a', "b", 'a', 'a']
{"a":nil}{"a":"b"}
"a""b"
nil10
OUTPUT14
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 15.
if test $result = ok -a $start_test_number -le 15; then
	echo test 15
        cat >$test_file <<'TEST15'
var i;
for (i = 0.0; i < 100000.0; i = i + 1.0);
TEST15
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT15' && $CMP $stdout $ftemp2; then
OUTPUT15
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 16.
if test $result = ok -a $start_test_number -le 16; then
	echo test 16
        cat >$test_file <<'TEST16'
func tak (x, y, z)
  {
    if (y >= x)
        return z;
    else
        return tak (tak (x-1, y, z), tak (y-1, z, x), tak (z-1, x, y));
  }
putln (tak(18, 12, 6));
TEST16
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT16' && $CMP $stdout $ftemp2; then
7
OUTPUT16
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 17.
if test $result = ok -a $start_test_number -le 17; then
	echo test 17
        cat >$test_file <<'TEST17'
var i, t;
t = {"e":10, 10:11};
putln (t{"e"});
putln (t{10});
putln ("e in t - 1:", "e" in t);
putln ("10 in t - 1:", 10 in t);
putln ("11 in t - 0:", 11 in t);
t = {"e":10, "f":11, "g":12, "h":13};
for (i in t) putln (i);
t = {"e", "f", "g", "h"};
for (i in t) putln (i);
TEST17
        echo '      ' $DINO $test_file "2>$stderr" ">$ftemp2" '&&' sort $ftemp2 ">$stdout"
        if $DINO $test_file 2>$stderr >$ftemp2 && sort $ftemp2 >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT17' && $CMP $stdout $ftemp2; then
10
10 in t - 1:1
11
11 in t - 0:0
e
e
e in t - 1:1
f
f
g
g
h
h
OUTPUT17
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 18.
if test $result = ok -a $start_test_number -le 18; then
	echo test 18
        cat >$test_file <<'TEST18'
var t;
t = {};
t{"e"} = 10;
t{10} = 11;
putln (t{"e"});
putln (t{10});
TEST18
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT18' && $CMP $stdout $ftemp2; then
10
11
OUTPUT18
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 19.
if test $result = ok -a $start_test_number -le 19; then
	echo test 19
        cat >$test_file <<'TEST19'
var i, v, pv;

v = [100:0, 100:'c'];
for (i = 0; i < 1000;i++)
{
  v = [100:10.0];
  v[50] = 'c';
  v[50] = 10.0;
  pv = v;
}
TEST19
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT19' && $CMP $stdout $ftemp2; then
OUTPUT19
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 20.
if test $result = ok -a $start_test_number -le 20; then
	echo test 20
        cat >$test_file <<'TEST20'
class c(p) {
  var i;
  i = 1;
  func f () {putln ("i=", i);}
  func g () {putln ("p=", p);}
  func f1 (i) {putln ("i=", i);}
  func g1 (p) {putln ("p=", p);}
}
var i;
i = c(10);
i.f();
i.g();
i.f1(100);
i.g1(1000);
TEST20
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT20' && $CMP $stdout $ftemp2; then
i=1
p=10
i=100
p=1000
OUTPUT20
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 21.
if test $result = ok -a $start_test_number -le 21; then
	echo test 21
        cat >$test_file <<'TEST21'
class c(p) {
  var i;
  class cc(p) {
    func f () {putln (p);}
  }
  i = 10;
}
var j,k;
j = c(10);
k = j.cc(100);
k.f();


TEST21
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT21' && $CMP $stdout $ftemp2; then
100
OUTPUT21
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 22.
if test $result = ok -a $start_test_number -le 22; then
	echo test 22
        cat >$test_file <<'TEST22'
var a, i;
for (i = 0; i < 10; i++)
  a = [5:2];
TEST22
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT22' && $CMP $stdout $ftemp2; then
OUTPUT22
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 23.
if test $result = ok -a $start_test_number -le 23; then
	echo test 23
        cat >$test_file <<'TEST23'
var v;
var i;
i = 3;
v = [5 : 7, i:8];
for (i = 0; i< #v; i = i + 1)
  putln (v[i]);
TEST23
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT23' && $CMP $stdout $ftemp2; then
7
7
7
7
7
8
8
8
OUTPUT23
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 24.
if test $result = ok -a $start_test_number -le 24; then
	echo test 24
        cat >$test_file <<'TEST24'
putln ("0:", '\n' === 10.0);
putln ("0:", 10 === 10.0);
putln ("0:", "10" === 10.0);
putln ("0:", "10.0" === 10.0);
putln ("0:", "aaaaa" === [5:'a', '\0']);
TEST24
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT24' && $CMP $stdout $ftemp2; then
0:0
0:0
0:0
0:0
0:0
OUTPUT24
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 25.
if test $result = ok -a $start_test_number -le 25; then
	echo test 25
        cat >$test_file <<'TEST25'
func f (args)
{
}

func g (a)
{
  var args;
}

func t (a, ...)
{
  var i;

  putln ("****");
  if (a !== nil)
    putln ("a = ", a);
  for (i = 0; i<#args;i++)
    putln ("args[", i, "]=", args[i]);
}

t ();
t (10);
t (10, 1);
t (10, 1, 2);
t (10, 1, 2, 3);
TEST25
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT25' && $CMP $stdout $ftemp2; then
****
****
a = 10
****
a = 10
args[0]=1
****
a = 10
args[0]=1
args[1]=2
****
a = 10
args[0]=1
args[1]=2
args[2]=3
OUTPUT25
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 26.
if test $result = ok -a $start_test_number -le 26; then
	echo test 26
        cat >$test_file <<'TEST26'
func f () {}
class c () {}

putln ("1:", "10" == "10");
putln ("1:", 10 == 10);
putln ("1:", 10.5 == 10.5);
putln ("1:", 'c' == 'c');
	  
putln ("1:", 10 == 10.0);
putln ("1:", 99 == 'c');
putln ("1:", 99.0 == 'c');
	  
putln ("1:", 10 == "10");
putln ("1:", 10.5 == "10.5");
putln ("1:", 'c' == "c");
	  
putln ("1:", f == f);
putln ("1:", c == c);
putln ("1:", c() == c());

var op;
op = 10;
putln ("1:", op == "10");
op = 10.5;
putln ("1:", op == "10.5");
op = 'c';
putln ("1:", op == "c");
TEST26
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT26' && $CMP $stdout $ftemp2; then
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
1:1
OUTPUT26
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 27.
if test $result = ok -a $start_test_number -le 27; then
	echo test 27
        cat >$test_file <<'TEST27'
func f () {}
var r;
r = f == 10;
putln ("0:", r);
TEST27
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT27' && $CMP $stdout $ftemp2; then
0:0
OUTPUT27
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 28.
if test $result = ok -a $start_test_number -le 28; then
	echo test 28
        cat >$test_file <<'TEST28'
class c () {}
var r;
r = c == 10;
putln ("0:", r);
TEST28
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT28' && $CMP $stdout $ftemp2; then
0:0
OUTPUT28
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 29.
if test $result = ok -a $start_test_number -le 29; then
	echo test 29
        cat >$test_file <<'TEST29'
class c () {}
var r;
r = c () == 10;
putln ("0:", r);
TEST29
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT29' && $CMP $stdout $ftemp2; then
0:0
OUTPUT29
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 30.
if test $result = ok -a $start_test_number -le 30; then
	echo test 30
        cat >$test_file <<'TEST30'
class c (p) {
  putln ("p = ", p);
};

c(10);
TEST30
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT30' && $CMP $stdout $ftemp2; then
p = 10
OUTPUT30
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 31.
if test $result = ok -a $start_test_number -le 31; then
	echo test 31
        cat >$test_file <<'TEST31'
class c (p, ...)
{
  var i;
  putln ("p = ", p);
  for (i = 0; i < #args; i++)
    putln (args[i]);
}

c (10, 11, 12, 13);
TEST31
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT31' && $CMP $stdout $ftemp2; then
p = 10
11
12
13
OUTPUT31
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 32.
if test $result = ok -a $start_test_number -le 32; then
	echo test 32
        cat >$test_file_1 <<'TEST32'
var i;
i = 8;
TEST32
        cat >$test_file <<'TEST32-1'
include "test1";
putln (i);
TEST32-1
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT32' && $CMP $stdout $ftemp2; then
8
OUTPUT32
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 33.
if test $result = ok -a $start_test_number -le 33; then
	echo test 33
        cat >$test_file <<'TEST33'
// vector
var v;
// pack
v = [1, 2, 3, 5, 6]; ins (v, 4, 3); println (v);
v = [2, 3, 4, 5, 6]; ins (v, 1); println (v);
v = [1, 2, 3, 4, 5]; ins (v, 6, -1); println (v);
v = [2, 3, 4, 5, 6]; ins (v, 1, 0); println (v);
// unpack
v = [1.0, 2, 3, 5, 6]; ins (v, 4, 3); println (v);
v = [2.0, 3, 4, 5, 6]; ins (v, 1); println (v);
v = [1.0, 2, 3, 4, 5]; ins (v, 6, -1); println (v);
v = [2.0, 3, 4, 5, 6]; ins (v, 1, 0); println (v);
// empty
v = []; ins (v, nil); println (v);
v = []; ins (v, nil, -1); println (v);
v = []; ins (v, nil, 0); println (v);
v = []; ins (v, nil, 10); println (v);
// string
v = new "123456"; ins (v, 2); println (v);
v = new "123456"; ins (v, "+++"); println (v);
v = new "123456"; ins (v, "+++", -1); println (v);
v = new "123456"; ins (v, "+++", 100); println (v);
//
var i, iter;
for (iter = 0; iter < 10000; iter++)
  { 
    v = [];
    for (i = 0; i < 100; i++)
      ins (v, 1);
    for (i = 0; i < 100; i++)
      del (v, 0);
  }
println (v);
TEST33
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT33' && $CMP $stdout $ftemp2; then
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[nil]
[nil]
[nil]
[nil]
[2, '1', '2', '3', '4', '5', '6']
["+++", '1', '2', '3', '4', '5', '6']
['1', '2', '3', '4', '5', '6', "+++"]
['1', '2', '3', '4', '5', '6', "+++"]
[]
OUTPUT33
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 34.
if test $result = ok -a $start_test_number -le 34; then
	echo test 34
        cat >$test_file <<'TEST34'
// vector
var v;
// pack & pack
v = [1, 2, 3, 5, 6]; insv (v, [4], 3); println (v);
v = [2, 3, 4, 5, 6]; insv (v, [1]); println (v);
v = [1, 2, 3, 4, 5]; insv (v, [6], -1); println (v);
v = [2, 3, 4, 5, 6]; insv (v, [1], 0); println (v);
// unpack & pack
v = [1.0, 2, 3, 5, 6]; insv (v, [4], 3); println (v);
v = [2.0, 3, 4, 5, 6]; insv (v, [1]); println (v);
v = [1.0, 2, 3, 4, 5]; insv (v, [6], -1); println (v);
v = [2.0, 3, 4, 5, 6]; insv (v, [1], 0); println (v);
// unpack & unpack
v = [1.0, 2, 3, 6]; insv (v, [4, 5.0], 3); println (v);
v = [3.0, 4, 5, 6]; insv (v, [1.0, 2]); println (v);
v = [1.0, 2, 3, 4, 5]; insv (v, [6, 7.0], -1); println (v);
v = [3, 4, 5, 6]; insv (v, [1, 2.0], 0); println (v);
// empty
v = []; insv (v, [10]); println (v);
v = []; insv (v, [10], -1); println (v);
v = []; insv (v, [10], 0); println (v);
v = []; insv (v, [10], 10); println (v);
v = [10]; insv (v, []); println (v);
v = [10]; insv (v, [], -1); println (v);
v = [10]; insv (v, [], 0); println (v);
v = [10]; insv (v, [], 10); println (v);
// string
v = new "123456"; insv (v, "+++"); putln (v);
v = new "123456"; insv (v, "+++", -1); putln (v);
v = new "123456"; insv (v, "+++", 100); putln (v);
//
var i, iter;
for (iter = 0; iter < 10000; iter++)
  { 
    v = [];
    for (i = 0; i < 100; i++)
      insv (v, [1]);
    for (i = 0; i < 100; i++)
      del (v, 0);
  }
println (v);
TEST34
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT34' && $CMP $stdout $ftemp2; then
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6, 7]
[1, 2, 3, 4, 5, 6]
[10]
[10]
[10]
[10]
[10]
[10]
[10]
[10]
+++123456
123456+++
123456+++
[]
OUTPUT34
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 35.
if test $result = ok -a $start_test_number -le 35; then
	echo test 35
        cat >$test_file <<'TEST35'
print (nil);put (" ");
print (10);put (" ");
print (10.2e10);put (" ");
print ('c');put (" ");
println ("ssss");
println (["aaa", "bbb", "ccc"]);
println (["v1", {"key":"val", {"key1":"val1"}}]);
func f () {}
println (f);
class c () {}
println (c);
println (c ());
var stop;
stop = 0;
thread t () {wait (stop);}
println (t());
wait (1) stop = 1;

TEST35
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT35' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+11 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", {"key":"val", {"key1":"val1"}:nil}]
func f
class c
instance c()
thread 1 t()
OUTPUT35
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT35-1' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+011 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", {"key":"val", {"key1":"val1"}:nil}]
func f
class c
instance c()
thread 1 t()
OUTPUT35-1
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT35-2' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+11 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", {{"key1":"val1"}:nil, "key":"val"}]
func f
class c
instance c()
thread 1 t()
OUTPUT35-2
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT35-3' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+011 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", {{"key1":"val1"}:nil, "key":"val"}]
func f
class c
instance c()
thread 1 t()
OUTPUT35-3
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 36.
if test $result = ok -a $start_test_number -le 36; then
	echo test 36
        cat >$test_file <<'TEST36'
var s, t;
s = new "aaaa";
s[1] = "b";
TEST36
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT36' && $CMP $stdout $ftemp2; then
OUTPUT36
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 37.
if test $result = ok -a $start_test_number -le 37; then
	echo test 37
        cat >$test_file <<'TEST37'
thread t1 () {
  var i;
  for (i = 0; i < 1000; i++)
     if (i % 100 == 0)
       putln ("thread 1 ", i);
}

thread t2 () {
  var i;
  for (i = 0; i < 1000; i++)
     if (i % 100 == 0)
       putln ("thread 2 ", i);
}

t1 ();
putln ("after t1()");
t2 ();
putln ("after t2()");
TEST37
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT37' && $CMP $stdout $ftemp2; then
after t1()
after t2()
thread 1 0
thread 1 100
thread 1 200
thread 1 300
thread 2 0
thread 2 100
thread 2 200
thread 2 300
thread 1 400
thread 1 500
thread 1 600
thread 2 400
thread 2 500
thread 2 600
thread 1 700
thread 1 800
thread 1 900
thread 2 700
thread 2 800
thread 2 900
OUTPUT37
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 38.
if test $result = ok -a $start_test_number -le 38; then
	echo test 38
        cat >$test_file <<'TEST38'
class c(){
thread f (start, iter) {var i;
  for (; iter >= 0; iter--){
    println (start);
    start++;
  }
}
}
var o;
o = c();
o.f (0, 5);
o.f (10, 5);
TEST38
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT38' && $CMP $stdout $ftemp2; then
0
1
2
3
4
5
10
11
12
13
14
15
OUTPUT38
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 39.
if test $result = ok -a $start_test_number -le 39; then
	echo test 39
        cat >$test_file <<'TEST39'
wait (1);
TEST39
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT39' && $CMP $stdout $ftemp2; then
OUTPUT39
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 40.
if test $result = ok -a $start_test_number -le 40; then
	echo test 40
        cat >$test_file <<'TEST40'
var i;
for (i = 0; i < #argv; i++)
  putln (argv[i]);
TEST40
        echo '      ' $DINO $test_file "2>$stderr -- aaaa bbbb"
        if $DINO $test_file 2>$stderr >$stdout -- aaaa bbbb; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT40' && $CMP $stdout $ftemp2; then
aaaa
bbbb
OUTPUT40
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 41.
if test $result = ok -a $start_test_number -le 41; then
	echo test 41
        cat >$test_file <<'TEST41'
// vector
var v;
// pack
v = [1, 2, 3, 4, 5, 6]; del (v, 2); println (v);
v = [1, 2, 3, 4, 5, 6]; del (v, -2, 2); println (v);
v = [1, 2, 3, 4, 5, 6]; del (v, 2, 2); println (v);
v = [1, 2, 3, 4, 5, 6]; del (v, 2, -1); println (v);
v = [1, 2, 3, 4, 5, 6]; del (v, 2, 0); println (v);
// unpack
v = [1, 2.0, 3.0, 4, 5, 6]; del (v, 2); println (v);
v = [1.0, 2, 3, 4, 5, 6]; del (v, -2, 2); println (v);
v = [1.0, 2, 3, 4, 5, 6]; del (v, 2, 2); println (v);
v = [1.0, 2, 3, 4, 5, 6]; del (v, 2, -1); println (v);
v = [1.0, 2, 3, 4, 5, 6]; del (v, 2, 0); println (v);
// empty
v = []; del (v, 0); println (v);
v = []; del (v, -2, 1); println (v);
v = []; del (v, 0, 1); println (v);
v = []; del (v, 1, 0); println (v);
v = []; del (v, 0, -1); println (v);
// string
v = new "123456"; del (v, 2, 2); putln (v);
v = new "123456"; del (v, -2, 2); putln (v);
// table
var t;
t = {1:1, 2:2, 3:3, 4:4, 5:5, 6:6}; del (t, 2); println (t);
//
var i, iter;
for (iter = 0; iter < 1000; iter++)
  { 
    v = [1000:1];
    for (i = 0; i < 1000; i++)
      del (v, 0);
  }
println (v);
TEST41
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT41' && $CMP $stdout $ftemp2; then
[1, 2, 4, 5, 6]
[3, 4, 5, 6]
[1, 2, 5, 6]
[1, 2]
[1, 2, 3, 4, 5, 6]
[1, 2, 4, 5, 6]
[3, 4, 5, 6]
[1, 2, 5, 6]
[1, 2]
[1, 2, 3, 4, 5, 6]
[]
[]
[]
[]
[]
1256
3456
{1:1, 3:3, 4:4, 5:5, 6:6}
[]
OUTPUT41
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 42.
if test $result = ok -a $start_test_number -le 42; then
	echo test 42
        cat >$test_file <<'TEST42'
println (system ("echo test"));
TEST42
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT42' && $CMP $stdout $ftemp2; then
test
0
OUTPUT42
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 43.
if test $result = ok -a $start_test_number -le 43; then
	echo test 43
        cat >$test_file <<'TEST43'
var i,j;
j = 0;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
i = j;
TEST43
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT43' && $CMP $stdout $ftemp2; then
OUTPUT43
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 44.
if test $result = ok -a $start_test_number -le 44; then
	echo test 44
        cat >$test_file <<'TEST44'
println (cos (3.14));
println (cos ("3.14"));
println (cos (3));
println (cos ('\3'));
TEST44
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT44' && $CMP $stdout $ftemp2; then
-0.999999
-0.999999
-0.989992
-0.989992
OUTPUT44
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 45.
if test $result = ok -a $start_test_number -le 45; then
	echo test 45
        cat >$test_file <<'TEST45'
println (sin (3.14));
println (sin ("3.14"));
println (sin (3));
println (sin ('\3'));
TEST45
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT45' && $CMP $stdout $ftemp2; then
0.00159265
0.00159265
0.14112
0.14112
OUTPUT45
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 46.
if test $result = ok -a $start_test_number -le 46; then
	echo test 46
        cat >$test_file <<'TEST46'
println (atan2 (3.14, 0));
println (atan2 ("3.14", 0));
println (atan2 (3, 0));
println (atan2 ('\3', 0));
//
println (atan2 (1.0, 0));
println (atan2 ("1.0", 0));
println (atan2 (1, 0));
println (atan2 ('\1', 0));
TEST46
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT46' && $CMP $stdout $ftemp2; then
1.5708
1.5708
1.5708
1.5708
1.5708
1.5708
1.5708
1.5708
OUTPUT46
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 47.
if test $result = ok -a $start_test_number -le 47; then
	echo test 47
        cat >$test_file <<'TEST47'
var SieveSize, i, prime, k, count, iter, flags;
SieveSize = 8190;

for (iter = 0; iter < 10; iter++;)
  {
    flags = [SieveSize + 1 : 0];
    count = 0;
    for (i = 0; i <= SieveSize; i++)
      flags[i] = 1;
    for (i = 0; i <= SieveSize; i++;)
      if (flags[i])
        {
          prime = i + i + 3;
          k = i + prime;
          for (;1;;)
            {
	      if (k > SieveSize)
                break;
              flags[k] = 0;
              k += prime;
            }
          count++;
        }
  }
println (count);
TEST47
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT47' && $CMP $stdout $ftemp2; then
1899
OUTPUT47
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 48.
if test $result = ok -a $start_test_number -le 48; then
	echo test 48
        cat >$test_file <<'TEST48'
var SieveSize, i, prime, k, count, iter, flags;
SieveSize = 8190;

for (iter = 0; iter < 10; iter++;)
  {
    flags = {};
    count = 0;
    for (i = 0; i <= SieveSize; i++)
      flags{i} = 1;
    for (i = 0; i <= SieveSize; i++;)
      if (flags{i})
        {
          prime = i + i + 3;
          k = i + prime;
          for (;1;;)
            {
	      if (k > SieveSize)
                break;
              flags{k} = 0;
              k += prime;
            }
          count++;
        }
  }
println (count);
TEST48
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT48' && $CMP $stdout $ftemp2; then
1899
OUTPUT48
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 49.
if test $result = ok -a $start_test_number -le 49; then
	echo test 49
        cat >$test_file <<'TEST49'
var m1, m2;

func mmult (m1, m2)
{
  var i, j, k, m1rows, m1cols, m2rows, m2cols, result;

  m1rows = #m1; m2rows = #m2;
  m1cols = #m1[0]; m2cols = #m2[0];
  if (m2cols != m2rows)
    {
       println ("matrices don't match");
       return;
    }
  result = [m1rows:[m2cols:0]];
  for (i=0; i < m1rows; i++)
    for (j=0; j < m2cols; j++)
      for (k=0; k < m1cols; k++)
        result[i][j] += m1[i][k]*m2[k][j];
  return result;
}

m1 = [100:[100:1]];
m2 = [100:[100:1]];
mmult (m1, m2);
TEST49
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT49' && $CMP $stdout $ftemp2; then
OUTPUT49
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 50.
if test $result = ok -a $start_test_number -le 50; then
	echo test 50
        cat >$test_file <<'TEST50'
var m1, m2;

func mmult (m1, m2)
{
  var i, j, k, m1rows, m1cols, m2rows, m2cols, result;

  m1rows = #m1; m2rows = #m2;
  m1cols = #m1{0}; m2cols = #m2{0};
  if (m2cols != m2rows)
    {
       println ("matrices don't match");
       return;
    }
  result = {};
  for (i=0; i < m1rows; i++) {
    result{i} = {};
    for (j=0; j < m2cols; j++) {
      result{i}{j} = 0;
      for (k=0; k < m1cols; k++)
        result{i}{j} += m1{i}{k}*m2{k}{j};
    }
  }
  return result;
}

var i, j;

m1 = {};
for (i = 0;i < 100; i++) {
  m1{i} = {};
  for (j = 0;j < 100; j++)
    m1{i}{j} = 2;
}
m2 = m1;
mmult (m1, m2);
TEST50
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT50' && $CMP $stdout $ftemp2; then
OUTPUT50
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 51.
if test $result = ok -a $start_test_number -le 51; then
	echo test 51
        cat >$test_file <<'TEST51'
var i;
i = 0;
func f ()
{
   var i;

   func g () {i = 20; return i;}
   i = 10;
   return g;
}
println (f ()());
TEST51
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT51' && $CMP $stdout $ftemp2; then
20
OUTPUT51
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 52.
if test $result = ok -a $start_test_number -le 52; then
	echo test 52
        cat >$test_file <<'TEST52'
var i;
i = 0;
class c ()
{
   var i;

   class sc ()
   {
     class scc ()
     {
       println (i);
     }
     i = 30;
   }
   i = 10;
}
var ssc, ssci;
ssc = c().sc().scc;
ssci = ssc ();
TEST52
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT52' && $CMP $stdout $ftemp2; then
30
OUTPUT52
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 53.
if test $result = ok -a $start_test_number -le 53; then
	echo test 53
        cat >$test_file <<'TEST53'
class c() {
  class sc() {
     class ssc() {
     }
  }
}
func f () {
  class sc () {
    func g () {}
  }
  return sc ();
}
println (c().sc().ssc);
println (f().g);
TEST53
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT53' && $CMP $ftemp $ftemp2; then
class c().sc().ssc
func f().sc().g
OUTPUT53
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 54.
if test $result = ok -a $start_test_number -le 54; then
	echo test 54
        cat >$test_file <<'TEST54'
// Recursive function to compute Fibonacci numbers
func fibonacci (n)
  {
     if (n <= 1) return 1;
     return (fibonacci(n-1) + fibonacci(n-2));
  }

var i, fibnum;

fibnum = 0;
for (i = 0; i <= 24; i++) 
  {
    fibnum = fibonacci(i);
    putln (i @ " " @ fibnum); 
  }
TEST54
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT54' && $CMP $stdout $ftemp2; then
0 1
1 1
2 2
3 3
4 5
5 8
6 13
7 21
8 34
9 55
10 89
11 144
12 233
13 377
14 610
15 987
16 1597
17 2584
18 4181
19 6765
20 10946
21 17711
22 28657
23 46368
24 75025
OUTPUT54
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 55.
if test $result = ok -a $start_test_number -le 55; then
	echo test 55
        cat >$test_file <<'TEST55'
ext f {putln ("hello, world # 1");}
func f () {putln ("hello, world # 0");}
ext f {putln ("hello, world # 2");}
ext f {putln ("hello, world # 3");}
f();
TEST55
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT55' && $CMP $stdout $ftemp2; then
hello, world # 0
hello, world # 1
hello, world # 2
hello, world # 3
OUTPUT55
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 56.
if test $result = ok -a $start_test_number -le 56; then
	echo test 56
        cat >$test_file <<'TEST56'
class c (p)
{
  var i;
  i = 10;
}

ext c {
  func f () {println (i);println (p);}
}

c (20).f();
TEST56
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT56' && $CMP $stdout $ftemp2; then
10
20
OUTPUT56
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 57.
if test $result = ok -a $start_test_number -le 57; then
	echo test 57
        cat >$test_file <<'TEST57'
class c (p)
{
  var i;
  i = 10;
  func f () {}
}

ext c {
  ext f {println (i);println (p);}
}

c (20).f();
TEST57
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT57' && $CMP $stdout $ftemp2; then
10
20
OUTPUT57
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 58.
if test $result = ok -a $start_test_number -le 58; then
	echo test 58
        cat >$test_file <<'TEST58'
class p (p)
{
  var i;
  i = 10;
  func f () {}
}

ext p {
  class c (p) {
   func f () {println (i);println (p);}
  } 
}

p(20).c(30).f();
TEST58
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT58' && $CMP $stdout $ftemp2; then
10
30
OUTPUT58
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 59.
if test $result = ok -a $start_test_number -le 59; then
	echo test 59
        cat >$test_file <<'TEST59'
var ff;
{
  var i;
  i = 10;
  func f () {return i;}
  ff = f;
}
println (ff ());
TEST59
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT59' && $CMP $stdout $ftemp2; then
10
OUTPUT59
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 60.
if test $result = ok -a $start_test_number -le 60; then
	echo test 60
        cat >$test_file <<'TEST60'
println (type (nil));
println (type ('a'));
println (type (10));
println (type (10.0));
println (type ([]));
println (type ({}));
func f ()
{
}
println (type (f));
var flag;
thread t ()
{
  wait (flag != nil);
}
println (type (t));
class c ()
{
}
println (type (c));
var i;
i = c ();
println (type (i));
println (type (t ()));
try {wait (1) flag = 1;}
println (type (context (i)));
println (type (type (1)));
TEST60
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT60' && $CMP $stdout $ftemp2; then
type (nil)
char
int
float
vector
table
func
thread
class
class ()
thread ()
func ()
type
OUTPUT60
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 61.
if test $result = ok -a $start_test_number -le 61; then
	echo test 61
        cat >$test_file <<'TEST61'
class c () {
};

var i;
i = c ();
println (class (i));
println (class (10));
TEST61
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT61' && $CMP $stdout $ftemp2; then
class c
nil
OUTPUT61
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 62.
if test $result = ok -a $start_test_number -le 62; then
	echo test 62
        cat >$test_file <<'TEST62'
var f;
thread t () {
  wait (f != nil);
}
var p;
p = t ();
println (thread (p));
println (thread (1));
println (thread (main_thread));
try {wait (1) f = 10;}
TEST62
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT62' && $CMP $stdout $ftemp2; then
func t
nil
nil
OUTPUT62
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 63.
if test $result = ok -a $start_test_number -le 63; then
	echo test 63
        cat >$test_file <<'TEST63'
var i;
func f () {
   class c () {
   }
   i = c ();
}

f ();
println (func (context (i)));
println (func (10));
TEST63
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT63' && $CMP $stdout $ftemp2; then
func f
nil
OUTPUT63
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 64.
if test $result = ok -a $start_test_number -le 64; then
	echo test 64
        cat >$test_file <<'TEST64'
println (main_thread);
TEST64
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT64' && $CMP $ftemp $ftemp2; then
main thread
OUTPUT64
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 65.
if test $result = ok -a $start_test_number -le 65; then
	echo test 65
        cat >$test_file <<'TEST65'
{
  var i;
  func f () {
     class c (){
       class c (){
       }
     }

     i = c ().c();
  }
  f ();
  println (context (i));
  println (context (context (i)));
  println (context (context (context (i))));
  println (context (context (context (context (i)))));
  println (context (context (context (context (context (i))))));
}
TEST65
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT65' && $CMP $ftemp $ftemp2; then
instance {}.f().c()
stack {}.f()
stack {}
stack 
nil
OUTPUT65
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 66.
if test $result = ok -a $start_test_number -le 66; then
	echo test 66
        cat >$test_file <<'TEST66'
var i;

{
  var l;
  public l;
  class c () {};
  i = c();
  l = 10;
}

println (context (i).l);

func f ()
{
  var l;
  public l;
  class c () {};
  i = c();
  l = 20;
}

f ();
println (context (i).l);

func fp (l)
{
  public l;
  class c () {};
  i = c();
}

fp (30);
println (context (i).l);

class c ()
{
  var l;
  class cc () {};
  i = cc();
  l = 40;
}

c ();
println (context (i).l);

class cp (l)
{
  class cc () {};
  i = cc();
}

cp (50);
println (context (i).l);

{
  var l;
  public l;
  func f () {};
  i = f;
  l = 60;
}

println (context (i).l);

{
  var l;
  public l;
  class c () {};
  i = c;
  l = 70;
}

println (context (i).l);

{
  var l;
  public l;
  thread t () { wait (l);};
  i = t ();
  try {wait (1) l = 0;}
}

println (context (i).l);
context (i).l = 1;
TEST66
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT66' && $CMP $ftemp $ftemp2; then
10
20
30
40
50
60
70
0
OUTPUT66
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 67.
if test $result = ok -a $start_test_number -le 67; then
	echo test 67
        cat >$test_file <<'TEST67'
var ci;
{
  public i;
  var i;
  class c () {
  }
  ci = c ();
  i = 0;
}

println (context(ci).i);
context(ci).i = 1;
println (context(ci).i);
TEST67
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT67' && $CMP $stdout $ftemp2; then
0
1
OUTPUT67
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 68.
if test $result = ok -a $start_test_number -le 68; then
	echo test 68
        cat >$test_file <<'TEST68'
var i = 10, j = i, k;
i = 0;
k = 5;
putln (i, " ", j, " ", k);
TEST68
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT68' && $CMP $stdout $ftemp2; then
0 10 5
OUTPUT68
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 69.
if test $result = ok -a $start_test_number -le 69; then
	echo test 69
        cat >$test_file <<'TEST69'
func e () {putln ("e");return 100;}
func f (p = e (), i) {
  putln (p, " ", i);
}

var i;
for (i = 0; i < 10; i++) {
  f (i, 20);
  f (nil, 20);
}
TEST69
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT69' && $CMP $stdout $ftemp2; then
0 20
e
100 20
1 20
e
100 20
2 20
e
100 20
3 20
e
100 20
4 20
e
100 20
5 20
e
100 20
6 20
e
100 20
7 20
e
100 20
8 20
e
100 20
9 20
e
100 20
OUTPUT69
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 70.
if test $result = ok -a $start_test_number -le 70; then
	echo test 70
        cat >$test_file <<'TEST70'
func e () {putln ("e");return 100;}
class c (p = e (), i) {
  putln (p, " ", i);
}

var i;
for (i = 0; i < 10; i++) {
  c (i, 20);
  c (nil, 20);
}
TEST70
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT70' && $CMP $stdout $ftemp2; then
0 20
e
100 20
1 20
e
100 20
2 20
e
100 20
3 20
e
100 20
4 20
e
100 20
5 20
e
100 20
6 20
e
100 20
7 20
e
100 20
8 20
e
100 20
9 20
e
100 20
OUTPUT70
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 71.
if test $result = ok -a $start_test_number -le 71; then
	echo test 71
        cat >$test_file <<'TEST71'
var fp, c;
{
  class cc () {
    class c1 () {
    }
    func f () {
    }
    {
      func f () {}
      fp = f;
    }
  }
  c = cc;
}
println (inside (c(), c, 1));
println (inside (c().c1, c, 1));
println (inside (c().c1(), c, 1));
println (inside (c().f, c, 1));
println (inside (fp, c, 1));
println (inside (context (fp), c, 1));
println (inside (c().c1 (), c().c1, 1));
println (inside (fp, c().c1, 1));
println (inside (c(), c().c1, 1));
println (inside (c().c1, c().c1, 1));
//
putln ();
println (inside (c(), c, "1"));
println (inside (c().c1, c, '1'));
println (inside (c().c1(), c, "1.0"));
println (inside (c().f, c, 1.0));
println (inside (fp, c, "1"));
println (inside (context (fp), c, "1"));
println (inside (c().c1 (), c().c1, "1"));
println (inside (fp, c().c1, "1"));
println (inside (c(), c().c1, "1"));
println (inside (c().c1, c().c1, "1"));
//
putln ();
println (inside (c(), c, 0));
println (inside (c().c1, c, 0));
println (inside (c().c1(), c, 0));
println (inside (c().f, c, 0));
println (inside (fp, c, 0));
println (inside (context (fp), c, 0));
println (inside (c().c1 (), c().c1, 0));
println (inside (fp, c().c1, 0));
println (inside (c(), c().c1, 0));
println (inside (c().c1, c().c1, 0));
//
putln ();
println (inside (c(), c, "0"));
println (inside (c().c1, c, '0'));
println (inside (c().c1(), c, 0.5));
println (inside (c().f, c, "0"));
println (inside (fp, c, "0"));
println (inside (context (fp), c, "0"));
println (inside (c().c1 (), c().c1, "0"));
println (inside (fp, c().c1, "0"));
println (inside (c(), c().c1, "0"));
println (inside (c().c1, c().c1, "0"));
//
putln ();
println (inside (c(), c));
println (inside (c().c1, c));
println (inside (c().c1(), c));
println (inside (c().f, c));
println (inside (fp, c));
println (inside (context (fp), c));
println (inside (c().c1 (), c().c1));
println (inside (fp, c().c1));
println (inside (c(), c().c1));
println (inside (c().c1, c().c1));
TEST71
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT71' && $CMP $stdout $ftemp2; then
1
1
1
1
1
1
0
0
0
0

1
1
1
1
1
1
0
0
0
0

1
1
1
1
1
1
1
0
0
1

1
1
1
1
1
1
1
0
0
1

1
1
1
1
1
1
1
0
0
1
OUTPUT71
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 72.
if test $result = ok -a $start_test_number -le 72; then
	echo test 72
        cat >$test_file <<'TEST72'
println (match ("aaa", "baaab"));
println (match ("(a)(a)(a)", "baaab"));
println (match ("aba", "baaab"));                 // no matching
println (match ("ab.", "baaab\n"));               // matching with NL
println (match ("[:alpha:]", "p"));
println (match ("^.aa", "baaab"));
println (match ("1", 10));
println (match ("1", 0));
println (match ("1", '1'));
println (match ("()aaa", "baaab"));
TEST72
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT72' && $CMP $stdout $ftemp2; then
[1, 4]
[1, 4, 1, 2, 2, 3, 3, 4]
nil
[3, 6]
[0, 1]
[0, 3]
[0, 1]
nil
[0, 1]
[1, 4, 1, 1]
OUTPUT72
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 73.
if test $result = ok -a $start_test_number -le 73; then
	echo test 73
        cat >$test_file <<'TEST73'
println (split ("aaa bbb ccc	ddd"));
println (split ("aaa bbb ccc	ddd", split_regex));
println (split ("aaa   bbb   ccc	  ddd"));
println (split ("  aaa   bbb   ccc	  ddd  "));
println (split ("abcdef", ""));
println (split ("  aaa   bbb   ccc ddd  ", " "));
println (split ("aaabbbcccddd"));
println (split (""));
println (split ("", ""));
println (split (10));
println (split ('c'));
println (split (10.0));
TEST73
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT73' && $CMP $stdout $ftemp2; then
["aaa", "bbb", "ccc", "ddd"]
["aaa", "bbb", "ccc", "ddd"]
["aaa", "bbb", "ccc", "ddd"]
["aaa", "bbb", "ccc", "ddd"]
["a", "b", "c", "d", "e", "f"]
["aaa", "bbb", "ccc", "ddd"]
["aaabbbcccddd"]
[""]
[""]
["10"]
["c"]
["10"]
OUTPUT73
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 74.
if test $result = ok -a $start_test_number -le 74; then
	echo test 74
        cat >$test_file <<'TEST74'
putln (sub ("aa", "abaabbaaaa", "11"));
putln (gsub ("aa", "abaabbaaaa", "11"), "\n");

putln (sub ("aa", "abaabbaaaa", "d&d"));
putln (gsub ("aa", "abaabbaaaa", "d&d"), "\n");

putln (sub ("(a)a", "abaabbaaaa", "d\\1d"));
putln (gsub ("(a)a", "abaabbaaaa", "d\\1d"), "\n");

putln (sub ("aa", "abaabbaaaa", "d\\2d"));
putln (gsub ("aa", "abaabbaaaa", "d\\2d"), "\n");

putln (sub ("aa", "abaabbaaaa", "d\\&d"));
putln (gsub ("aa", "abaabbaaaa", "d\\&d"), "\n");

putln (sub ("aa", "abaabbaaaa", "d\\\\d"));
putln (gsub ("aa", "abaabbaaaa", "d\\\\d"), "\n");

putln (sub ("", "abc", "d"));
putln (gsub ("", "abc", "d"), "\n");

putln (sub ("", "", "d"));
putln (gsub ("", "", "d"), "\n");

putln (sub ("a", "a", 10));
putln (sub ("a", "a", 'c'));
putln (sub ("a", "a", 10.0));
putln (sub ("8", 8, 10));
TEST74
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT74' && $CMP $stdout $ftemp2; then
ab11bbaaaa
ab11bb1111

abdaadbbaaaa
abdaadbbdaaddaad

abdadbbaaaa
abdadbbdaddad

abddbbaaaa
abddbbdddd

abd&dbbaaaa
abd&dbbd&dd&d

abd\dbbaaaa
abd\dbbd\dd\d

dabc
dadbdc

d
d

10
c
10
10
OUTPUT74
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 75.
if test $result = ok -a $start_test_number -le 75; then
	echo test 75
        cat >$test_file <<TEST75
println (sort (readdir ("__tempdir"), cmpv));

try {
println (readdir ("abracadabra"));
} catch (syserrors.enoent) {
  putln ("abracadabra: no such directory");
}

try {
println (readdir (1000022));
} catch (syserrors.enoent) {
  putln ("1000022: no such directory");
}
TEST75
        rm -rf $tempdir
        mkdir $tempdir
        echo > $tempdir/a
        echo > $tempdir/b
        echo > $tempdir/c
        echo > $tempdir/d
        echo > $tempdir/e
        echo > $tempdir/f
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT75' && $CMP $stdout $ftemp2; then
[".", "..", "a", "b", "c", "d", "e", "f"]
abracadabra: no such directory
1000022: no such directory
OUTPUT75
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 76.
if test $result = ok -a $start_test_number -le 76; then
	echo test 76
        cat >$test_file <<'TEST76'
var i = 0;
i[10]=0;
TEST76
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT76' && $CMP $stderr $ftemp2; then
test.d:2:2: run time error - index operation for non array
OUTPUT76
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 77.
if test $result = ok -a $start_test_number -le 77; then
	echo test 77
        cat >$test_file <<'TEST77'
try {
  var i = 0;
  i[10]=0;
} catch (except().error) {
  putln ("got it: ", e.msg);
}
TEST77
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT77' && $CMP $stdout $ftemp2; then
got it: run time error - index operation for non array
OUTPUT77
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 78.
if test $result = ok -a $start_test_number -le 78; then
	echo test 78
	cat >$test_file <<'TEST78'
var i = 0 / 0;
TEST78
	echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
	    if test `uname` = AIX && $CMP - $stderr <<'OUTPUT78'; then
OUTPUT78
		    result=ok
	    elif uname -a|fgrep Linux|fgrep ppc && $CMP - $stderr <<'OUTPUT78a'; then
OUTPUT78a
		    result=ok
	    elif uname -a|fgrep Linux|fgrep ia64 && $CMP - $stderr <<'OUTPUT78b'; then
OUTPUT78b
		    result=ok
	    else
		    result=fail
	    fi
	else
	    echo '      ' $CMP - $stderr
	    if cat >$ftemp2 <<'OUTPUT78-1' && $CMP $stderr $ftemp2; then
test.d:1:12: floating point exception
OUTPUT78-1
		    result=ok
	    else
                    result=fail
	    fi
        fi
fi

# Test 79.
if test $result = ok -a $start_test_number -le 79; then
	echo test 79
        if uname | fgrep CYGWIN; then
	    echo skip the test
	    result=ok
        else
	    cat >$test_file <<'TEST79'
for (var i = 0; i < 10; i++)
try {
  var i = 0 / 0;
} catch (except ().error) {
  putln ("got it: ", e.msg);
}
TEST79
	    echo '      ' $DINO $test_file "2>$stderr"
	    if $DINO $test_file 2>$stderr >$stdout; then
		    echo '      ' $CMP $stdout $ftemp2
		    if cat >$ftemp2 <<'OUTPUT79' && $CMP $stdout $ftemp2; then
OUTPUT79
			result=ok
		    elif cat >$ftemp2 <<'OUTPUT79-1' && $CMP $stdout $ftemp2; then
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
OUTPUT79-1
			    result=ok
		    else
			    result=fail
		    fi
	    else
		    result=fail
	    fi
        fi
fi

# Test 80.
if test $result = ok -a $start_test_number -le 80; then
	echo test 80
	cat >$test_file <<'TEST80'
try {
} catch (except) {var e;
}
TEST80
	echo '      ' $DINO $test_file "2>$stderr"
	if $DINO $test_file 2>$stderr >$stdout; then
	    result=fail
	else
	    echo '      ' $CMP - $stderr
	    if cat >$ftemp2 <<'OUTPUT80' && $CMP $stderr $ftemp2; then
test.d:2:22: repeated declaration for identifier `e'
test.d:2:16: (previous declaration of identifier `e')
OUTPUT80
		    result=ok
	    else
		    result=fail
	    fi
        fi
fi

# Test 81.
if test $result = ok -a $start_test_number -le 81; then
	echo test 81
        if uname | fgrep CYGWIN; then
	    echo skip the test
	    result=ok
        else
	    cat >$test_file <<'TEST81'
for (var i = 0; i < 10; i++)
try {
  var i = 0 / 0;
} catch (signals.sigfpe) {
  putln ("got it: ", e.msg);
}
TEST81
	    echo '      ' $DINO $test_file "2>$stderr"
	    if $DINO $test_file 2>$stderr >$stdout; then
		    echo '      ' $CMP $stdout $ftemp2
		    if cat >$ftemp2 <<'OUTPUT81' && $CMP $stdout $ftemp2; then
OUTPUT81
			result=ok
		    elif cat >$ftemp2 <<'OUTPUT81-1' && $CMP $stdout $ftemp2; then
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
got it: floating point exception
OUTPUT81-1
			    result=ok
		    else
			    result=fail
		    fi
	    else
		    result=fail
	    fi
        fi
fi

# Test 82.
if test $result = ok -a $start_test_number -le 82; then
	echo test 82
        cat >$test_file <<'TEST82'
match ("[a", "");
TEST82
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT82' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - unmatched bracket list operators in regexp
OUTPUT82
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 83.
if test $result = ok -a $start_test_number -le 83; then
	echo test 83
        cat >$test_file <<'TEST83'
match ("[z-a]", "");
TEST83
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT83' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid use of the range operator in regexp
OUTPUT83
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 84.
if test $result = ok -a $start_test_number -le 84; then
	echo test 84
        cat >$test_file <<'TEST84'
match ("[[:foo:]]", "");
TEST84
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT84' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - unknown character class name in regexp
OUTPUT84
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 85.
if test $result = ok -a $start_test_number -le 85; then
	echo test 85
        cat >$test_file <<'TEST85'
match ("(a", "");
TEST85
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT85' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - unmatched parenthesis group operators in regexp
OUTPUT85
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 86.
if test $result = ok -a $start_test_number -le 86; then
	echo test 86
        cat >$test_file <<'TEST86'
match ("(a)\\2", "");
TEST86
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT86' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid back reference to a subexpr. in regexp
OUTPUT86
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 87.
if test $result = ok -a $start_test_number -le 87; then
	echo test 87
        cat >$test_file <<'TEST87'
match ("a\\", "");
TEST87
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT87' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid escape sequence in regexp
OUTPUT87
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 88.
if test $result = ok -a $start_test_number -le 88; then
	echo test 88
        cat >$test_file <<'TEST88'
var final i;
i = 10;
putln(i);
TEST88
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT88' && $CMP $stderr $ftemp2; then
test.d:2:0: constant `i' in assignment statement
OUTPUT88
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 89.
if test $result = ok -a $start_test_number -le 89; then
	echo test 89
        cat >$test_file <<'TEST89'
func f (final i)
{
  i = 10;
  putln(i);
}
f (1);
TEST89
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT89' && $CMP $stderr $ftemp2; then
test.d:3:2: constant `i' in assignment statement
OUTPUT89
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 90.
if test $result = ok -a $start_test_number -le 90; then
	echo test 90
        cat >$test_file <<'TEST90'
var final i = 10; putln(i);
func f (final i = 10)
{
  putln(i);
}
f (1);
f ();
class c (final i = 100)
{
  putln(i);
}
c (1);
c ();
TEST90
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT90' && $CMP $stdout $ftemp2; then
10
1
10
1
100
OUTPUT90
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 91.
if test $result = ok -a $start_test_number -le 91; then
	echo test 91
        cat >$test_file <<'TEST91'
final func f () {putln ("hello, world # 0");}
f();
TEST91
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT91' && $CMP $stdout $ftemp2; then
hello, world # 0
OUTPUT91
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 92.
if test $result = ok -a $start_test_number -le 92; then
	echo test 92
        cat >$test_file <<'TEST92'
final class c (p)
{
  var i;
  i = 10;
  putln (i);
}

c (20);
TEST92
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT92' && $CMP $stdout $ftemp2; then
10
OUTPUT92
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 93.
if test $result = ok -a $start_test_number -le 93; then
	echo test 93
        cat >$test_file <<'TEST93'
class c (p)
{
  var i;
  i = 10;
  final func f () {}
}

ext c {
  putln (i);putln (p);
}

c (20);
TEST93
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT93' && $CMP $stdout $ftemp2; then
10
20
OUTPUT93
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 94.
if test $result = ok -a $start_test_number -le 94; then
	echo test 94
        cat >$test_file <<'TEST94'
final func f () {putln ("hello, world # 0");}
ext f {putln ("hello, world # 1");}
TEST94
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT94' && $CMP $stderr $ftemp2; then
test.d:2:4: extension of final func/class `f'
OUTPUT94
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 95.
if test $result = ok -a $start_test_number -le 95; then
	echo test 95
        cat >$test_file <<'TEST95'
ext f {putln ("hello, world # 1");}
final func f () {putln ("hello, world # 0");}
TEST95
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT95' && $CMP $stderr $ftemp2; then
test.d:1:5: extension of final func/class `f'
OUTPUT95
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 96.
if test $result = ok -a $start_test_number -le 96; then
	echo test 96
        cat >$test_file <<'TEST96'
final class c (p)
{
  var i;
  i = 10;
}

ext c {
  func f () {putln (i);putln (p);}
}

c (20).f();
TEST96
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT96' && $CMP $stderr $ftemp2; then
test.d:7:4: extension of final func/class `c'
OUTPUT96
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 97.
if test $result = ok -a $start_test_number -le 97; then
	echo test 97
        cat >$test_file <<'TEST97'
ext c {
  func f () {putln (i);putln (p);}
}

final class c (p)
{
  var i;
  i = 10;
}

c (20).f();
TEST97
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT97' && $CMP $stderr $ftemp2; then
test.d:1:5: extension of final func/class `c'
OUTPUT97
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 98.
if test $result = ok -a $start_test_number -le 98; then
	echo test 98
        cat >$test_file <<'TEST98'
class c (p)
{
  var i;
  i = 10;
  final func f () {}
}

ext c {
  ext f {putln (i);putln (p);}
}

c (20).f();
TEST98
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT98' && $CMP $stderr $ftemp2; then
test.d:9:6: extension of final func/class `f'
OUTPUT98
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 99.
if test $result = ok -a $start_test_number -le 99; then
	echo test 99
        cat >$test_file <<'TEST99'
seek (stdout, 10, 10);
TEST99
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT99' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `seek'
OUTPUT99
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 100.
if test $result = ok -a $start_test_number -le 100; then
	echo test 100
        if uname | fgrep Linux || uname | fgrep linux; then
	    cat >$test_file <<'TEST100'
seek (stdout, 10000, 'C');
TEST100
	    echo '      ' $DINO $test_file "2>$stderr"
	    if $DINO $test_file 2>$stderr; then
		    result=fail
	    else
		    echo '      ' $CMP - $stderr
		    if cat >$ftemp2 <<'OUTPUT100' && $CMP $stderr $ftemp2; then
test.d:1:7: system error - invalid seek: `seek'
OUTPUT100
			    result=ok
		    else
			    result=fail
		    fi
	    fi
        else
	    echo skip the test
	    result=ok
        fi
fi

# Test 101.
if test $result = ok -a $start_test_number -le 101; then
	echo test 101
        if uname | fgrep Linux || uname | fgrep linux; then
	    cat >$test_file <<'TEST101'
seek (stdout, 10, "c");
TEST101
	    echo '      ' $DINO $test_file "2>$stderr"
	    if $DINO $test_file 2>$stderr; then
		    result=fail
	    else
		    echo '      ' $CMP - $stderr
		    if cat >$ftemp2 <<'OUTPUT101' && $CMP $stderr $ftemp2; then
test.d:1:7: system error - invalid seek: `seek'
OUTPUT101
			    result=ok
		    else
			    result=fail
		    fi
	    fi
        else
	    echo skip the test
	    result=ok
        fi
fi

# Test 102.
if test $result = ok -a $start_test_number -le 102; then
	echo test 102
        cat >$test_file <<'TEST102'
seek (stdout, 10, "t");
TEST102
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT102' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `seek'
OUTPUT102
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 103.
if test $result = ok -a $start_test_number -le 103; then
	echo test 103
        cat >$test_file <<'TEST103'
seek (stdout, "aaa", 's');
TEST103
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT103' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `seek'
OUTPUT103
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT103' && $CMP $stderr $ftemp2; then
test.d:1:7: system error - invalid argument: `string-to-float conversion'
OUTPUT103
                        result=ok

                else
                        result=fail
                fi
        fi
fi

# Test 104.
if test $result = ok -a $start_test_number -le 104; then
	echo test 104
        cat >$test_file <<'TEST104'
seek (10, 10, 'e');
TEST104
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT104' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `seek'
OUTPUT104
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 105.
if test $result = ok -a $start_test_number -le 105; then
	echo test 105
        cat >$test_file <<'TEST105'
var f = open ("test.d", "r");
putln (tell (f));
seek (f, 10, 's');
putln (tell (f));
seek (f, -10, 'c');
putln (tell (f));
seek (f, 0, 'e');
putln (tell (f));
TEST105
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT105'\
		   && wc -c $test_file|awk '{print $1}' >>$ftemp2\
		   && $CMP $stdout $ftemp2; then
0
10
0
OUTPUT105
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 106.
if test $result = ok -a $start_test_number -le 106; then
	echo test 106
        cat >$test_file <<'TEST106'
putln (time ());
TEST106
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^[0-9][0-9][0-9][0-9][0-9]*$' $stdout
                if egrep '^[0-9][0-9][0-9][0-9][0-9]*$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 107.
if test $result = ok -a $start_test_number -le 107; then
	echo test 107
        cat >$test_file <<'TEST107'
time (10);
TEST107
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT107' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of parameters of `time'
OUTPUT107
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 108.
if test $result = ok -a $start_test_number -le 108; then
	echo test 108
        cat >$test_file <<'TEST108'
strtime (10, nil, nil);
TEST108
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT108' && $CMP $stderr $ftemp2; then
test.d:1:10: run time error - invalid number of parameters of `strtime'
OUTPUT108
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 109.
if test $result = ok -a $start_test_number -le 109; then
	echo test 109
        cat >$test_file <<'TEST109'
strtime (nil);
TEST109
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT109' && $CMP $stderr $ftemp2; then
test.d:1:10: run time error - invalid parameter type of `strtime'
OUTPUT109
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 110.
if test $result = ok -a $start_test_number -le 110; then
	echo test 110
        cat >$test_file <<'TEST110'
strtime (10, nil);
TEST110
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT110' && $CMP $stderr $ftemp2; then
test.d:1:10: run time error - invalid parameter type of `strtime'
OUTPUT110
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 111.
if test $result = ok -a $start_test_number -le 111; then
	echo test 111
        cat >$test_file <<'TEST111'
time_format = nil;
strtime ();
TEST111
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT111' && $CMP $stderr $ftemp2; then
test.d:2:9: run time error - bad value of environment variable `time_format'
OUTPUT111
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 112.
if test $result = ok -a $start_test_number -le 112; then
	echo test 112
        cat >$test_file <<'TEST112'
put (strtime ("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa "));
put (strtime ("%Y ", time()));
put (strtime (time_format, time()));
put (strtime (" %d "));
put (strtime ());
putln (strtime (" aa"));
TEST112
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa [0-9][0-9][0-9][0-9] [A-Za-z][A-Za-z]* [A-Za-z][A-Za-z]* [0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9] [A-Z]* [0-9][0-9][0-9][0-9] [0-3][0-9] [A-Za-z][A-Za-z]* [A-Za-z][A-Za-z]* [0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9] [A-Z]* [0-9][0-9][0-9][0-9] aa$' $stdout
                if egrep '^aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa [0-9][0-9][0-9][0-9] [A-Za-z][A-Za-z]* [A-Za-z][A-Za-z]* [0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9] [A-Z]* [0-9][0-9][0-9][0-9] [0-3][0-9] [A-Za-z][A-Za-z]* [A-Za-z][A-Za-z]* [0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9] [A-Z]* [0-9][0-9][0-9][0-9] aa$' $stdout; then
                        result=ok
                elif egrep '^aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa [0-9][0-9][0-9][0-9] [A-Za-z][A-Za-z]* [A-Za-z][A-Za-z]* [0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9] [A-Za-z]* [A-Za-z]* [A-Za-z]* [0-9][0-9][0-9][0-9] [0-3][0-9] [A-Za-z][A-Za-z]* [A-Za-z][A-Za-z]* [0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9] [A-Za-z]* [A-Za-z]* [A-Za-z]* [0-9][0-9][0-9][0-9] aa$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 113.
if test $result = ok -a $start_test_number -le 113; then
	echo test 113
        cat >$test_file <<'TEST113'
clock (nil);
TEST113
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT113' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of parameters of `clock'
OUTPUT113
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 114.
if test $result = ok -a $start_test_number -le 114; then
	echo test 114
        cat >$test_file <<'TEST114'
putln (clock ());
TEST114
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^[0-1]\.?[0-9]*$' $stdout
                if egrep '^[0-1]\.?[0-9]*$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 115.
if test $result = ok -a $start_test_number -le 115; then
	echo test 115
        cat >$test_file <<'TEST115'
split_regex = nil;
println (split ("aaa bbb ccc	ddd"));
TEST115
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT115' && $CMP $stderr $ftemp2; then
test.d:2:16: run time error - bad value of environment variable `split_regex'
OUTPUT115
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 116.
if test $result = ok -a $start_test_number -le 116; then
	echo test 116
        cat >$test_file <<'TEST116'
throw except ();
TEST116
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT116' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - exception except has not been processed
OUTPUT116
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 117.
if test $result = ok -a $start_test_number -le 117; then
	echo test 117
        cat >$test_file <<'TEST117'
throw except (). error ("Error111");
TEST117
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT117' && $CMP $stderr $ftemp2; then
test.d:1:6: Error111
OUTPUT117
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 118.
if test $result = ok -a $start_test_number -le 118; then
	echo test 118
        cat >$test_file <<'TEST118'
for (var i = 0; i < 50;i++)
{
  try {
    putln ("in try");
    throw except ();
    putln ("after throw");
  } catch (except) {
    putln ("in catch");
  } 
  putln ("finish");
}
TEST118
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT118' && $CMP $stdout $ftemp2; then
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
in try
in catch
finish
OUTPUT118
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 119.
if test $result = ok -a $start_test_number -le 119; then
	echo test 119
        cat >$test_file <<'TEST119'
try {
  put ("Good");
} catch (except) {
}
putln (" and good");
TEST119
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT119' && $CMP $stdout $ftemp2; then
Good and good
OUTPUT119
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 120.
if test $result = ok -a $start_test_number -le 120; then
	echo test 120
        cat >$test_file <<'TEST120'
var f = open ("test.d", "r"), f1;
f1 = f;
println (f == f1);
println (type (f));
println (type (hide));
println (hide);
println (type (hideblock));
println (hideblock);
TEST120
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT120' && $CMP $stdout $ftemp2; then
1
class ()
type
hide
type
hideblock
OUTPUT120
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 121.
if test $result = ok -a $start_test_number -le 121; then
	echo test 121
        cat >$test_file <<'TEST121'
var v = [4, 2, 1, 3]; println (sort (v)); println (v);
v = [4.0, 2.0, 1.0, 3.0]; println (sort (v)); println (v);
v = ['4', '2', '1', '3']; println (sort (v)); println (v);
v = "5132"; println (sort (v)); println (v);

func c(i,j) {
  if (i < j)
    return -1;
  else if (i == j)
    return 0;
  else
    return 1;
}
v = [4, 2, 1, 3.5];
println (sort (v, c)); println (v);
TEST121
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT121' && $CMP $stdout $ftemp2; then
[1, 2, 3, 4]
[4, 2, 1, 3]
[1, 2, 3, 4]
[4, 2, 1, 3]
"1234"
"4213"
"1235"
"5132"
[1, 2, 3.5, 4]
[4, 2, 1, 3.5]
OUTPUT121
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 122.
if test $result = ok -a $start_test_number -le 122; then
	echo test 122
        cat >$test_file <<'TEST122'
var v = "5132"; println (sort ());
TEST122
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT122' && $CMP $stderr $ftemp2; then
test.d:1:32: run time error - invalid number of parameters of `sort'
OUTPUT122
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 123.
if test $result = ok -a $start_test_number -le 123; then
	echo test 123
        cat >$test_file <<'TEST123'
var v = "5132"; println (sort (nil, nil, nil));
TEST123
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT123' && $CMP $stderr $ftemp2; then
test.d:1:32: run time error - invalid number of parameters of `sort'
OUTPUT123
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 124.
if test $result = ok -a $start_test_number -le 124; then
	echo test 124
        cat >$test_file <<'TEST124'
println (sort (nil));
TEST124
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT124' && $CMP $stderr $ftemp2; then
test.d:1:16: run time error - invalid parameter type of `sort'
OUTPUT124
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 125.
if test $result = ok -a $start_test_number -le 125; then
	echo test 125
        cat >$test_file <<'TEST125'
var v = [4.0, 2.0, 1.0, 3]; println (sort (v));
TEST125
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT125' && $CMP $stderr $ftemp2; then
test.d:1:44: run time error - invalid parameter type of `sort'
OUTPUT125
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 126.
if test $result = ok -a $start_test_number -le 126; then
	echo test 126
        cat >$test_file <<'TEST126'
var v = [nil, nil]; println (sort (v));
TEST126
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT126' && $CMP $stderr $ftemp2; then
test.d:1:36: run time error - invalid parameter type of `sort'
OUTPUT126
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 127.
if test $result = ok -a $start_test_number -le 127; then
	echo test 127
        cat >$test_file <<'TEST127'
var v = [2, 1]; println (sort (v, v));
TEST127
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT127' && $CMP $stderr $ftemp2; then
test.d:1:32: run time error - invalid parameter type of `sort'
OUTPUT127
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 128.
if test $result = ok -a $start_test_number -le 128; then
	echo test 128
        cat >$test_file <<'TEST128'
func c (i, j) {return nil;}
var v = [2, 1]; println (sort (v, c));
TEST128
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT128' && $CMP $stderr $ftemp2; then
test.d:2:31: run time error - invalid function result used by function `sort'
OUTPUT128
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 129.
if test $result = ok -a $start_test_number -le 129; then
	echo test 129
        cat >$test_file <<'TEST129'
putln (getpid (), " ", getun (), " ", geteun (), " ", getgn (), " ", getegn ());
TEST129
        echo '      ' $DINO $test_file "2>$stderr"
        if uname | fgrep CYGWIN; then
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^-?[0-9][0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]*$' $stdout
                if egrep '^-?[0-9][0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]*$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^[0-9][0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]*$' $stdout
                if egrep '^[0-9][0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]*$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	fi
fi

# Test 130.
if test $result = ok -a $start_test_number -le 130; then
	echo test 130
        cat >$test_file <<'TEST130'
getpid (1);
TEST130
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT130' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of parameters of `getpid'
OUTPUT130
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 131.
if test $result = ok -a $start_test_number -le 130; then
	echo test 131
        cat >$test_file <<'TEST131'
getppid (1);
TEST131
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT131' && $CMP $stderr $ftemp2; then
test.d:1:1: undeclared identifier `getppid'
OUTPUT131
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 132.
if test $result = ok -a $start_test_number -le 132; then
	echo test 132
        cat >$test_file <<'TEST132'
getun (1);
TEST132
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT132' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of parameters of `getun'
OUTPUT132
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 133.
if test $result = ok -a $start_test_number -le 133; then
	echo test 133
        cat >$test_file <<'TEST133'
geteun (1);
TEST133
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT133' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of parameters of `geteun'
OUTPUT133
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 134.
if test $result = ok -a $start_test_number -le 134; then
	echo test 134
        cat >$test_file <<'TEST134'
getgn (1);
TEST134
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT134' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of parameters of `getgn'
OUTPUT134
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 135.
if test $result = ok -a $start_test_number -le 135; then
	echo test 135
        cat >$test_file <<'TEST135'
getegn (1);
TEST135
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT135' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of parameters of `getegn'
OUTPUT135
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 136.
if test $result = ok -a $start_test_number -le 136; then
	echo test 136
        cat >$test_file <<'TEST136'
putln (ftype ("test.d"));
putln (ftype ("."));
putln (ftype (stdin));
putln (ftype (stdout));
TEST136
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT136' && $CMP $stdout $ftemp2; then
f
d
c
f
OUTPUT136
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 137.
if test $result = ok -a $start_test_number -le 137; then
	echo test 137
        cat >$test_file <<'TEST137'
ftype ();
TEST137
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT137' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of parameters of `ftype'
OUTPUT137
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 138.
if test $result = ok -a $start_test_number -le 138; then
	echo test 138
        cat >$test_file <<'TEST138'
ftype (nil, nil);
TEST138
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT138' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of parameters of `ftype'
OUTPUT138
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 139.
if test $result = ok -a $start_test_number -le 139; then
	echo test 139
        cat >$test_file <<'TEST139'
ftype (nil);
TEST139
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT139' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `ftype'
OUTPUT139
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 140.
if test $result = ok -a $start_test_number -le 140; then
	echo test 140
        cat >$test_file <<'TEST140'
println (getgroups ());
TEST140
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                regex="^\[(\"[a-zA-Z0-9][a-zA-Z0-9]*\"(, \"[a-zA-Z0-9][a-zA-Z0-9]*\")*)?\]$"
                echo '      ' egrep \'$regex\' $stdout
                if egrep "$regex" $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 141.
if test $result = ok -a $start_test_number -le 141; then
	echo test 141
        cat >$test_file <<'TEST141'
getgroups (nil);
TEST141
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT141' && $CMP $stderr $ftemp2; then
test.d:1:12: run time error - invalid number of parameters of `getgroups'
OUTPUT141
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 142.
if test $result = ok -a $start_test_number -le 142; then
	echo test 142
        cat >$test_file <<'TEST142'
var i, j;
for (i=0;i<10000;i++)
  {
    j=0;
  }
putln (gc());
TEST142
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^[0-9][0-9][0-9][0-9][0-9][0-9]*$' $stdout
                if egrep '^[0-9][0-9][0-9][0-9][0-9][0-9]*$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 143.
if test $result = ok -a $start_test_number -le 143; then
	echo test 143
        cat >$test_file <<'TEST143'
gc (nil);
TEST143
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT143' && $CMP $stderr $ftemp2; then
test.d:1:5: run time error - invalid number of parameters of `gc'
OUTPUT143
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 144.
if test $result = ok -a $start_test_number -le 144; then
	echo test 144
        cat >$test_file <<'TEST144'
put (fun ("test.d"));
put (" ", fgn ("test.d"));
putln (" ", fsize ("test.d"));
TEST144
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		regex="^[a-zA-Z0-9][a-zA-Z0-9]* [a-zA-Z0-9][a-zA-Z0-9]* "
		regex=$regex`wc -c $test_file|awk '{print $1}'`\$
                echo '      \'$regex\' $stdout
                if egrep "$regex" $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 145.
if test $result = ok -a $start_test_number -le 145; then
	echo test 145
        cat >$test_file <<'TEST145'
put (fatime ("test.d"));
put (" ", fmtime ("test.d"));
putln (" ", fctime ("test.d"));
TEST145
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*( [0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*)*$' $stdout
                if egrep '^[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*( [0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]*)*$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 146.
if test $result = ok -a $start_test_number -le 146; then
	echo test 146
        cat >$test_file <<'TEST146'
put (fumode ("test.d"));
put (" ", fgmode ("test.d"));
putln (" ", fomode ("test.d"));
TEST146
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' egrep '^s?r?w?x? r?w?x? r?w?x?$' $stdout
                if egrep '^s?r?w?x? r?w?x? r?w?x?$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 147.
if test $result = ok -a $start_test_number -le 147; then
	echo test 147
        cat >$test_file <<'TEST147'
fatime ();
TEST147
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT147' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of parameters of `fatime'
OUTPUT147
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 148.
if test $result = ok -a $start_test_number -le 148; then
	echo test 148
        cat >$test_file <<'TEST148'
fatime (nil);
TEST148
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT148' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `fatime'
OUTPUT148
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 149.
if test $result = ok -a $start_test_number -le 149; then
	echo test 149
        cat >$test_file <<'TEST149'
var i,t;
t = {};
for (i = 0; i < 10000; i++)
  t {i} = -i;
TEST149
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT149' && $CMP $stdout $ftemp2; then
OUTPUT149
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 150.
if test $result = ok -a $start_test_number -le 150; then
	echo test 150
        cat >$test_file <<'TEST150'
var c, i;
for (i = 0; i < 5; i++)
{
  c = get ();
  putln (c);
}
TEST150
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT150' && $CMP $stdout $ftemp2; then
a
b
c
d


OUTPUT150
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 151.
if test $result = ok -a $start_test_number -le 151; then
	echo test 151
        cat >$test_file <<'TEST151'
var c;
for (;1;)
{
  try {c = get ();} catch (invcalls.eof) {break;}
  putln (c);
}
TEST151
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT151' && $CMP $stdout $ftemp2; then
a
b
c
d


OUTPUT151
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 152.
if test $result = ok -a $start_test_number -le 152; then
	echo test 152
        cat >$test_file <<'TEST152'
var c, f = open ("test.d", "r");
for (;1;)
{
  try {c = fget (f);} catch (invcalls.eof) {break;}
  put (c);
}
TEST152
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT152' && $CMP $stdout $ftemp2; then
var c, f = open ("test.d", "r");
for (;1;)
{
  try {c = fget (f);} catch (invcalls.eof) {break;}
  put (c);
}
OUTPUT152
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 153.
if test $result = ok -a $start_test_number -le 153; then
	echo test 153
        cat >$test_file <<'TEST153'
var c;
for (;1;)
{
  c = get ();
  putln (c);
}
TEST153
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT153' && $CMP $stderr $ftemp2; then
test.d:4:11: run time error - EOF occured in `get'
OUTPUT153
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 154.
if test $result = ok -a $start_test_number -le 154; then
	echo test 154
        cat >$test_file <<'TEST154'
var c, f=open ("test.d", "r");
for (;1;)
{
  c = fget (f);
  put (c);
}
TEST154
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT154' && $CMP $stderr $ftemp2; then
test.d:4:12: run time error - EOF occured in `fget'
OUTPUT154
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 155.
if test $result = ok -a $start_test_number -le 155; then
	echo test 155
        cat >$test_file <<'TEST155'
var c = get (nil);
TEST155
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT155' && $CMP $stderr $ftemp2; then
test.d:1:14: run time error - invalid number of parameters of `get'
OUTPUT155
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 156.
if test $result = ok -a $start_test_number -le 156; then
	echo test 156
        cat >$test_file <<'TEST156'
var c = fget ();
TEST156
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT156' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid number of parameters of `fget'
OUTPUT156
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 157.
if test $result = ok -a $start_test_number -le 157; then
	echo test 157
        cat >$test_file <<'TEST157'
var c = fget (nil);
TEST157
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT157' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid parameter type of `fget'
OUTPUT157
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 158.
if test $result = ok -a $start_test_number -le 158; then
	echo test 158
        cat >$test_file <<'TEST158'
putln (getln());
TEST158
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT158' && $CMP $stdout $ftemp2; then
abcd
OUTPUT158
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 159.
if test $result = ok -a $start_test_number -le 159; then
	echo test 159
        cat >$test_file <<'TEST159'
var c, f = open ("test.d", "r");
for (;1;)
{
  try {putln (fgetln (f));} catch (invcalls.eof) {break;}
}
TEST159
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT159' && $CMP $stdout $ftemp2; then
var c, f = open ("test.d", "r");
for (;1;)
{
  try {putln (fgetln (f));} catch (invcalls.eof) {break;}
}
OUTPUT159
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 160.
if test $result = ok -a $start_test_number -le 160; then
	echo test 160
        cat >$test_file <<'TEST160'
putln (getln ());
putln (getln ());
TEST160
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT160' && $CMP $stderr $ftemp2; then
test.d:2:14: run time error - EOF occured in `getln'
OUTPUT160
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 161.
if test $result = ok -a $start_test_number -le 161; then
	echo test 161
        cat >$test_file <<'TEST161'
var c, f=open ("test.d", "r");
for (;1;)
  putln (fgetln (f));
TEST161
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT161' && $CMP $stderr $ftemp2; then
test.d:3:17: run time error - EOF occured in `fgetln'
OUTPUT161
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 162.
if test $result = ok -a $start_test_number -le 162; then
	echo test 162
        cat >$test_file <<'TEST162'
var c = getln (nil);
TEST162
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT162' && $CMP $stderr $ftemp2; then
test.d:1:16: run time error - invalid number of parameters of `getln'
OUTPUT162
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 163.
if test $result = ok -a $start_test_number -le 163; then
	echo test 163
        cat >$test_file <<'TEST163'
var c = fgetln ();
TEST163
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT163' && $CMP $stderr $ftemp2; then
test.d:1:17: run time error - invalid number of parameters of `fgetln'
OUTPUT163
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 164.
if test $result = ok -a $start_test_number -le 164; then
	echo test 164
        cat >$test_file <<'TEST164'
var c = fgetln (nil);
TEST164
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT164' && $CMP $stderr $ftemp2; then
test.d:1:17: run time error - invalid parameter type of `fgetln'
OUTPUT164
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 165.
if test $result = ok -a $start_test_number -le 165; then
	echo test 165
        cat >$test_file <<'TEST165'
putln (nil);
TEST165
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT165' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `putln'
OUTPUT165
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 166.
if test $result = ok -a $start_test_number -le 166; then
	echo test 166
        cat >$test_file <<'TEST166'
put ([10]);
TEST166
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT166' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `put'
OUTPUT166
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 167.
if test $result = ok -a $start_test_number -le 167; then
	echo test 167
        cat >$test_file <<'TEST167'
fputln (nil);
TEST167
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT167' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `fputln'
OUTPUT167
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 168.
if test $result = ok -a $start_test_number -le 168; then
	echo test 168
        cat >$test_file <<'TEST168'
fput ([10]);
TEST168
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT168' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `fput'
OUTPUT168
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 169.
if test $result = ok -a $start_test_number -le 169; then
	echo test 169
        cat >$test_file <<'TEST169'
for (;1;)
{
  try {
    println (scanln ());
  } catch (invcalls.eof) {putln ("eof"); break;}
    catch (invcalls.invinput) {putln ("catch invalid input");}
}
TEST169
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout <<'INPUT169' ; then
'c'
"aaaaa"
1000
-1000
10e+10
-10e+10
[]
[2]
[2:2]
[2:[2]]
[2,2.2, 2:[10, 'c', "aaa", 10.7]]
{}
{10, 2:"10"}
{[2,5]:{1:5, 5}, 10:[10, 'c']}
[2,3] [3,2]
[2, a
[3,3]
INPUT169
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT169' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
-1000
1e+11
-1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{}
{2:"10", 10:10}
{10:[10, 'c'], [2, 5]:{1:5, 5:5}}
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT169
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT169-2' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
-1000
1e+011
-1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{}
{2:"10", 10:10}
{10:[10, 'c'], [2, 5]:{1:5, 5:5}}
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT169-2
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT169-3' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
-1000
1e+11
-1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{}
{2:"10", 10:10}
{[2, 5]:{1:5, 5:5}, 10:[10, 'c']}
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT169-3
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT169-4' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
-1000
1e+011
-1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{}
{2:"10", 10:10}
{[2, 5]:{1:5, 5:5}, 10:[10, 'c']}
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT169-4
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 170.
if test $result = ok -a $start_test_number -le 170; then
	echo test 170
        cat >$test_file <<'TEST170'
scan (nil);
TEST170
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT170' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of parameters of `scan'
OUTPUT170
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 171.
if test $result = ok -a $start_test_number -le 171; then
	echo test 171
        cat >$test_file <<'TEST171'
scanln (nil);
TEST171
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT171' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of parameters of `scanln'
OUTPUT171
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 172.
if test $result = ok -a $start_test_number -le 172; then
	echo test 172
        cat >$test_file <<'TEST172'
fscan ();
TEST172
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT172' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of parameters of `fscan'
OUTPUT172
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 173.
if test $result = ok -a $start_test_number -le 173; then
	echo test 173
        cat >$test_file <<'TEST173'
fscanln ();
TEST173
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT173' && $CMP $stderr $ftemp2; then
test.d:1:10: run time error - invalid number of parameters of `fscanln'
OUTPUT173
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 174.
if test $result = ok -a $start_test_number -le 174; then
	echo test 174
        cat >$test_file <<'TEST174'
fscan ([10]);
TEST174
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT174' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `fscan'
OUTPUT174
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 175.
if test $result = ok -a $start_test_number -le 175; then
	echo test 175
        cat >$test_file <<'TEST175'
fscanln ([10]);
TEST175
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT175' && $CMP $stderr $ftemp2; then
test.d:1:10: run time error - invalid parameter type of `fscanln'
OUTPUT175
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 176.
if test $result = ok -a $start_test_number -le 176; then
	echo test 176
        cat >$test_file <<'TEST176'
for (;1;)
{
  try {
    println (scan ());
  } catch (invcalls.eof) {putln ("eof"); break;}
}
TEST176
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout <<'INPUT176' ; then
'c'"aaaaa"1000 10e+10[][2][2:2][2:[2]][2,2.2, 2:[10, 'c', "aaa", 10.7]]
{10, 2:"10"}{[2,5]:{1:5, 5}, 10:[10, 'c']}[2,3] [3,2] [3,3]
INPUT176
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT176' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{2:"10", 10:10}
{10:[10, 'c'], [2, 5]:{1:5, 5:5}}
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT176
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT176-2' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{2:"10", 10:10}
{10:[10, 'c'], [2, 5]:{1:5, 5:5}}
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT176-2
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT176-3' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{2:"10", 10:10}
{[2, 5]:{1:5, 5:5}, 10:[10, 'c']}
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT176-3
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT176-4' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{2:"10", 10:10}
{[2, 5]:{1:5, 5:5}, 10:[10, 'c']}
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT176-4
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 177.
if test $result = ok -a $start_test_number -le 177; then
	echo test 177
        cat >$test_file <<'TEST177'
var f = open ("_temp.out", "r");
for (;1;)
{
  try {
    println (fscanln (f));
  } catch (invcalls.eof) {putln ("eof"); break;}
    catch (invcalls.invinput) {putln ("catch invalid input");}
}
TEST177
        echo '      ' "$DINO $test_file 2>$stderr"
	cat >$ftemp  <<'INPUT177'
'c'
"aaaaa"
1000
10e+10
[]
[2]
[2:2]
[2:[2]]
[2,2.2, 2:[10, 'c', "aaa", 10.7]]
{10, 2:"10"}
{[2,5]:{1:5, 5}, 10:[10, 'c']}
[2,3] [3,2]
[2, a
[3,3]
INPUT177
        if $DINO $test_file 2>$stderr >$stdout ; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT177' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{2:"10", 10:10}
{10:[10, 'c'], [2, 5]:{1:5, 5:5}}
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT177
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT177-2' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{2:"10", 10:10}
{10:[10, 'c'], [2, 5]:{1:5, 5:5}}
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT177-2
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT177-3' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{2:"10", 10:10}
{[2, 5]:{1:5, 5:5}, 10:[10, 'c']}
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT177-3
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT177-4' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{2:"10", 10:10}
{[2, 5]:{1:5, 5:5}, 10:[10, 'c']}
[2, 3]
catch invalid input
[3, 3]
eof
OUTPUT177-4
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 178.
if test $result = ok -a $start_test_number -le 178; then
	echo test 178
        cat >$test_file <<'TEST178'
var f = open ("_temp.out", "r");
for (;1;)
{
  try {
    println (fscan (f));
  } catch (invcalls.eof) {putln ("eof"); break;}
    catch (invcalls.invinput) {putln ("catch invalid input");}
}
TEST178
        echo '      ' "$DINO $test_file 2>$stderr"
	cat >$ftemp  <<'INPUT178'
'c'"aaaaa"1000 10e+10[][2][2:2][2:[2]][2,2.2, 2:[10, 'c', "aaa", 10.7]]
{10, 2:"10"}{[2,5]:{1:5, 5}, 10:[10, 'c']}[2,3] [3,2] [3,3]
INPUT178
        if $DINO $test_file 2>$stderr >$stdout ; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT178' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{2:"10", 10:10}
{10:[10, 'c'], [2, 5]:{1:5, 5:5}}
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT178
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT178-2' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{2:"10", 10:10}
{10:[10, 'c'], [2, 5]:{1:5, 5:5}}
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT178-2
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT178-3' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+11
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{2:"10", 10:10}
{[2, 5]:{1:5, 5:5}, 10:[10, 'c']}
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT178-3
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT178-4' && $CMP $stdout $ftemp2; then
'c'
"aaaaa"
1000
1e+011
[]
[2]
[2, 2]
[[2], [2]]
[2, 2.2, [10, 'c', "aaa", 10.7], [10, 'c', "aaa", 10.7]]
{2:"10", 10:10}
{[2, 5]:{1:5, 5:5}, 10:[10, 'c']}
[2, 3]
[3, 2]
[3, 3]
eof
OUTPUT178-4
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 179.
if test $result = ok -a $start_test_number -le 179; then
	echo test 179
        cat >$test_file <<'TEST179'
println (scanln ());
TEST179
        echo '      ' "echo 1000000000000|$DINO $test_file 2>$stderr"
        if echo 1000000000000|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT179' && $CMP $stderr $ftemp2; then
test.d:1:18: system error - result too big (small): `string-to-int conversion'
OUTPUT179
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 180.
if test $result = ok -a $start_test_number -le 180; then
	echo test 180
        cat >$test_file <<'TEST180'
println (scanln ());
TEST180
        echo '      ' "echo 1000000000000e1000|$DINO $test_file 2>$stderr"
        if echo 1000000000000e1000|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT180' && $CMP $stderr $ftemp2; then
test.d:1:18: system error - result too big (small): `string-to-float conversion'
OUTPUT180
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 181.
if test $result = ok -a $start_test_number -le 181; then
	echo test 181
        cat >$test_file <<'TEST181'
println (scanln ());
TEST181
        echo '      ' "echo 1000000000000e-1000|$DINO $test_file 2>$stderr"
        if echo 1000000000000e-1000|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT181' && $CMP $stderr $ftemp2; then
test.d:1:18: system error - result too big (small): `string-to-float conversion'
OUTPUT181
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 182.
if test $result = ok -a $start_test_number -le 182; then
	echo test 182
        cat >$test_file <<'TEST182'
var i=100000000000;
TEST182
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT182' && $CMP $stderr $ftemp2; then
test.d:1:19: too big integer value
OUTPUT182
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 183.
if test $result = ok -a $start_test_number -le 183; then
	echo test 183
        cat >$test_file <<'TEST183'
var i=-100000000000;
TEST183
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT183' && $CMP $stderr $ftemp2; then
test.d:1:20: too big integer value
OUTPUT183
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 184.
if test $result = ok -a $start_test_number -le 184; then
	echo test 184
        cat >$test_file <<'TEST184'
var f=1000000000000e1000;
TEST184
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT184' && $CMP $stderr $ftemp2; then
test.d:1:25: too big or too small floating point value
OUTPUT184
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 185.
if test $result = ok -a $start_test_number -le 185; then
	echo test 185
        cat >$test_file <<'TEST185'
var f=1000000000000e-1000;
TEST185
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT185' && $CMP $stderr $ftemp2; then
test.d:1:26: too big or too small floating point value
OUTPUT185
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 186.
if test $result = ok -a $start_test_number -le 186; then
	echo test 186
        cat >$test_file <<'TEST186'
var f=-1000000000000e1000;
TEST186
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT186' && $CMP $stderr $ftemp2; then
test.d:1:26: too big or too small floating point value
OUTPUT186
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 187.
if test $result = ok -a $start_test_number -le 187; then
	echo test 187
        cat >$test_file <<'TEST187'
var i="1000000000000" + 0;
TEST187
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT187' && $CMP $stderr $ftemp2; then
test.d:1:24: system error - result too big (small): `string-to-int conversion'
OUTPUT187
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 188.
if test $result = ok -a $start_test_number -le 188; then
	echo test 188
        cat >$test_file <<'TEST188'
var f="1000000000000e1000" + 0.0;
TEST188
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT188' && $CMP $stderr $ftemp2; then
test.d:1:29: system error - result too big (small): `string-to-float conversion'
OUTPUT188
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 189.
if test $result = ok -a $start_test_number -le 189; then
	echo test 189
        cat >$test_file <<'TEST189'
thread t1() {
  put ("thread 1: ");print (curr_thread); put (" "); println (main_thread);
}

thread t2() {
  put ("thread 2: ");print (curr_thread); put (" "); println (main_thread);
}

put ("thread 2: ");print (curr_thread); put (" "); println (main_thread);

t1 ();
t2 ();
TEST189
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT189' && $CMP $ftemp $ftemp2; then
thread 2: main thread main thread
thread 1: thread 1 t1() main thread
thread 2: thread 2 t2() main thread
OUTPUT189
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 190.
if test $result = ok -a $start_test_number -le 190; then
	echo test 190
        cat >$test_file <<'TEST190'
var i;
for(i=0;;i++) {
  if (i == 10)
    break;
  putln (i);
}
TEST190
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout ; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT190' && $CMP $stdout $ftemp2; then
0
1
2
3
4
5
6
7
8
9
OUTPUT190
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 191.
if test $result = ok -a $start_test_number -le 191; then
	echo test 191
        cat >$test_file <<'TEST191'
var f = open ("1000000000000e1000", "r");
TEST191
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT191' && $CMP $stderr $ftemp2; then
test.d:1:15: system error - no such file or directory: `open'
OUTPUT191
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 192.
if test $result = ok -a $start_test_number -le 192; then
	echo test 192
        cat >$test_file <<'TEST192'
var f;
try {
 f = open ("1000000000000e1000", "r");
} catch (errors.invcall) {}
close (f);
TEST192
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT192' && $CMP $stderr $ftemp2; then
test.d:5:7: run time error - invalid parameter type of `close'
OUTPUT192
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 193.
if test $result = ok -a $start_test_number -le 193; then
	echo test 193
        cat >$test_file <<'TEST193'
var f = open ("1000000000000e1000");
TEST193
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT193' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid number of parameters of `open'
OUTPUT193
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 194.
if test $result = ok -a $start_test_number -le 194; then
	echo test 194
        cat >$test_file <<'TEST194'
var f = open ("1000000000000e1000", "k");
TEST194
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT194' && $CMP $stderr $ftemp2; then
test.d:1:15: system error - invalid argument: `open'
OUTPUT194
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 195.
if test $result = ok -a $start_test_number -le 195; then
	echo test 195
        cat >$test_file <<'TEST195'
var f = open ("1000000000000e1000", nil);
TEST195
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT195' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid parameter type of `open'
OUTPUT195
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 196.
if test $result = ok -a $start_test_number -le 196; then
	echo test 196
        cat >$test_file <<'TEST196'
close ();
TEST196
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT196' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of parameters of `close'
OUTPUT196
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 197.
if test $result = ok -a $start_test_number -le 197; then
	echo test 197
        cat >$test_file <<'TEST197'
close (nil);
TEST197
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT197' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `close'
OUTPUT197
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 198.
if test $result = ok -a $start_test_number -le 198; then
	echo test 198
        cat >$test_file <<'TEST198'
flush ();
TEST198
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT198' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of parameters of `flush'
OUTPUT198
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 199.
if test $result = ok -a $start_test_number -le 199; then
	echo test 199
        cat >$test_file <<'TEST199'
flush (nil);
TEST199
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT199' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `flush'
OUTPUT199
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 200.
if test $result = ok -a $start_test_number -le 200; then
	echo test 200
        cat >$test_file <<'TEST200'
put ("aaaaaa");
fputln (stderr, "end of output");
flush (stdout);
fputln (stderr, "end of output");
TEST200
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT200' && $CMP $stdout $ftemp2; then
end of output
aaaaaaend of output
OUTPUT200
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT200-2' && $CMP $stdout $ftemp2; then
aaaaaaend of output
end of output
OUTPUT200-2
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 201.
if test $result = ok -a $start_test_number -le 201; then
	echo test 201
        cat >$test_file <<'TEST201'
var f = popen ("1000000000000e1000");
TEST201
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT201' && $CMP $stderr $ftemp2; then
test.d:1:16: run time error - invalid number of parameters of `popen'
OUTPUT201
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 202.
if test $result = ok -a $start_test_number -le 202; then
	echo test 202
        cat >$test_file <<'TEST202'
var f=popen("cat test.d", "r"), l;
for (;;)
{
  try {l = fgetln (f);} catch (invcalls.eof) {break;}
  putln (l);
}
pclose (f);
TEST202
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT202' && $CMP $stdout $ftemp2; then
var f=popen("cat test.d", "r"), l;
for (;;)
{
  try {l = fgetln (f);} catch (invcalls.eof) {break;}
  putln (l);
}
pclose (f);
OUTPUT202
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 203.
if test $result = ok -a $start_test_number -le 203; then
	echo test 203
        cat >$test_file <<'TEST203'
var f=popen("cat >_temp.out", "w"), l;
fputln (f, "tests ");
fputln (f, "tests #1");
pclose (f);
TEST203
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT203' && $CMP $ftemp $ftemp2; then
tests 
tests #1
OUTPUT203
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 204.
if test $result = ok -a $start_test_number -le 204; then
	echo test 204
        cat >$test_file <<'TEST204'
var f = popen ("cat test.d", "rw");
TEST204
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT204' && $CMP $stderr $ftemp2; then
test.d:1:16: system error - invalid argument: `popen'
OUTPUT204
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 205.
if test $result = ok -a $start_test_number -le 205; then
	echo test 205
        cat >$test_file <<'TEST205'
var f = popen ("1000000000000e1000", nil);
TEST205
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT205' && $CMP $stderr $ftemp2; then
test.d:1:16: run time error - invalid parameter type of `popen'
OUTPUT205
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 206.
if test $result = ok -a $start_test_number -le 206; then
	echo test 206
        cat >$test_file <<'TEST206'
pclose ();
TEST206
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT206' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of parameters of `pclose'
OUTPUT206
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 207.
if test $result = ok -a $start_test_number -le 207; then
	echo test 207
        cat >$test_file <<'TEST207'
pclose (nil);
TEST207
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT207' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `pclose'
OUTPUT207
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 208.
if test $result = ok -a $start_test_number -le 208; then
	echo test 208
        cat >$test_file <<'TEST208'
println (eltype ([1,2,3]));
println (eltype ([1.0,2,'c']));
println (eltype ([]));
TEST208
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT208' && $CMP $stdout $ftemp2; then
int
nil
type (nil)
OUTPUT208
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 209.
if test $result = ok -a $start_test_number -le 209; then
	echo test 209
        cat >$test_file <<'TEST209'
eltype ();
TEST209
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT209' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of parameters of `eltype'
OUTPUT209
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 210.
if test $result = ok -a $start_test_number -le 210; then
	echo test 210
        cat >$test_file <<'TEST210'
eltype (1);
TEST210
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT210' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `eltype'
OUTPUT210
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 211.
if false; then
# Removed deprecated operations.
	echo test 211
        cat >$test_file <<'TEST211'
class c() {
var i = 10;
}
var i=c();
putln (("i")->i);
("i")->i = 20;
putln (("i")->i);
("i")->i = 30;
putln (("i")->i);
("i")->i = 40;
putln (("i")->i);
("i")->i = 50;
putln (("i")->i);
TEST211
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT211' && $CMP $stdout $ftemp2; then
10
20
30
40
50
OUTPUT211
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 212.
if false; then
# Removed deprecated operations.
	echo test 212
        cat >$test_file <<'TEST212'
class c() {
var i = 10;
}
var i=c();
putln ((10)->i);
TEST212
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT212' && $CMP $stderr $ftemp2; then
test.d:5:13: left operand of arrow must be of string type
OUTPUT212
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 213.
if false; then
# Removed deprecated operations.
	echo test 213
        cat >$test_file <<'TEST213'
class c() {
var i = 10;
}
var i=c();
var j=[];
putln ((j)->i);
TEST213
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT213' && $CMP $stderr $ftemp2; then
test.d:6:12: run time error - decl name is not string (operation "->" or "*")
OUTPUT213
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 214.
if false; then
# Removed deprecated operations.
	echo test 214
        cat >$test_file <<'TEST214'
class c() {
var i = 10;
}
var i=c();
var j=10;
putln (("i")->k);
TEST214
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT214' && $CMP $stderr $ftemp2; then
test.d:6:14: there is no such declaration in a block
OUTPUT214
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 215.
if false; then
# Removed deprecated operations.
	echo test 215
        cat >$test_file <<'TEST215'
class c() {
var i = 10;
}
var i=c();
var j=10;
putln (("i")->j);
TEST215
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT215' && $CMP $stderr $ftemp2; then
test.d:6:14: run time error - there is no such declaration in given class
OUTPUT215
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 216.
if test $result = ok -a $start_test_number -le 216; then
	echo test 216
        cat >$test_file <<'TEST216'
var f=open ("_temp2.out", "w");
close(f);
putln (ftype ("_temp2.out"));
remove ("_temp2.out");
TEST216
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT216' && $CMP $stdout $ftemp2; then
f
OUTPUT216
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 217.
if test $result = ok -a $start_test_number -le 217; then
	echo test 217
        cat >$test_file <<'TEST217'
remove ();
TEST217
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT217' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of parameters of `remove'
OUTPUT217
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 218.
if test $result = ok -a $start_test_number -le 218; then
	echo test 218
        cat >$test_file <<'TEST218'
remove (nil);
TEST218
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT218' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `remove'
OUTPUT218
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 219.
if test $result = ok -a $start_test_number -le 219; then
	echo test 219
        cat >$test_file <<'TEST219'
var f=open ("_temp.out", "w");
close(f);
putln (ftype ("_temp.out"));
rename ("_temp.out", "_temp2.out");
putln (ftype ("_temp2.out"));
remove ("_temp2.out");
TEST219
	rm -f $ftemp2
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT219' && $CMP $stdout $ftemp2; then
f
f
OUTPUT219
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 220.
if test $result = ok -a $start_test_number -le 220; then
	echo test 220
        cat >$test_file <<'TEST220'
rename (nil);
TEST220
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT220' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of parameters of `rename'
OUTPUT220
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 221.
if test $result = ok -a $start_test_number -le 221; then
	echo test 221
        cat >$test_file <<'TEST221'
rename ("aaa", nil);
TEST221
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT221' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `rename'
OUTPUT221
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 222.
if test $result = ok -a $start_test_number -le 222; then
	echo test 222
        cat >$test_file <<TEST222
mkdir ("__tempdir");
putln (ftype ("__tempdir"));
TEST222
        rm -rf $tempdir
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT222' && $CMP $stdout $ftemp2; then
d
OUTPUT222
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 223.
if test $result = ok -a $start_test_number -le 223; then
	echo test 223
        cat >$test_file <<'TEST223'
mkdir ();
TEST223
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT223' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of parameters of `mkdir'
OUTPUT223
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 224.
if test $result = ok -a $start_test_number -le 224; then
	echo test 224
        cat >$test_file <<'TEST224'
mkdir (nil);
TEST224
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT224' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `mkdir'
OUTPUT224
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 225.
if test $result = ok -a $start_test_number -le 225; then
	echo test 225
        cat >$test_file <<TEST225
mkdir ("__tempdir");
putln (ftype ("__tempdir"));
rmdir ("__tempdir");
TEST225
        rm -rf $tempdir
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT225' && $CMP $stdout $ftemp2 && test ! -d $tempdir; then
d
OUTPUT225
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 226.
if test $result = ok -a $start_test_number -le 226; then
	echo test 226
        cat >$test_file <<'TEST226'
rmdir ();
TEST226
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT226' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of parameters of `rmdir'
OUTPUT226
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 227.
if test $result = ok -a $start_test_number -le 227; then
	echo test 227
        cat >$test_file <<'TEST227'
rmdir (nil);
TEST227
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT227' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `rmdir'
OUTPUT227
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 228.
if test $result = ok -a $start_test_number -le 228; then
	echo test 228
        cat >$test_file <<TEST228
putln (getcwd ());
TEST228
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/^[A-Za-z]://' $stdout|sed 's,\\,/,g' >$ftemp
                echo '      ' egrep "$ftemp2" $ftemp
                if uname | fgrep CYGWIN && test x$msvc != x;then
                   echo `pwd`| sed 's%/cygdrive/[a-z]%%' >$ftemp2
                else
                   echo `pwd` >$ftemp2
                fi
                echo '      ' $CMP $ftemp2 $ftemp
                if $CMP $ftemp $ftemp2; then
                        result=ok
                else
                        result=ok
			echo difference in the expected and result:
                        diff -c $ftemp2 $ftemp
                fi
        else
                result=fail
        fi
fi

# Test 229.
if test $result = ok -a $start_test_number -le 229; then
	echo test 229
        cat >$test_file <<'TEST229'
getcwd (1);
TEST229
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT229' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of parameters of `getcwd'
OUTPUT229
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 230.
if test $result = ok -a $start_test_number -le 230; then
	echo test 230
        cat >$test_file <<TEST230
chdir ("__tempdir");
putln (getcwd ());
TEST230
        rm -rf $tempdir
        mkdir $tempdir
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/^[A-Za-z]://' $stdout|sed 's,\\,/,g' >$ftemp
                if uname | fgrep CYGWIN && test x$msvc != x;then
                   echo `pwd`/$tempdir| sed 's%/cygdrive/[a-z]%%' >$ftemp2
                else
                   echo `pwd`/$tempdir >$ftemp2
                fi
                echo '      ' $CMP $ftemp $ftemp2
                if  $CMP $ftemp $ftemp2; then
                        result=ok
                else
                        result=ok
			echo difference in the expected and result:
                        diff -c $ftemp2 $ftemp
                fi
        else
                result=fail
        fi
fi

# Test 231.
if test $result = ok -a $start_test_number -le 231; then
	echo test 231
        cat >$test_file <<'TEST231'
chdir ();
TEST231
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT231' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of parameters of `chdir'
OUTPUT231
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 232.
if test $result = ok -a $start_test_number -le 232; then
	echo test 232
        cat >$test_file <<'TEST232'
chdir (nil);
TEST232
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT232' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `chdir'
OUTPUT232
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 233.
if test $result = ok -a $start_test_number -le 233; then
	echo test 233
        cat >$test_file <<'TEST233'
chdir ("abracadabra");
TEST233
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT233' && $CMP $stderr $ftemp2; then
test.d:1:8: system error - no such file or directory: `chdir'
OUTPUT233
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 234.
if test $result = ok -a $start_test_number -le 234; then
	echo test 234
        cat >$test_file <<'TEST234'
rmdir ("abracadabra");
TEST234
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT234' && $CMP $stderr $ftemp2; then
test.d:1:8: system error - no such file or directory: `rmdir'
OUTPUT234
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 235.
if test $result = ok -a $start_test_number -le 235; then
	echo test 235
        cat >$test_file <<'TEST235'
mkdir ("abracadabra/abaraca");
TEST235
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT235' && $CMP $stderr $ftemp2; then
test.d:1:8: system error - no such file or directory: `mkdir'
OUTPUT235
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 236.
if test $result = ok -a $start_test_number -le 236; then
	echo test 236
        cat >$test_file <<TEST236
putln (isatty (open ("test.d", "r")));
TEST236
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT236' && $CMP $stdout $ftemp2; then
0
OUTPUT236
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 237.
if test $result = ok -a $start_test_number -le 237; then
	echo test 237
        cat >$test_file <<'TEST237'
isatty ();
TEST237
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT237' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of parameters of `isatty'
OUTPUT237
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 238.
if test $result = ok -a $start_test_number -le 238; then
	echo test 238
        cat >$test_file <<'TEST238'
isatty (nil);
TEST238
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT238' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `isatty'
OUTPUT238
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 239.
if test $result = ok -a $start_test_number -le 239; then
	echo test 239
        cat >$test_file <<TEST239
chumod ("test.d", "rwx");
putln (fumode ("test.d"));
TEST239
        if uname | fgrep CYGWIN; then
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT239' && $CMP $stdout $ftemp2; then
rwx
OUTPUT239
                        result=ok
                elif  cat >$ftemp2 <<'OUTPUT239-1' && $CMP $stdout $ftemp2; then
rw
OUTPUT239-1
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT239-2' && $CMP $stdout $ftemp2; then
rwx
OUTPUT239-2
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	fi
fi

# Test 240.
if test $result = ok -a $start_test_number -le 240; then
	echo test 240
        cat >$test_file <<'TEST240'
chumod (nil);
TEST240
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT240' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of parameters of `chumod'
OUTPUT240
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 241.
if test $result = ok -a $start_test_number -le 241; then
	echo test 241
        cat >$test_file <<'TEST241'
chumod (nil, "aaa");
TEST241
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT241' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `chumod'
OUTPUT241
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 242.
if test $result = ok -a $start_test_number -le 242; then
	echo test 242
        cat >$test_file <<'TEST242'
chumod ("abracadabra", "r");
TEST242
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT242' && $CMP $stderr $ftemp2; then
test.d:1:9: system error - no such file or directory: `chumod'
OUTPUT242
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 243.
if test $result = ok -a $start_test_number -le 243; then
	echo test 243
        cat >$test_file <<TEST243
chgmod ("test.d", "rwx");
putln (fgmode ("test.d"));
TEST243
        if uname | fgrep CYGWIN; then
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT243' && $CMP $stdout $ftemp2; then

OUTPUT243
                        result=ok
		elif cat >$ftemp2 <<'OUTPUT243-1' && $CMP $stdout $ftemp2; then
r
OUTPUT243-1
                        result=ok
		elif cat >$ftemp2 <<'OUTPUT243-11' && $CMP $stdout $ftemp2; then
rw
OUTPUT243-11
                        result=ok
		elif cat >$ftemp2 <<'OUTPUT243-12' && $CMP $stdout $ftemp2; then
rwx
OUTPUT243-12
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT243-2' && $CMP $stdout $ftemp2; then
rwx
OUTPUT243-2
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	fi
fi

# Test 244.
if test $result = ok -a $start_test_number -le 244; then
	echo test 244
        cat >$test_file <<'TEST244'
chgmod (nil);
TEST244
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT244' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of parameters of `chgmod'
OUTPUT244
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 241.
if test $result = ok -a $start_test_number -le 245; then
	echo test 245
        cat >$test_file <<'TEST245'
chgmod (nil, "aaa");
TEST245
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT245' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `chgmod'
OUTPUT245
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 246.
if test $result = ok -a $start_test_number -le 246; then
	echo test 246
        cat >$test_file <<'TEST246'
chgmod ("abracadabra", "r");
TEST246
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT246' && $CMP $stderr $ftemp2; then
test.d:1:9: system error - no such file or directory: `chgmod'
OUTPUT246
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 247.
if test $result = ok -a $start_test_number -le 247; then
	echo test 247
        cat >$test_file <<TEST247
chomod ("test.d", "rwx");
putln (fomode ("test.d"));
TEST247
        if uname | fgrep CYGWIN; then
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT247' && $CMP $stdout $ftemp2; then

OUTPUT247
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT247-1' && $CMP $stdout $ftemp2; then
r
OUTPUT247-1
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT247-11' && $CMP $stdout $ftemp2; then
rw
OUTPUT247-11
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT247-12' && $CMP $stdout $ftemp2; then
rwx
OUTPUT247-12
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
	    if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if  cat >$ftemp2 <<'OUTPUT247-2' && $CMP $stdout $ftemp2; then
rwx
OUTPUT247-2
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	fi
fi

# Test 248.
if test $result = ok -a $start_test_number -le 248; then
	echo test 248
        cat >$test_file <<'TEST248'
chomod (nil);
TEST248
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT248' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of parameters of `chomod'
OUTPUT248
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 241.
if test $result = ok -a $start_test_number -le 249; then
	echo test 249
        cat >$test_file <<'TEST249'
chomod (nil, "aaa");
TEST249
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT249' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `chomod'
OUTPUT249
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 250.
if test $result = ok -a $start_test_number -le 250; then
	echo test 250
        cat >$test_file <<'TEST250'
chomod ("abracadabra", "r");
TEST250
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT250' && $CMP $stderr $ftemp2; then
test.d:1:9: system error - no such file or directory: `chomod'
OUTPUT250
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 251.
if false; then
# Removed deprecated operations.
	echo test 251
        cat >$test_file <<'TEST251'
func f ()
{
  putln ("call f");
}
class c ()
{
  putln ("call c");
}
var i = 10;
putln (*("i"));
*("i") = 20;
putln (*("i"));
*("i") = 30;
putln (*("i"));
*("i") = 40;
putln (*("i"));
*("i") = 50;
putln (*("i"));
*("f") ();
*("c") ();
TEST251
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT251' && $CMP $stdout $ftemp2; then
10
20
30
40
50
call f
call c
OUTPUT251
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 252.
if false; then
# Removed deprecated operations.
	echo test 252
        cat >$test_file <<'TEST252'
var i=10;
putln (*(10));
TEST252
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT252' && $CMP $stderr $ftemp2; then
test.d:2:8: operand of unary `*' must be of string type
OUTPUT252
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 253.
if false; then
# Removed deprecated operations.
	echo test 253
        cat >$test_file <<'TEST253'
var i=10;
var j={};
putln (*(j));
TEST253
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT253' && $CMP $stderr $ftemp2; then
test.d:3:8: run time error - decl name is not string (operation "->" or "*")
OUTPUT253
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 254.
if false; then
# Removed deprecated operations.
	echo test 254
        cat >$test_file <<'TEST254'
func f() {}
*("f") = 10;
TEST254
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT254' && $CMP $stderr $ftemp2; then
test.d:2:1: run time error - usage function as variable
OUTPUT254
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 255.
if false; then
# Removed deprecated operations.
	echo test 255
        cat >$test_file <<'TEST255'
class c() {}
*("c") = 10;
TEST255
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT255' && $CMP $stderr $ftemp2; then
test.d:2:1: run time error - usage class as variable
OUTPUT255
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 256.
if false; then
# Removed deprecated operations.
	echo test 256
        cat >$test_file <<'TEST256'
class c()
{
    func f () {}
}
var i = c();
("i")->f = 10;
TEST256
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT256' && $CMP $stderr $ftemp2; then
test.d:6:7: run time error - usage function as variable
OUTPUT256
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 257.
if false; then
# Removed deprecated operations.
	echo test 257
        cat >$test_file <<'TEST257'
class c()
{
    class c () {}
}
var i = c();
("i")->c = 10;
TEST257
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT257' && $CMP $stderr $ftemp2; then
test.d:6:7: run time error - usage class as variable
OUTPUT257
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 258.
if test $result = ok -a $start_test_number -le 258; then
	echo test 258: mpi package
        cat >$test_file <<'TEST258'
include "mpi";

var mpi1 = mpis.from_string(1, "10");
var mpi2 = mpis.from_string(1, "5");
putln (mpis.to_string (mpis.add (mpi1, mpi2)));
putln (mpis.to_string (mpis.subtract (mpi1, mpi2)));
putln (mpis.to_string (mpis.subtract (mpi2, mpi1)));
putln (mpis.to_string (mpis.multiply (mpi1, mpi2)));
putln (mpis.to_string (mpis.divide (mpi1, mpi2)));
putln (mpis.to_string (mpis.remainder (mpi1, mpi2)));
putln (mpis.eq (mpi1, mpi2));
putln (mpis.ne (mpi1, mpi2));
putln (mpis.lt (mpi1, mpi2));
putln (mpis.le (mpi1, mpi2));
putln (mpis.gt (mpi1, mpi2));
putln (mpis.ge (mpi1, mpi2));

try {
  mpis.multiply (mpis.multiply (mpi1, mpi2), mpis.multiply (mpi1, mpi2));
} catch (mpis.mpi_excepts.mpi_overflow) {
  putln ("got overflow 1");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.to_string (mpis.multiply (mpis.multiply (mpi1, mpi2), mpis.multiply (mpi1, mpi2))));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
mpi2 = mpis.from_string(2, "300");
try {
  mpis.change_size (mpi2, 1);
} catch (mpis.mpi_excepts.mpi_overflow) {
  putln ("got overflow 2");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.to_string (mpis.change_size (mpi2, 1)));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;

mpi1 = mpis.unsigned_from_string(1, "10");
mpi2 = mpis.unsigned_from_string(1, "5");
putln (mpis.unsigned_to_string (mpis.unsigned_add (mpi1, mpi2)));
putln (mpis.unsigned_to_string (mpis.unsigned_subtract (mpi1, mpi2)));
try {
  putln (mpis.unsigned_to_string (mpis.unsigned_subtract (mpi2, mpi1)));
} catch (mpis.mpi_excepts.mpi_overflow) {
  putln ("got overflow 3");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.unsigned_to_string (mpis.unsigned_subtract (mpi2, mpi1)));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
putln (mpis.unsigned_to_string (mpis.unsigned_multiply (mpi1, mpi2)));
putln (mpis.unsigned_to_string (mpis.unsigned_divide (mpi1, mpi2)));
putln (mpis.unsigned_to_string (mpis.unsigned_remainder (mpi1, mpi2)));
putln (mpis.unsigned_eq (mpi1, mpi2));
putln (mpis.unsigned_ne (mpi1, mpi2));
putln (mpis.unsigned_lt (mpi1, mpi2));
putln (mpis.unsigned_le (mpi1, mpi2));
putln (mpis.unsigned_gt (mpi1, mpi2));
putln (mpis.unsigned_ge (mpi1, mpi2));

try {
  mpis.unsigned_multiply (mpis.unsigned_multiply (mpi1, mpi2), mpis.unsigned_multiply (mpi1, mpi2));
} catch (mpis.mpi_excepts.mpi_overflow) {
  putln ("got overflow 4");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.unsigned_to_string (mpis.unsigned_multiply (mpis.unsigned_multiply (mpi1, mpi2), mpis.unsigned_multiply (mpi1, mpi2))));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
mpi2 = mpis.unsigned_from_string(2, "300");
try {
  mpis.unsigned_change_size (mpi2, 1);
} catch (mpis.mpi_excepts.mpi_overflow) {
  putln ("got overflow 5");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.unsigned_to_string (mpis.unsigned_change_size (mpi2, 1)));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;

mpi1 = mpis.from_string(50, "10000000000000000000000000000000000000000000000");
mpi2 = mpis.from_string(50, "5000000000000000000000000000000000000000000000");
putln (mpis.to_string (mpis.add (mpi1, mpi2)));
putln (mpis.to_string (mpis.subtract (mpi1, mpi2)));
putln (mpis.to_string (mpis.subtract (mpi2, mpi1)));
putln (mpis.to_string (mpis.multiply (mpi1, mpi2)));
putln (mpis.to_string (mpis.divide (mpi1, mpi2)));
putln (mpis.to_string (mpis.remainder (mpi1, mpi2)));
putln (mpis.eq (mpi1, mpi2));
putln (mpis.ne (mpi1, mpi2));
putln (mpis.lt (mpi1, mpi2));
putln (mpis.le (mpi1, mpi2));
putln (mpis.gt (mpi1, mpi2));
putln (mpis.ge (mpi1, mpi2));
try {
  mpis.multiply (mpis.multiply (mpi1, mpi2), mpis.multiply (mpi1, mpi2));
} catch (mpis.mpi_excepts.mpi_overflow) {
  putln ("got overflow 6");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.to_string (mpis.multiply (mpis.multiply (mpi1, mpi2), mpis.multiply (mpi1, mpi2))));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
try {
  mpis.change_size (mpi2, 2);
} catch (mpis.mpi_excepts.mpi_overflow) {
  putln ("got overflow 7");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.to_string (mpis.change_size (mpi2, 2)));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;

mpi1 = mpis.unsigned_from_string(50, "10000000000000000000000000000000000000000000000");
mpi2 = mpis.unsigned_from_string(50, "5000000000000000000000000000000000000000000000");
putln (mpis.unsigned_to_string (mpis.unsigned_add (mpi1, mpi2)));
putln (mpis.unsigned_to_string (mpis.unsigned_subtract (mpi1, mpi2)));
try {
  putln (mpis.unsigned_to_string (mpis.unsigned_subtract (mpi2, mpi1)));
} catch (mpis.mpi_excepts.mpi_overflow) {
  putln ("got overflow 8");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.unsigned_to_string (mpis.unsigned_subtract (mpi2, mpi1)));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
putln (mpis.unsigned_to_string (mpis.unsigned_multiply (mpi1, mpi2)));
putln (mpis.unsigned_to_string (mpis.unsigned_divide (mpi1, mpi2)));
putln (mpis.unsigned_to_string (mpis.unsigned_remainder (mpi1, mpi2)));
putln (mpis.unsigned_eq (mpi1, mpi2));
putln (mpis.unsigned_ne (mpi1, mpi2));
putln (mpis.unsigned_lt (mpi1, mpi2));
putln (mpis.unsigned_le (mpi1, mpi2));
putln (mpis.unsigned_gt (mpi1, mpi2));
putln (mpis.unsigned_ge (mpi1, mpi2));
try {
  mpis.unsigned_multiply (mpis.unsigned_multiply (mpi1, mpi2), mpis.unsigned_multiply (mpi1, mpi2));
} catch (mpis.mpi_excepts.mpi_overflow) {
  putln ("got overflow 9");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.unsigned_to_string (mpis.unsigned_multiply (mpis.unsigned_multiply (mpi1, mpi2), mpis.unsigned_multiply (mpi1, mpi2))));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
try {
  mpis.unsigned_change_size (mpi2, 2);
} catch (mpis.mpi_excepts.mpi_overflow) {
  putln ("got overflow 10");
}
mpis.mpi_ignore_overflow = 1;
putln (mpis.unsigned_to_string (mpis.unsigned_change_size (mpi2, 2)));
putln ("ovfw=", mpis.mpi_overflow);
mpis.mpi_ignore_overflow = 0;
TEST258
        if uname | fgrep CYGWIN; then
            echo '      ' $DINO -L./mpi.dll -I@srcdir@ $test_file "2>$stderr"
	    if $DINO -Lmpi.dll -I@srcdir@ $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT258' && $CMP $stdout $ftemp2; then
15
5
-5
50
2
0
0
1
0
0
1
1
got overflow 1
-60
ovfw=1
got overflow 2
44
ovfw=1
15
5
got overflow 3
251
ovfw=1
50
2
0
0
1
0
0
1
1
got overflow 4
196
ovfw=1
got overflow 5
44
ovfw=1
15000000000000000000000000000000000000000000000
5000000000000000000000000000000000000000000000
-5000000000000000000000000000000000000000000000
50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
2
0
0
1
0
0
1
1
got overflow 6
867904737743324110893126166364363704770614348168184133037106651590308130409865771824596108187979317115712568128322928640
ovfw=1
got overflow 7
0
ovfw=1
15000000000000000000000000000000000000000000000
5000000000000000000000000000000000000000000000
got overflow 8
2582249878086908589655919172003011874329705792829223512830659356540647622011841194629645353280137831435903171972747493376
ovfw=1
50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
2
0
0
1
0
0
1
1
got overflow 9
867904737743324110893126166364363704770614348168184133037106651590308130409865771824596108187979317115712568128322928640
ovfw=1
got overflow 10
0
ovfw=1
OUTPUT258
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
            echo '      ' $DINO -L./mpi.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file "2>$stderr"
	    if $DINO -L./mpi.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT258' && $CMP $stdout $ftemp2; then
15
5
-5
50
2
0
0
1
0
0
1
1
got overflow 1
-60
ovfw=1
got overflow 2
44
ovfw=1
15
5
got overflow 3
251
ovfw=1
50
2
0
0
1
0
0
1
1
got overflow 4
196
ovfw=1
got overflow 5
44
ovfw=1
15000000000000000000000000000000000000000000000
5000000000000000000000000000000000000000000000
-5000000000000000000000000000000000000000000000
50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
2
0
0
1
0
0
1
1
got overflow 6
867904737743324110893126166364363704770614348168184133037106651590308130409865771824596108187979317115712568128322928640
ovfw=1
got overflow 7
0
ovfw=1
15000000000000000000000000000000000000000000000
5000000000000000000000000000000000000000000000
got overflow 8
2582249878086908589655919172003011874329705792829223512830659356540647622011841194629645353280137831435903171972747493376
ovfw=1
50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
2
0
0
1
0
0
1
1
got overflow 9
867904737743324110893126166364363704770614348168184133037106651590308130409865771824596108187979317115712568128322928640
ovfw=1
got overflow 10
0
ovfw=1
OUTPUT258
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
        fi
fi

# Test 259.
if test $result = ok -a $start_test_number -le 259; then
	echo test 259
        cat >$test_file <<'TEST259'
{
  public a;
}
TEST259
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT259' && $CMP $stderr $ftemp2; then
test.d:2:9: there is no declaration for identifier `a' in access list
OUTPUT259
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 260.
if test $result = ok -a $start_test_number -le 260; then
	echo test 260
        cat >$test_file <<'TEST260'
{
  public a, a;
  var a;
  private a;
}
TEST260
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT260' && $CMP $stderr $ftemp2; then
test.d:4:10: identifier `a' is declared as public and private
test.d:2:9: previous place of identifier `a' in access list
OUTPUT260
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 261.
if test $result = ok -a $start_test_number -le 261; then
	echo test 261
        cat >$test_file <<'TEST261'
class c () {
  var i;
  private i;
  i = 0;
}

var i;
i = c ();
i.i = 1;
TEST261
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT261' && $CMP $stderr $ftemp2; then
test.d:9:2: run time error - access to private decl `i' from outside
OUTPUT261
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 262.
if test $result = ok -a $start_test_number -le 262; then
	echo test 262
        cat >$test_file <<'TEST262'
var ci;
{
  var i;
  class c () {
  }
  ci = c ();
  i = 0;
}

context(ci).i = 1;
TEST262
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT262' && $CMP $stderr $ftemp2; then
test.d:10:12: run time error - access to private decl `i' from outside
OUTPUT262
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 263.
if test $result = ok -a $start_test_number -le 263; then
	echo test 263
        cat >$test_file <<'TEST263'
func f (a, ...)
{
  var args;
}
TEST263
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT263' && $CMP $stderr $ftemp2; then
test.d:3:6: repeated declaration for identifier `args'
test.d:1:15: (previous declaration of identifier `args')
OUTPUT263
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 264.
if test $result = ok -a $start_test_number -le 264; then
	echo test 264
        cat >$test_file <<'TEST264'
func f (args, ...)
{
}
TEST264
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT264' && $CMP $stderr $ftemp2; then
test.d:1:18: repeated declaration for identifier `args'
test.d:1:9: (previous declaration of identifier `args')
OUTPUT264
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 265.
if test $result = ok -a $start_test_number -le 265; then
	echo test 265
        cat >$test_file <<'TEST265'
var argv;
TEST265
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT265' && $CMP $stderr $ftemp2; then
test.d:1:5: repeated declaration for identifier `argv'
<environment>:123:4: (previous declaration of identifier `argv')
OUTPUT265
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 266.
if test $result = ok -a $start_test_number -le 266; then
	echo test 266
        cat >$test_file <<'TEST266'
argv[0] = 1;
TEST266
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT266' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - attempt to modify immutable vector
OUTPUT266
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 267.
if test $result = ok -a $start_test_number -le 267; then
	echo test 267
        cat >$test_file <<'TEST267'
atan2 (10);
TEST267
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT267' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of parameters of `atan2'
OUTPUT267
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 268.
if test $result = ok -a $start_test_number -le 268; then
	echo test 268
        cat >$test_file <<'TEST268'
atan2 ({}, 10);
TEST268
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT268' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `atan2'
OUTPUT268
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 269.
if test $result = ok -a $start_test_number -le 269; then
	echo test 269
        cat >$test_file <<'TEST269'
atan2 (10, 10, 10);
TEST269
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT269' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of parameters of `atan2'
OUTPUT269
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 270.
if test $result = ok -a $start_test_number -le 270; then
	echo test 270
        cat >$test_file <<'TEST270'
atan2 ();
TEST270
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT270' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of parameters of `atan2'
OUTPUT270
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 271.
if test $result = ok -a $start_test_number -le 271; then
	echo test 271
        cat >$test_file <<'TEST271'
class c () {
  return 10;
}

var i;

i = c ();
TEST271
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT271' && $CMP $stderr $ftemp2; then
test.d:2:8: statement return with result is in class
OUTPUT271
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 272.
if test $result = ok -a $start_test_number -le 272; then
	echo test 272
        cat >$test_file <<'TEST272'
class c () {
  {
    return 10;
  }
}

var i;

i = c ();
TEST272
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT272' && $CMP $stderr $ftemp2; then
test.d:3:10: statement return with result is in class
OUTPUT272
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 273.
if test $result = ok -a $start_test_number -le 273; then
	echo test 273
        cat >$test_file <<'TEST273'
cos ();
TEST273
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT273' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of parameters of `cos'
OUTPUT273
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 274.
if test $result = ok -a $start_test_number -le 274; then
	echo test 274
        cat >$test_file <<'TEST274'
cos ({});
TEST274
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT274' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `cos'
OUTPUT274
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 275.
if test $result = ok -a $start_test_number -le 275; then
	echo test 275
        cat >$test_file <<'TEST275'
del ();
TEST275
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT275' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of parameters of `del'
OUTPUT275
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 276.
if test $result = ok -a $start_test_number -le 276; then
	echo test 276
        cat >$test_file <<'TEST276'
var v;
v = "123456"; del (v, 1);
TEST276
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT276' && $CMP $stderr $ftemp2; then
test.d:2:19: run time error - attempt to modify immutable vector
OUTPUT276
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 277.
if test $result = ok -a $start_test_number -le 277; then
	echo test 277
        cat >$test_file <<'TEST277'
var t;
t = final {1, 2, 3, 4, 5, 6}; del (t, 1);
TEST277
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT277' && $CMP $stderr $ftemp2; then
test.d:2:35: run time error - attempt to modify immutable table
OUTPUT277
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 278.
if test $result = ok -a $start_test_number -le 278; then
	echo test 278
        cat >$test_file <<'TEST278'
del (10);
TEST278
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT278' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of parameters of `del'
OUTPUT278
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 279.
if test $result = ok -a $start_test_number -le 279; then
	echo test 279
        cat >$test_file <<'TEST279'
del (10, 10);
TEST279
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT279' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `del'
OUTPUT279
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 280.
if test $result = ok -a $start_test_number -le 280; then
	echo test 280
        cat >$test_file <<'TEST280'
del (10,10,10,10);
TEST280
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT280' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of parameters of `del'
OUTPUT280
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 281.
if test $result = ok -a $start_test_number -le 281; then
	echo test 281
        cat >$test_file <<'TEST281'
var t;
t = {10}; del (t, 10, 10);
TEST281
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT281' && $CMP $stderr $ftemp2; then
test.d:2:15: run time error - invalid number of parameters of `del'
OUTPUT281
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 282.
if test $result = ok -a $start_test_number -le 282; then
	echo test 282
        cat >$test_file <<'TEST282'
var v;
v = []; del (v, {});
TEST282
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT282' && $CMP $stderr $ftemp2; then
test.d:2:13: run time error - invalid parameter type of `del'
OUTPUT282
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 283.
if test $result = ok -a $start_test_number -le 283; then
	echo test 283
        cat >$test_file <<'TEST283'
var v;
v = []; del (v, 0, {});
TEST283
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT283' && $CMP $stderr $ftemp2; then
test.d:2:13: run time error - invalid parameter type of `del'
OUTPUT283
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 284.
if test $result = ok -a $start_test_number -le 284; then
	echo test 284
        cat >$test_file <<'TEST284'
var env;
TEST284
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT284' && $CMP $stderr $ftemp2; then
test.d:1:5: repeated declaration for identifier `env'
<environment>:123:10: (previous declaration of identifier `env')
OUTPUT284
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 285.
if test $result = ok -a $start_test_number -le 285; then
	echo test 285
        cat >$test_file <<'TEST285'
env {"PATH"} = "abracadabra";
TEST285
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT285' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - attempt to modify immutable table
OUTPUT285
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 286.
if test $result = ok -a $start_test_number -le 286; then
	echo test 286
        cat >$test_file <<'TEST286'
ins ();
TEST286
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT286' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of parameters of `ins'
OUTPUT286
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 287.
if test $result = ok -a $start_test_number -le 287; then
	echo test 287
        cat >$test_file <<'TEST287'
var v;
v = "123456"; ins (v, 1);
TEST287
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT287' && $CMP $stderr $ftemp2; then
test.d:2:19: run time error - attempt to modify immutable vector
OUTPUT287
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 288.
if test $result = ok -a $start_test_number -le 288; then
	echo test 288
        cat >$test_file <<'TEST288'
ins (10);
TEST288
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT288' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of parameters of `ins'
OUTPUT288
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 289.
if test $result = ok -a $start_test_number -le 289; then
	echo test 289
        cat >$test_file <<'TEST289'
ins (10, 10);
TEST289
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT289' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `ins'
OUTPUT289
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 290.
if test $result = ok -a $start_test_number -le 290; then
	echo test 290
        cat >$test_file <<'TEST290'
ins (10,10,10,10);
TEST290
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT290' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of parameters of `ins'
OUTPUT290
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 291.
if test $result = ok -a $start_test_number -le 291; then
	echo test 291
        cat >$test_file <<'TEST291'
var v;
v = []; ins (v, 1, {});
TEST291
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT291' && $CMP $stderr $ftemp2; then
test.d:2:13: run time error - invalid parameter type of `ins'
OUTPUT291
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 292.
if test $result = ok -a $start_test_number -le 292; then
	echo test 292
        cat >$test_file <<'TEST292'
insv ();
TEST292
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT292' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of parameters of `insv'
OUTPUT292
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 293.
if test $result = ok -a $start_test_number -le 293; then
	echo test 293
        cat >$test_file <<'TEST293'
var v;
v = "123456"; insv (v, [1]);
TEST293
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT293' && $CMP $stderr $ftemp2; then
test.d:2:20: run time error - attempt to modify immutable vector
OUTPUT293
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 294.
if test $result = ok -a $start_test_number -le 294; then
	echo test 294
        cat >$test_file <<'TEST294'
insv (10);
TEST294
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT294' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of parameters of `insv'
OUTPUT294
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 295.
if test $result = ok -a $start_test_number -le 295; then
	echo test 295
        cat >$test_file <<'TEST295'
insv (10, 10);
TEST295
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT295' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `insv'
OUTPUT295
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 296.
if test $result = ok -a $start_test_number -le 296; then
	echo test 296
        cat >$test_file <<'TEST296'
insv (10,10,10,10);
TEST296
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT296' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of parameters of `insv'
OUTPUT296
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 297.
if test $result = ok -a $start_test_number -le 297; then
	echo test 297
        cat >$test_file <<'TEST297'
var v;
v = []; insv (v, [1], {});
TEST297
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT297' && $CMP $stderr $ftemp2; then
test.d:2:14: run time error - invalid parameter type of `insv'
OUTPUT297
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 298.
if test $result = ok -a $start_test_number -le 298; then
	echo test 298
        cat >$test_file <<'TEST298'
var v;
v = []; insv (v, 1);
TEST298
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT298' && $CMP $stderr $ftemp2; then
test.d:2:14: run time error - invalid parameter type of `insv'
OUTPUT298
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 299.
if test $result = ok -a $start_test_number -le 299; then
	echo test 299
        cat >$test_file <<'TEST299'
func f () {}
class c () {
  ext f {}
}
TEST299
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT299' && $CMP $stderr $ftemp2; then
test.d:3:6: extension f without extended func or class
OUTPUT299
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 300.
if test $result = ok -a $start_test_number -le 300; then
	echo test 300
        cat >$test_file <<'TEST300'
fput ();
TEST300
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT300' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of parameters of `fput'
OUTPUT300
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 301.
if test $result = ok -a $start_test_number -le 301; then
	echo test 301
        cat >$test_file <<'TEST301'
fput ("AAAA");
TEST301
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT301' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `fput'
OUTPUT301
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 302.
if test $result = ok -a $start_test_number -le 302; then
	echo test 302
        cat >$test_file <<'TEST302'
extern f();
extern f();
TEST302
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT302' && $CMP $stderr $ftemp2; then
test.d:2:7: repeated declaration for identifier `f'
test.d:1:8: (previous declaration of identifier `f')
OUTPUT302
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 303.
if test $result = ok -a $start_test_number -le 303; then
	echo test 303
        cat >$test_file <<'TEST303'
var f;
extern f();
TEST303
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT303' && $CMP $stderr $ftemp2; then
test.d:2:7: repeated declaration for identifier `f'
test.d:1:5: (previous declaration of identifier `f')
OUTPUT303
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 304.
if test $result = ok -a $start_test_number -le 304; then
	echo test 304
        cat >$test_file <<'TEST304'
var f;
extern f;
TEST304
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT304' && $CMP $stderr $ftemp2; then
test.d:2:7: repeated declaration for identifier `f'
test.d:1:5: (previous declaration of identifier `f')
OUTPUT304
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 305.
if test $result = ok -a $start_test_number -le 305; then
	echo test 305
        cat >$test_file <<'TEST305'
inside ("");
TEST305
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT305' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of parameters of `inside'
OUTPUT305
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 306.
if test $result = ok -a $start_test_number -le 306; then
	echo test 306
        cat >$test_file <<'TEST306'
class c () {}
inside ("", c);
TEST306
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT306' && $CMP $stderr $ftemp2; then
test.d:2:8: run time error - invalid parameter type of `inside'
OUTPUT306
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 307.
if test $result = ok -a $start_test_number -le 307; then
	echo test 307
        cat >$test_file <<'TEST307'
class c () {}
inside (c,"");
TEST307
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT307' && $CMP $stderr $ftemp2; then
test.d:2:8: run time error - invalid parameter type of `inside'
OUTPUT307
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 308.
if test $result = ok -a $start_test_number -le 308; then
	echo test 308
        cat >$test_file <<'TEST308'
match ("");
TEST308
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT308' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of parameters of `match'
OUTPUT308
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 309.
if test $result = ok -a $start_test_number -le 309; then
	echo test 309
        cat >$test_file <<'TEST309'
match (nil, 10);
TEST309
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT309' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `match'
OUTPUT309
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 310.
if test $result = ok -a $start_test_number -le 310; then
	echo test 310
        cat >$test_file <<'TEST310'
match ("", nil);
TEST310
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT310' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `match'
OUTPUT310
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 311.
if test $result = ok -a $start_test_number -le 311; then
	echo test 311
        cat >$test_file <<'TEST311'
var s;
s = "aaaa";
s[1] = "b";
TEST311
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT311' && $CMP $stderr $ftemp2; then
test.d:3:2: run time error - attempt to modify immutable vector
OUTPUT311
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 312.
if test $result = ok -a $start_test_number -le 312; then
	echo test 312
        cat >$test_file <<'TEST312'
var s;
s = final {"a"};
s{"a"} = "b";
TEST312
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT312' && $CMP $stderr $ftemp2; then
test.d:3:2: run time error - attempt to modify immutable table
OUTPUT312
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 313.
if test $result = ok -a $start_test_number -le 313; then
	echo test 313
        cat >$test_file <<'TEST313'
var s, t;
s = ['a'];
t = {s:"a"};
s[0] = 'b';
TEST313
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT313' && $CMP $stderr $ftemp2; then
test.d:4:2: run time error - attempt to modify immutable vector
OUTPUT313
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 314.
if test $result = ok -a $start_test_number -le 314; then
	echo test 314
        cat >$test_file <<'TEST314'
class c()
{
  var i;
}
var o;
o = final c ();
o.i = 10;
TEST314
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT314' && $CMP $stderr $ftemp2; then
test.d:7:2: run time error - attempt to modify immutable instance
OUTPUT314
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 315.
if test $result = ok -a $start_test_number -le 315; then
	echo test 315
        cat >$test_file <<'TEST315'
var i;
i = nil;
i++;
TEST315
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT315' && $CMP $stderr $ftemp2; then
test.d:3:3: run time error - invalid types of operands of operator "+"
OUTPUT315
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 316.
if test $result = ok -a $start_test_number -le 316; then
	echo test 316
        cat >$test_file <<'TEST316'
rand (10);
TEST316
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT316' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of parameters of `rand'
OUTPUT316
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 317.
if test $result = ok -a $start_test_number -le 317; then
	echo test 317
        cat >$test_file <<'TEST317'
rand (10, 10);
TEST317
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT317' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of parameters of `rand'
OUTPUT317
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 318.
if test $result = ok -a $start_test_number -le 318; then
	echo test 318
        cat >$test_file <<'TEST318'
readdir ();
TEST318
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT318' && $CMP $stderr $ftemp2; then
test.d:1:10: run time error - invalid number of parameters of `readdir'
OUTPUT318
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 319.
if test $result = ok -a $start_test_number -le 319; then
	echo test 319
        cat >$test_file <<'TEST319'
readdir ("1", "");
TEST319
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT319' && $CMP $stderr $ftemp2; then
test.d:1:10: run time error - invalid number of parameters of `readdir'
OUTPUT319
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 320.
if test $result = ok -a $start_test_number -le 320; then
	echo test 320
        cat >$test_file <<'TEST320'
readdir (nil);
TEST320
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT320' && $CMP $stderr $ftemp2; then
test.d:1:10: run time error - invalid parameter type of `readdir'
OUTPUT320
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 321.
if test $result = ok -a $start_test_number -le 321; then
	echo test 321
        cat >$test_file <<'TEST321'
func f () {putln ("aa";return 1;}
func g () {putln ("aa";return 1;}
TEST321
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT321' && $CMP $stderr $ftemp2; then
test.d:1:23: syntax error
test.d:2:22: syntax error
OUTPUT321
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 322.
if test $result = ok -a $start_test_number -le 322; then
	echo test 322
        cat >$test_file <<'TEST322'
func f () {}
f = 1;
TEST322
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT322' && $CMP $stderr $ftemp2; then
test.d:2:0: non variable in assignment statement
OUTPUT322
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 323.
if test $result = ok -a $start_test_number -le 323; then
	echo test 323
        cat >$test_file <<'TEST323'
func f () {}
var t;
t = {};
for (f in t);
TEST323
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT323' && $CMP $stderr $ftemp2; then
test.d:4:5: non variable in for-stmt left to `in'
OUTPUT323
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 324.
if test $result = ok -a $start_test_number -le 324; then
	echo test 324
        cat >$test_file <<'TEST324'
class c() {
  func f () {}
}
var o;
o = c();
o.f = 1;
TEST324
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT324' && $CMP $stderr $ftemp2; then
test.d:6:2: run time error - usage function as variable
OUTPUT324
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 325.
if test $result = ok -a $start_test_number -le 325; then
	echo test 325
        cat >$test_file <<'TEST325'
class c() {
  func f () {}
}
var o, t;
o = c();
t = {};
for (o.f in t);
TEST325
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT325' && $CMP $stderr $ftemp2; then
test.d:7:7: run time error - usage function as variable
OUTPUT325
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 326.
if test $result = ok -a $start_test_number -le 326; then
	echo test 326
        cat >$test_file <<'TEST326'
class c() {
  class f () {}
}
var o;
o = c();
o.f = 1;
TEST326
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT326' && $CMP $stderr $ftemp2; then
test.d:6:2: run time error - usage class as variable
OUTPUT326
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 327.
if test $result = ok -a $start_test_number -le 327; then
	echo test 327
        cat >$test_file <<'TEST327'
class c() {
  class f () {}
}
var o, t;
o = c();
t = {};
for (o.f in t);
TEST327
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT327' && $CMP $stderr $ftemp2; then
test.d:7:7: run time error - usage class as variable
OUTPUT327
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 328.
if test $result = ok -a $start_test_number -le 328; then
	echo test 328
        cat >$test_file <<'TEST328'
sin ();
TEST328
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT328' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of parameters of `sin'
OUTPUT328
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 329.
if test $result = ok -a $start_test_number -le 329; then
	echo test 329
        cat >$test_file <<'TEST329'
sin ({});
TEST329
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT329' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `sin'
OUTPUT329
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 330.
if test $result = ok -a $start_test_number -le 330; then
	echo test 330
        cat >$test_file <<'TEST330'
split ("a", "A", "A");
TEST330
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT330' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of parameters of `split'
OUTPUT330
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 331.
if test $result = ok -a $start_test_number -le 331; then
	echo test 331
        cat >$test_file <<'TEST331'
split ();
TEST331
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT331' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of parameters of `split'
OUTPUT331
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 332.
if test $result = ok -a $start_test_number -le 332; then
	echo test 332
        cat >$test_file <<'TEST332'
split ("aaa", nil);
TEST332
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT332' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `split'
OUTPUT332
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 333.
if test $result = ok -a $start_test_number -le 333; then
	echo test 333
        cat >$test_file <<'TEST333'
split (nil);
TEST333
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT333' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `split'
OUTPUT333
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 334.
if test $result = ok -a $start_test_number -le 334; then
	echo test 334
        cat >$test_file <<'TEST334'
srand (10, 10);
TEST334
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT334' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid number of parameters of `srand'
OUTPUT334
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 335.
if test $result = ok -a $start_test_number -le 335; then
	echo test 335
        cat >$test_file <<'TEST335'
srand ({});
TEST335
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT335' && $CMP $stderr $ftemp2; then
test.d:1:8: run time error - invalid parameter type of `srand'
OUTPUT335
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 336.
if test $result = ok -a $start_test_number -le 336; then
	echo test 336
        cat >$test_file <<'TEST336'
sub ();
TEST336
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT336' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of parameters of `sub'
OUTPUT336
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 337.
if test $result = ok -a $start_test_number -le 337; then
	echo test 337
        cat >$test_file <<'TEST337'
sub ("", "", "", "");
TEST337
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT337' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of parameters of `sub'
OUTPUT337
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 338.
if test $result = ok -a $start_test_number -le 338; then
	echo test 338
        cat >$test_file <<'TEST338'
sub (nil, "", "");
TEST338
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT338' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `sub'
OUTPUT338
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 339.
if test $result = ok -a $start_test_number -le 339; then
	echo test 339
        cat >$test_file <<'TEST339'
sub (nil, "", "");
TEST339
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT339' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `sub'
OUTPUT339
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 340.
if test $result = ok -a $start_test_number -le 340; then
	echo test 340
        cat >$test_file <<'TEST340'
putln (system (10));
TEST340
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT340' && $CMP $stderr $ftemp2; then
test.d:1:16: run time error - invalid parameter type of `system'
OUTPUT340
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 341.
if test $result = ok -a $start_test_number -le 341; then
	echo test 341
        cat >$test_file <<'TEST341'
putln (system ());
TEST341
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT341' && $CMP $stderr $ftemp2; then
test.d:1:16: run time error - invalid number of parameters of `system'
OUTPUT341
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 342.
if test $result = ok -a $start_test_number -le 342; then
	echo test 342
        cat >$test_file <<'TEST342'
var t;
t = {};
putln (t{10});
TEST342
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT342' && $CMP $stderr $ftemp2; then
test.d:3:9: run time error - no such key in table
OUTPUT342
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 343.
if test $result = ok -a $start_test_number -le 343; then
	echo test 343
        cat >$test_file <<'TEST343'
var t;
t = 10;
putln (10 in t);
TEST343
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT343' && $CMP $stderr $ftemp2; then
test.d:3:12: run time error - non table right to `in'
OUTPUT343
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 344.
if test $result = ok -a $start_test_number -le 344; then
	echo test 344
        cat >$test_file <<'TEST344'
var t;
t = [];
putln (t{10});
TEST344
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT344' && $CMP $stderr $ftemp2; then
test.d:3:9: run time error - key index operation for non table
OUTPUT344
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 345.
if test $result = ok -a $start_test_number -le 345; then
	echo test 345
        cat >$test_file <<'TEST345'
var i,t;
t = [];
for (i in t) putln ("wrong");
TEST345
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT345' && $CMP $stderr $ftemp2; then
test.d:3:3: run time error - non table right to `in'
OUTPUT345
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 346.
if test $result = ok -a $start_test_number -le 346; then
	echo test 346
        cat >$test_file <<'TEST346'
thread f () {
  return 10;
}

var t;

t = f ();
TEST346
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT346' && $CMP $stderr $ftemp2; then
test.d:2:8: statement return with result is in thread
OUTPUT346
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 347.
if test $result = ok -a $start_test_number -le 347; then
	echo test 347
        cat >$test_file <<'TEST347'
thread f () {
  {
    return 10;
  }
}

var t;

t = f ();
TEST347
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT347' && $CMP $stderr $ftemp2; then
test.d:3:10: statement return with result is in thread
OUTPUT347
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 348.
if test $result = ok -a $start_test_number -le 348; then
	echo test 348
        cat >$test_file <<'TEST348'
wait (0);
TEST348
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT348' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - process deadlock
OUTPUT348
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 349.
if test $result = ok -a $start_test_number -le 349; then
	echo test 349
        cat >$test_file <<'TEST349'
thread t () { wait (0);}
var p;
p = t ();
wait (0);
TEST349
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT349' && $CMP $stderr $ftemp2; then
test.d:1:21: run time error - process deadlock
OUTPUT349
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 350.
if test $result = ok -a $start_test_number -le 350; then
	echo test 350
        cat >$test_file <<'TEST350'
thread t () { wait (0);}
var p;
p = t ();
TEST350
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT350' && $CMP $stderr $ftemp2; then
test.d:1:21: run time error - process deadlock
OUTPUT350
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 351.
if test $result = ok -a $start_test_number -le 351; then
	echo test 351
        cat >$test_file <<'TEST351'
func f() {return 1;}
wait (f());
TEST351
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT351' && $CMP $stderr $ftemp2; then
test.d:2:6: function call is present in wait statement
OUTPUT351
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 352.
if test $result = ok -a $start_test_number -le 352; then
	echo test 352
        cat >$test_file <<'TEST352'
class c(){}
if ({}) {}
var i;
for (i=0;c;i++) {}
wait (c);
for (i in 10) {}
try {
  throw 1;
}
catch 10 {
}
TEST352
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT352' && $CMP $stderr $ftemp2; then
test.d:2:6: invalid type of if-expr
test.d:4:9: invalid type of for-expr
test.d:5:6: invalid type of wait-expr
test.d:6:5: invalid type of foreach-table
test.d:8:7: invalid type of throw-expr
test.d:10:6: syntax error
OUTPUT352
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 353.
if test $result = ok -a $start_test_number -le 353; then
	echo test 353
        cat >$test_file <<'TEST353'
i := 10;
TEST353
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT353' && $CMP $stderr $ftemp2; then
test.d:1:3: syntax error
OUTPUT353
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 354.
if test $result = ok -a $start_test_number -le 354; then
	echo test 354
        cat >$test_file <<'TEST354'
var i;
for (i:=0; i<1000000; i:=i+1;)
 ;
TEST354
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT354' && $CMP $stderr $ftemp2; then
test.d:2:6: syntax error
test.d:2:12: syntax error
OUTPUT354
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 355.
if test $result = ok -a $start_test_number -le 355; then
	echo test 355
        cat >$test_file <<'TEST355'
var ctime;
ctime = 0.0;

func waitfor (n, t){
  var cont;
  wait (1) cont = 1;
  putln (n, " waitfor ", t, " ctime ", ctime);
  for (; cont;)
    try {
      wait (ctime == t) cont = 0;
    } catch (errors.deadlock) {
      wait (1) ctime++;
      putln ("tick ", ctime); 
    }
}

thread output() {
  waitfor ("output", 2.0);
  putln ("output 1");
  waitfor ("output", 4.0);
  putln ("output 2");
}

thread move () {
   waitfor ("move", 1.0);
   putln ("move 1");
   waitfor ("move", 3.0);
   putln ("move 2");
}

move ();
output ();
TEST355
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT355' && $CMP $stdout $ftemp2; then
move waitfor 1 ctime 0
output waitfor 2 ctime 0
tick 1
move 1
move waitfor 3 ctime 1
tick 2
output 1
output waitfor 4 ctime 2
tick 3
move 2
tick 4
output 2
OUTPUT355
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 356.
if test $result = ok -a $start_test_number -le 356; then
	echo test 356
        cat >$test_file <<'TEST356'
var ctime;
ctime = 0.0;
var X,Y,Z;
X = [1.0,0.0,0.0];
Y = [0.0,1.0,0.0];
Z = [0.0,0.0,1.0];
func fulfill (){ putln ("FULFILL");}
func publish (){ putln ("PUBLISH");}
func rotate (what, axis, angle){
  putln ("ROTATE ", what, " ",
         axis [0], " ", axis [1], " ", axis [2], " ", angle);
}

func waitfor (n, t){
  var cont;
  wait (1) cont = 1;
  putln ("waitfor ", n, " ", t, " ctime ", ctime);
  for (; cont;)
    try {
      wait (ctime == t) cont = 0;
    } catch (errors.deadlock) {
      wait (1) ctime++;
      putln ("tick ", ctime); 
    }
}

class back_leg(side){
  var angle;
  angle = 1.0;

  func step () {
    var start;
    putln ("step ", ctime);
    start = ctime;
    rotate (side @ "_back_hoof", Z, -angle);
    waitfor (side, start+1);
    rotate (side @ "_back_hoof", Z, -angle);
    waitfor (side, start+2);
    rotate (side @ "_back_hoof", Z, angle);
    waitfor (side, start+3);
    rotate (side @ "_back_hoof", Z, angle);
  }

  thread move (start_ctime, steps_number) {
    waitfor (side, start_ctime);
    var i;
    for (i=0; i<steps_number; i = i+1)
	step ();
  }
}     

thread output(interval) {
  var i, cont;
  for (i=0; i<interval; i=i+1) {
    waitfor ("output", i + 0.0);
    fulfill ();
    publish ();
  }
}

var left_back_leg, right_back_leg;

left_back_leg = back_leg("left");
right_back_leg = back_leg("right");

left_back_leg.move (ctime, 10.0);
right_back_leg.move (ctime+1.0, 10.0);
output (32);
TEST356
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT356' && $CMP $stdout $ftemp2; then
waitfor left 0 ctime 0
step 0
ROTATE left_back_hoof 0 0 1 -1
waitfor left 1 ctime 0
waitfor right 1 ctime 0
waitfor output 0 ctime 0
FULFILL
PUBLISH
waitfor output 1 ctime 0
tick 1
ROTATE left_back_hoof 0 0 1 -1
waitfor left 2 ctime 1
step 1
ROTATE right_back_hoof 0 0 1 -1
waitfor right 2 ctime 1
FULFILL
PUBLISH
waitfor output 2 ctime 1
tick 2
ROTATE left_back_hoof 0 0 1 1
waitfor left 3 ctime 2
ROTATE right_back_hoof 0 0 1 -1
waitfor right 3 ctime 2
FULFILL
PUBLISH
waitfor output 3 ctime 2
tick 3
ROTATE left_back_hoof 0 0 1 1
step 3
ROTATE left_back_hoof 0 0 1 -1
waitfor left 4 ctime 3
ROTATE right_back_hoof 0 0 1 1
waitfor right 4 ctime 3
FULFILL
PUBLISH
waitfor output 4 ctime 3
tick 4
ROTATE left_back_hoof 0 0 1 -1
waitfor left 5 ctime 4
ROTATE right_back_hoof 0 0 1 1
step 4
ROTATE right_back_hoof 0 0 1 -1
waitfor right 5 ctime 4
FULFILL
PUBLISH
waitfor output 5 ctime 4
tick 5
ROTATE left_back_hoof 0 0 1 1
waitfor left 6 ctime 5
ROTATE right_back_hoof 0 0 1 -1
waitfor right 6 ctime 5
FULFILL
PUBLISH
waitfor output 6 ctime 5
tick 6
ROTATE left_back_hoof 0 0 1 1
step 6
ROTATE left_back_hoof 0 0 1 -1
waitfor left 7 ctime 6
ROTATE right_back_hoof 0 0 1 1
waitfor right 7 ctime 6
FULFILL
PUBLISH
waitfor output 7 ctime 6
tick 7
ROTATE left_back_hoof 0 0 1 -1
waitfor left 8 ctime 7
ROTATE right_back_hoof 0 0 1 1
step 7
ROTATE right_back_hoof 0 0 1 -1
waitfor right 8 ctime 7
FULFILL
PUBLISH
waitfor output 8 ctime 7
tick 8
ROTATE left_back_hoof 0 0 1 1
waitfor left 9 ctime 8
ROTATE right_back_hoof 0 0 1 -1
waitfor right 9 ctime 8
FULFILL
PUBLISH
waitfor output 9 ctime 8
tick 9
ROTATE left_back_hoof 0 0 1 1
step 9
ROTATE left_back_hoof 0 0 1 -1
waitfor left 10 ctime 9
ROTATE right_back_hoof 0 0 1 1
waitfor right 10 ctime 9
FULFILL
PUBLISH
waitfor output 10 ctime 9
tick 10
ROTATE left_back_hoof 0 0 1 -1
waitfor left 11 ctime 10
ROTATE right_back_hoof 0 0 1 1
step 10
ROTATE right_back_hoof 0 0 1 -1
waitfor right 11 ctime 10
FULFILL
PUBLISH
waitfor output 11 ctime 10
tick 11
ROTATE left_back_hoof 0 0 1 1
waitfor left 12 ctime 11
ROTATE right_back_hoof 0 0 1 -1
waitfor right 12 ctime 11
FULFILL
PUBLISH
waitfor output 12 ctime 11
tick 12
ROTATE left_back_hoof 0 0 1 1
step 12
ROTATE left_back_hoof 0 0 1 -1
waitfor left 13 ctime 12
ROTATE right_back_hoof 0 0 1 1
waitfor right 13 ctime 12
FULFILL
PUBLISH
waitfor output 13 ctime 12
tick 13
ROTATE left_back_hoof 0 0 1 -1
waitfor left 14 ctime 13
ROTATE right_back_hoof 0 0 1 1
step 13
ROTATE right_back_hoof 0 0 1 -1
waitfor right 14 ctime 13
FULFILL
PUBLISH
waitfor output 14 ctime 13
tick 14
ROTATE left_back_hoof 0 0 1 1
waitfor left 15 ctime 14
ROTATE right_back_hoof 0 0 1 -1
waitfor right 15 ctime 14
FULFILL
PUBLISH
waitfor output 15 ctime 14
tick 15
ROTATE left_back_hoof 0 0 1 1
step 15
ROTATE left_back_hoof 0 0 1 -1
waitfor left 16 ctime 15
ROTATE right_back_hoof 0 0 1 1
waitfor right 16 ctime 15
FULFILL
PUBLISH
waitfor output 16 ctime 15
tick 16
ROTATE left_back_hoof 0 0 1 -1
waitfor left 17 ctime 16
ROTATE right_back_hoof 0 0 1 1
step 16
ROTATE right_back_hoof 0 0 1 -1
waitfor right 17 ctime 16
FULFILL
PUBLISH
waitfor output 17 ctime 16
tick 17
ROTATE left_back_hoof 0 0 1 1
waitfor left 18 ctime 17
ROTATE right_back_hoof 0 0 1 -1
waitfor right 18 ctime 17
FULFILL
PUBLISH
waitfor output 18 ctime 17
tick 18
ROTATE left_back_hoof 0 0 1 1
step 18
ROTATE left_back_hoof 0 0 1 -1
waitfor left 19 ctime 18
ROTATE right_back_hoof 0 0 1 1
waitfor right 19 ctime 18
FULFILL
PUBLISH
waitfor output 19 ctime 18
tick 19
ROTATE left_back_hoof 0 0 1 -1
waitfor left 20 ctime 19
ROTATE right_back_hoof 0 0 1 1
step 19
ROTATE right_back_hoof 0 0 1 -1
waitfor right 20 ctime 19
FULFILL
PUBLISH
waitfor output 20 ctime 19
tick 20
ROTATE left_back_hoof 0 0 1 1
waitfor left 21 ctime 20
ROTATE right_back_hoof 0 0 1 -1
waitfor right 21 ctime 20
FULFILL
PUBLISH
waitfor output 21 ctime 20
tick 21
ROTATE left_back_hoof 0 0 1 1
step 21
ROTATE left_back_hoof 0 0 1 -1
waitfor left 22 ctime 21
ROTATE right_back_hoof 0 0 1 1
waitfor right 22 ctime 21
FULFILL
PUBLISH
waitfor output 22 ctime 21
tick 22
ROTATE left_back_hoof 0 0 1 -1
waitfor left 23 ctime 22
ROTATE right_back_hoof 0 0 1 1
step 22
ROTATE right_back_hoof 0 0 1 -1
waitfor right 23 ctime 22
FULFILL
PUBLISH
waitfor output 23 ctime 22
tick 23
ROTATE left_back_hoof 0 0 1 1
waitfor left 24 ctime 23
ROTATE right_back_hoof 0 0 1 -1
waitfor right 24 ctime 23
FULFILL
PUBLISH
waitfor output 24 ctime 23
tick 24
ROTATE left_back_hoof 0 0 1 1
step 24
ROTATE left_back_hoof 0 0 1 -1
waitfor left 25 ctime 24
ROTATE right_back_hoof 0 0 1 1
waitfor right 25 ctime 24
FULFILL
PUBLISH
waitfor output 25 ctime 24
tick 25
ROTATE left_back_hoof 0 0 1 -1
waitfor left 26 ctime 25
ROTATE right_back_hoof 0 0 1 1
step 25
ROTATE right_back_hoof 0 0 1 -1
waitfor right 26 ctime 25
FULFILL
PUBLISH
waitfor output 26 ctime 25
tick 26
ROTATE left_back_hoof 0 0 1 1
waitfor left 27 ctime 26
ROTATE right_back_hoof 0 0 1 -1
waitfor right 27 ctime 26
FULFILL
PUBLISH
waitfor output 27 ctime 26
tick 27
ROTATE left_back_hoof 0 0 1 1
step 27
ROTATE left_back_hoof 0 0 1 -1
waitfor left 28 ctime 27
ROTATE right_back_hoof 0 0 1 1
waitfor right 28 ctime 27
FULFILL
PUBLISH
waitfor output 28 ctime 27
tick 28
ROTATE left_back_hoof 0 0 1 -1
waitfor left 29 ctime 28
ROTATE right_back_hoof 0 0 1 1
step 28
ROTATE right_back_hoof 0 0 1 -1
waitfor right 29 ctime 28
FULFILL
PUBLISH
waitfor output 29 ctime 28
tick 29
ROTATE left_back_hoof 0 0 1 1
waitfor left 30 ctime 29
ROTATE right_back_hoof 0 0 1 -1
waitfor right 30 ctime 29
FULFILL
PUBLISH
waitfor output 30 ctime 29
tick 30
ROTATE left_back_hoof 0 0 1 1
ROTATE right_back_hoof 0 0 1 1
waitfor right 31 ctime 30
FULFILL
PUBLISH
waitfor output 31 ctime 30
tick 31
ROTATE right_back_hoof 0 0 1 1
FULFILL
PUBLISH
OUTPUT356
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 357.
if test $result = ok -a $start_test_number -le 357; then
	echo test 357
        cat >$test_file <<'TEST357'
var k;
//putln ("#env=", #env);
for (k in env)
  putln (k, "=", env {k});
TEST357
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sort $stdout | awk '/^(HOSTNAME|USER|MACHTYPE|TERMCAP|LANG|DISPLAY|LOGNAME|COLUMNS|TERM|OSTYPE)/ && length != 0' >$ftemp
		sh -c 'env' | sort | awk '/^(HOSTNAME|USER|MACHTYPE|TERMCAP|LANG|DISPLAY|LOGNAME|COLUMNS|TERM|OSTYPE)/ && length != 0' >$ftemp2
                echo '      ' $CMP $ftemp $ftemp2
                if $CMP $ftemp $ftemp2; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 358.
if test $result = ok -a $start_test_number -le 358; then
	echo test 358
        cat >$test_file <<'TEST358'
putln (log (-1.0));
TEST358
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT358' && $CMP $stderr $ftemp2; then
test.d:1:13: system error - domain error: `log'
OUTPUT358
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 359.
if test $result = ok -a $start_test_number -le 359; then
	echo test 359
        cat >$test_file <<'TEST359'
putln (pow (-10, 1000));
TEST359
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT359' && $CMP $stderr $ftemp2; then
test.d:1:13: system error - result too big (small): `pow'
OUTPUT359
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 360.
if test $result = ok -a $start_test_number -le 360; then
	echo test 360
        cat >$test_file <<'TEST360'
putln (sqrt (-10.0));
TEST360
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT360' && $CMP $stderr $ftemp2; then
test.d:1:14: system error - domain error: `sqrt'
OUTPUT360
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 361.
if test $result = ok -a $start_test_number -le 361; then
	echo test 361
        cat >$test_file <<'TEST361'
putln (rand ());
putln (rand ());
srand ();
putln (rand ());
putln (rand ());
srand ();
putln (rand ());
putln (rand ());
srand (10);
putln (rand ());
putln (rand ());
srand (10.0);
putln (rand ());
putln (rand ());
srand ("10.0");
putln (rand ());
putln (rand ());
TEST361
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		awk '!/^0\.[0-9]+$/' $stdout >$ftemp
                echo '      ' $CMP $ftemp $ftemp2
                if cat >$ftemp2 <<'OUTPUT361' && $CMP $ftemp $ftemp2; then
OUTPUT361
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 362.
if test $result = ok -a $start_test_number -le 362; then
	echo test 362
        cat >$test_file <<'TEST362'
println (table ([]));
println (table ([5:10]));
println (table (101));
println (table ('c'));
println (table (10.1));
println (table ([5:10, "c"]));
println (table ({}));
println (table ({"a":10.0, 10:5}));
println (vector ({}));
println (vector ({"e":5, "g": 6}));
println (vector (101));
println (vector ('c'));
println (vector (10.1));
println (vector ([]));
println (vector ("abcd"));
println (vector ([3:3]));
TEST362
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT362' && $CMP $stdout $ftemp2; then
{}
{0:10, 1:10, 2:10, 3:10, 4:10}
{0:'1', 1:'0', 2:'1'}
{0:'c'}
{0:'1', 1:'0', 2:'.', 3:'1'}
{0:10, 1:10, 2:10, 3:10, 4:10, 5:"c"}
{}
{"a":10, 10:5}
[]
["e", 5, "g", 6]
"101"
"c"
"10.1"
[]
"abcd"
[3, 3, 3]
OUTPUT362
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 363.
if test $result = ok -a $start_test_number -le 363; then
	echo test 363
        cat >$test_file <<'TEST363'
func f () {}
var v = table (f);
TEST363
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT363' && $CMP $stderr $ftemp2; then
test.d:2:15: invalid operand type table (...)
OUTPUT363
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 364.
if test $result = ok -a $start_test_number -le 364; then
	echo test 364
        cat >$test_file <<'TEST364'
var v = table (nil);
TEST364
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT364' && $CMP $stderr $ftemp2; then
test.d:1:14: run time error - invalid type of operand of table (...)
OUTPUT364
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 365.
if test $result = ok -a $start_test_number -le 365; then
	echo test 365
        cat >$test_file <<'TEST365'
func f () {}
var v = vector (f);
TEST365
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT365' && $CMP $stderr $ftemp2; then
test.d:2:16: invalid operand type vector (...)
OUTPUT365
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 366.
if test $result = ok -a $start_test_number -le 366; then
	echo test 366
        cat >$test_file <<'TEST366'
var v = vector (nil);
TEST366
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT366' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid type of operand of vector (...)
OUTPUT366
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 367.
if test $result = ok -a $start_test_number -le 367; then
	echo test 367
        cat >$test_file <<'TEST367'
println (keys ({}));
println (keys ({8:5, 7:7}));
println (keys ({"a":5, "ha":7}));
TEST367
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT367' && $CMP $stdout $ftemp2; then
[]
[7, 8]
["a", "ha"]
OUTPUT367
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 368.
if test $result = ok -a $start_test_number -le 368; then
	echo test 368
        cat >$test_file <<'TEST368'
var v = keys ([]);
TEST368
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT368' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid parameter type of `keys'
OUTPUT368
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 369.
if test $result = ok -a $start_test_number -le 369; then
	echo test 369
        cat >$test_file <<'TEST369'
var v = keys ();
TEST369
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT369' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid number of parameters of `keys'
OUTPUT369
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 370.
if test $result = ok -a $start_test_number -le 370; then
	echo test 370
        cat >$test_file <<'TEST370'
println (cmpv ("var", "if"));
println (cmpv ([10, 12], [10, 11, nil]));
println (cmpv ([10.0, 12.0], [10.0]));
println (cmpv ([10.0, 12], [10.0, 11, 13.0]));
println (cmpv ([10.0, 12.0], [10.0, 12.0]));
println (cmpv (10, 'c'));
println (cmpv ([], []));
println (cmpv ([], [10]));
TEST370
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT370' && $CMP $stdout $ftemp2; then
1
1
1
1
0
-1
0
-1
OUTPUT370
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 371.
if test $result = ok -a $start_test_number -le 371; then
	echo test 371
        cat >$test_file <<'TEST371'
cmpv ();
TEST371
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT371' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of parameters of `cmpv'
OUTPUT371
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 372.
if test $result = ok -a $start_test_number -le 372; then
	echo test 372
        cat >$test_file <<'TEST372'
cmpv ([], nil);
TEST372
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT372' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `cmpv'
OUTPUT372
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 373.
if test $result = ok -a $start_test_number -le 373; then
	echo test 373
        cat >$test_file <<'TEST373'
cmpv ([10, 11], [10, 'c']);
TEST373
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT373' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `cmpv'
OUTPUT373
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 374.
if test $result = ok -a $start_test_number -le 374; then
	echo test 374
        cat >$test_file <<'TEST374'
var i, key, voc = {};
for (;;)
  try {
    var ln, a;

    ln = getln ();
    if (ln == "")
      continue;
    a = split (ln, "[^[:alnum:]]");
    for (i = 0; i < #a; i++)
      voc {a[i]} = (a[i] in voc ? voc {a[i]} + 1 : 1);
  } catch (invcalls.eof) {
    break;
  }
key = sort (keys (voc), cmpv);
for (i = 0; i < #key; i++)
  putln (key[i], " : ", voc{key[i]});
TEST374
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout <<'INPUT374' ; then

var i, prime, k, count, iter, flags;
var final SieveSize = 8190;

flags = [SieveSize + 1 : 0];
for (iter = 0; iter < 10; iter++;)
  {
    count = 0;
    for (i = 0; i <= SieveSize; i++)
      flags[i] = 1;
    for (i = 0; i <= SieveSize; i++;)
      if (flags[i])
        {
          prime = i + i + 3;
          k = i + prime;
          for (;1;;)
            {
	      if (k > SieveSize)
                break;
              flags[k] = 0;
              k += prime;
            }
          count++;
        }
  }
putln (count);
INPUT374
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT374' && $CMP $stdout $ftemp2; then
0 : 6
1 : 3
10 : 1
3 : 1
8190 : 1
SieveSize : 5
break : 1
count : 4
final : 1
flags : 5
for : 4
i : 12
if : 2
iter : 4
k : 5
prime : 4
putln : 1
var : 2
OUTPUT374
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 375.
if test $result = ok -a $start_test_number -le 375; then
	echo test 375
        cat >$test_file <<'TEST375'
putln (tolower ("abcd"));
putln (tolower ("ABCD"));
putln (tolower (10));
putln (tolower (10e10));
putln (tolower ('c'));
putln (tolower ('C'));
//
putln (toupper ("abcd"));
putln (toupper ("ABCD"));
putln (toupper (10));
putln (toupper (10e10));
putln (toupper ('c'));
putln (toupper ('C'));
TEST375
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout ; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT375' && $CMP $stdout $ftemp2; then
abcd
abcd
10
1e+11
c
c
ABCD
ABCD
10
1E+11
C
C
OUTPUT375
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT375-1' && $CMP $stdout $ftemp2; then
abcd
abcd
10
1e+011
c
c
ABCD
ABCD
10
1E+011
C
C
OUTPUT375-1
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 376.
if test $result = ok -a $start_test_number -le 376; then
	echo test 376
        cat >$test_file <<'TEST376'
tolower ();
TEST376
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT376' && $CMP $stderr $ftemp2; then
test.d:1:10: run time error - invalid number of parameters of `tolower'
OUTPUT376
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 377.
if test $result = ok -a $start_test_number -le 377; then
	echo test 377
        cat >$test_file <<'TEST377'
tolower (nil);
TEST377
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT377' && $CMP $stderr $ftemp2; then
test.d:1:10: run time error - invalid parameter type of `tolower'
OUTPUT377
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 378.
if test $result = ok -a $start_test_number -le 378; then
	echo test 378
        cat >$test_file <<'TEST378'
tolower ();
TEST378
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT378' && $CMP $stderr $ftemp2; then
test.d:1:10: run time error - invalid number of parameters of `tolower'
OUTPUT378
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 379.
if test $result = ok -a $start_test_number -le 379; then
	echo test 379
        cat >$test_file <<'TEST379'
tolower (nil);
TEST379
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT379' && $CMP $stderr $ftemp2; then
test.d:1:10: run time error - invalid parameter type of `tolower'
OUTPUT379
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 380.
if test $result = ok -a $start_test_number -le 380; then
	echo test 380
        cat >$test_file <<'TEST380'
a
TEST380
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT380' && $CMP $stderr $ftemp2; then
test.d:2:0: syntax error
OUTPUT380
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 381.
if test $result = ok -a $start_test_number -le 381; then
	echo test 381
        cat >$test_file <<'TEST381'
// vector
var v;
// pack
v = [1, 2, 3, 4, 5, 6]; v = subv (v, 2); println (v);
v = [1, 2, 3, 4, 5, 6]; v = subv (v, -2, 2); println (v);
v = [1, 2, 3, 4, 5, 6]; v = subv (v, 2, 2); println (v);
v = [1, 2, 3, 4, 5, 6]; v = subv (v, 2, -1); println (v);
v = [1, 2, 3, 4, 5, 6]; v = subv (v, 2, 0); println (v);
// unpack
v = [1, 2.0, 3.0, 4, 5, 6]; v = subv (v, 2); println (v);
v = [1.0, 2, 3, 4, 5, 6]; v = subv (v, -2, 2); println (v);
v = [1.0, 2, 3, 4, 5, 6]; v = subv (v, 2, 2); println (v);
v = [1.0, 2, 3, 4, 5, 6]; v = subv (v, 2, -1); println (v);
v = [1.0, 2, 3, 4, 5, 6]; v = subv (v, 2, 0); println (v);
// empty
v = []; v = subv (v, 0); println (v);
v = []; v = subv (v, -2, 1); println (v);
v = []; v = subv (v, 0, 1); println (v);
v = []; v = subv (v, 1, 0); println (v);
v = []; v = subv (v, 0, -1); println (v);
// string
v = new "123456"; v = subv (v, 2, 2); putln (v);
v = new "123456"; v = subv (v, -2, 2); putln (v);
v = new "123456"; v = subv (v, 2, 0); println (v);
var i, iter, t;
for (iter = 0; iter < 1000; iter++)
  { 
    v = [1000:1];
    for (i = 0; i < 1000; i++)
      t = subv (v, 2, 2);
  }
println (t);
TEST381
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT381' && $CMP $stdout $ftemp2; then
[3, 4, 5, 6]
[1, 2]
[3, 4]
[3, 4, 5, 6]
[]
[3, 4, 5, 6]
[1, 2]
[3, 4]
[3, 4, 5, 6]
[]
[]
[]
[]
[]
[]
34
12
""
[1, 1]
OUTPUT381
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 382.
if test $result = ok -a $start_test_number -le 382; then
	echo test 382
        cat >$test_file <<'TEST382'
subv ();
TEST382
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT382' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of parameters of `subv'
OUTPUT382
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 383.
if test $result = ok -a $start_test_number -le 383; then
	echo test 383
        cat >$test_file <<'TEST383'
subv (10);
TEST383
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT383' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of parameters of `subv'
OUTPUT383
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 384.
if test $result = ok -a $start_test_number -le 384; then
	echo test 384
        cat >$test_file <<'TEST384'
subv (nil, 10);
TEST384
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT384' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `subv'
OUTPUT384
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 385.
if test $result = ok -a $start_test_number -le 385; then
	echo test 385
        cat >$test_file <<'TEST385'
subv (10,10,10,10);
TEST385
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT385' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of parameters of `subv'
OUTPUT385
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 386.
if test $result = ok -a $start_test_number -le 386; then
	echo test 386
        cat >$test_file <<'TEST386'
var t;
t = {10}; subv (t, 10, 10);
TEST386
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT386' && $CMP $stderr $ftemp2; then
test.d:2:16: run time error - invalid parameter type of `subv'
OUTPUT386
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 387.
if test $result = ok -a $start_test_number -le 387; then
	echo test 387
        cat >$test_file <<'TEST387'
var v;
v = []; subv (v, {});
TEST387
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT387' && $CMP $stderr $ftemp2; then
test.d:2:14: run time error - invalid parameter type of `subv'
OUTPUT387
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 388.
if test $result = ok -a $start_test_number -le 388; then
	echo test 388
        cat >$test_file <<'TEST388'
var v;
v = []; subv (v, 0, {});
TEST388
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT388' && $CMP $stderr $ftemp2; then
test.d:2:14: run time error - invalid parameter type of `subv'
OUTPUT388
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 389.
if test $result = ok -a $start_test_number -le 389; then
	echo test 389
        cat >$test_file <<'TEST389'
exit (1);
putln (stderr, "ahaha");
TEST389
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT389' && $CMP $stderr $ftemp2; then
OUTPUT389
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 390.
if test $result = ok -a $start_test_number -le 390; then
	echo test 390
        cat >$test_file <<'TEST390'
exit (0);
putln ("ahaha");
TEST390
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT390' && $CMP $stdout $ftemp2; then
OUTPUT390
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 391.
if test $result = ok -a $start_test_number -le 391; then
	echo test 391
        cat >$test_file <<'TEST391'
exit ();
TEST391
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT391' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of parameters of `exit'
OUTPUT391
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 392.
if test $result = ok -a $start_test_number -le 392; then
	echo test 392
        cat >$test_file <<'TEST392'
exit (1, 1);
TEST392
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT392' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid number of parameters of `exit'
OUTPUT392
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 393.
if test $result = ok -a $start_test_number -le 393; then
	echo test 393
        cat >$test_file <<'TEST393'
exit (nil);
TEST393
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT393' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `exit'
OUTPUT393
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 394.
if test $result = ok -a $start_test_number -le 394; then
	echo test 394
        cat >$test_file <<'TEST394'
putln (max (1.5, 2));
putln (min (1.5, 2));
putln (max (1.5, 2, "3.0"));
putln (min (1.5, 2, "3.0"));
putln (min (1.5, 2, 'a'));
putln (max (1.5, 2, 'a'));
putln (min (1.5, 2, 'a'));
TEST394
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT394' && $CMP $stdout $ftemp2; then
2
1.5
3
1.5
1.5
97
1.5
OUTPUT394
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 395.
if test $result = ok -a $start_test_number -le 395; then
	echo test 395
        cat >$test_file <<'TEST395'
max (1);
TEST395
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT395' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of parameters of `max'
OUTPUT395
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 396.
if test $result = ok -a $start_test_number -le 396; then
	echo test 396
        cat >$test_file <<'TEST396'
min (1);
TEST396
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT396' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of parameters of `min'
OUTPUT396
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 397.
if test $result = ok -a $start_test_number -le 397; then
	echo test 397
        cat >$test_file <<'TEST397'
max ();
TEST397
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT397' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of parameters of `max'
OUTPUT397
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 398.
if test $result = ok -a $start_test_number -le 398; then
	echo test 398
        cat >$test_file <<'TEST398'
min ();
TEST398
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT398' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid number of parameters of `min'
OUTPUT398
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 399.
if test $result = ok -a $start_test_number -le 399; then
	echo test 399
        cat >$test_file <<'TEST399'
max (nil, nil);
TEST399
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT399' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `max'
OUTPUT399
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 400.
if test $result = ok -a $start_test_number -le 400; then
	echo test 400
        cat >$test_file <<'TEST400'
min (nil, nil);
TEST400
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT400' && $CMP $stderr $ftemp2; then
test.d:1:6: run time error - invalid parameter type of `min'
OUTPUT400
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 401.
if test $result = ok -a $start_test_number -le 401; then
	echo test 401
        cat >$test_file <<'TEST401'
class c (par) {
  class sc (i) {
  }
}

var i=c(10).sc(20);
putln (i.par, " ", i.i);
i.par = 15;
putln (i.par, " ", i.i);
TEST401
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT401' && $CMP $stdout $ftemp2; then
10 20
15 20
OUTPUT401
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 402.
if test $result = ok -a $start_test_number -le 402; then
	echo test 402
        cat >$test_file <<'TEST402'
func f (par) {
  class sc (i) {
  }
  return sc;
}

var i=f(10)(20);
putln (i.par);
TEST402
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT402' && $CMP $stderr $ftemp2; then
test.d:8:9: run time error - there is no such declaration in given class
OUTPUT402
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 403.
if test $result = ok -a $start_test_number -le 403; then
	echo test 403
        cat >$test_file <<'TEST403'
var c;
{
  class sc (i) {
  }
  c = sc;
}

var i=c(20);
putln (i.par);
TEST403
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT403' && $CMP $stderr $ftemp2; then
test.d:9:7: there is no such declaration in a block
OUTPUT403
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 404.
if test $result = ok -a $start_test_number -le 404; then
	echo test 404
        cat >$test_file <<'TEST404'
var i = 0;
include "../DINO/../DINO/test1";
i = 1;
include +"../DINO/..//////DINO/test1";
i = 2;
{
  include "../DINO/../DINO/test1";
  i = 3;
  include "../DINO/..//////DINO/test1";
  i = 4;
  include +"../DINO/../DINO/test1";
}
i = 5;
include "../DINO/../DINO/test1";
i = 6;
include +"../DINO/..//////DINO/test1";
TEST404
        cat >$test_file_1 <<'TEST404-1'
putln (i);
TEST404-1
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT404' && $CMP $stdout $ftemp2; then
0
1
2
4
6
OUTPUT404
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 406.
if test $result = ok -a $start_test_number -le 406; then
	echo test 406
        cat >$test_file <<'TEST406'
inside (nil);
TEST406
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT406' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of parameters of `inside'
OUTPUT406
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 407.
if test $result = ok -a $start_test_number -le 407; then
	echo test 407
        cat >$test_file <<'TEST407'
inside (nil, nil, nil, nil);
TEST407
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT407' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid number of parameters of `inside'
OUTPUT407
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 408.
if test $result = ok -a $start_test_number -le 408; then
	echo test 408
        cat >$test_file <<'TEST408'
class c() {}
inside (c, c, nil);
TEST408
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT408' && $CMP $stderr $ftemp2; then
test.d:2:8: run time error - invalid parameter type of `inside'
OUTPUT408
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 409.
if test $result = ok -a $start_test_number -le 409; then
	echo test 409
        cat >$test_file <<'TEST409'
class c() {}
inside (c, c());
TEST409
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT409' && $CMP $stderr $ftemp2; then
test.d:2:8: run time error - invalid parameter type of `inside'
OUTPUT409
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 410.
if test $result = ok -a $start_test_number -le 410; then
	echo test 410: Parsing expression
        cat >$test_file <<'TEST410'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(a+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (p.ambiguous_p);
TEST410
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT410' && $CMP $stdout $ftemp2; then
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      $term(97, 5)
      mult(
        $term(97, 7)
        $term(97, 9)
      )
    )
  )
)
OUTPUT410
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 411.
if test $result = ok -a $start_test_number -le 411; then
	echo test 411: Undefined grammar
        cat >$test_file <<'TEST411'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST411
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT411' && $CMP $stderr $ftemp2; then
test.d:32:20: run time error (parse) -- undefined or bad grammar
OUTPUT411
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 412.
if test $result = ok -a $start_test_number -le 412; then
	echo test 412: Already defined grammar.
        cat >$test_file <<'TEST412'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);
p.set_grammar (g, 1);

var str = "a+a*(a+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST412
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT412' && $CMP $stdout $ftemp2; then
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      $term(97, 5)
      mult(
        $term(97, 7)
        $term(97, 9)
      )
    )
  )
)
OUTPUT412
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 413.
if test $result = ok -a $start_test_number -le 413; then
	echo test 413: Description syntax error.
        cat >$test_file <<'TEST413'
var g = "TERM 1\n\
         E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST413
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT413' && $CMP $stderr $ftemp2; then
test.d:16:15: run time error (set_grammar) -- description syntax error on ln 1
OUTPUT413
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 414.
if test $result = ok -a $start_test_number -le 414; then
	echo test 414: error in the left side of the rule.
        cat >$test_file <<'TEST414'
var g = "TERM;\n\
         error : T         # 0\n\
         E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST414
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT414' && $CMP $stderr $ftemp2; then
test.d:17:15: run time error (set_grammar) -- term `error' in the left hand side of rule
OUTPUT414
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 415.
if test $result = ok -a $start_test_number -le 415; then
	echo test 415: The same code for terminals.
        cat >$test_file <<'TEST415'
var g = "TERM ident=10 i=10;\n\
         E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST415
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT415' && $CMP $stderr $ftemp2; then
test.d:16:15: run time error (set_grammar) -- repeated code 10 in term `i'
OUTPUT415
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 416.
if test $result = ok -a $start_test_number -le 416; then
	echo test 416: No rules.
        cat >$test_file <<'TEST416'
var g = "TERM ident=10;\n";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST416
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT416' && $CMP $stderr $ftemp2; then
test.d:9:15: run time error (set_grammar) -- grammar does not contains rules
OUTPUT416
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 417.
if test $result = ok -a $start_test_number -le 417; then
	echo test 417: Term in the left hand side of rule.
        cat >$test_file <<'TEST417'
var g = "TERM ident=10;\n\
         ident : 'a'\n\
         E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST417
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT417' && $CMP $stderr $ftemp2; then
test.d:17:15: run time error (set_grammar) -- term `ident' in the left hand side of rule
OUTPUT417
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 418.
if test $result = ok -a $start_test_number -le 418; then
	echo test 418: Incorrect translation number.
        cat >$test_file <<'TEST418'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 1\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST418
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT418' && $CMP $stderr $ftemp2; then
test.d:15:15: run time error (set_grammar) -- translation symbol number 1 in rule for `E' is out of range
OUTPUT418
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 419.
if test $result = ok -a $start_test_number -le 419; then
	echo test 419: Repeated translation symbol number.
        cat >$test_file <<'TEST419'
var g = "E : E '+' T # plus (0 0)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST419
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT419' && $CMP $stderr $ftemp2; then
test.d:15:15: run time error (set_grammar) -- repeated translation symbol number 0 in rule for `E'
OUTPUT419
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 420.
if test $result = ok -a $start_test_number -le 420; then
	echo test 420: No derivations.
        cat >$test_file <<'TEST420'
var g = "E : 'a' E\n\
           | E '+'";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST420
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT420' && $CMP $stderr $ftemp2; then
test.d:10:15: run time error (set_grammar) -- nonterm `E' does not derive any term string
OUTPUT420
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 421.
if test $result = ok -a $start_test_number -le 421; then
	echo test 421: Grammar loops.
        cat >$test_file <<'TEST421'
var g = "E : A O O\n\
           | E 'a'\n\
           | 'b'\n\
           |\n\
         A : O O N\n\
         N : O E E O\n\
         O :\n";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST421
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT421' && $CMP $stderr $ftemp2; then
test.d:15:15: run time error (set_grammar) -- nonterm `E' can derive only itself (grammar with loops)
OUTPUT421
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 422.
if test $result = ok -a $start_test_number -le 422; then
	echo test 422: Invalid token code.
        cat >$test_file <<'TEST422'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*b)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST422
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT422' && $CMP $stderr $ftemp2; then
test.d:33:20: run time error (parse) -- invalid token code 98
OUTPUT422
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 423.
if test $result = ok -a $start_test_number -le 423; then
	echo test 423: Unaccessible nonterm.
        cat >$test_file <<'TEST423'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         G : 'a'       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*b)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST423
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT423' && $CMP $stderr $ftemp2; then
test.d:16:15: run time error (set_grammar) -- nonterm `G' is not accessible from axiom
OUTPUT423
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 424.
if test $result = ok -a $start_test_number -le 424; then
	echo test 424: Fixed name error.
        cat >$test_file <<'TEST424'
var g = "TERM error=10;\n\
         E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(+a*b)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST424
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT424' && $CMP $stderr $ftemp2; then
test.d:16:15: run time error (set_grammar) -- do not use fixed name `error'
OUTPUT424
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 425.
if test $result = ok -a $start_test_number -le 425; then
	echo test 425: Error recovery.
        cat >$test_file <<'TEST425'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(a*+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST425
        echo '      ' "$DINO $test_file 2>$stderr >$stdout"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT425' && $CMP $stdout $ftemp2; then
syntax error on token #7 (43) -- ignore 10 tokens starting with token #0
$nil
OUTPUT425
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 426.
if test $result = ok -a $start_test_number -le 426; then
	echo test 426: More error recovery.
        cat >$test_file <<'TEST426'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(a*+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST426
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT426' && $CMP $stdout $ftemp2; then
syntax error on token #7 (43) -- ignore 4 tokens starting with token #5
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    $error
  )
)
OUTPUT426
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 427.
if test $result = ok -a $start_test_number -le 427; then
	echo test 427: More error recovery.
        cat >$test_file <<'TEST427'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST427
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT427' && $CMP $stdout $ftemp2; then
syntax error on token #5 (42) -- ignore 4 tokens starting with token #5
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    $error
  )
)
OUTPUT427
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 428.
if test $result = ok -a $start_test_number -le 428; then
	echo test 428: Ambiguous grammar.
        cat >$test_file <<'TEST428'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | '(' E ')' # 1\n";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (1);
p.set_grammar (g, 1);

var str = "a+a*(a*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (!p.ambiguous_p);
TEST428
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT428' && $CMP $stdout $ftemp2; then
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      mult(
        $term(97, 5)
        $term(97, 7)
      )
      $term(97, 9)
    )
  )
)
OUTPUT428
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 429.
if test $result = ok -a $start_test_number -le 429; then
	echo test 429: More ambiguous grammar.
        cat >$test_file <<'TEST429'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | '(' E ')' # 1\n";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(a*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST429
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT429' && $CMP $stdout $ftemp2; then
$alt(
  mult(
    plus(
      $term(97, 0)
      $term(97, 2)
    )
    $alt(
      mult(
        $term(97, 5)
        plus(
          $term(97, 7)
          $term(97, 9)
        )
      )
      plus(
        mult(
          $term(97, 5)
          $term(97, 7)
        )
        $term(97, 9)
      )
    )
  )
  plus(
    $term(97, 0)
    mult(
      $term(97, 2)
      $alt(
        mult(
          $term(97, 5)
          plus(
            $term(97, 7)
            $term(97, 9)
          )
        )
        plus(
          mult(
            $term(97, 5)
            $term(97, 7)
          )
          $term(97, 9)
        )
      )
    )
  )
)
OUTPUT429
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 430.
if test $result = ok -a $start_test_number -le 430; then
	echo test 430: Ambiguous grammar with error recovery
        cat >$test_file <<'TEST430'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | '(' E ')' # 1\n";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (1);
p.set_grammar (g, 1);

var str = "a+a*(*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST430
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT430' && $CMP $stdout $ftemp2; then
syntax error on token #5 (42) -- ignore 10 tokens starting with token #0
$nil
OUTPUT430
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 431.
if test $result = ok -a $start_test_number -le 431; then
	echo test 431: More ambiguous grammar with error recovery
        cat >$test_file <<'TEST431'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1\n";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (1);
p.set_grammar (g, 1);

var str = "a+a*(*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST431
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT431' && $CMP $stdout $ftemp2; then
syntax error on token #5 (42) -- ignore 4 tokens starting with token #5
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    $error
  )
)
OUTPUT431
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 432.
if test $result = ok -a $start_test_number -le 432; then
	echo test 432: More ambiguous grammar with error recovery
        cat >$test_file <<'TEST432'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1\n";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST432
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT432' && $CMP $stdout $ftemp2; then
syntax error on token #5 (42) -- ignore 4 tokens starting with token #5
$alt(
  mult(
    plus(
      $term(97, 0)
      $term(97, 2)
    )
    $error
  )
  plus(
    $term(97, 0)
    mult(
      $term(97, 2)
      $error
    )
  )
)
OUTPUT432
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 433.
if test $result = ok -a $start_test_number -le 433; then
	echo test 433: Error recovery with 2 errors.
        cat >$test_file <<'TEST433'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(a*)+(*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST433
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT433' && $CMP $stdout $ftemp2; then
syntax error on token #7 (41) -- ignore 2 tokens starting with token #5
syntax error on token #10 (42) -- ignore 2 tokens starting with token #10
plus(
  plus(
    $term(97, 0)
    mult(
      $term(97, 2)
      $error
    )
  )
  $error
)
OUTPUT433
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 434.
if test $result = ok -a $start_test_number -le 434; then
	echo test 434: More error recovery with 2 errors.
        cat >$test_file <<'TEST434'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_recovery_match (4);
p.set_grammar (g, 1);

var str = "a+a*(a*)+(*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (p.ambiguous_p);
TEST434
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT434' && $CMP $stdout $ftemp2; then
syntax error on token #7 (41) -- ignore 4 tokens starting with token #5
plus(
  plus(
    $term(97, 0)
    mult(
      $term(97, 2)
      $error
    )
  )
  $error
)
OUTPUT434
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 435.
if test $result = ok -a $start_test_number -le 435; then
	echo test 435: More ambiguous grammar.
        cat >$test_file <<'TEST435'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | 'b' # 0\n\
           | 'c' # 0\n\
           | 'd' # 0\n\
           | '(' E ')' # 1\n";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+b*c+d";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (0);
TEST435
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT435' && $CMP $stdout $ftemp2; then
$alt(
  plus(
    $alt(
      mult(
        plus(
          $term(97, 0)
          $term(98, 2)
        )
        $term(99, 4)
      )
      plus(
        $term(97, 0)
        mult(
          $term(98, 2)
          $term(99, 4)
        )
      )
    )
    $term(100, 6)
  )
  mult(
    plus(
      $term(97, 0)
      $term(98, 2)
    )
    plus(
      $term(99, 4)
      $term(100, 6)
    )
  )
  plus(
    $term(97, 0)
    $alt(
      mult(
        $term(98, 2)
        plus(
          $term(99, 4)
          $term(100, 6)
        )
      )
      plus(
        mult(
          $term(98, 2)
          $term(99, 4)
        )
        $term(100, 6)
      )
    )
  )
)
OUTPUT435
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 436.
if test $result = ok -a $start_test_number -le 436; then
	echo test 436: More ambiguous grammar and GC.
        cat >$test_file <<'TEST436'
var g = "E : E '+' E # plus (0 2)\n\
           | E '*' E # mult (0 2)\n\
           | 'a' # 0\n\
           | 'b' # 0\n\
           | 'c' # 0\n\
           | 'd' # 0\n\
           | '(' E ')' # 1\n";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+b*c+a";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);

var v, iter;

for (iter = 0; iter < 1000; iter++) { 
  v = [];
  for (i = 0; i < 100; i++)
    insv (v, [1]);
  for (i = 0; i < 100; i++)
    del (v, 0);
}

println (v);

pr (root, 0);

exit (!p.ambiguous_p);
TEST436
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT436' && $CMP $stdout $ftemp2; then
$alt(
  plus(
    $term(97, 0)
    $alt(
      mult(
        $term(98, 2)
        plus(
          $term(99, 4)
          $term(97, 6)
        )
      )
      plus(
        mult(
          $term(98, 2)
          $term(99, 4)
        )
        $term(97, 6)
      )
    )
  )
  mult(
    plus(
      $term(97, 0)
      $term(98, 2)
    )
    plus(
      $term(99, 4)
      $term(97, 6)
    )
  )
  plus(
    $alt(
      mult(
        plus(
          $term(97, 0)
          $term(98, 2)
        )
        $term(99, 4)
      )
      plus(
        $term(97, 0)
        mult(
          $term(98, 2)
          $term(99, 4)
        )
      )
    )
    $term(97, 6)
  )
)
[]
$alt(
  plus(
    $term(97, 0)
    $alt(
      mult(
        $term(98, 2)
        plus(
          $term(99, 4)
          $term(97, 6)
        )
      )
      plus(
        mult(
          $term(98, 2)
          $term(99, 4)
        )
        $term(97, 6)
      )
    )
  )
  mult(
    plus(
      $term(97, 0)
      $term(98, 2)
    )
    plus(
      $term(99, 4)
      $term(97, 6)
    )
  )
  plus(
    $alt(
      mult(
        plus(
          $term(97, 0)
          $term(98, 2)
        )
        $term(99, 4)
      )
      plus(
        $term(97, 0)
        mult(
          $term(98, 2)
          $term(99, 4)
        )
      )
    )
    $term(97, 6)
  )
)
OUTPUT436
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 437.
if test $result = ok -a $start_test_number -le 437; then
	echo test 437: Debugging information.
        cat >$test_file <<'TEST437'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (1);
p.set_one_parse (0);
p.set_recovery_match (4);
p.set_grammar (g, 1);

var str = "a+a*(a*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (p.ambiguous_p);
TEST437
        echo '      ' "$DINO $test_file >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT437' && $CMP $stdout $ftemp2; then
Grammar: #terms = 7, #nonterms = 4, #rules = 8, rules size = 24
Input: #tokens = 12, #unique situations = 22
       #terminal sets = 30, their size = 240
       #unique set cores = 10, #their start situations = 25
       #parent indexes for some non start situations = 0
       #unique set dist. vects = 13, their length = 30
       #pairs(set core, symb) = 38, their trans+reduce vects length = 43
       #unique transition vectors = 12, their length = 16
       #unique reduce vectors = 4, their length = 4
       #term nodes = 5, #abstract nodes = 4
       #alternative nodes = 0, #all nodes = 9
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      mult(
        $term(97, 5)
        $term(97, 7)
      )
      $term(97, 9)
    )
  )
)
OUTPUT437
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT437' && $CMP $stdout $ftemp2; then
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      mult(
        $term(97, 5)
        $term(97, 7)
      )
      $term(97, 9)
    )
  )
)
Grammar: #terms = 7, #nonterms = 4, #rules = 8, rules size = 24
Input: #tokens = 12, #unique situations = 22
       #terminal sets = 30, their size = 240
       #unique set cores = 10, #their start situations = 25
       #parent indexes for some non start situations = 0
       #unique set dist. vects = 13, their length = 30
       #pairs(set core, symb) = 38, their trans+reduce vects length = 43
       #unique transition vectors = 12, their length = 16
       #unique reduce vectors = 4, their length = 4
       #term nodes = 5, #abstract nodes = 4
       #alternative nodes = 0, #all nodes = 9
OUTPUT437
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 438.
if test $result = ok -a $start_test_number -le 438; then
	echo test 438: Debugging information.
        cat >$test_file <<'TEST438'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (2);
p.set_one_parse (0);
p.set_recovery_match (4);
p.set_grammar (g, 1);

var str = "a+a*(a*a+a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
exit (p.ambiguous_p);
TEST438
        echo '      ' "$DINO $test_file >$stdout 2>&1"
        if $DINO $test_file >$stdout 2>&1; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT438' && $CMP $stdout $ftemp2; then
Translation:
      0: ABSTRACT: plus ( 1 2 )
      1: TERMINAL: code=97, repr='a'
      2: ABSTRACT: mult ( 3 4 )
      3: TERMINAL: code=97, repr='a'
      4: ABSTRACT: plus ( 5 6 )
      5: ABSTRACT: mult ( 7 8 )
      7: TERMINAL: code=97, repr='a'
      8: TERMINAL: code=97, repr='a'
      6: TERMINAL: code=97, repr='a'

Grammar: #terms = 7, #nonterms = 4, #rules = 8, rules size = 24
Input: #tokens = 12, #unique situations = 22
       #terminal sets = 30, their size = 240
       #unique set cores = 10, #their start situations = 25
       #parent indexes for some non start situations = 0
       #unique set dist. vects = 13, their length = 30
       #pairs(set core, symb) = 38, their trans+reduce vects length = 43
       #unique transition vectors = 12, their length = 16
       #unique reduce vectors = 4, their length = 4
       #term nodes = 5, #abstract nodes = 4
       #alternative nodes = 0, #all nodes = 9
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      mult(
        $term(97, 5)
        $term(97, 7)
      )
      $term(97, 9)
    )
  )
)
OUTPUT438
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT438' && $CMP $stdout $ftemp2; then
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      mult(
        $term(97, 5)
        $term(97, 7)
      )
      $term(97, 9)
    )
  )
)
Translation:
      0: ABSTRACT: plus ( 1 2 )
      1: TERMINAL: code=97, repr='a'
      2: ABSTRACT: mult ( 3 4 )
      3: TERMINAL: code=97, repr='a'
      4: ABSTRACT: plus ( 5 6 )
      5: ABSTRACT: mult ( 7 8 )
      7: TERMINAL: code=97, repr='a'
      8: TERMINAL: code=97, repr='a'
      6: TERMINAL: code=97, repr='a'

Grammar: #terms = 7, #nonterms = 4, #rules = 8, rules size = 24
Input: #tokens = 12, #unique situations = 22
       #terminal sets = 30, their size = 240
       #unique set cores = 10, #their start situations = 25
       #parent indexes for some non start situations = 0
       #unique set dist. vects = 13, their length = 30
       #pairs(set core, symb) = 38, their trans+reduce vects length = 43
       #unique transition vectors = 12, their length = 16
       #unique reduce vectors = 4, their length = 4
       #term nodes = 5, #abstract nodes = 4
       #alternative nodes = 0, #all nodes = 9
OUTPUT438
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 439.
if test $result = ok -a $start_test_number -le 439; then
	echo test 439: Parameter exception.
        cat >$test_file <<'TEST439'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (nil);
p.set_one_parse ("0");

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST439
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT439' && $CMP $stderr $ftemp2; then
test.d:12:13: run time error - invalid parameter type of `set_debug'
OUTPUT439
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 440.
if test $result = ok -a $start_test_number -le 440; then
	echo test 440: More parameter exception.
        cat >$test_file <<'TEST440'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug ("0");
p.set_one_parse (nil);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST440
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT440' && $CMP $stderr $ftemp2; then
test.d:13:17: run time error - invalid parameter type of `set_one_parse'
OUTPUT440
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 441.
if test $result = ok -a $start_test_number -le 441; then
	echo test 441: More parameter exception.
        cat >$test_file <<'TEST441'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery (nil);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST441
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT441' && $CMP $stderr $ftemp2; then
test.d:14:16: run time error - invalid parameter type of `set_recovery'
OUTPUT441
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 442.
if test $result = ok -a $start_test_number -le 442; then
	echo test 442: More parameter exception.
        cat >$test_file <<'TEST442'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match (nil);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST442
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT442' && $CMP $stderr $ftemp2; then
test.d:15:22: run time error - invalid parameter type of `set_recovery_match'
OUTPUT442
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 443.
if test $result = ok -a $start_test_number -le 443; then
	echo test 443: More parameter exception.
        cat >$test_file <<'TEST443'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (['T', 'E', 'R', 'M'], nil);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST443
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT443' && $CMP $stderr $ftemp2; then
test.d:17:15: run time error - invalid parameter type of `set_grammar'
OUTPUT443
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 444.
if test $result = ok -a $start_test_number -le 444; then
	echo test 444: More parameter exception.
        cat >$test_file <<'TEST444'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (nil, 0);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST444
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT444' && $CMP $stderr $ftemp2; then
test.d:17:15: run time error - invalid parameter type of `set_grammar'
OUTPUT444
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 445.
if test $result = ok -a $start_test_number -le 445; then
	echo test 445: More parameter exception.
        cat >$test_file <<'TEST445'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (0, 0);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);
exit (0);
TEST445
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT445' && $CMP $stderr $ftemp2; then
test.d:17:15: run time error - invalid parameter type of `set_grammar'
OUTPUT445
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 446.
if test $result = ok -a $start_test_number -le 446; then
	echo test 446: More parameter exception.
        cat >$test_file <<'TEST446'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, 0);
exit (0);
TEST446
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT446' && $CMP $stderr $ftemp2; then
test.d:35:20: run time error - invalid parameter type of `parse'
OUTPUT446
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 447.
if test $result = ok -a $start_test_number -le 447; then
	echo test 447: More parameter exception.
        cat >$test_file <<'TEST447'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (nil, error);
exit (0);
TEST447
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT447' && $CMP $stderr $ftemp2; then
test.d:35:20: run time error - invalid parameter type of `parse'
OUTPUT447
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 447.
if test $result = ok -a $start_test_number -le 447; then
	echo test 447: More parameter exception.
        cat >$test_file <<'TEST447'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (['a', 'b'], error);
exit (0);
TEST447
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT447' && $CMP $stderr $ftemp2; then
test.d:35:20: run time error - invalid parameter type of `parse'
OUTPUT447
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 448.
if test $result = ok -a $start_test_number -le 448; then
	echo test 448: More parameter exception.
        cat >$test_file <<'TEST448'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (g, 1);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

{
 class token (c) {}
 var root = p.parse ([token ('a'), token ('b')], error);
}
exit (0);
TEST448
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT448' && $CMP $stderr $ftemp2; then
test.d:37:21: run time error (parse) -- invalid token #0
OUTPUT448
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 449.
if test $result = ok -a $start_test_number -le 449; then
	echo test 449: More parameter exception.
        cat >$test_file <<'TEST449'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug ("0");
p.set_one_parse ("0");
p.set_recovery ('\0');
p.set_recovery_match ('\0');

p.set_grammar (g, 0);

var str = "a+a*(+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse ([token ('a'), token ('b')], error);
exit (0);
TEST449
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT449' && $CMP $stderr $ftemp2; then
test.d:35:20: run time error (parse) -- invalid code of token #0
OUTPUT449
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 450.
if test $result = ok -a $start_test_number -le 450; then
	echo test 450: More parameter exception.
        cat >$test_file <<'TEST450'
class c1 () {friend g; var a; private a;}
TEST450
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT450' && $CMP $stderr $ftemp2; then
test.d:1:21: there is no declaration for identifier `g' in access list
OUTPUT450
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 451.
if test $result = ok -a $start_test_number -le 451; then
	echo test 451: More parameter exception.
        cat >$test_file <<'TEST451'
class c1 () {friend g; var a; private a;}
var g;
TEST451
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT451' && $CMP $stderr $ftemp2; then
test.d:1:21: friend identifier `g' is neither function nor class
OUTPUT451
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 452.
if test $result = ok -a $start_test_number -le 452; then
	echo test 452
        cat >$test_file <<'TEST452'
class c1 () {friend c2; var a = 10; private a;}
var i1 = c1 ();
class c2 () {var a; a = i1.a;}
var i2 = c2 ();
putln (i2.a);
TEST452
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT452' && $CMP $stdout $ftemp2; then
10
OUTPUT452
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 453.
if test $result = ok -a $start_test_number -le 453; then
	echo test 453: IEEE package
        cat >$test_file <<'TEST453'
// There is no goal to test IEEE package we simply testing all
// functions of ieee.d

include "ieee";

var s1 = ieees.single(), s2 = ieees.single();
putln ("*******IEEE singles:**********");

putln ("pzero s1 (2, 4, 8, 16)=", s1.to_binary_string (2), ", ",
       s1.to_binary_string (4), ", ", s1.to_binary_string (8), ", ",
       s1.to_binary_string (16));
putln ("pzero s1=", s1.to_string ());
putln ("pzero s2 (2, 4, 8, 16)=", s2.to_binary_string (2), ", ",
       s2.to_binary_string (4), ", ", s2.to_binary_string (8), ", ",
       s2.to_binary_string (16));
putln ("pzero s2=", s2.to_string ());

s1 = ieees.single("0");
s2 = ieees.single("0");

s1.nzero();
putln ("-zero s1=", s1.to_string (), " s1 is -zero = ", s1.is_nzero ());
s1.nan();
putln ("nan s1=", s1.to_string (), " s1 is nan = ", s1.is_nan ());
s1.trap_nan();
putln ("trap nan s1=", s1.to_string (),
       " s1 is trap nan = ", s1.is_trap_nan ());
s1.pinfinity();
putln ("+infinity s1=", s1.to_string (),
       " s1 is +infinity = ", s1.is_pinfinity ());
s1.ninfinity();
putln ("-infinity s1=", s1.to_string (),
       " s1 is -infinity = ", s1.is_ninfinity ());
s1.pmax();
putln ("+max s1 (10, 16)=", s1.to_string (), ", ", s1.to_binary_string (16),
       " s1 is norm = ", s1.is_normalized ());
s1.nmax();
putln ("-max s1 (10, 16)=", s1.to_string (), ", ", s1.to_binary_string (16),
       " s1 is norm = ", s1.is_normalized ());
s1.pmin();
putln ("+min s1 (10, 16)=", s1.to_string (), ", ", s1.to_binary_string (16),
       " s1 is denorm = ", s1.is_denormalized ());
s1.nmin();
putln ("-min s1 (10,16)=", s1.to_string (), ", ", s1.to_binary_string (16),
       " s1 is denorm = ", s1.is_denormalized ());

s1.from_float(5.0);
s2.from_float(10.0);
putln ("s1 (10,2,4,8,16)= ", s1.to_string (), ", ", s1.to_binary_string (2),
       ", ", s1.to_binary_string (4), ", ", s1.to_binary_string (8),
       ", ", s1.to_binary_string (16));
putln ("s2 = ", s2.to_string ());

s1.from_string("5.0");
s2.from_string("10.0");
putln ("s1 = ", s1.to_string ());
putln ("s2 = ", s2.to_string ());

s1.from_binary_string("5.0", 16);
s2.from_binary_string("2.8p2", 16);
putln ("s1 = ", s1.to_string ());
putln ("s2 = ", s2.to_string ());

putln ("s1 + s2 = ", s1.add (s2).to_string ());
putln ("s1 - s2 = ", s1.subtract (s2).to_string ());
putln ("s2 - s1 = ", s2.subtract (s1).to_string ());
putln ("s1 * s2 = ", s1.multiply (s2).to_string ());
putln ("s1 / s2 = ", s1.divide (s2).to_string ());
putln ("s1 == s2 = ", s1.eq (s2));
putln ("s1 != s2 = ", s1.ne (s2));
putln ("s1 < s2 = ", s1.lt (s2));
putln ("s1 <= s2 = ", s1.le (s2));
putln ("s1 > s2 = ", s1.gt (s2));
putln ("s1 >= s2 = ", s1.ge (s2));

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

try {
  var s3 = ieees.single ();
  put (s1.to_string (), " / ", s3.to_string (), " ...");
  s1.divide (s3);
} catch (ieees.ieee_excepts.zero_division) {
  putln ("  got zero_division");
}

{
  var s3 = ieees.single (), st, res;
  ieees.ignore_excepts = 1;
  put (s1.to_string (), " / ", s3.to_string (), " = ");
  res = s1.divide (s3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.dz);
  ieees.ignore_excepts = 0;
}

try {
  var s3 = ieees.single ("3");
  put (s1.to_string (), " / ", s3.to_string (), " ...");
  s1.divide (s3);
} catch (ieees.ieee_excepts.imprecise_result) {
  putln ("  got imprecise result");
}

{
  var s3 = ieees.single ("3"), st, res;
  ieees.ignore_excepts = 1;
  put (s1.to_string (), " / ", s3.to_string (), " = ");
  res = s1.divide (s3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.imp);
  ieees.ignore_excepts = 0;
}

try {
  var s3 = ieees.single ();
  s3.pmax ();
  put (s3.to_string (), " + ", s3.to_string (), " ...");
  s3.add (s3);
} catch (ieees.ieee_excepts.overflow) {
  putln ("  got overflow");
}

{
  var s3 = ieees.single (), st, res;
  ieees.ignore_excepts = 1;
  s3.pmax ();
  put (s3.to_string (), " + ", s3.to_string (), " = ");
  res = s3.add (s3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ofl);
  ieees.ignore_excepts = 0;
}

try {
  var s3 = ieees.single ();
  s3.pmin ();
  put (s3.to_string (), " / 10 ...");
  s3.divide (ieees.single ("10"));
} catch (ieees.ieee_excepts.underflow) {
  putln ("  got underflow");
}

{
  var s3 = ieees.single (), st, res;
  s3.pmin ();
  ieees.ignore_excepts = 1;
  put (s3.to_string (), " / 10 = ");
  res = s3.divide (ieees.single ("10"));
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ufl);
  ieees.ignore_excepts = 0;
}

try {
  var s3 = ieees.single ("SNaN");
  put (s3.to_string (), " + ", s3.to_string (), " ...");
  s3.add (s3);
} catch (ieees.ieee_excepts.invalid_operation) {
  putln ("  got invalid operation");
}

{
  var s3 = ieees.single ("SNaN"), st, res;
  ieees.ignore_excepts = 1;
  put (s3.to_string (), " + ", s3.to_string (), " = ");
  res = s3.add (s3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.inv);
  ieees.ignore_excepts = 0;
}

try {
  var s3 = ieees.single ("QNaN");
  put (s3.to_string (), " + ", s3.to_string (), " ...");
  s3.add (s3);
} catch (ieees.ieee_excepts.reserved_operand) {
  putln ("  got reserved operand");
}

{
  var s3 = ieees.single ("QNaN"), st, res;
  ieees.ignore_excepts = 1;
  put (s3.to_string (), " + ", s3.to_string (), " = ");
  res = s3.add (s3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ro);
  ieees.ignore_excepts = 0;
}

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

putln ("trap mask = ", ieees.get_trap_mask ());

ieees.set_trap_mask (ieees.inv|ieees.ro|ieees.ofl
		     |ieees.ufl|ieees.imp|ieees.dz);
putln ("trap mask = ", ieees.get_trap_mask ());

var s3 = ieees.single ();
put (s1.to_string (), " / ", s3.to_string (), " = ");
putln (s1.divide (s3).to_string ());

s3 = ieees.single ("3");
put (s1.to_string (), " / ", s3.to_string (), " = ");
putln (s1.divide (s3).to_string ());

s3 = ieees.single ();
s3.pmax ();
put (s3.to_string (), " + ", s3.to_string (), " = ");
putln (s3.add (s3).to_string ());

s3 = ieees.single ();
s3.pmin ();
put (s3.to_string (), " / 10 = ");
putln (s3.divide (ieees.single ("10")).to_string ());

s3 = ieees.single ("SNaN");
put (s3.to_string (), " + ", s3.to_string (), " = ");
putln (s3.add (s3).to_string ());

s3 = ieees.single ("QNaN");
put (s3.to_string (), " + ", s3.to_string (), " = ");
putln (s3.add (s3).to_string ());

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

putln ("round = ", ieees.get_round ());

s3 = ieees.single ("1.23456788");
s1 = ieees.single ("0.00000001");
putln (s3.to_string (), " + ", s1.to_string (), " = ",
       s3.add (s1).to_string ());

ieees.set_round (ieees.rni);
putln ("round = ", ieees.get_round ());

s3 = ieees.single ("1.23456788");
s1 = ieees.single ("0.00000001");
putln (s3.to_string (), " + ", s1.to_string (), " = ",
       s3.add (s1).to_string ());

ieees.set_round (ieees.rpi);
putln ("round = ", ieees.get_round ());

s3 = ieees.single ("1.23456788");
s1 = ieees.single ("0.00000001");
putln (s3.to_string (), " + ", s1.to_string (), " = ",
       s3.add (s1).to_string ());

ieees.set_round (ieees.rz);
putln ("round = ", ieees.get_round ());

s3 = ieees.single ("1.23456788");
s1 = ieees.single ("0.00000001");
putln (s3.to_string (), " + ", s1.to_string (), " = ",
       s3.add (s1).to_string ());

try {
  ieees.set_round (6);
} catch (ieees.ieee_excepts.round_value) {
  putln ("  got invalid round value");
}

s1 = ieees.single ("5");
var ms = s1.to_mpi (4);
putln ("ms (from s1) = ", mpis.to_string (ms));
s1.from_mpi (ms);
putln ("s1 (from ms) = ", s1.to_string ());

//////////////////////////////////////////////////////////////

ieees.reset ();
var d1 = ieees.double(), d2 = ieees.double();
putln ("*******IEEE doubles:**********");

putln ("pzero d1 (2, 4, 8, 16)=", d1.to_binary_string (2), ", ",
       d1.to_binary_string (4), ", ", d1.to_binary_string (8), ", ",
       d1.to_binary_string (16));
putln ("pzero d1=", d1.to_string ());
putln ("pzero d2 (2, 4, 8, 16)=", d2.to_binary_string (2), ", ",
       d2.to_binary_string (4), ", ", d2.to_binary_string (8), ", ",
       d2.to_binary_string (16));
putln ("pzero d2=", d2.to_string ());

d1 = ieees.double("0");
d2 = ieees.double("0");

d1.nzero();
putln ("-zero d1=", d1.to_string (), " d1 is -zero = ", d1.is_nzero ());
d1.nan();
putln ("nan d1=", d1.to_string (), " d1 is nan = ", d1.is_nan ());
d1.trap_nan();
putln ("trap nan d1=", d1.to_string (),
       " d1 is trap nan = ", d1.is_trap_nan ());
d1.pinfinity();
putln ("+infinity d1=", d1.to_string (),
       " d1 is +infinity = ", d1.is_pinfinity ());
d1.ninfinity();
putln ("-infinity d1=", d1.to_string (),
       " d1 is -infinity = ", d1.is_ninfinity ());
d1.pmax();
putln ("+max d1 (10, 16)=", d1.to_string (), ", ", d1.to_binary_string (16),
       " d1 is norm = ", d1.is_normalized ());
d1.nmax();
putln ("-max d1 (10, 16)=", d1.to_string (), ", ", d1.to_binary_string (16),
       " d1 is norm = ", d1.is_normalized ());
d1.pmin();
putln ("+min d1 (10, 16)=", d1.to_string (), ", ", d1.to_binary_string (16),
       " d1 is denorm = ", d1.is_denormalized ());
d1.nmin();
putln ("-min d1 (10,16)=", d1.to_string (), ", ", d1.to_binary_string (16),
       " d1 is denorm = ", d1.is_denormalized ());

d1.from_float(5.0);
d2.from_float(10.0);
putln ("d1 (10,2,4,8,16)= ", d1.to_string (), ", ", d1.to_binary_string (2),
       ", ", d1.to_binary_string (4), ", ", d1.to_binary_string (8),
       ", ", d1.to_binary_string (16));
putln ("d2 = ", d2.to_string ());

d1.from_string("5.0");
d2.from_string("10.0");
putln ("d1 = ", d1.to_string ());
putln ("d2 = ", d2.to_string ());

d1.from_binary_string("5.0", 16);
d2.from_binary_string("2.8p2", 16);
putln ("d1 = ", d1.to_string ());
putln ("d2 = ", d2.to_string ());

putln ("d1 + d2 = ", d1.add (d2).to_string ());
putln ("d1 - d2 = ", d1.subtract (d2).to_string ());
putln ("d2 - d1 = ", d2.subtract (d1).to_string ());
putln ("d1 * d2 = ", d1.multiply (d2).to_string ());
putln ("d1 / d2 = ", d1.divide (d2).to_string ());
putln ("d1 == d2 = ", d1.eq (d2));
putln ("d1 != d2 = ", d1.ne (d2));
putln ("d1 < d2 = ", d1.lt (d2));
putln ("d1 <= d2 = ", d1.le (d2));
putln ("d1 > d2 = ", d1.gt (d2));
putln ("d1 >= d2 = ", d1.ge (d2));

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

try {
  var d3 = ieees.double ();
  put (d1.to_string (), " / ", d3.to_string (), " ...");
  d1.divide (d3);
} catch (ieees.ieee_excepts.zero_division) {
  putln ("  got zero_division");
}

{
  var d3 = ieees.double (), st, res;
  ieees.ignore_excepts = 1;
  put (d1.to_string (), " / ", d3.to_string (), " = ");
  res = d1.divide (d3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.dz);
  ieees.ignore_excepts = 0;
}

try {
  var d3 = ieees.double ("3");
  put (d1.to_string (), " / ", d3.to_string (), " ...");
  d1.divide (d3);
} catch (ieees.ieee_excepts.imprecise_result) {
  putln ("  got imprecise result");
}

{
  var d3 = ieees.double ("3"), st, res;
  ieees.ignore_excepts = 1;
  put (d1.to_string (), " / ", d3.to_string (), " = ");
  res = d1.divide (d3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.imp);
  ieees.ignore_excepts = 0;
}

try {
  var d3 = ieees.double ();
  d3.pmax ();
  put (d3.to_string (), " + ", d3.to_string (), " ...");
  d3.add (d3);
} catch (ieees.ieee_excepts.overflow) {
  putln ("  got overflow");
}

{
  var d3 = ieees.double (), st, res;
  ieees.ignore_excepts = 1;
  d3.pmax ();
  put (d3.to_string (), " + ", d3.to_string (), " = ");
  res = d3.add (d3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ofl);
  ieees.ignore_excepts = 0;
}

try {
  var d3 = ieees.double ();
  d3.pmin ();
  put (d3.to_string (), " / 10 ...");
  d3.divide (ieees.double ("10"));
} catch (ieees.ieee_excepts.underflow) {
  putln ("  got underflow");
}

{
  var d3 = ieees.double (), st, res;
  d3.pmin ();
  ieees.ignore_excepts = 1;
  put (d3.to_string (), " / 10 = ");
  res = d3.divide (ieees.double ("10"));
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ufl);
  ieees.ignore_excepts = 0;
}

try {
  var d3 = ieees.double ("SNaN");
  put (d3.to_string (), " + ", d3.to_string (), " ...");
  d3.add (d3);
} catch (ieees.ieee_excepts.invalid_operation) {
  putln ("  got invalid operation");
}

{
  var d3 = ieees.double ("SNaN"), st, res;
  ieees.ignore_excepts = 1;
  put (d3.to_string (), " + ", d3.to_string (), " = ");
  res = d3.add (d3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.inv);
  ieees.ignore_excepts = 0;
}

try {
  var d3 = ieees.double ("QNaN");
  put (d3.to_string (), " + ", d3.to_string (), " ...");
  d3.add (d3);
} catch (ieees.ieee_excepts.reserved_operand) {
  putln ("  got reserved operand");
}

{
  var d3 = ieees.double ("QNaN"), st, res;
  ieees.ignore_excepts = 1;
  put (d3.to_string (), " + ", d3.to_string (), " = ");
  res = d3.add (d3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ro);
  ieees.ignore_excepts = 0;
}

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

putln ("trap mask = ", ieees.get_trap_mask ());

ieees.set_trap_mask (ieees.inv|ieees.ro|ieees.ofl
		     |ieees.ufl|ieees.imp|ieees.dz);
putln ("trap mask = ", ieees.get_trap_mask ());

var d3 = ieees.double ();
put (d1.to_string (), " / ", d3.to_string (), " = ");
putln (d1.divide (d3).to_string ());

d3 = ieees.double ("3");
put (d1.to_string (), " / ", d3.to_string (), " = ");
putln (d1.divide (d3).to_string ());

d3 = ieees.double ();
d3.pmax ();
put (d3.to_string (), " + ", d3.to_string (), " = ");
putln (d3.add (d3).to_string ());

d3 = ieees.double ();
d3.pmin ();
put (d3.to_string (), " / 10 = ");
putln (d3.divide (ieees.double ("10")).to_string ());

d3 = ieees.double ("SNaN");
put (d3.to_string (), " + ", d3.to_string (), " = ");
putln (d3.add (d3).to_string ());

d3 = ieees.double ("QNaN");
put (d3.to_string (), " + ", d3.to_string (), " = ");
putln (d3.add (d3).to_string ());

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

putln ("round = ", ieees.get_round ());

d3 = ieees.double ("1.2345678901234567");
d1 = ieees.double ("0.0000000000000004");
putln (d3.to_string (), " + ", d1.to_string (), " = ",
       d3.add (d1).to_string ());

ieees.set_round (ieees.rni);
putln ("round = ", ieees.get_round ());

d3 = ieees.double ("1.2345678901234567");
d1 = ieees.double ("0.0000000000000004");
putln (d3.to_string (), " + ", d1.to_string (), " = ",
       d3.add (d1).to_string ());

ieees.set_round (ieees.rpi);
putln ("round = ", ieees.get_round ());

d3 = ieees.double ("1.2345678901234567");
d1 = ieees.double ("0.0000000000000004");
putln (d3.to_string (), " + ", d1.to_string (), " = ",
       d3.add (d1).to_string ());

ieees.set_round (ieees.rz);
putln ("round = ", ieees.get_round ());

d3 = ieees.double ("1.2345678901234567");
d1 = ieees.double ("0.0000000000000004");
putln (d3.to_string (), " + ", d1.to_string (), " = ",
       d3.add (d1).to_string ());

try {
  ieees.set_round (6);
} catch (ieees.ieee_excepts.round_value) {
  putln ("  got invalid round value");
}

d1 = ieees.double ("5");
var md = d1.to_mpi (4);
putln ("md (from d1) = ", mpis.to_string (md));
d1.from_mpi (md);
putln ("d1 (from md) = ", d1.to_string ());

//////////////////////////////////////////////////////////////

ieees.reset ();
var q1 = ieees.quad(), q2 = ieees.quad();
putln ("*******IEEE quads:**********");

putln ("pzero q1 (2, 4, 8, 16)=", q1.to_binary_string (2), ", ",
       q1.to_binary_string (4), ", ", q1.to_binary_string (8), ", ",
       q1.to_binary_string (16));
putln ("pzero q1=", q1.to_string ());
putln ("pzero q2 (2, 4, 8, 16)=", q2.to_binary_string (2), ", ",
       q2.to_binary_string (4), ", ", q2.to_binary_string (8), ", ",
       q2.to_binary_string (16));
putln ("pzero q2=", q2.to_string ());

q1 = ieees.quad("0");
q2 = ieees.quad("0");

q1.nzero();
putln ("-zero q1=", q1.to_string (), " q1 is -zero = ", q1.is_nzero ());
q1.nan();
putln ("nan q1=", q1.to_string (), " q1 is nan = ", q1.is_nan ());
q1.trap_nan();
putln ("trap nan q1=", q1.to_string (),
       " q1 is trap nan = ", q1.is_trap_nan ());
q1.pinfinity();
putln ("+infinity q1=", q1.to_string (),
       " q1 is +infinity = ", q1.is_pinfinity ());
q1.ninfinity();
putln ("-infinity q1=", q1.to_string (),
       " q1 is -infinity = ", q1.is_ninfinity ());
q1.pmax();
putln ("+max q1 (10, 16)=", q1.to_string (), ", ", q1.to_binary_string (16),
       " q1 is norm = ", q1.is_normalized ());
q1.nmax();
putln ("-max q1 (10, 16)=", q1.to_string (), ", ", q1.to_binary_string (16),
       " q1 is norm = ", q1.is_normalized ());
q1.pmin();
putln ("+min q1 (10, 16)=", q1.to_string (), ", ", q1.to_binary_string (16),
       " q1 is denorm = ", q1.is_denormalized ());
q1.nmin();
putln ("-min q1 (10,16)=", q1.to_string (), ", ", q1.to_binary_string (16),
       " q1 is denorm = ", q1.is_denormalized ());

q1.from_float(5.0);
q2.from_float(10.0);
putln ("q1 (10,2,4,8,16)= ", q1.to_string (), ", ", q1.to_binary_string (2),
       ", ", q1.to_binary_string (4), ", ", q1.to_binary_string (8),
       ", ", q1.to_binary_string (16));
putln ("q2 = ", q2.to_string ());

q1.from_string("5.0");
q2.from_string("10.0");
putln ("q1 = ", q1.to_string ());
putln ("q2 = ", q2.to_string ());

q1.from_binary_string("5.0", 16);
q2.from_binary_string("2.8p2", 16);
putln ("q1 = ", q1.to_string ());
putln ("q2 = ", q2.to_string ());

putln ("q1 + q2 = ", q1.add (q2).to_string ());
putln ("q1 - q2 = ", q1.subtract (q2).to_string ());
putln ("q2 - q1 = ", q2.subtract (q1).to_string ());
putln ("q1 * q2 = ", q1.multiply (q2).to_string ());
putln ("q1 / q2 = ", q1.divide (q2).to_string ());
putln ("q1 == q2 = ", q1.eq (q2));
putln ("q1 != q2 = ", q1.ne (q2));
putln ("q1 < q2 = ", q1.lt (q2));
putln ("q1 <= q2 = ", q1.le (q2));
putln ("q1 > q2 = ", q1.gt (q2));
putln ("q1 >= q2 = ", q1.ge (q2));

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

try {
  var q3 = ieees.quad ();
  put (q1.to_string (), " / ", q3.to_string (), " ...");
  q1.divide (q3);
} catch (ieees.ieee_excepts.zero_division) {
  putln ("  got zero_division");
}

{
  var q3 = ieees.quad (), st, res;
  ieees.ignore_excepts = 1;
  put (q1.to_string (), " / ", q3.to_string (), " = ");
  res = q1.divide (q3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.dz);
  ieees.ignore_excepts = 0;
}

try {
  var q3 = ieees.quad ("3");
  put (q1.to_string (), " / ", q3.to_string (), " ...");
  q1.divide (q3);
} catch (ieees.ieee_excepts.imprecise_result) {
  putln ("  got imprecise result");
}

{
  var q3 = ieees.quad ("3"), st, res;
  ieees.ignore_excepts = 1;
  put (q1.to_string (), " / ", q3.to_string (), " = ");
  res = q1.divide (q3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.imp);
  ieees.ignore_excepts = 0;
}

try {
  var q3 = ieees.quad ();
  q3.pmax ();
  put (q3.to_string (), " + ", q3.to_string (), " ...");
  q3.add (q3);
} catch (ieees.ieee_excepts.overflow) {
  putln ("  got overflow");
}

{
  var q3 = ieees.quad (), st, res;
  ieees.ignore_excepts = 1;
  q3.pmax ();
  put (q3.to_string (), " + ", q3.to_string (), " = ");
  res = q3.add (q3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ofl);
  ieees.ignore_excepts = 0;
}

try {
  var q3 = ieees.quad ();
  q3.pmin ();
  put (q3.to_string (), " / 10 ...");
  q3.divide (ieees.quad ("10"));
} catch (ieees.ieee_excepts.underflow) {
  putln ("  got underflow");
}

{
  var q3 = ieees.quad (), st, res;
  q3.pmin ();
  ieees.ignore_excepts = 1;
  put (q3.to_string (), " / 10 = ");
  res = q3.divide (ieees.quad ("10"));
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ufl);
  ieees.ignore_excepts = 0;
}

try {
  var q3 = ieees.quad ("SNaN");
  put (q3.to_string (), " + ", q3.to_string (), " ...");
  q3.add (q3);
} catch (ieees.ieee_excepts.invalid_operation) {
  putln ("  got invalid operation");
}

{
  var q3 = ieees.quad ("SNaN"), st, res;
  ieees.ignore_excepts = 1;
  put (q3.to_string (), " + ", q3.to_string (), " = ");
  res = q3.add (q3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.inv);
  ieees.ignore_excepts = 0;
}

try {
  var q3 = ieees.quad ("QNaN");
  put (q3.to_string (), " + ", q3.to_string (), " ...");
  q3.add (q3);
} catch (ieees.ieee_excepts.reserved_operand) {
  putln ("  got reserved operand");
}

{
  var q3 = ieees.quad ("QNaN"), st, res;
  ieees.ignore_excepts = 1;
  put (q3.to_string (), " + ", q3.to_string (), " = ");
  res = q3.add (q3);
  st = ieees.get_status_bits ();
  putln (res.to_string (), " status bits = ", st, ", ", ieees.ro);
  ieees.ignore_excepts = 0;
}

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

putln ("trap mask = ", ieees.get_trap_mask ());

ieees.set_trap_mask (ieees.inv|ieees.ro|ieees.ofl
		     |ieees.ufl|ieees.imp|ieees.dz);
putln ("trap mask = ", ieees.get_trap_mask ());

var q3 = ieees.quad ();
put (q1.to_string (), " / ", q3.to_string (), " = ");
putln (q1.divide (q3).to_string ());

q3 = ieees.quad ("3");
put (q1.to_string (), " / ", q3.to_string (), " = ");
putln (q1.divide (q3).to_string ());

q3 = ieees.quad ();
q3.pmax ();
put (q3.to_string (), " + ", q3.to_string (), " = ");
putln (q3.add (q3).to_string ());

q3 = ieees.quad ();
q3.pmin ();
put (q3.to_string (), " / 10 = ");
putln (q3.divide (ieees.quad ("10")).to_string ());

q3 = ieees.quad ("SNaN");
put (q3.to_string (), " + ", q3.to_string (), " = ");
putln (q3.add (q3).to_string ());

q3 = ieees.quad ("QNaN");
put (q3.to_string (), " + ", q3.to_string (), " = ");
putln (q3.add (q3).to_string ());

putln ("sticky status bits = ", ieees.get_sticky_status_bits ());

putln ("round = ", ieees.get_round ());

q3 = ieees.quad ("1.23456789012345678901234567890123456");
q1 = ieees.quad ("0.00000000000000000000000000000000015");
putln (q3.to_string (), " + ", q1.to_string (), " = ",
       q3.add (q1).to_string ());

ieees.set_round (ieees.rni);
putln ("round = ", ieees.get_round ());

q3 = ieees.quad ("1.23456789012345678901234567890123456");
q1 = ieees.quad ("0.00000000000000000000000000000000015");
putln (q3.to_string (), " + ", q1.to_string (), " = ",
       q3.add (q1).to_string ());

ieees.set_round (ieees.rpi);
putln ("round = ", ieees.get_round ());

q3 = ieees.quad ("1.23456789012345678901234567890123456");
q1 = ieees.quad ("0.00000000000000000000000000000000015");
putln (q3.to_string (), " + ", q1.to_string (), " = ",
       q3.add (q1).to_string ());

ieees.set_round (ieees.rz);
putln ("round = ", ieees.get_round ());

q3 = ieees.quad ("1.23456789012345678901234567890123456");
q1 = ieees.quad ("0.00000000000000000000000000000000015");
putln (q3.to_string (), " + ", q1.to_string (), " = ",
       q3.add (q1).to_string ());

try {
  ieees.set_round (6);
} catch (ieees.ieee_excepts.round_value) {
  putln ("  got invalid round value");
}

q1 = ieees.quad ("5");
var mq = q1.to_mpi (4);
putln ("mq (from q1) = ", mpis.to_string (mq));
q1.from_mpi (mq);
putln ("q1 (from mq) = ", q1.to_string ());

// Transformation single -> double -> quad

d1 = s1.to_double ();
putln ("single ", s1.to_string (), " -> double ", d1.to_string ());
q1 = s1.to_quad ();
putln ("single ", s1.to_string (), " -> quad ", q1.to_string ());

s1 = d1.to_single ();
putln ("double ", d1.to_string (), " -> single ", s1.to_string ());
q1 = d1.to_quad ();
putln ("double ", d1.to_string (), " -> quad ", q1.to_string ());

s1 = q1.to_single ();
putln ("quad ", q1.to_string (), " -> single ", s1.to_string ());
d1 = q1.to_double ();
putln ("quad ", q1.to_string (), " -> double ", d1.to_string ());
TEST453
        if uname | fgrep CYGWIN; then
            echo '      ' $DINO -L./ieee.dll -L./mpi.dll -I@srcdir@ $test_file "2>$stderr"
	    if $DINO -Lieee.dll -Lmpi.dll -I@srcdir@ $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT453' && $CMP $stdout $ftemp2; then
*******IEEE singles:**********
pzero s1 (2, 4, 8, 16)=+0, +0, +0, +0
pzero s1=+0
pzero s2 (2, 4, 8, 16)=+0, +0, +0, +0
pzero s2=+0
-zero s1=-0 s1 is -zero = 1
nan s1=QNaN s1 is nan = 1
trap nan s1=SNaN s1 is trap nan = 1
+infinity s1=+Inf s1 is +infinity = 1
-infinity s1=-Inf s1 is -infinity = 1
+max s1 (10, 16)=3.40282347e38, 1.fffffep127 s1 is norm = 1
-max s1 (10, 16)=-3.40282347e38, -1.fffffep127 s1 is norm = 1
+min s1 (10, 16)=1.40129846e-45, 1.p-149 s1 is denorm = 1
-min s1 (10,16)=-1.40129846e-45, -1.p-149 s1 is denorm = 1
s1 (10,2,4,8,16)= 5.00000000, 1.01p2, 1.1p2, 1.2p2, 1.4p2
s2 = 1.00000000e1
s1 = 5.00000000
s2 = 1.00000000e1
s1 = 5.00000000
s2 = 1.00000000e1
s1 + s2 = 1.50000000e1
s1 - s2 = -5.00000000
s2 - s1 = 5.00000000
s1 * s2 = 5.00000000e1
s1 / s2 = 5.00000000e-1
s1 == s2 = 0
s1 != s2 = 1
s1 < s2 = 1
s1 <= s2 = 1
s1 > s2 = 0
s1 >= s2 = 0
sticky status bits = 0
5.00000000 / +0 ...  got zero_division
5.00000000 / +0 = +Inf status bits = 32, 32
5.00000000 / 3.00000000 ...  got imprecise result
5.00000000 / 3.00000000 = 1.66666663 status bits = 16, 16
3.40282347e38 + 3.40282347e38 ...  got overflow
3.40282347e38 + 3.40282347e38 = +Inf status bits = 4, 4
1.40129846e-45 / 10 ...  got underflow
1.40129846e-45 / 10 = +0 status bits = 24, 8
SNaN + SNaN ...  got invalid operation
SNaN + SNaN = QNaN status bits = 3, 1
QNaN + QNaN ...  got reserved operand
QNaN + QNaN = QNaN status bits = 2, 2
sticky status bits = 0
trap mask = 0
trap mask = 63
5.00000000 / +0 = +Inf
5.00000000 / 3.00000000 = 1.66666663
3.40282347e38 + 3.40282347e38 = +Inf
1.40129846e-45 / 10 = +0
SNaN + SNaN = QNaN
QNaN + QNaN = QNaN
sticky status bits = 63
round = 0
1.23456788 + 9.99999994e-9 = 1.23456788
round = 1
1.23456776 + 9.99999994e-9 = 1.23456776
round = 2
1.23456788 + 1.00000008e-8 = 1.23456800
round = 3
1.23456776 + 9.99999994e-9 = 1.23456776
  got invalid round value
ms (from s1) = 5
s1 (from ms) = 5.00000000
*******IEEE doubles:**********
pzero d1 (2, 4, 8, 16)=+0, +0, +0, +0
pzero d1=+0
pzero d2 (2, 4, 8, 16)=+0, +0, +0, +0
pzero d2=+0
-zero d1=-0 d1 is -zero = 1
nan d1=QNaN d1 is nan = 1
trap nan d1=SNaN d1 is trap nan = 1
+infinity d1=+Inf d1 is +infinity = 1
-infinity d1=-Inf d1 is -infinity = 1
+max d1 (10, 16)=1.7976931348623157e308, 1.fffffffffffffp1023 d1 is norm = 1
-max d1 (10, 16)=-1.7976931348623157e308, -1.fffffffffffffp1023 d1 is norm = 1
+min d1 (10, 16)=4.9406564584124654e-324, 1.p-1074 d1 is denorm = 1
-min d1 (10,16)=-4.9406564584124654e-324, -1.p-1074 d1 is denorm = 1
d1 (10,2,4,8,16)= 5.0000000000000000, 1.01p2, 1.1p2, 1.2p2, 1.4p2
d2 = 1.0000000000000000e1
d1 = 5.0000000000000000
d2 = 1.0000000000000000e1
d1 = 5.0000000000000000
d2 = 1.0000000000000000e1
d1 + d2 = 1.5000000000000000e1
d1 - d2 = -5.0000000000000000
d2 - d1 = 5.0000000000000000
d1 * d2 = 5.0000000000000000e1
d1 / d2 = 5.0000000000000000e-1
d1 == d2 = 0
d1 != d2 = 1
d1 < d2 = 1
d1 <= d2 = 1
d1 > d2 = 0
d1 >= d2 = 0
sticky status bits = 0
5.0000000000000000 / +0 ...  got zero_division
5.0000000000000000 / +0 = +Inf status bits = 32, 32
5.0000000000000000 / 3.0000000000000000 ...  got imprecise result
5.0000000000000000 / 3.0000000000000000 = 1.6666666666666667 status bits = 16, 16
1.7976931348623157e308 + 1.7976931348623157e308 ...  got overflow
1.7976931348623157e308 + 1.7976931348623157e308 = +Inf status bits = 4, 4
4.9406564584124654e-324 / 10 ...  got underflow
4.9406564584124654e-324 / 10 = +0 status bits = 24, 8
SNaN + SNaN ...  got invalid operation
SNaN + SNaN = QNaN status bits = 3, 1
QNaN + QNaN ...  got reserved operand
QNaN + QNaN = QNaN status bits = 2, 2
sticky status bits = 0
trap mask = 0
trap mask = 63
5.0000000000000000 / +0 = +Inf
5.0000000000000000 / 3.0000000000000000 = 1.6666666666666667
1.7976931348623157e308 + 1.7976931348623157e308 = +Inf
4.9406564584124654e-324 / 10 = +0
SNaN + SNaN = QNaN
QNaN + QNaN = QNaN
sticky status bits = 63
round = 0
1.2345678901234567 + 3.9999999999999999e-16 = 1.2345678901234571
round = 1
1.2345678901234567 + 3.9999999999999999e-16 = 1.2345678901234569
round = 2
1.2345678901234569 + 4.0000000000000004e-16 = 1.2345678901234574
round = 3
1.2345678901234567 + 3.9999999999999999e-16 = 1.2345678901234569
  got invalid round value
md (from d1) = 5
d1 (from md) = 5.0000000000000000
*******IEEE quads:**********
pzero q1 (2, 4, 8, 16)=+0, +0, +0, +0
pzero q1=+0
pzero q2 (2, 4, 8, 16)=+0, +0, +0, +0
pzero q2=+0
-zero q1=-0 q1 is -zero = 1
nan q1=QNaN q1 is nan = 1
trap nan q1=SNaN q1 is trap nan = 1
+infinity q1=+Inf q1 is +infinity = 1
-infinity q1=-Inf q1 is -infinity = 1
+max q1 (10, 16)=1.18973149535723176508575932662800702e4932, 1.ffffffffffffffffffffffffffffp16383 q1 is norm = 1
-max q1 (10, 16)=-1.18973149535723176508575932662800702e4932, -1.ffffffffffffffffffffffffffffp16383 q1 is norm = 1
+min q1 (10, 16)=6.47517511943802511092443895822764655e-4966, 1.p-16494 q1 is denorm = 1
-min q1 (10,16)=-6.47517511943802511092443895822764655e-4966, -1.p-16494 q1 is denorm = 1
q1 (10,2,4,8,16)= 5.00000000000000000000000000000000000, 1.01p2, 1.1p2, 1.2p2, 1.4p2
q2 = 1.00000000000000000000000000000000000e1
q1 = 5.00000000000000000000000000000000000
q2 = 1.00000000000000000000000000000000000e1
q1 = 5.00000000000000000000000000000000000
q2 = 1.00000000000000000000000000000000000e1
q1 + q2 = 1.50000000000000000000000000000000000e1
q1 - q2 = -5.00000000000000000000000000000000000
q2 - q1 = 5.00000000000000000000000000000000000
q1 * q2 = 5.00000000000000000000000000000000000e1
q1 / q2 = 5.00000000000000000000000000000000000e-1
q1 == q2 = 0
q1 != q2 = 1
q1 < q2 = 1
q1 <= q2 = 1
q1 > q2 = 0
q1 >= q2 = 0
sticky status bits = 0
5.00000000000000000000000000000000000 / +0 ...  got zero_division
5.00000000000000000000000000000000000 / +0 = +Inf status bits = 32, 32
5.00000000000000000000000000000000000 / 3.00000000000000000000000000000000000 ...  got imprecise result
5.00000000000000000000000000000000000 / 3.00000000000000000000000000000000000 = 1.66666666666666666666666666666666673 status bits = 16, 16
1.18973149535723176508575932662800702e4932 + 1.18973149535723176508575932662800702e4932 ...  got overflow
1.18973149535723176508575932662800702e4932 + 1.18973149535723176508575932662800702e4932 = +Inf status bits = 4, 4
6.47517511943802511092443895822764655e-4966 / 10 ...  got underflow
6.47517511943802511092443895822764655e-4966 / 10 = +0 status bits = 24, 8
SNaN + SNaN ...  got invalid operation
SNaN + SNaN = QNaN status bits = 3, 1
QNaN + QNaN ...  got reserved operand
QNaN + QNaN = QNaN status bits = 2, 2
sticky status bits = 0
trap mask = 0
trap mask = 63
5.00000000000000000000000000000000000 / +0 = +Inf
5.00000000000000000000000000000000000 / 3.00000000000000000000000000000000000 = 1.66666666666666666666666666666666673
1.18973149535723176508575932662800702e4932 + 1.18973149535723176508575932662800702e4932 = +Inf
6.47517511943802511092443895822764655e-4966 / 10 = +0
SNaN + SNaN = QNaN
QNaN + QNaN = QNaN
sticky status bits = 63
round = 0
1.23456789012345678901234567890123455 + 1.49999999999999999999999999999999996e-34 = 1.23456789012345678901234567890123475
round = 1
1.23456789012345678901234567890123455 + 1.49999999999999999999999999999999996e-34 = 1.23456789012345678901234567890123455
round = 2
1.23456789012345678901234567890123475 + 1.50000000000000000000000000000000015e-34 = 1.23456789012345678901234567890123494
round = 3
1.23456789012345678901234567890123455 + 1.49999999999999999999999999999999996e-34 = 1.23456789012345678901234567890123455
  got invalid round value
mq (from q1) = 5
q1 (from mq) = 5.00000000000000000000000000000000000
single 5.00000000 -> double 5.0000000000000000
single 5.00000000 -> quad 5.00000000000000000000000000000000000
double 5.0000000000000000 -> single 5.00000000
double 5.0000000000000000 -> quad 5.00000000000000000000000000000000000
quad 5.00000000000000000000000000000000000 -> single 5.00000000
quad 5.00000000000000000000000000000000000 -> double 5.0000000000000000
OUTPUT453
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
            echo '      ' $DINO -L./ieee.@EXTERN_LIB_SUFFIX@ -L./mpi.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file "2>$stderr"
	    if $DINO -L./ieee.@EXTERN_LIB_SUFFIX@ -L./mpi.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT453' && $CMP $stdout $ftemp2; then
*******IEEE singles:**********
pzero s1 (2, 4, 8, 16)=+0, +0, +0, +0
pzero s1=+0
pzero s2 (2, 4, 8, 16)=+0, +0, +0, +0
pzero s2=+0
-zero s1=-0 s1 is -zero = 1
nan s1=QNaN s1 is nan = 1
trap nan s1=SNaN s1 is trap nan = 1
+infinity s1=+Inf s1 is +infinity = 1
-infinity s1=-Inf s1 is -infinity = 1
+max s1 (10, 16)=3.40282347e38, 1.fffffep127 s1 is norm = 1
-max s1 (10, 16)=-3.40282347e38, -1.fffffep127 s1 is norm = 1
+min s1 (10, 16)=1.40129846e-45, 1.p-149 s1 is denorm = 1
-min s1 (10,16)=-1.40129846e-45, -1.p-149 s1 is denorm = 1
s1 (10,2,4,8,16)= 5.00000000, 1.01p2, 1.1p2, 1.2p2, 1.4p2
s2 = 1.00000000e1
s1 = 5.00000000
s2 = 1.00000000e1
s1 = 5.00000000
s2 = 1.00000000e1
s1 + s2 = 1.50000000e1
s1 - s2 = -5.00000000
s2 - s1 = 5.00000000
s1 * s2 = 5.00000000e1
s1 / s2 = 5.00000000e-1
s1 == s2 = 0
s1 != s2 = 1
s1 < s2 = 1
s1 <= s2 = 1
s1 > s2 = 0
s1 >= s2 = 0
sticky status bits = 0
5.00000000 / +0 ...  got zero_division
5.00000000 / +0 = +Inf status bits = 32, 32
5.00000000 / 3.00000000 ...  got imprecise result
5.00000000 / 3.00000000 = 1.66666663 status bits = 16, 16
3.40282347e38 + 3.40282347e38 ...  got overflow
3.40282347e38 + 3.40282347e38 = +Inf status bits = 4, 4
1.40129846e-45 / 10 ...  got underflow
1.40129846e-45 / 10 = +0 status bits = 24, 8
SNaN + SNaN ...  got invalid operation
SNaN + SNaN = QNaN status bits = 3, 1
QNaN + QNaN ...  got reserved operand
QNaN + QNaN = QNaN status bits = 2, 2
sticky status bits = 0
trap mask = 0
trap mask = 63
5.00000000 / +0 = +Inf
5.00000000 / 3.00000000 = 1.66666663
3.40282347e38 + 3.40282347e38 = +Inf
1.40129846e-45 / 10 = +0
SNaN + SNaN = QNaN
QNaN + QNaN = QNaN
sticky status bits = 63
round = 0
1.23456788 + 9.99999994e-9 = 1.23456788
round = 1
1.23456776 + 9.99999994e-9 = 1.23456776
round = 2
1.23456788 + 1.00000008e-8 = 1.23456800
round = 3
1.23456776 + 9.99999994e-9 = 1.23456776
  got invalid round value
ms (from s1) = 5
s1 (from ms) = 5.00000000
*******IEEE doubles:**********
pzero d1 (2, 4, 8, 16)=+0, +0, +0, +0
pzero d1=+0
pzero d2 (2, 4, 8, 16)=+0, +0, +0, +0
pzero d2=+0
-zero d1=-0 d1 is -zero = 1
nan d1=QNaN d1 is nan = 1
trap nan d1=SNaN d1 is trap nan = 1
+infinity d1=+Inf d1 is +infinity = 1
-infinity d1=-Inf d1 is -infinity = 1
+max d1 (10, 16)=1.7976931348623157e308, 1.fffffffffffffp1023 d1 is norm = 1
-max d1 (10, 16)=-1.7976931348623157e308, -1.fffffffffffffp1023 d1 is norm = 1
+min d1 (10, 16)=4.9406564584124654e-324, 1.p-1074 d1 is denorm = 1
-min d1 (10,16)=-4.9406564584124654e-324, -1.p-1074 d1 is denorm = 1
d1 (10,2,4,8,16)= 5.0000000000000000, 1.01p2, 1.1p2, 1.2p2, 1.4p2
d2 = 1.0000000000000000e1
d1 = 5.0000000000000000
d2 = 1.0000000000000000e1
d1 = 5.0000000000000000
d2 = 1.0000000000000000e1
d1 + d2 = 1.5000000000000000e1
d1 - d2 = -5.0000000000000000
d2 - d1 = 5.0000000000000000
d1 * d2 = 5.0000000000000000e1
d1 / d2 = 5.0000000000000000e-1
d1 == d2 = 0
d1 != d2 = 1
d1 < d2 = 1
d1 <= d2 = 1
d1 > d2 = 0
d1 >= d2 = 0
sticky status bits = 0
5.0000000000000000 / +0 ...  got zero_division
5.0000000000000000 / +0 = +Inf status bits = 32, 32
5.0000000000000000 / 3.0000000000000000 ...  got imprecise result
5.0000000000000000 / 3.0000000000000000 = 1.6666666666666667 status bits = 16, 16
1.7976931348623157e308 + 1.7976931348623157e308 ...  got overflow
1.7976931348623157e308 + 1.7976931348623157e308 = +Inf status bits = 4, 4
4.9406564584124654e-324 / 10 ...  got underflow
4.9406564584124654e-324 / 10 = +0 status bits = 24, 8
SNaN + SNaN ...  got invalid operation
SNaN + SNaN = QNaN status bits = 3, 1
QNaN + QNaN ...  got reserved operand
QNaN + QNaN = QNaN status bits = 2, 2
sticky status bits = 0
trap mask = 0
trap mask = 63
5.0000000000000000 / +0 = +Inf
5.0000000000000000 / 3.0000000000000000 = 1.6666666666666667
1.7976931348623157e308 + 1.7976931348623157e308 = +Inf
4.9406564584124654e-324 / 10 = +0
SNaN + SNaN = QNaN
QNaN + QNaN = QNaN
sticky status bits = 63
round = 0
1.2345678901234567 + 3.9999999999999999e-16 = 1.2345678901234571
round = 1
1.2345678901234567 + 3.9999999999999999e-16 = 1.2345678901234569
round = 2
1.2345678901234569 + 4.0000000000000004e-16 = 1.2345678901234574
round = 3
1.2345678901234567 + 3.9999999999999999e-16 = 1.2345678901234569
  got invalid round value
md (from d1) = 5
d1 (from md) = 5.0000000000000000
*******IEEE quads:**********
pzero q1 (2, 4, 8, 16)=+0, +0, +0, +0
pzero q1=+0
pzero q2 (2, 4, 8, 16)=+0, +0, +0, +0
pzero q2=+0
-zero q1=-0 q1 is -zero = 1
nan q1=QNaN q1 is nan = 1
trap nan q1=SNaN q1 is trap nan = 1
+infinity q1=+Inf q1 is +infinity = 1
-infinity q1=-Inf q1 is -infinity = 1
+max q1 (10, 16)=1.18973149535723176508575932662800702e4932, 1.ffffffffffffffffffffffffffffp16383 q1 is norm = 1
-max q1 (10, 16)=-1.18973149535723176508575932662800702e4932, -1.ffffffffffffffffffffffffffffp16383 q1 is norm = 1
+min q1 (10, 16)=6.47517511943802511092443895822764655e-4966, 1.p-16494 q1 is denorm = 1
-min q1 (10,16)=-6.47517511943802511092443895822764655e-4966, -1.p-16494 q1 is denorm = 1
q1 (10,2,4,8,16)= 5.00000000000000000000000000000000000, 1.01p2, 1.1p2, 1.2p2, 1.4p2
q2 = 1.00000000000000000000000000000000000e1
q1 = 5.00000000000000000000000000000000000
q2 = 1.00000000000000000000000000000000000e1
q1 = 5.00000000000000000000000000000000000
q2 = 1.00000000000000000000000000000000000e1
q1 + q2 = 1.50000000000000000000000000000000000e1
q1 - q2 = -5.00000000000000000000000000000000000
q2 - q1 = 5.00000000000000000000000000000000000
q1 * q2 = 5.00000000000000000000000000000000000e1
q1 / q2 = 5.00000000000000000000000000000000000e-1
q1 == q2 = 0
q1 != q2 = 1
q1 < q2 = 1
q1 <= q2 = 1
q1 > q2 = 0
q1 >= q2 = 0
sticky status bits = 0
5.00000000000000000000000000000000000 / +0 ...  got zero_division
5.00000000000000000000000000000000000 / +0 = +Inf status bits = 32, 32
5.00000000000000000000000000000000000 / 3.00000000000000000000000000000000000 ...  got imprecise result
5.00000000000000000000000000000000000 / 3.00000000000000000000000000000000000 = 1.66666666666666666666666666666666673 status bits = 16, 16
1.18973149535723176508575932662800702e4932 + 1.18973149535723176508575932662800702e4932 ...  got overflow
1.18973149535723176508575932662800702e4932 + 1.18973149535723176508575932662800702e4932 = +Inf status bits = 4, 4
6.47517511943802511092443895822764655e-4966 / 10 ...  got underflow
6.47517511943802511092443895822764655e-4966 / 10 = +0 status bits = 24, 8
SNaN + SNaN ...  got invalid operation
SNaN + SNaN = QNaN status bits = 3, 1
QNaN + QNaN ...  got reserved operand
QNaN + QNaN = QNaN status bits = 2, 2
sticky status bits = 0
trap mask = 0
trap mask = 63
5.00000000000000000000000000000000000 / +0 = +Inf
5.00000000000000000000000000000000000 / 3.00000000000000000000000000000000000 = 1.66666666666666666666666666666666673
1.18973149535723176508575932662800702e4932 + 1.18973149535723176508575932662800702e4932 = +Inf
6.47517511943802511092443895822764655e-4966 / 10 = +0
SNaN + SNaN = QNaN
QNaN + QNaN = QNaN
sticky status bits = 63
round = 0
1.23456789012345678901234567890123455 + 1.49999999999999999999999999999999996e-34 = 1.23456789012345678901234567890123475
round = 1
1.23456789012345678901234567890123455 + 1.49999999999999999999999999999999996e-34 = 1.23456789012345678901234567890123455
round = 2
1.23456789012345678901234567890123475 + 1.50000000000000000000000000000000015e-34 = 1.23456789012345678901234567890123494
round = 3
1.23456789012345678901234567890123455 + 1.49999999999999999999999999999999996e-34 = 1.23456789012345678901234567890123455
  got invalid round value
mq (from q1) = 5
q1 (from mq) = 5.00000000000000000000000000000000000
single 5.00000000 -> double 5.0000000000000000
single 5.00000000 -> quad 5.00000000000000000000000000000000000
double 5.0000000000000000 -> single 5.00000000
double 5.0000000000000000 -> quad 5.00000000000000000000000000000000000
quad 5.00000000000000000000000000000000000 -> single 5.00000000
quad 5.00000000000000000000000000000000000 -> double 5.0000000000000000
OUTPUT453
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
        fi
fi

# Test 454.
if test $result = ok -a $start_test_number -le 454; then
	echo test 454
        cat >$test_file <<'TEST454'
println (gmatch ("aa", "aaaaa"));
TEST454
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT454' && $CMP $stdout $ftemp2; then
[0, 2, 2, 4]
OUTPUT454
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 455.
if test $result = ok -a $start_test_number -le 455; then
	echo test 455
        cat >$test_file <<'TEST455'
println (gmatch ("aa", "aaaaa", 1));
TEST455
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT455' && $CMP $stdout $ftemp2; then
[0, 2, 1, 3, 2, 4, 3, 5]
OUTPUT455
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 456.
if test $result = ok -a $start_test_number -le 456; then
	echo test 456
        cat >$test_file <<'TEST456'
var i;
for (i = 0; i < 300000; i++)
  gmatch ("aa", "aaaaa", 1);
TEST456
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT456' && $CMP $stdout $ftemp2; then
OUTPUT456
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 457.
if test $result = ok -a $start_test_number -le 457; then
	echo test 457
        cat >$test_file <<'TEST457'
gmatch ("aa", "aaaaa", nil);
TEST457
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=fail
        elif $SCMP $stderr - <<'TEST457-1'; then
test.d:1:9: run time error - invalid parameter type of `gmatch'
TEST457-1
                result=ok
        else
                result=fail
        fi
fi

# Test 458.
if test $result = ok -a $start_test_number -le 458; then
	echo test 458
        cat >$test_file <<'TEST458'
gmatch ("aa");
TEST458
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=fail
        elif $SCMP $stderr - <<'TEST458-1'; then
test.d:1:9: run time error - invalid number of parameters of `gmatch'
TEST458-1
                result=ok
        else
                result=fail
        fi
fi

# Test 459.
if test $result = ok -a $start_test_number -le 459; then
	echo test 459
        cat >$test_file <<'TEST459'
gmatch ("[aa", "aa");
TEST459
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=fail
        elif $SCMP $stderr - <<'TEST459-1'; then
test.d:1:9: run time error - unmatched bracket list operators in regexp
TEST459-1
                result=ok
        else
                result=fail
        fi
fi

# Test 460.
if test $result = ok -a $start_test_number -le 460; then
	echo test 460
        cat >$test_file <<'TEST460'
gmatch (nil, "aa");
TEST460
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=fail
        elif $SCMP $stderr - <<'TEST460-1'; then
test.d:1:9: run time error - invalid parameter type of `gmatch'
TEST460-1
                result=ok
        else
                result=fail
        fi
fi

# Test 461.
if test $result = ok -a $start_test_number -le 461; then
	echo test 461
        cat >$test_file <<'TEST461'
gmatch ("aa", nil);
TEST461
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=fail
        elif $SCMP $stderr - <<'TEST461-1'; then
test.d:1:9: run time error - invalid parameter type of `gmatch'
TEST461-1
                result=ok
        else
                result=fail
        fi
fi

# Test 462.
if test $result = ok -a $start_test_number -le 462; then
	echo test 462
        cat >$test_file <<'TEST462'
put (getf());
TEST462
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT462' && $CMP $stdout $ftemp2; then
abcd
OUTPUT462
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 463.
if test $result = ok -a $start_test_number -le 463; then
	echo test 463
        cat >$test_file <<'TEST463'
var c, f = open ("test.d", "r");
put (fgetf (f));
TEST463
        echo '      ' "echo abcd | $DINO $test_file 2>$stderr"
        if echo abcd | $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT463' && $CMP $stdout $ftemp2; then
var c, f = open ("test.d", "r");
put (fgetf (f));
OUTPUT463
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 464.
if test $result = ok -a $start_test_number -le 464; then
	echo test 464
        cat >$test_file <<'TEST464'
put (getf ());
put (getf ());
TEST464
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT464' && $CMP $stderr $ftemp2; then
test.d:2:11: run time error - EOF occured in `getf'
OUTPUT464
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 465.
if test $result = ok -a $start_test_number -le 465; then
	echo test 465
        cat >$test_file <<'TEST465'
var c, f=open ("test.d", "r");
for (;1;)
  put (fgetf (f));
TEST465
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT465' && $CMP $stderr $ftemp2; then
test.d:3:14: run time error - EOF occured in `fgetf'
OUTPUT465
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 466.
if test $result = ok -a $start_test_number -le 466; then
	echo test 466
        cat >$test_file <<'TEST466'
var c = getf (nil);
TEST466
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT466' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid parameter type of `getf'
OUTPUT466
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 467.
if test $result = ok -a $start_test_number -le 467; then
	echo test 467
        cat >$test_file <<'TEST467'
var c = fgetf ();
TEST467
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT467' && $CMP $stderr $ftemp2; then
test.d:1:16: run time error - invalid number of parameters of `fgetf'
OUTPUT467
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 468.
if test $result = ok -a $start_test_number -le 468; then
	echo test 468
        cat >$test_file <<'TEST468'
var c = fgetf (nil);
TEST468
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT468' && $CMP $stderr $ftemp2; then
test.d:1:16: run time error - invalid parameter type of `fgetf'
OUTPUT468
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 469.
if test $result = ok -a $start_test_number -le 469; then
	echo test 469
        cat >$test_file <<'TEST469'
var c = fgetf (stdin, nil);
TEST469
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT469' && $CMP $stderr $ftemp2; then
test.d:1:16: run time error - invalid parameter type of `fgetf'
OUTPUT469
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 470.
if test $result = ok -a $start_test_number -le 470; then
	echo test 470
        cat >$test_file <<'TEST470'
println (char ('a'));
println (char ("97"));
TEST470
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT470' && $CMP $stdout $ftemp2; then
'a'
'a'
OUTPUT470
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 471.
if test $result = ok -a $start_test_number -le 471; then
	echo test 471
        cat >$test_file <<'TEST471'
println (int (10.0));
println (int ("10"));
TEST471
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT471' && $CMP $stdout $ftemp2; then
10
10
OUTPUT471
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 472.
if test $result = ok -a $start_test_number -le 472; then
	echo test 472
        cat >$test_file <<'TEST472'
println (float (10.5));
println (float ("10.5"));
println (float (10));
TEST472
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT472' && $CMP $stdout $ftemp2; then
10.5
10.5
10
OUTPUT472
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 473.
if test $result = ok -a $start_test_number -le 473; then
	echo test 473
        cat >$test_file <<'TEST473'
println (char (nil));
TEST473
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT473' && $CMP $stderr $ftemp2; then
test.d:1:14: run time error - invalid type of operand of char (...)
OUTPUT473
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 474.
if test $result = ok -a $start_test_number -le 474; then
	echo test 474
        cat >$test_file <<'TEST474'
println (char ({}));
TEST474
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT474' && $CMP $stderr $ftemp2; then
test.d:1:18: invalid operand type in char (...)
OUTPUT474
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 475.
if test $result = ok -a $start_test_number -le 475; then
	echo test 475
        cat >$test_file <<'TEST475'
println (char (300));
TEST475
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT475' && $CMP $stderr $ftemp2; then
test.d:1:14: system error - result too big (small): `int-to-char conversion'
OUTPUT475
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 476.
if test $result = ok -a $start_test_number -le 476; then
	echo test 476
        cat >$test_file <<'TEST476'
println (char ("30000000000000000"));
TEST476
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT476' && $CMP $stderr $ftemp2; then
test.d:1:14: system error - result too big (small): `string-to-int conversion'
OUTPUT476
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 477.
if test $result = ok -a $start_test_number -le 477; then
	echo test 477
        cat >$test_file <<'TEST477'
println (int (nil));
TEST477
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT477' && $CMP $stderr $ftemp2; then
test.d:1:13: run time error - invalid type of operand of int (...)
OUTPUT477
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 478.
if test $result = ok -a $start_test_number -le 478; then
	echo test 478
        cat >$test_file <<'TEST478'
println (int ({}));
TEST478
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT478' && $CMP $stderr $ftemp2; then
test.d:1:17: invalid operand type in int (...)
OUTPUT478
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 479.
if test $result = ok -a $start_test_number -le 479; then
	echo test 479
        cat >$test_file <<'TEST479'
println (int ("30000000000000000"));
TEST479
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT479' && $CMP $stderr $ftemp2; then
test.d:1:13: system error - result too big (small): `string-to-int conversion'
OUTPUT479
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 480.
if test $result = ok -a $start_test_number -le 480; then
	echo test 480
        cat >$test_file <<'TEST480'
println (float (nil));
TEST480
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT480' && $CMP $stderr $ftemp2; then
test.d:1:15: run time error - invalid type of operand of float (...)
OUTPUT480
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 481.
if test $result = ok -a $start_test_number -le 481; then
	echo test 481
        cat >$test_file <<'TEST481'
println (float ({}));
TEST481
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT481' && $CMP $stderr $ftemp2; then
test.d:1:19: invalid operand type in float (...)
OUTPUT481
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 482.
if test $result = ok -a $start_test_number -le 482; then
	echo test 482
        cat >$test_file <<'TEST482'
println (float ("1e500"));
TEST482
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT482' && $CMP $stderr $ftemp2; then
test.d:1:15: system error - result too big (small): `string-to-float conversion'
OUTPUT482
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 483.
if test $result = ok -a $start_test_number -le 483; then
	echo test 483
        cat >$test_file <<'TEST483'
println (float ("1e-500"));
TEST483
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT483' && $CMP $stdout $ftemp2; then
0
OUTPUT483
                        result=ok
                else
                        result=fail
                fi
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT483-1' && $CMP $stderr $ftemp2; then
test.d:1:15: system error - result too big (small): `string-to-float conversion'
OUTPUT483-1
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 484.
if test $result = ok -a $start_test_number -le 484; then
	echo test 484
        cat >$test_file <<'TEST484'
putln (version);
TEST484
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                regex="^[0-9]\.[0-9][0-9]$"
                echo '      ' egrep \'$regex\' $stdout
                if egrep "$regex" $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 485.
if test $result = ok -a $start_test_number -le 485; then
	echo test 485
        cat >$test_file <<'TEST485'
var objs_number = 0;
class obj () {
  private n, destroy;
  var n = objs_number;
  objs_number++;
  putln ("creating ", n);
  private destroy;
  func destroy () {objs_number--; putln ("destroying ", n);}
}

var i;
for (i = 0; i < 20; i++)
  obj ();
gc ();
putln (objs_number);
TEST485
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT485' && $CMP $stdout $ftemp2; then
creating 0
creating 1
creating 2
creating 3
creating 4
creating 5
creating 6
creating 7
creating 8
creating 9
creating 10
creating 11
creating 12
creating 13
creating 14
creating 15
creating 16
creating 17
creating 18
creating 19
destroying 0
destroying 1
destroying 2
destroying 3
destroying 4
destroying 5
destroying 6
destroying 7
destroying 8
destroying 9
destroying 10
destroying 11
destroying 12
destroying 13
destroying 14
destroying 15
destroying 16
destroying 17
destroying 18
destroying 19
0
OUTPUT485
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 486.
if test $result = ok -a $start_test_number -le 486; then
	echo test 486
        cat >$test_file <<'TEST486'
put (sprint (nil));put (" ");
put (sprint (10));put (" ");
put (sprint (10.2e10));put (" ");
put (sprint ('c'));put (" ");
put (sprintln ("ssss"));
put (sprintln (["aaa", "bbb", "ccc"]));
put (sprintln (["v1", {"key":"val", {"key1":"val1"}}]));
func f () {}
put (sprintln (f));
class c () {}
put (sprintln (c));
put (sprintln (c ()));
var stop;
stop = 0;
thread t () {wait (stop);}
put (sprintln (t()));
wait (1) stop = 1;
TEST486
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
		sed 's/([0-9]*)/()/g' $stdout >$ftemp
                echo '      ' $CMP - $ftemp
                if cat >$ftemp2 <<'OUTPUT486' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+11 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", {"key":"val", {"key1":"val1"}:nil}]
func f
class c
instance c()
thread 1 t()
OUTPUT486
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT486-1' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+011 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", {"key":"val", {"key1":"val1"}:nil}]
func f
class c
instance c()
thread 1 t()
OUTPUT486-1
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT486-2' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+11 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", {{"key1":"val1"}:nil, "key":"val"}]
func f
class c
instance c()
thread 1 t()
OUTPUT486-2
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT486-3' && $CMP $ftemp $ftemp2; then
nil 10 1.02e+011 'c' "ssss"
["aaa", "bbb", "ccc"]
["v1", {{"key1":"val1"}:nil, "key":"val"}]
func f
class c
instance c()
thread 1 t()
OUTPUT486-3
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 487.
if test $result = ok -a $start_test_number -le 487; then
	echo test 487
        cat >$test_file <<'TEST487'
put (sput (10));put (" ");
put (sput (10.2e10, " "));
put (sputln ('c', " ", "ssss"));
TEST487
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT487' && $CMP $stdout $ftemp2; then
10 1.02e+11 c ssss
OUTPUT487
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT487a' && $CMP $stdout $ftemp2; then
10 1.02e+011 c ssss
OUTPUT487a
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 488.
if test $result = ok -a $start_test_number -le 488; then
	echo test 488
        cat >$test_file <<'TEST488'
sputln (nil);
TEST488
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT488' && $CMP $stderr $ftemp2; then
test.d:1:9: run time error - invalid parameter type of `sputln'
OUTPUT488
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 489.
if test $result = ok -a $start_test_number -le 489; then
	echo test 489
        cat >$test_file <<'TEST489'
sput ([10]);
TEST489
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT489' && $CMP $stderr $ftemp2; then
test.d:1:7: run time error - invalid parameter type of `sput'
OUTPUT489
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 490.
if test $result = ok -a $start_test_number -le 490; then
	echo test 490: More error recovery with 2 errors.
        cat >$test_file <<'TEST490'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1\n\
           | '(' error ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
p.set_one_parse (0);
p.set_recovery (0);
p.set_grammar (g, 1);

var str = "a+a*(a*)+(*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

println (root);
exit (p.ambiguous_p);
TEST490
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT490' && $CMP $stdout $ftemp2; then
syntax error on token #7 (41) -- ignore 0 tokens starting with token #-1
nil
OUTPUT490
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 491.
if test $result = ok -a $start_test_number -le 491; then
	echo test 491: Parsing expression without lookahead
        cat >$test_file <<'TEST491'
var g = "E : E '+' T # plus (0 2)\n\
           | T       # 0\n\
           | error   # 0\n\
         T : T '*' F # mult (0 2)\n\
           | F       # 0\n\
         F : 'a' # 0\n\
           | '(' E ')' # 1";

var p = parser ();

ext token { var order;}

p.set_debug (0);
println (p.set_lookahead (0));
p.set_one_parse (0);
p.set_grammar (g, 1);

var str = "a+a*(a+a*a)";
var i, inp = [#str : nil];

for (i = 0; i < #str; i++) {
  inp [i] = token (str[i] + 0);
  inp [i].order = i;
}

func error (err_tok_num, err_tok,
            start_ignored_tok_num, start_ignored_tok_attr,
	    start_recovered_tok_num, start_recovered_tok) {
  put ("syntax error on token #", err_tok_num, " (", err_tok.code, ")");
  putln (" -- ignore ", start_recovered_tok_num - start_ignored_tok_num,
         " tokens starting with token #", start_ignored_tok_num);
}

var root = p.parse (inp, error);

func pr (r, ind) {
  var i, n = r.name;

  for (i = 0; i < ind; i++)
    put (" ");
  put (n);
  if (n == "$term")
    putln ("(", r.transl.code, ", ", r.transl.order, ")");
  else if (n == "$error" || n == "$nil")
    putln ();
  else {
    putln ("(");
    for (i = 0; i < #r.transl; i++)
       pr (r.transl [i], ind + 2);
    for (i = 0; i < ind; i++)
      put (" ");
    putln (")");
  }
}

pr (root, 0);
println (p.set_lookahead (1));
exit (p.ambiguous_p);
TEST491
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT491' && $CMP $stdout $ftemp2; then
1
plus(
  $term(97, 0)
  mult(
    $term(97, 2)
    plus(
      $term(97, 5)
      mult(
        $term(97, 7)
        $term(97, 9)
      )
    )
  )
)
0
OUTPUT491
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 492.
if test $result = ok -a $start_test_number -le 492; then
	echo test 492: More parameter exception.
        cat >$test_file <<'TEST492'
var p = parser ();
p.set_lookahead ("0");
p.set_debug ("0");
p.set_lookahead (nil);
exit (0);
TEST492
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT492' && $CMP $stderr $ftemp2; then
test.d:4:17: run time error - invalid parameter type of `set_lookahead'
OUTPUT492
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 493.
if test $result = ok -a $start_test_number -le 493; then
	echo test 493: gethostinfo.
        cat >$test_file <<'TEST493'
include "socket";
var hi = sockets.gethostinfo (argv [0]);
println (hi.name, hi.aliases, hi.ipaddrs);
exit (0);
TEST493
        if uname | fgrep CYGWIN; then
            echo '      ' "$DINO -L./ipcerr.dll -L./socket.dll -I@srcdir@  $test_file 127.0.0.1 >$stdout"
            if $DINO -L./ipcerr.dll -L./socket.dll -I@srcdir@ $test_file 127.0.0.1 >$stdout; then
                echo '      ' egrep '^".+"\[.*\]\[".+"\]$' $stdout
                if egrep '^".+"\[.*\]\[".+"\]$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
            else
                result=fail
            fi
        else
            echo '      ' "$DINO -L./ipcerr.@EXTERN_LIB_SUFFIX@ -L./socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file 127.0.0.1 >$stdout"
            if $DINO -L./ipcerr.@EXTERN_LIB_SUFFIX@ -L./socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 127.0.0.1 >$stdout; then
                echo '      ' egrep '^".+"\[.*\]\[".+"\]$' $stdout
                if egrep '^".+"\[.*\]\[".+"\]$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
            else
                result=fail
            fi
	fi
fi

# Test 494.
if test $result = ok -a $start_test_number -le 494; then
	echo test 494: getservbyname.
        cat >$test_file <<'TEST494'
include "socket";

var s = sockets.getservbyname (argv[0], "tcp");
if (s != nil)
  println (s.name, s.aliases, s.port, s.proto);
exit (0);
TEST494
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./ipcerr.dll -L./socket.dll -I@srcdir@  $test_file time >$stdout"
        if $DINO -L./ipcerr.dll -L./socket.dll -I@srcdir@ $test_file time >$stdout; then
                echo '      ' egrep '^".+"\[".+"\]37"tcp"$' $stdout
                if egrep '^".+"\[".+"\]37"tcp"$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     else
        echo '      ' "$DINO -L./ipcerr.@EXTERN_LIB_SUFFIX@ -L./socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file time >$stdout"
        if $DINO -L./ipcerr.@EXTERN_LIB_SUFFIX@ -L./socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file time >$stdout; then
                echo '      ' egrep '^".+"\[".+"\]37"tcp"$' $stdout
                if egrep '^".+"\[".+"\]37"tcp"$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     fi
fi

# Test 495.
if test $result = ok; then
	echo test 495: Skipping daytime udp.
elif test $result = ok -a $start_test_number -le 495; then
	echo test 495: daytime udp.
        cat >$test_file <<'TEST495'
include "socket";

var str, s = sockets.dgram_client ();
s.sendto ("get me date", "tock.usno.navy.mil", 13);
var d = s.recvfrom (300);
putln (d.str);
exit (0);
TEST495
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./ipcerr.dll -L./socket.dll -I@srcdir@  $test_file time >$stdout"
        if $DINO -L./ipcerr.dll -L./socket.dll -I@srcdir@ $test_file time >$stdout; then
                echo '      ' egrep '^[A-Za-z]+ [A-Za-z]+ [0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9]' $stdout
                if egrep '^[A-Za-z]+ [A-Za-z]+ [0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9]' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     else
        echo '      ' "$DINO -L./ipcerr.@EXTERN_LIB_SUFFIX@ -L./socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file time >$stdout"
        if $DINO -L./ipcerr.@EXTERN_LIB_SUFFIX@ -L./socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file time >$stdout; then
                echo '      ' egrep '^[A-Za-z]+ [A-Za-z]+ [0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9]' $stdout
                if egrep '^[A-Za-z]+ [A-Za-z]+ [0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9]' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     fi
fi

# Test 496.
if test $result = ok -a $start_test_number -le 496; then
	echo test 496: daytime udp.
        cat >$test_file <<'TEST496'
include "socket";

var str, s = sockets.stream_client ("time.ien.it", 13);

str = "";
try {
  for (;;) {str @= s.read (20);}
} catch (socket_excepts.eof) {
}

putln (str);
exit (0);
TEST496
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./ipcerr.dll -L./socket.dll -I@srcdir@  $test_file time >$stdout"
        if $DINO -L./ipcerr.dll -L./socket.dll -I@srcdir@ $test_file time >$stdout; then
                echo '      ' egrep '(^[A-Za-z]+ [A-Za-z]+[ ]+[0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [0-9][0-9][0-9][0-9])|(^[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z0-9]+)' $stdout
                if egrep '(^[A-Za-z]+ [A-Za-z]+[ ]+[0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [0-9][0-9][0-9][0-9])|(^[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z0-9]+)' $stdout; then
                        result=ok
                else
			cat $stdout
                        result=fail
                fi
        else
                result=fail
        fi
     else
        echo '      ' "$DINO -L./ipcerr.@EXTERN_LIB_SUFFIX@ -L./socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file time >$stdout"
        if $DINO -L./ipcerr.@EXTERN_LIB_SUFFIX@ -L./socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file time >$stdout; then
                echo '      ' egrep '(^[A-Za-z]+ [A-Za-z]+[ ]+[0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [0-9][0-9][0-9][0-9])|(^[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z0-9]+)' $stdout
                if egrep '(^[A-Za-z]+ [A-Za-z]+[ ]+[0-9][0-9]? [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [0-9][0-9][0-9][0-9])|(^[0-9][0-9] [A-Za-z]+ [0-9][0-9][0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [A-Za-z0-9]+)' $stdout; then
                        result=ok
                else
			cat $stdout
                        result=fail
                fi
        else
                result=fail
        fi
     fi
fi

# Test 497.
if test $result = ok -a $start_test_number -le 497; then
	echo test 497: host is unknown
        cat >$test_file <<'TEST497'
include "socket";
var cl, send, rec, i;
cl = sockets.stream_client ("abracadabra", 10003);
exit (0);
TEST497
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./ipcerr.dll -L./socket.dll -I@srcdir@ $test_file 2>$stderr"
        if $DINO -L./ipcerr.dll -L./socket.dll -I@srcdir@ $test_file 2>$stderr >$stdout; then
                result=fail
        else
		sed 's,\\,/,g' $stderr|sed 's%^.*socket.d%@srcdir@/socket.d%' >$ftemp
                echo '      ' $CMP $ftemp $ftemp2
                if cat >$ftemp2 <<'OUTPUT497' && $CMP $ftemp $ftemp2; then
In file processed from test.d:1:18:
@srcdir@/socket.d:63:11: host is unknown
OUTPUT497
                        result=ok
                else
                        result=fail
                fi
        fi
     else
        echo '      ' "$DINO -L./ipcerr.@EXTERN_LIB_SUFFIX@ -L./socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 2>$stderr"
        if $DINO -L./ipcerr.@EXTERN_LIB_SUFFIX@ -L./socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 2>$stderr >$stdout; then
                result=fail
        else
		sed 's,\\,/,g' $stderr|sed 's%^.*socket.d%@srcdir@/socket.d%' >$ftemp
                echo '      ' $CMP $ftemp $ftemp2
                if cat >$ftemp2 <<'OUTPUT497' && $CMP $ftemp $ftemp2; then
In file processed from test.d:1:18:
@srcdir@/socket.d:63:11: host is unknown
OUTPUT497
                        result=ok
                else
                        result=fail
                fi
        fi
     fi
fi

# Test 498.
if test $result = ok -a $start_test_number -le 498; then
	echo test 498: Contexts and internal caches.
        cat >$test_file <<'TEST498'
class a (i, n) {
  func ex () {
    putln ("before = ", i);
    if (n != nil) n.ex ();
    putln ("after = ", i);
  }
}

var o = a (1, a (10, nil));

o.ex ();
TEST498
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT498' && $CMP $stdout $ftemp2; then
before = 1
before = 10
after = 10
after = 1
OUTPUT498
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 499.
if test $result = ok -a $start_test_number -le 499; then
	echo test 499: getservbyport.
        cat >$test_file <<'TEST499'
include "socket";

var s = sockets.getservbyport (argv [0] + 0, "tcp");
if (s != nil)
  println (s.name, s.aliases, s.port, s.proto);
exit (0);
TEST499
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./ipcerr.dll -L./socket.dll -I@srcdir@  $test_file 37 >$stdout"
        if $DINO -L./ipcerr.dll -L./socket.dll -I@srcdir@ $test_file 37 >$stdout; then
                echo '      ' test -z "\`cat $stdout\`" '|| egrep ^".+"\[".+"\]37"tcp"$' $stdout
                if test -z "`cat $stdout`" || egrep '^".+"\[".+"\]37"tcp"$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     else
        echo '      ' "$DINO -L./ipcerr.@EXTERN_LIB_SUFFIX@ -L./socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file 37 >$stdout"
        if $DINO -L./ipcerr.@EXTERN_LIB_SUFFIX@ -L./socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 37 >$stdout; then
                echo '      ' test -z "\`cat $stdout\`" '|| egrep ^".+"\[".+"\]37"tcp"$' $stdout
                if test -z "`cat $stdout`" || egrep '^".+"\[".+"\]37"tcp"$' $stdout; then
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     fi
fi

# Test 500.
if test $result = ok -a $start_test_number -le 500; then
	echo test 500: getservbyname for unknown name.
        cat >$test_file <<'TEST500'
include "socket";

var s = sockets.getservbyname (argv[0], "tcp");
if (s != nil)
  println (s.name, s.aliases, s.port, s.proto);
exit (0);
TEST500
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./ipcerr.dll -L./socket.dll -I@srcdir@  $test_file abracadabra >$stdout"
        if $DINO -L./ipcerr.dll -L./socket.dll -I@srcdir@ $test_file abracadabra >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT500' && $CMP $stdout $ftemp2; then
OUTPUT500
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     else
        echo '      ' "$DINO -L./ipcerr.@EXTERN_LIB_SUFFIX@ -L./socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file abracadabra >$stdout"
        if $DINO -L./ipcerr.@EXTERN_LIB_SUFFIX@ -L./socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file abracadabra >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT500a' && $CMP $stdout $ftemp2; then
OUTPUT500a
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     fi
fi

# Test 501.
if test $result = ok -a $start_test_number -le 501; then
	echo test 501: getservbyport for unknown port.
        cat >$test_file <<'TEST501'
include "socket";

var s = sockets.getservbyport (argv[0] + 0, "tcp");
if (s != nil)
  println (s.name, s.aliases, s.port, s.proto);
exit (0);
TEST501
     if uname | fgrep CYGWIN; then
        echo '      ' "$DINO -L./ipcerr.dll -L./socket.dll -I@srcdir@  $test_file 313131 >$stdout"
        if $DINO -L./ipcerr.dll -L./socket.dll -I@srcdir@ $test_file 313131 >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT501' && $CMP $stdout $ftemp2; then
OUTPUT501
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     else
        echo '      ' "$DINO -L./ipcerr.@EXTERN_LIB_SUFFIX@ -L./socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@  $test_file 313131 >$stdout"
        if $DINO -L./ipcerr.@EXTERN_LIB_SUFFIX@ -L./socket.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 313131 >$stdout; then
                echo '      ' $CMP - $stdout
                if cat >$ftemp2 <<'OUTPUT501a' && $CMP $stdout $ftemp2; then
OUTPUT501a
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
     fi
fi

# Test 502.
if test $result = ok -a $start_test_number -le 502; then
	echo test 502: Final destroying by implicit program finish.
        cat >$test_file <<'TEST502'
class c () {
  putln ("creating instance");
  func destroy () {putln ("destroying instance");}
}

var i = c ();
TEST502
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT502' && $CMP $stdout $ftemp2; then
creating instance
destroying instance
OUTPUT502
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 503.
if test $result = ok -a $start_test_number -le 503; then
	echo test 503: Final destroying by zero exit.
        cat >$test_file <<'TEST503'
class c () {
  putln ("creating instance");
  func destroy () {putln ("destroying instance");}
}

var i = c ();
exit (0);
TEST503
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT503' && $CMP $stdout $ftemp2; then
creating instance
destroying instance
OUTPUT503
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 504.
if test $result = ok -a $start_test_number -le 504; then
	echo test 504: Final destroying by nonzero exit.
        cat >$test_file <<'TEST504'
class c () {
  putln ("creating instance");
  func destroy () {putln ("destroying instance");}
}

var i = c ();
exit (1);
TEST504
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT504' && $CMP $stdout $ftemp2; then
creating instance
destroying instance
OUTPUT504
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 505.
if test $result = ok -a $start_test_number -le 505; then
	echo test 505: Final destroying by throw.
        cat >$test_file <<'TEST505'
class c () {
  putln ("creating instance");
  func destroy () {putln ("destroying instance");}
}

var i = c ();
throw except ();
TEST505
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT505' && $CMP $stdout $ftemp2; then
creating instance
destroying instance
OUTPUT505
	           if cat >$ftemp2 <<'OUTPUT505a' && $CMP $stderr $ftemp2; then
test.d:7:5: run time error - exception except has not been processed
OUTPUT505a
                        result=ok
                   else
                        result=fail
                   fi
                else
                        result=fail
                fi
        fi
fi

# Test 506.
if test $result = ok -a $start_test_number -le 506; then
	echo test 506: Serhei\'s interpereter -- big program - 1500 lines.
	echo '      ' rm -rf $tempdir
	echo '      ' mkdir $tempdir
	if rm -rf $tempdir && mkdir $tempdir; then
	  echo '      ' Forming Grip interpriter files and test program in $tempdir
	  cat >$tempdir/anode_work.d <<'TEST506'
/***********************************************************
** These functions are used to translate a given object   **
** of class anode() to the equivalent object of class     **
** prog().                                                **
***********************************************************/
// For elaborate dumpings:
var dumpfl = 0;
// Here is the function to parse a program anode. It is very trivial and
// is included for the client's convenience.
func parse_program_anode (program_anode, local_dumpfl = 1) {
  // Initialize the dumpings.
  dumpfl = local_dumpfl;
  var object_program = prog (), intermediate_view;
  if (program_anode.name != "program") { // Wrong node.
    putln ("! Wrong grammar. Root anode name is : ", program_anode.name);
    bad_anode ();
  }
  if (dumpfl) putln ("& Entering translation phase.");
  intermediate_view =
  parse_instruction_anode (program_anode.transl[0], dumpfl);
  // If we parsed a block, we return it as the object program so as to
  // have a bit of efficiency.
  if (intermediate_view. name == "block")
    object_program = intermediate_view.args[0];
  // Otherwise we copy the instruction.
  else object_program.exec = [intermediate_view];
  if (dumpfl)
    putln ("& Entering semantical checking phase.");
  object_program = check_block (object_program);
  if (dumpfl) {
    if (global_errfl) putln ("! Semantic check failed.");
    else putln ("& Semantic check sucessful.");
  }
  return object_program;
}
/* The function parse_instruction_anode() is used to parse an instruction. */
func parse_instruction_anode (instruction_anode) {
  // We declare a variable to work on the result, which is an object of class
  // instr().
  if (dumpfl) {
    putln ("@ Initializing instruction parsing operation with node:");
    print_anode (instruction_anode);
  }
  var result = instr ();
  if (instruction_anode.name == "assign") { // Assignment statement.
    if (dumpfl) putln ("* Identified assignment statement.");
    result.name = "assign";
    result.args = [3 : nil];
    result.args [0] = instruction_anode.transl [0].transl [0].transl;
    result.args [2] = parse_expression_anode (instruction_anode.transl[1]);
    result.args [1] = (instruction_anode.transl [0].transl [0].transl.type0
                      == 'I' ?
                      instruction_anode.transl [0].transl :
                      bad_anode () );
    if (instruction_anode.transl [0].name == "array")
      result.args [1] = parse_expression_anode (instruction_anode.
                       transl [0].transl [1]);
    else if (instruction_anode.transl [0].name == "varac") {
      result.args [1] = expression ();
      result.args [1].opr = "num";
      result.args [1].opa1 = token (0);
      // For compatibility with the semantic checker.
      result.args [1].opa1.type0 = "I";
      result.args [1].opa1.value = "0";
      result.args [1].opa2 = "integer";
    } else bad_anode ();
  } else if (instruction_anode.name == "vblock") {
    // Parse the block now.
    if (dumpfl) putln ("@ Initiating block parsing.");
    result.name = "block";
    result.args = [1 : nil];
    result.args [0] = prog ();
    // A block should be an object of class prog().
    // Process the declarations:
    if (dumpfl) putln ("@ Processing declarations...");
    var declarations = flatten (instruction_anode.transl[0], 2),
    current_identifier_declared_flag = new {};
    for (var current_declaration_processed = 0;
         current_declaration_processed < #declarations;
         current_declaration_processed++) {
      // "Flatten" the identifiers we want to declare.
      var identifiers_on_wait = flatten (
                                declarations [current_declaration_processed]
                              . transl[0], 1),
      // Analyze the specification.
      current_specification_analysis =
      component (declarations [current_declaration_processed]
                . transl [1]. transl [0],
                declarations [current_declaration_processed]
                . transl [1]. name);
      // We just assigned an object of class anode() where it is
      // not needed, so we must eradicate that.

      // Here we declare a shortcut variable used to declare arrays.
      var array_translation = current_specification_analysis.value;

      // Declare arrays here by deriving their size.
      if (current_specification_analysis.type0 != "constant")
        current_specification_analysis.arrfl +=
                      ( array_translation.name == "$nil" ? 0
                      : array_translation.name == "$term" ?
                        array_translation.transl.value
                      : bad_anode () ); // The grammar is corrupted.
      current_specification_analysis.value =
                   ( current_specification_analysis.type0 == "constant" ?
                     +array_translation.transl.value
                   : array_translation.name == "$nil" ? 0
                   : [current_specification_analysis.arrfl : 0]
                   // For arrays.
                   );
      // Now that we have the specification, we may introduce the identifiers
      // into the environment.
      if (dumpfl) putln ("@ Declaring identifiers...");
      for (var current_identifier_processing = 0;
           current_identifier_processing < #identifiers_on_wait;
           current_identifier_processing++) {
        if (identifiers_on_wait [current_identifier_processing]
           . transl [0].transl in current_identifier_declared_flag) {
          if (dumpfl) putln ("! Identifier declared twice.");
          put (program_file, ":",
               identifiers_on_wait [current_identifier_processing]
               . transl [0].transl.line_num, ":", identifiers_on_wait
               [current_identifier_processing]. transl [0].transl.char_num,
               ": ");
          error ("Attempt to declare an identifier twice.");
        }
        result.args [0].vartable
        {identifiers_on_wait [current_identifier_processing]
        . transl [0].transl} = new current_specification_analysis;
        // Now we make a note of the fact that we have just declared the
        // identifier to solve the fact that the semantic checker that is
        // applied later to the block has no way of knowing that we attempted
        // to declare an identifier twice, so we check it right now.
        current_identifier_declared_flag
        {identifiers_on_wait
        [current_identifier_processing].transl [0].transl} = 1;
      }
    }
    // In case we stumble on a wrong node.
    /* The rest is pretty easy sailing. All we have to do now
    is let the instructions be parsed, and convert tokens in the table to
    strings. */
    var current_declaration, declarations_to_convert =
    keys (result.args [0].vartable);
    if (dumpfl) putln ("* Convert values : ",
                       sprint (declarations_to_convert));
    for (var current_declaration_num = 0;
         current_declaration_num < #declarations_to_convert;
         current_declaration_num++) {
      current_declaration = declarations_to_convert [current_declaration_num];
      if (dumpfl)
        putln ("* Conversion of ",
               sprint (current_declaration));
      if (type (current_declaration) == class ()) {
        if (dumpfl)
          putln ("* Conversion worthy to ",
                 sprint (current_declaration.value));
        result.args [0].vartable {current_declaration.value} =
        result.args [0].vartable {current_declaration};
        result.args [0].vartable =
        del (result.args [0].vartable, current_declaration);
      } else if (dumpfl) putln ("* Conversion unworthy.");
    }
    if (dumpfl) {
      putln ("* Result variables :");
      println (result.args [0].vartable);
      putln ("@ Parsing the instructions...");
    }
    var instructions = flatten (instruction_anode.transl [1],
                                1);
    // We recursively call parse_instruction_anode() for each instruction.
    for (var current_instruction_number = 0;
         current_instruction_number < #instructions;
         current_instruction_number++) {
      result.args [0].exec @=
      [parse_instruction_anode (instructions [current_instruction_number].
                               transl [0])];
    }
    // Now we must declare the configuration of variables here for the
    // other blocks.
    if (dumpfl) putln ("@ Redeclaring underlying blocks...");
    result.args [0] = redeclare_block (result.args [0]);
    func redeclare_block (block) {
      func do_redeclaration (block_to_redeclare) {
        // We have a block we need to define with synchronized variables.
        var current_identifier_processed_key;
        for (current_identifier_processed_key in block.vartable)
          if (!(current_identifier_processed_key
	        in block_to_redeclare.vartable)) {
            block_to_redeclare.vartable {current_identifier_processed_key} =
            block.vartable {current_identifier_processed_key};
          }
          redeclare_block (block_to_redeclare);
      }
      func do_instruction (instr) {
        if (instr.name == "block") {
          do_redeclaration (instr.args [0]);
        } else if (instr.name == "for") {
          do_instruction (instr.args [0]);
          do_instruction (instr.args [2]);
          do_instruction (instr.args [3]);
        } else if (instr.name == "cond") {
          for (var current_alternative_processing = 1;
               current_alternative_processing < #instr.args;
               current_alternative_processing += 2)
            do_instruction (instr.args [current_alternative_processing]);
        }
      }
      try {
        for (var current_candidate_number = 0;
             current_candidate_number < #block.exec;
             current_candidate_number++)
          do_instruction (block.exec [current_candidate_number]);
      } catch (except (). error ()) {
        if (dumpfl) putln ("! Synchronization of declarations failed.");
        bad_anode();
      }
      return block;
    }
    if (dumpfl) putln ("@ Block parsing over.");
    // Now we are done with our work on the block.
  } else if (instruction_anode.name == "condit") { // The GRIP conditional.
    /* In general, a GRIP conditional is written like this:
       'cond' '{'
        (<condition> <statement>)...
        ['else'      <statement>]
       '}'
       Not unlike the LISP version. */
       if (dumpfl) putln ("* Processing conditional.");
       // Do any initial poking around with the nodes:
       result = instr ();
       result.name = "cond";
       var option_list = flatten (instruction_anode.transl [0], 2);
       /* Now that we've done that, let's translate that conditional.
       Args[] for a cond statement look like this:
        [condition, statement,...]
       and the else part is represented by a expression evaluating to 1. */
       for (var current_option_number = 0;
            current_option_number < #option_list;
            current_option_number++) {
         var temp, current_parsed_option;
         if (option_list [current_option_number].name == "elsif")
           temp = parse_expression_anode (option_list [current_option_number].
                                          transl [0]);
         else if (option_list [current_option_number].name == "else") {
           temp = expression ();
           temp.opr = "num";
           temp.opa1 = token (3);
           temp.opa1.type0 = 'I';
           temp.opa1.value = "1";
           temp.opa2 = "integer";
         } else bad_anode ();
         result.args @= [temp, parse_instruction_anode
                        (option_list [current_option_number].transl [1])];
       }
  } else if (instruction_anode.name == "foritr") {
  /* The GRIP for statement is exactly like the C one,
     except for the fact that a guard expression is REQUIRED.
     The internal representation is self-explanatory and represented
     by the tuple [initialization, guard, increment, body]. */
    // This is a quite trivial process:
    if (dumpfl) putln ("* For loop identified.");
    result.name = "for";
    result.args = [parse_instruction_anode (instruction_anode.transl [0]),
                   parse_expression_anode  (instruction_anode.transl [1]),
                   parse_instruction_anode (instruction_anode.transl [2]),
                   parse_instruction_anode (instruction_anode.transl [3])];
  /* The remaining commands are very trivial: The put statement, and the
     empty statement. */
  } else if (instruction_anode.name == "output") {
  /* The put statement outputs all its parameters with an additional newline
     character at the end. */
    // Trivial stuff first:
    if (dumpfl) putln ("* Analyzing output statement.");
    result.name = "put";
    var objects_on_wait_list = flatten (instruction_anode.transl [0],
                                        1);
    // Now, a loop to deal with every object we want to output.
    for (var current_object_processing = 0;
         current_object_processing < #objects_on_wait_list;
         current_object_processing++) {
      if (objects_on_wait_list [current_object_processing].name
          == "expressionel")
        result.args @= [parse_expression_anode
                       (objects_on_wait_list
                       [current_object_processing].transl [0])];
      else if (objects_on_wait_list [current_object_processing].name
               == "stringel") {
        var temp = expression ();
        temp.opr = "num";
        temp.opa1 = objects_on_wait_list [current_object_processing].transl[0]
                                         . transl;
        temp.opa2 = "string";
        result.args @= [temp];
      } else {
        if (dumpfl) putln ("! Wrong instruction node, name : ",               
                           instruction_anode.name);
        bad_anode ();
      }
    }
  } else if (instruction_anode.name == "$nil") {
    // The empty statement is represented by a nil-anode.
    if (dumpfl) putln ("* Conversion $nil -> empty statement.");
    result.name = "empty";
  /* If we get an unknown node, we finish with a fatal error message. */
  } else {
    if (dumpfl) putln ("! Unknown node name : ", instruction_anode.name);
    bad_anode ();
  }
  return result; // Now the result is returned.
}

func parse_expression_anode (expression_anode) {
  /* This function parses an expression node into an object of
     class expression(). It can take both a factor and an expression. */
  if (dumpfl) {
    putln ("@ Initiating expression parsing with node :");
    print_anode (expression_anode);
  }
  // A variable on which to work and then return.
  var result = expression ();
  // For describing a factor.
  if (expression_anode.name == "factor") {
    if (dumpfl) putln ("* Identified a factor.");
    if (expression_anode.transl [0].name == "$term") { // Literal numbers.
      if (dumpfl) putln ("* Found literal number.");
      result.opr = "num";
      result.opa1 = expression_anode.transl [0].transl;
      result.opa2 = (expression_anode.transl [0].transl.value ==
                     int (expression_anode.transl [0].transl.value) ?
                     "integer" : "real");
    } else if (expression_anode.transl [0].name == "varac") {
      // Variable acessing.
      result.opr = "var";
      result.opa1 = expression_anode.transl [0].transl [0].transl;
      result.opa2 = expression ();
      result.opa2.opr = "num";
      result.opa2.opa1 = token (3);
      result.opa2.opa1.type0 = 'N';
      result.opa2.opa1.value = "0";
      result.opa2.opa2 = "integer";
      if (dumpfl) putln ("* Parsed an variable reference.");
    } else if (expression_anode.transl [0].name == "array") {
      // Array referencing -- done by the same operator.
      result.opr = "var";
      result.opa1 = expression_anode.transl [0].transl [0].transl;
      result.opa2 = parse_expression_anode
      (expression_anode.transl [0].transl [1]);
      if (dumpfl) putln ("* Parsed an array reference.");
    } else if (expression_anode.transl [0].name == "expression" ||
               expression_anode.transl [0].name == "double" ||
               expression_anode.transl [0].name == "single") {
      // We have a parenthesized expression for which we just recursively
      // invoke parse_expression_anode().
      result = parse_expression_anode (expression_anode.transl [0]);
      if (dumpfl) putln ("* Processed parenthesized expression.");
    } else {
      if (dumpfl) putln ("! Bad node, name is ", expression_anode.name);
      bad_anode ();
    }
  } else if (expression_anode.name == "double") { // Binary operators.
    result.opr = (expression_anode.transl [1].transl.code == 21 ? // Plus.
                  "add" :
                  expression_anode.transl [1].transl.code == 22 ? // Minus.
                  "sub" :
                  expression_anode.transl [1].transl.code == 23 ? // Times.
                  "mul" :
                  expression_anode.transl [1].transl.code == 24 ?
                  // Division.
                  "div" :
                  expression_anode.transl [1].transl.code == 26 ?
                  // Logical or.
                  "or " :
                  expression_anode.transl [1].transl.code == 25 ?
                  // Logical and.
                  "and" :
                  expression_anode.transl [1].transl.code == 14 ?
                  "gtt" :
                  expression_anode.transl [1].transl.code == 13 ?
                  "ltt" :
                  expression_anode.transl [1].transl.code == 29 ?
                  "eqs" : bad_anode () );
    result.opa1 = parse_expression_anode (expression_anode.transl [0]);
    result.opa2 = parse_expression_anode (expression_anode.transl [2]);
    /* Now, for efficiency we replace ltt (A,B) by gtt (B,A). */
    if (result.opr == "ltt") {
        // Swap the operands.
        var temp = result.opa1;
        result.opa1 = result.opa2;
        result.opa2 = temp;
        // Rename the operator.
        result.opr = "gtt";
    }
  } else if (expression_anode.name == "single") {
    // To work on unary operators.
    if (expression_anode.transl [0].transl.code == 21) {
      // We have a unary plus operation that does not affect the operand.
      result = parse_expression_anode (expression_anode.transl [1]);
    } else {
      // Other possible operators include unary minus and negation (!).
      result.opr = ( expression_anode.transl [0].transl.code == 22 ?
                     // Unary minus.
                     "neg" :
                     expression_anode.transl [0].transl.code == 27 ?
                     // Logical negation.
                     "not" : bad_anode () );
      result.opa1 = parse_expression_anode (expression_anode.transl [1]);
    }
  } else if (expression_anode.name == "expression") {
    // This is a reference to a factor.
    result = parse_expression_anode (expression_anode.transl [0]);
  } else bad_anode ();
  return result;
}
       /**************************************************
       ** These are the functions to perform semantical **
       ** checking. The errors recognized are:          **
       ** 1. Attempt to declare identifier twice (found **
       ** at translation time).                         **
       ** 2. No such identifier declared.               **
       ** 3. Vector in a context expecting a scalar     **
       ** value.                                        **
       ** 4. Attempt to extract an element of a scalar  **
       ** value.                                        **
       ** 5. Attempt to assign to a constant.           **
       **************************************************/
// The function to check a block does nothing but introduce a name scope for
// its two internal functions and call check_instruction() for each statement.
func check_block (block) {
  /* check_block() has two internal functions that work on an instruction
     (check_instruction()) and expression (check_expression()). */
  func check_instruction (instruction) {
    /* Most of the commands just cause invocations of other functions,
       but assignment finds four important semantic errors (see #2-5). */
    // Most important parts first this time.
    if (instruction.name == "assign") {
      if (dumpfl) putln ("* Checking an assignment statement.");
      /* First, check for error #2. */
      if (!(instruction.args [0].value in block.vartable)) {
        put (program_file, ":", instruction.args [0].line_num, ":",
        instruction.args [0].char_num, ": ");
        error ("No such variable declared.");
      } else {
        /* If these would have appeared after the conditional, !keyvalue would
           be generated, which is undesirable. */
        /* Now, we may check for error #3. */
//        if (type (block.vartable {instruction.args [0].value}.value)
//            == vector 
//            && instruction.args [1].opr == "num" &&
//            int (instruction.args [1].opa1.value) == 0) {
//          put (program_file, ":", instruction.args [0].line_num, ":",
//               instruction.args [0].char_num, ": ");
//          error ("Structured value in scalar context.");
//        }
//        /* Lastly, error #4 must be checked. "elsif" is used for efficiency. */
//        else
        if (type (block.vartable {instruction.args [0].value}.value) !=
                 vector &&
                 instruction.args [1].opr != "num" &&
                 int (instruction.args [1].opa1.value) != 0) {
          put (program_file, ":", instruction.args [0].line_num, ":",
               instruction.args [0].char_num, ": ");
          error ("Attempt to reference element of scalar value.");
        } else if (block.vartable {instruction.args [0].value}.type0 ==
                   "constant") {
          put (program_file, ":", instruction.args [0].line_num, ":",
               instruction.args [0].char_num, ": ");
          error ("Attempt to assign to a constant.");
        }
      }
      // Here, we change the token to its value field.
      instruction.args [0] = instruction.args [0].value;
      // Now, we invoke check_expression to check two of the expressions:
      instruction.args [1] = check_expression (instruction.args [1]);
      instruction.args [2] = check_expression (instruction.args [2]);
      // Now we are done with our work.
    } else if (instruction.name == "put") {
      if (dumpfl) putln ("* Checking a put statement.");
    /* Here we just invoke check_expression() for every expression. */
      for (var current_object_num = 0;
           current_object_num < #instruction.args;
           current_object_num++) {
       instruction.args [current_object_num] =
        check_expression (instruction.args [current_object_num]);
      }
    } else if (instruction.name == "empty") {
      if (dumpfl) putln ("* Checking an empty statement.");
      // The empty statement is automatically correct.
    /* All the recursion is done by the statements that are structured. */
    } else if (instruction.name == "cond") {
      // Here we juct iterate through all the possible alternatives,
      // verifying whether each is correct.
      for (var current_alternative_num = 0;
           current_alternative_num < #instruction.args;
           current_alternative_num += 2) {
        instruction.args [current_alternative_num] =
        check_expression (instruction.args [current_alternative_num]);
        instruction.args [current_alternative_num + 1] =
        check_instruction (instruction.args [current_alternative_num + 1]);
      }
    } else if (instruction.name == "for") {
      // Here, it is even more basic.
      if (dumpfl) putln ("* Checking a for loop.");
      instruction.args [0] = check_instruction (instruction.args [0]);
      instruction.args [2] = check_instruction (instruction.args [2]);
      instruction.args [3] = check_instruction (instruction.args [3]);
      instruction.args [1] = check_expression  (instruction.args [1]);
    } else if (instruction.name == "block") {
      /* The block statement is resolved by a recursive invocation of
         check_block(). */
      instruction.args [0] = check_block (instruction.args [0]);
    } else fatal_error ("Internal error in translator.");
    if (dumpfl) {
      putln ("* Checked instruction, value :");
      print_instruction (instruction);
    }
    return instruction;
  }
  /* This function is used to check an expression and replace all tokens with
     corresponding values. */
  func check_expression (expression) {
    /* Let us discuss the values that we need to check. Our errors
       shall be found all in one operator: var. Its internal representation
       is as follows:
       | opr   | opa1  | opa2    |
       +-------+-------+---------+
       | "var" | IDENT | ELEMENT |
       As you can see, it acts both as a reference to a scalar value
       and a vector. The other operators are trivial:
       num : don't do anything.
       neg, not : check opa1 only.
       Otherwise, we check both operands. */
    if (expression.opr == "num") { // Don't do anything except replace tokens:
      expression.opa1 = expression.opa1.value;
    } else if (expression.opr == "neg" ||
               expression.opr == "not") { // Check opa1:
      expression.opa1 = check_expression (expression.opa1);
    } else if (expression.opr == "var") { // Check for errors.
      /* The same errors are fixed here as the ones in the assignment
         statement. In fact, almost the same procedure is used here,
         except that we do only one recursive invokation at the end, and we
         work on a different domain of objects. For a more detailed explanation
         of the algorithm's quirks, see the procedure for assignment.*/
      if (!(expression.opa1.value in block.vartable)) {
        put (program_file, ":", expression.opa1.line_num, ":0: ");
        error ("No such variable declared.");
      } else {
        /* Check for error #3. */
//        if (type (block.vartable {expression.opa1.value}.value) == vector &&
//            expression.opa2.opr == "num" &&
//            int (expression.opa2.opa1.value) == 0) {
//          put (program_file, ":", expression.opa1.line_num, ":0: ");
//          error ("Structured value in scalar context.");
//        }
//        else
          if (type (block.vartable {expression.opa1.value}.value) !=
                 vector &&
                 expression.opa2.opr != "num" &&
                 int (expression.opa2.opa1.value) != 0) {
          put (program_file, ":", expression.opa1.value, ":0: ");
          error ("Scalar value in structured context.");
        }
      }
      expression.opa1 = expression.opa1.value;
      expression.opa2 = check_expression (expression.opa2);
    } else { // A binary operator. Recursively invoke check_expression():
      expression.opa1 = check_expression (expression.opa1);
      expression.opa2 = check_expression (expression.opa2);
    }
    return expression;
  }
  if (dumpfl) putln ("@ Initiating block checking.");
  /* The main body of the function is quite trivial and consists of just a
     for-loop. Also, we must process the declarations. */
  for (var current_instruction_num = 0;
       current_instruction_num < #block.exec;
       current_instruction_num++)
    block.exec [current_instruction_num] =
    check_instruction (block.exec [current_instruction_num]);
  // Process the declarations.
  var current_declaration;
  return block;
}
/* What we have left now is a couple of common tasks I found to be
   easier to put in separate functions. */
// When an anode that is not supposed to turn up turns up, we finish
// with a diagnostic message.
func bad_anode () {
  fatal_error ("Grammar 'grip.g' corrupted or internal error.");
}
// For flattening recursive lists. This is so easily encoded in functional
// programming languages like ML! Wish I could use it here, but the SPI
// doesn't allow it.
func flatten (list_anode_to_flatten, next_num) {
  if (dumpfl) {
    putln ("@ Executing flatten operation with:");
    println (list_anode_to_flatten.transl);
    print_anode (list_anode_to_flatten);
  }
  return // Last element or not?
         (list_anode_to_flatten.name != "$nil" ?
          [list_anode_to_flatten] @
          flatten (list_anode_to_flatten.transl [next_num], next_num) : []);
}
TEST506
	  cat >$tempdir/error.d <<'TEST506a'
/* If an error arises, this function shall perform the necessary dumping, and
   increment global_errfl. Other procedures check this variable occasionally,
   and if it isn't zero, call abend(). */
var global_errfl = 0;

func error (message, ...) {
  putln ("Error : ", message); // Print a general description of the problem.
  // Do any dumping necessary to roughly locate the problem.
  if (#args != 0)
    for (var i = 0; i < #args; i++)
      try {putln(args[i]);} catch (except (). error (). invcall (). partype)
          {println(args[i]);}
  global_errfl++; // Increment the global error counter.
}

// For fatal errors :
func fatal_error (message, ...) {
  putln ("Fatal Error : ", message);
  if (#args != 0)
    for (var i = 0; i < #args; i++)
      try {putln (args[i]);}
      catch (except (). error (). invcall (). partype ())
          {println (args[i]);}
  exit (3);
}

// To assist with abnormal endings.

func abend (message) {
  putln (global_errfl, message, "error" @ (global_errfl == 1 ? "." : "s."));
  exit (2);
}

// To print out abstract nodes in a readable manner:

func print_anode (node_to_print, tablevel = 0, tabchar = ' ') {
  for (var i = 0; i < tablevel; i++) put (tabchar);
  put (node_to_print.name, " ");
  if (node_to_print.name == "$nil") println ();
  else if (node_to_print.name == "$term")
    putln (node_to_print.transl.code, ":",
           node_to_print.transl.type0, ":",
           sprint (node_to_print.transl.value));
  else {
    putln ("(");
    for (i = 0; i < #node_to_print.transl; i++)
      print_anode (node_to_print.transl [i], tablevel + 2, tabchar);
    for (i = 0; i < tablevel; i++) put (tabchar);
    putln (")");
  }
}

// For printing objects of class expr().

func print_expression (expr, tablevel = 0, tabchar = ' ') {
  for (var i = 0; i < tablevel; i++) put (tabchar);
  if (expr == nil) return;
  if (expr.opr == "num") putln (sprint (expr.opa1), " : ", sprint (expr.opa2));
  else if (expr.opr == "var") {
    put ("$", sprint (expr.opa1));
    if (!(expr.opa2.opr == "num" && expr.opa2.opa1 == "0")) {
      putln (" [");
      print_expression (expr.opa2, tablevel + 2, tabchar);
      for (i = 0; i < tablevel; i++) put (tabchar);
      putln ("]");
    } else putln ();
  } else {
    putln (expr.opr, " (");
    print_expression (expr.opa1, tablevel + 2, tabchar);
    print_expression (expr.opa2, tablevel + 2, tabchar);
    for (i = 0; i < tablevel; i++) put (tabchar);
    putln (")");
  }
}
// This function is used to print an instruction:
func print_instruction (instruction, tablevel = 0, tabchar = ' ') {
  for (var i = 0; i < tablevel; i++) put (tabchar);
  if (instruction.name == "empty") putln ("-");
  else {
    put (instruction.name, " ");
    if (instruction.name == "block") {
      putln ("{");
      for (i in instruction.args [0].vartable) {
        for (var j = 0; j < tablevel + 2; j++) put (tabchar);
        putln ("$", sprint (i), " : ", instruction.args [0].vartable {i}.type0,
               instruction.args [0].vartable {i}.arrfl ?
               " [" @ instruction.args [0].vartable {i}.arrfl @ "]" : "");
      }
      for (i = 0; i < #instruction.args [0].exec; i++)
        print_instruction (instruction.args [0].exec [i],
                           tablevel + 2, tabchar);
      for (i = 0; i < tablevel; i++) put (tabchar);
      putln ("}");
    } else if (instruction.name == "for") {
      putln ();
      for (i = 0; i < tablevel + 2; i++) put (tabchar);
      putln ("Initialization : ");
      print_instruction (instruction.args [0], tablevel + 2, tabchar);
      for (i = 0; i < tablevel + 2; i++) put (tabchar);
      putln ("---");
      for (i = 0; i < tablevel + 2; i++) put (tabchar);
      putln ("Condition : ");
      print_expression (instruction.args [1], tablevel + 2, tabchar);
      for (i = 0; i < tablevel + 2; i++) put (tabchar);
      putln ("Body : ");
      print_instruction (instruction.args [3], tablevel + 2, tabchar);
      for (i = 0; i < tablevel + 2; i++) put (tabchar);
      put ("Increment : ");
      print_instruction (instruction.args [2]);
    } else if (instruction.name == "cond") {
      putln ();
      for (i = 0; i < #instruction.args; i += 2) {
        print_expression  (instruction.args [i], tablevel + 2, tabchar);
        print_instruction (instruction.args [i + 1], tablevel + 2, tabchar);
        if (i < #instruction.args - 1) {
          for (var j = 0; j < tablevel; j++) put (tabchar);
          putln ("---");
        }
      }
    } else if (instruction.name == "assign") {
      put ("$", sprint (instruction.args [0]));
      if (!(instruction.args [1].opr == "num" &&
            instruction.args [1].opa1 == "0")) {
        putln (" [");
        print_expression (instruction.args [1], tablevel + 2, tabchar);
        for (i = 0; i < tablevel; i++) put (tabchar);
        putln ("]");
      } else putln ();
      print_expression (instruction.args [2], tablevel + 2, tabchar);
    } else if (instruction.name == "put") {
      putln ();
      for (i = 0; i < #instruction.args; i++)
        print_expression (instruction.args [i], tablevel + 2, tabchar);
      }
    }
}
TEST506a
	  cat >$tempdir/grip.d <<'TEST506b'
////////////////////////////////////////////////////////////////
// Grip 0.5s54 Designed and implemented by: Serhei Makarov.   //
// Special thanks to: Vladimir Makarov, for mentoring and     //
// moral support,                                             //
//                    Nadia Makarov, for moral support, and   //
//                    The person who invented ISPs, otherwise //
// I might not have gotten time to get such a head start in   //
// programming language design.                               //
////////////////////////////////////////////////////////////////

// GRIP 0.5 is a structured language roughly capable of performing
// algorhythmic calculations, e.g. a sieve for primes.
// WARNING : WE HAVE NOT IMPLEMENTED ANY INPUT DEVICES.

include "error"; // The error management package.
include "intrep"; // Interpretation package.
include "parser"; // Translation package.

// Command line options :
//  -v
//  --verbose       Turns on dumpings at runtime.
//
//  -t
//  --parse-results Output the results of parsing.
//
//  -d
//  --full-parse    Output information about how
//                  the parse went.
//
//  -h
//  --help          Print possible command line
//                  options and quit.
//
//  -n
//  --version       Print version number and quit.
//
//  filename        Interpret 'filename'.
var verbose_flag = 0, debug_level = 0, file_name = "",
    translator = grip_parser(), db_fl = 0;
// Db_fl is defined to find conflicting -td options and for -hn option usage.
// Find if we just want help.
if (#argv == 0) {
  putln ("No arguments found. Use 'grip --help' for help.");
  exit (0);
}
for (var argpos = 0; argpos < #argv; argpos++)
  if (argv[argpos] == "--help" ||
      argv[argpos] == "-h") {
    putln ("GRIP 0.5s54.");
    putln ("Usage: grip (option | filename)...");
    putln ("Options:");
    putln ("POSIX one character | GNU style long");
    putln (" -v                 | --verbose       : ",
           "Turn on dumpings at runtime.");
    putln (" -t                 | --parse-results : ",
           "Show the results of parsing.");
    putln (" -d                 | --full-parse    : ",
           "Show how the parse went.");
    putln (" -n                 | --version       : ",
           "Print version number and quit.");
    putln (" -h                 | --help          : ",
           "Show this screen.");
    putln ();
    putln ("Grip returns 0 on success, 2 on a non-fatal error, and");
    putln ("3 on a fatal error that prevents its functioning properly."); 
    exit (0);
  } else if (argv[argpos] == "-n" ||
             argv[argpos] == "--version") {
    putln ("GRIP 0.5s54 designed and implemented by Serhei V. Makarov.");
    putln ("Special thanks to:");
    putln ("                   Vladimir Makarov, for mentoring and");
    putln ("                   moral support, and");
    putln ("                   Nadia Makarov, for moral support.");
    exit (0);
  }
// Analyze argv[] to find out the filename needed.
for (argpos = 0; argpos < #argv; argpos++) {
  if (argv[argpos] == "-v" ||
      argv[argpos] == "--verbose") verbose_flag = 1;
  else if (argv[argpos] == "-t" ||
           argv[argpos] == "--parse-results") if (!db_fl) {
                debug_level = 2;
                db_fl++;
        } else error ("Conflicting '-t' and '-d' options.");
  else if (argv[argpos] == "-d" ||
           argv[argpos] == "--full-parse") if (!db_fl) {
                debug_level = 5;
                db_fl++;
        } else error ("Conflicting '-t' and '-d' options.");
  else if (argv[argpos] == "-" && file_name == "") file_name = "/dev/stdin";
  else if (file_name == "") file_name = argv[argpos];
  else error ("Too many arguments or arguments invalid.");
}
if (file_name == "") error ("No file name specified or file name invalid");
if (global_errfl) abend (" command line ");
// Translate and interpret.
var executable_program = 
translator.parse_file(file_name, debug_level, verbose_flag);
executable_program.execute (verbose_flag, verbose_flag, verbose_flag);
exit(0);
TEST506b
	  cat >$tempdir/grip.g <<'TEST506c'
TERM string = 1
      ident = 2
     number = 3
   programk = 4
        ddt = 5
   constant = 6
    integer = 7
       real = 8
       cond = 9
        for = 10
        put = 11
       else = 12
        lts = 13
        gts = 14
        lfp = 15
        rtp = 16
        lbr = 17
        rbr = 18
        lsb = 19
        rsb = 20
        pls = 21
        mns = 22
        str = 23
        fsl = 24
        amp = 25
        vrt = 26
        exc = 27
        smc = 28
        eqs = 29
        spc = 30
    invalid = 31;
program : programk ident statement # program (2)
statement : varac lts mns expression smc # assign (0 3)
          | lbr decl st_list rbr         # vblock (1 2)
          | cond lbr c_list              # condit (2)
          | for lfp statement expression smc statement rtp statement # foritr (2 3 5 7)
          | put p_list smc               # output (1)
          | smc                          # -
expression : expression dop factor # double (0 1 2)
           | uop factor            # single (0 1)
           | factor                # expression (0)
factor : varac              # factor (0)
       | number             # factor (0)
       | lfp expression rtp # factor (1)
dop : pls # 0
    | mns # 0
    | str # 0
    | fsl # 0
    | vrt # 0
    | amp # 0
    | eqs # 0
    | gts # 0
    | lts # 0
uop : pls # 0
    | mns # 0
    | exc # 0
decl : ident_list ddt specif smc decl # declare (0 2 4)
     |                                # -
ident_list : ident ident_list  # idl (0 1)
           |                   # -
specif : integer as      # integer (1)
       | real as         # real (1)
       | constant number # constant (1)
as : lsb number rsb # 1
   |                # -
st_list : statement st_list # st_list (0 1)
        |                   # -
c_list : expression statement c_list # elsif (0 1 2)
       | else statement rbr          # else (- 1 -)
       | rbr                         # -
p_list : expression p_list # expressionel (0 1)
       | string p_list     # stringel (0 1)
       |                   # -
varac : ident                    # varac (0)
      | ident lsb expression rsb # array (0 2)
TEST506c
	  cat >$tempdir/intrep.d <<'TEST506d'
// Here follows the internal representation of a GRIP program.
/* This is a variable cell class, designed for use with eval(). */
class component (value, type0) {
  var arrfl = 0;
}
/* This is a simple instruction definition, with a descriptor and arguments. */
class instr (){
  var name = "", args = [];
}
/* This is an expression class. Note that at most two operands are allowed. */
class expression (){
  var opr, opa1, opa2;
}

/******************************************************************************
** This is the definition for the actual internal representation of the      **
** program. Note that the high level structure is almost just an abstract    **
** form of the source code. There are only two variables: exec, which is     **
** a vector of instructions, and vartable, a table of component cells.       **
** This class also contains a virtual machine capable of executing the code. **
******************************************************************************/
class prog () {
  var exec = []; // The executable code.
  var vartable = new {};
  // The environment, statically derived during translation.
  func eval (expr, dumpfl = 0) { // The expression evaluator.
    var res; // The result is retained for debugging purposes.
    if (dumpfl) putln ("@ Initiating expression evaluator.");
    func ovrlap (type1, type2) // A function to derive the type of the result. 
      { return type1 == "real" || type2 == "real" ? "real" : "integer"; }
    if (expr.opr == "num") res = component(expr.opa1,expr.opa2);
                           /* Expression is a single constant */
    else if (expr.opr == "var") {
      var index = eval (expr.opa2, dumpfl).value;

      res = vartable {expr.opa1};
      if (type (res.value) == vector) {
	//        println (index, "--", #res.value);
	if (index < 1 || index > #res.value) {
	  error ("Runtime error : Array index out of bounds.");
	  exit (2);
	}
        res = component (res.value [index - 1], res.type0);
      }
    }
    // Variable reference.
    else if (expr.opr == "neg") // Unary minus.
      res = component (-eval (expr.opa1, dumpfl).value,
                        eval (expr.opa1, dumpfl).type0);
    else if (expr.opr == "add") // Addition.
      res = component (eval (expr.opa1, dumpfl).value +
                       eval (expr.opa2, dumpfl).value,
                       ovrlap (eval (expr.opa1, dumpfl).type0,
                               eval (expr.opa2, dumpfl).type0));
    else if (expr.opr == "sub") // Subtraction.
      res = component (eval (expr.opa1, dumpfl).value -
                       eval (expr.opa2, dumpfl).value,
                       ovrlap (eval (expr.opa1, dumpfl).type0,
                               eval (expr.opa2, dumpfl).type0));
    else if (expr.opr == "mul") // Multiplication.
      res = component (eval (expr.opa1, dumpfl).value *
                       eval (expr.opa2, dumpfl).value,
                       ovrlap (eval (expr.opa1, dumpfl).type0,
                               eval (expr.opa2, dumpfl).type0));
    else if (expr.opr == "div") {// Division.
      res = component (eval (expr.opa1, dumpfl).value /
                       eval (expr.opa2, dumpfl).value,
                       ovrlap (eval (expr.opa1, dumpfl).type0,
                               eval (expr.opa2, dumpfl).type0));
    }
    else if (expr.opr == "and") // Logical and.
      res = component (eval (expr.opa1, dumpfl).value &&
                       eval (expr.opa2, dumpfl).value,
                       "integer");
    else if (expr.opr == "or ") // Logical or.
      res = component (eval (expr.opa1, dumpfl).value ||
                       eval (expr.opa2, dumpfl).value,
                       "integer");
    else if (expr.opr == "not") // Logical negation
      res = component (!eval (expr.opa1, dumpfl).value, "integer");
    else if (expr.opr == "gtt") // Greater than.
      res = component (eval (expr.opa1, dumpfl).value >
                       eval (expr.opa2, dumpfl).value,
                       "integer");
    // The lack of a less than operation is for the fact that x<y <=> y>x.
    else if (expr.opr == "eqs") // Equals.
      res = component (eval (expr.opa1, dumpfl).value ==
                       eval (expr.opa2, dumpfl).value,
                       "integer");
    else {
      // If opr is not one of the specified operations, then there is an
      // error in the coding.
      putln ("Fatal Error : Internal error in expression generator :");
      print_expression (expr);
    }
    if (dumpfl) { // Dumping.
      putln ("* Expression Dumping:\n", sprint (res.value), " : ",
             sprint (res.type0));
      if (expr.opr != "num") print_expression (expr);
      putln ();
    }
    return res; // Now the result is made available to the client function.
  }
  /***********************************************************************
  ** This is the actual execution function. It invokes execinstr(), a   **
  ** function internal to execute(), which may recursively invoke       **
  ** itself, eval(), and execute() to evaluate expressions, or use      **
  ** structures.                                                        **
  ***********************************************************************/
  func execute (dumpfl, strdumpfl, edumpfl) {
    if (dumpfl) putln ("& Entering execution phase.");
    // Dumping for blocks :
    if (dumpfl) {
      putln ("* Preliminary dumping of variables for this block:\n",
             vartable != {} ?
             sprint (vartable) : "", "\n"); 
    }
    for (var instr = 0; instr < #exec; instr++) {
      // Sequentially perform statements.
      execinstr (exec [instr], strdumpfl, edumpfl); 
      /* Invoke execinstr() with the current instruction. */
    }
    if (global_errfl) abend (" runtime ");
    /*******************************************************
    ** Implementation of execinstr(). Like eval(), it     **
    ** chooses from a list of possible operations it can  **
    ** do, and executes the corresponding procedure       **
    ** needed to do the job.                              **
    *******************************************************/
    func execinstr (currinstr, dumpfl, edumpfl) {
      // Dumping for instructions :
      if (dumpfl) { putln ("@ Executing of instruction #",
                           instr + 1, ", value:");
                    print_instruction (currinstr);
      }
      if (currinstr.name == "cond") { /* Conditional branch. */
        for (var current_option_number = 0;
             current_option_number < #currinstr.args;
             current_option_number += 2) {
          /* This loop iterates through all of the
             alternatives, checking each one. */
          if (eval (currinstr.args [current_option_number], edumpfl).value) { 
            /* Check the current alternative. */
            execinstr (currinstr.args [current_option_number + 1], dumpfl); 
            // True: Execute this branch.
            break; // Exit the loop : No more altenatives need to be checked. 
          }
        }
      } else if (currinstr.name == "for") {
         // C-style 'for' loop implementation. Note that this statement can
         // loop at most 100,000 times.
         var g = 0; // This variable is used for enforcing the iteration limit.
         for (execinstr (currinstr.args [0], dumpfl); // Initialization.
              eval (currinstr.args [1], edumpfl). value; // Condition.
              execinstr (currinstr.args [2], dumpfl)) { // Increment.
           execinstr (currinstr.args [3], dumpfl); // Execute the body.
           g++; // Iteration count.
           if (g > 99999) { // Kill the for loop if alloted
                            // iterations are used up.
             if (dumpfl) putln ("! For loop ran out of iterations.");
             putln ("Warning: Iteration limit exceeded: For loop killed.");
             break; // Kill the loop.
           }
         }
       } else if (currinstr.name == "assign") {
         // Classical absolute assignment.
         var res = eval (currinstr.args [2], edumpfl),
             index = eval (currinstr.args [1], edumpfl).value,
             ourtype;
         // Ourtype is for real <- int compatibility.
         if (vartable  {currinstr.args [0]}.type0 == "real") ourtype = "real";
         else ourtype = "integer";
         var target = vartable {currinstr.args [0]};
         if (type (target.value) != vector) {
           // Is this an array? If no :
          target.value = (ourtype == "real"
			  ? float (res. value) : int (res. value));
         } else { // If yes :
           if (#target.value < index || index < 1) {
             error ("Runtime error : Array index out of bounds.");
             exit (2);
           }
           target.value [index - 1] = res.value;
         }
         vartable {currinstr.args [0]}.type0 = ourtype;
       } else if (currinstr.name == "block") { // The compound statement.
         currinstr.args [0].execute (dumpfl, dumpfl, edumpfl);
       } else if (currinstr.name == "put") { // Output statement.
         var put_objs = []; // So as not to intermingle output with dumpings.
         for (var i = 0; i < #currinstr.args; i++)
           put_objs @= eval (currinstr.args [i], edumpfl).value;
         for (i = 0; i < #put_objs; i++)
           put (put_objs [i]);
           // Output the values of all expressions.
         putln (); // Don't forget a newline.
       } else if (currinstr.name == "empty") {
         // The nil statement - does nothing.
       } else { // Coding error.
         putln ("Fatal Error : Internal parsing error : ",
                "Illegal instruction generated as follows :");
         print_instruction (currinstr.name, currinstr.args);
         exit (3);
       }
     }
     // Dumping for blocks :
     if (dumpfl) {
       putln ("* Dumping of variables for this block:\n", #vartable != 0 ?
              sprint (vartable) : "", "\n"); 
     }
   } // End execute().
} // End class prog.
TEST506d
	  cat >$tempdir/parser.d <<'TEST506e'
/****************************************************************************
** This is the translator for the source code.                             **
****************************************************************************/
ext token { // For encoding of identifiers, etc.
  var value, type0, line_num, char_num;
}
class grip_parser () {
  // The grip_parser class, using the Earley parser.
  var grammar, source_code; // Grammar is the Earley Parser code.
  include "scanner"; // Lexical analysis.
  include "translates"; // Syntactical and semantical analysis.
}
TEST506e
	  cat >$tempdir/scanner.d <<'TEST506f'
 /*****************************************************************
 ** The scanner() function does lexical analysis, i.e. finding   **
 ** numbers, and returns a vector of tokens ready for parsing.   **
 *****************************************************************/
func scanner (code) {
  var tokens = [],
  /* Array that will later be translated to tokens and returned,
     which will be called the "token stream". */
  lexem = "", /* Lexem will accumulate characters in case we wanted to
  make a token with more than one character, i.e. an identifier.
  (Will be referred to as the "accumulation stream".) */
  /* Note on streams: We can't write to the token stream unless
                      accumulation stream is empty.
  */
  /* Next come two important tables to increase parsing efficiency. */
  character = final {':' : 5,
                     '<' : 13,
                     '>' : 14,
                     '(' : 15,
                     ')' : 16,
                     '{' : 17,
                     '}' : 18,
                     '[' : 19,
                     ']' : 20,
                     '+' : 21,
                     '-' : 22,
                     '*' : 23,
                     '/' : 24,
                     '&' : 25,
                     '|' : 26,
                     '!' : 27,
                     ';' : 28,
                     '=' : 29,
                     ' ' : 30}, // For encoding special characters.
  keyword = final {"program" : 4,
                   "constant" : 6,
                   "integer" : 7,
                   "real" : 8,
                   "for" : 10,
                   "cond" : 9,
                   "else" : 12,
                   "put" : 11}, // For encoding keywords.
  char0, /* Counter for the loop that follows. */
  lx = 0,
  lnn = 1; // For retaining the line number of a token.
  for (char0 = 0; char0 < #code;) { // Build up tokens[].
    if (char0 != 0 &&
        code[char0 - 1] == '\n') lnn++;
    if (code[char0] == '/') { // Value might be a comment.
      var nofl = 1; // Tells us whether we should keep the slash.
      char0++; // Look at the next character.
      if (code[char0] == '*') {
        nofl = 0; // Don't put the slash to tokens[].
        for (;; char0++) // It is a comment.
          if (code[char0] == '*') { // Comment might end.
            char0++; // Look at next character.
            if (code[char0] == '/') {
              char0++;
              break; // Comment is over.
            }
          }
      }
      // So that the slash is preserved if there was no comment.
      if (nofl) tokens = tokens @ '/';
    } else if (code[char0] <= '9' && code[char0] >= '0') {
      var realfl = 0; // For support of reals.
      lexem = "N";
      for (;; char0++) {
        for (; code[char0] <= '9' && code[char0] >= '0'; char0++)
          lexem = lexem @ code[char0];
        if (code[char0] == '.' && ! realfl) {
          realfl++; // To avoid meaningless constructs such as 2.3.56.
          continue; // For scanning reals.
        }
        break;
      }
      tokens = ins (tokens, lexem, #tokens);
      lexem = "";
    } else if (code [char0] <= 'z' &&
               code [char0] >= 'a' || code[char0] <= 'Z' &&
               code [char0] >= 'A') {
      lexem = "I";
      for (; code [char0] <= 'z' && code[char0] >= 'a'
             || code [char0] <= 'Z' && code [char0] >= 'A'
             || code [char0] <= '9' && code [char0] >= '0';
             char0++)
        lexem = lexem @ tolower (code [char0]);
      tokens = ins (tokens, lexem, #tokens);
      lexem = "";
    } else if (char0 < #code && (code [char0] == ' '  ||
                                 code [char0] == '\n' ||
                                 code [char0] == '\t' ||
                                 code [char0] == '\f' ||
                                 code [char0] == '\r' ||
                                 code [char0] == '\v')) {
      for (; char0 < #code && (code [char0] == ' '  ||
                               code [char0] == '\n' ||
                               code [char0] == '\t' ||
                               code [char0] == '\f' ||
                               code [char0] == '\r' ||
                               code [char0] == '\v');
           char0++)
        if (char0 != 0 && code [char0 - 1] == '\n') lnn++;
    } else if (code[char0] == '"'){
      char0++;
      lexem = "S";
      for (; char0 < #code && code[char0] != '"'; char0++)
        lexem = lexem @ code[char0];
      char0++;
      tokens = ins (tokens, lexem, #tokens);
      lexem = "";
    } else {
      tokens = ins (tokens, code[char0], #tokens);
      char0++;
    }
    // Translate what we got to a token.
    if (lx < #tokens &&
        type (tokens[lx]) != char) { // Are we dealing with a string?
      if (tokens[lx][0] == 'S') { // We have a string constant.
        var temp = token (1); // Token with code 1.
        temp.type0 = tokens[lx][0]; // Add the type specifier.
        temp.value = del (tokens[lx], 0, 1); // Put the rest into value.
        tokens[lx] = temp; // Put the result into tokens.
      } else if (tokens[lx][0] == 'I') { // Identifier.
        var temp;
        if (del (tokens[lx], 0, 1) in keyword) {
          // Translate it into a keyword token if it's a keyword.
          temp = token(keyword{tokens[lx]});
          // Look it up in the keyword table.
          temp.type0 = 'K';
          // Give it type "K".
          temp.value = tokens[lx];
          // Give its reproduction for the syntax error manager.
        } else {
          temp = token (2); // Token - code 2.
          temp.type0 = 'I';
          temp.value = tokens[lx];
          // Same procedure here as for string constants.
        }
        tokens[lx] = temp;
      } else if (tokens[lx][0] == 'N') { // Number.
        var temp = token (3); // Token - code 3.
        temp.type0 = tokens[lx][0];
        temp.value = del (tokens[lx], 0, 1);
        tokens[lx] = temp;
      } else fatal_error ("Internal scanner error.", tokens, tokens[lx]);
      // Scanner malfunction.
    } else if (lx < #tokens) { // Single character.
      if (!(tokens[lx] in character)) { 
        // We have a bad character that we know the parser will spit out.
        put (file_name, ":", lnn, ":", char0 % lnn, ": ");
        error ("Lexical error: Invalid character -- no encoding available.",
               sprint(tokens[lx]));
        /* Generate an invalid token that the parser recognizes, but does
           not use in any rule. */
        tokens [lx] = token (31);
        lx++;
        continue;
      } else {
        var temp = token(character {tokens[lx]});
        temp.type0 = 'C';
        temp.value = tokens[lx];
        tokens[lx] = temp;
      }
    }
    if (lx < #tokens) {
      tokens[lx].line_num = lnn;
      tokens[lx].char_num = char0 % lnn;
      lx++;
    }
  }
  return tokens; // Make the result available to the client.
}
TEST506f
	  cat >$tempdir/translates.d <<'TEST506g'
 /*************************************************************************
 ** This is the actual translation function. It does any necessary       **
 ** operations that are done after the translation, so all the main      **
 ** block needs to do is analyze args and determine the parameters to    **
 ** this method.                                                         **
 *************************************************************************/
func parse_file (program_file, debug_level, verbose_flag) {
  if (verbose_flag) putln ("& Entering parsing phase.");
  var token_vector,
  outside = except (). error (). invcall (). syserror(); // To save typing.
  /* The following function is called by the parser to
     do any error messaging. */
  func syntax_error (error_token_index,
                     error_token_value,
                     first_ignored_token_index,
                     first_ignored_token_value,
                     new_starting_token_index,
                     new_starting_token_value) {
    if (error_token_value == nil ||
        error_token_value.code != 31) {
      if (verbose_flag) putln ("! Syntax error.");
      if (error_token_value != nil)
        put (program_file, ":", error_token_value.line_num, ":0: ");
      error (sput ("Syntax error at token value ",
                        error_token_value
                        == nil ? "EOF" :
                        error_token_value.code,
                   ":", error_token_value
                        == nil ? "EOF" :
                        error_token_value.type0,
                   ":", error_token_value
                        == nil ? "EOF" :
                        sprint (error_token_value.value)
                  )
            );
    }
  }
  // The next few lines install the grammar.
  try { // In case we can't find the file.
    var tape = open (env {"GRAMMARPATH"},"read");
    grammar = fgetf (tape);
    close (tape);
  } catch (outside. eaccess,
           outside. eagain,
           outside. ebadf,
           outside. ebusy,
           outside. edom,
           outside. efault,
           outside. efbig,
           outside. eio,
           outside. eisdir,
           outside. emfile,
           outside. emlink,
           outside. enametoolong,
           outside. enfile,
           outside. enodev,
           outside. enoent,
           outside. enomem,
           outside. eperm,
           outside. epipe,
           outside. espipe,
           outside. exdev)
  {fatal_error ("Could not find grammar file 'grip.g'.");}
  var program, // Source code.
  abstract_tree; // Intermediate code.
  try { // To cause exception !pmemory to die with a graceful error message.
    var machine = parser();
    public machine;
    machine.set_grammar (grammar, 1);
    machine.set_debug (debug_level); // Turns on verbose mode if applicable.
    machine.set_one_parse (1); // In case the grammar is ambiguous.
    machine.set_recovery (1); // Turn off error recovery.
    machine.set_recovery_match (0); // Shift 5 tokens when error is found.
    try { // To cover 'no such file' errors.
      program = open (program_file, "read"); // Get the source code.
    } catch (outside. eaccess,
             outside. eagain,
             outside. ebadf,
             outside. ebusy,
             outside. edom,
             outside. efault,
             outside. efbig,
             outside. eio,
             outside. eisdir,
             outside. emfile,
             outside. emlink,
             outside. enametoolong,
             outside. enfile,
             outside. enodev,
             outside. enoent,
             outside. enomem,
             outside. eperm,
             outside. epipe,
             outside. espipe,
             outside. exdev
             ) { // No such file in reach.
      putln ("Error: No valid file named ",
             sprint (program_file), " found.");
      global_errfl++;
      abend (" I/O ");
    }
    source_code = fgetf (program) @ " ";
    // So we don't get out-of range array bounds during scanning.
    close(program);
    if (verbose_flag) putln ("@ Initiating scanner.");
    token_vector = scanner (source_code);
    if (verbose_flag && global_errfl)
      putln ("! Scanner failed, working in error recovery mode.");
    // Use scanner() to process source_code.
    if (verbose_flag) putln ("@ Initiating Earley's Parser.");
    abstract_tree =
    machine.parse (token_vector, syntax_error);
    // Parse token_vector into abstract_tree.
  } catch (except (). error (). invcall (). invparser (). pmemory) {
    // There wasn't enough memory to parse the program.
    if (verbose_flag)
      putln ("! Insufficient memory to set up parser, parsing failed.");
    error ("Insufficient memory for parser.");
  }
  if (global_errfl) { // If syntax errors were found, stop the program.
    if (verbose_flag) putln ("! Syntax error: Terminating now.");
    abend (" syntax ");
  } else if (verbose_flag) {
    putln ("& Parsing phase sucessful.");
  /* Here ends the grammar checking. abstract_tree contains the
     intermediate representation of the program. The task now is
     to translate it into an object of class prog, and check it
     for semantical correctness. */
  }
  include "anode_work"; // Used to derive an object of class prog().
  if (verbose_flag) print_anode (abstract_tree);
  return parse_program_anode (abstract_tree, verbose_flag);
}
TEST506g
	  cat >$tempdir/sieve.g <<'TEST506h'
/* The program heading. The identifier can conflict with identifiers in
   the statement. */
program primeSieve 
/* This is all one block statement. A GRIP program in fact consists of
    only one statement. */
{
        /* Constant declarations. */
        sievesize : constant 100;
        /* Global variables. */
        i count : integer;
        /* An array. */
        flags : integer [100];
        /* Initialize count and flags. */
        count <- 0;
        /* If it isn't the C-style for loop :-) */
        for (i <- 0; i < sievesize; i <- i + 1; /* This semicolon has to be here. */)
                flags[i + 1] <- 1;
        /* Now get to work! */
        for (i <- 0; i < sievesize; i <- i + 1;)
                /* This is a multi-branch form of if-then-else. */
                cond { /* This is NOT a block statement. Negative. */
                        flags[i + 1] { /* This is another block-statement. */
                                /* Two local variables. */
                                k prime : integer;
                                prime <- 2 * i + 3;
                                k <- prime + i;
                                for (; k < sievesize; k <- k + prime;)
                                        flags[k + 1] <- 0;
                                count <- count + 1;
                        }
                        /* Here would have been "else blablablablabla...", but primeSieve has no
                            need for "else blablablablabla..." */
                }
        /* I/O, unfortunately without the I. Maybe later ;-( */
        put "The number of primes less than " sievesize " is " count;
}
/* This has all of the constructs available to a GRIP programmer. Not much, eh? :-| */
TEST506h
	  echo '      ' GRAMMARPATH=$tempdir/grip.g $DINO $tempdir/grip.d $tempdir/sieve.g
          if GRAMMARPATH=$tempdir/grip.g $DINO $tempdir/grip.d $tempdir/sieve.g 2>$stderr >$stdout; then
              echo '      ' $CMP $stdout $ftemp2
              if cat >$ftemp2 <<'OUTPUT506-2' && $CMP $stdout $ftemp2; then
The number of primes less than 100 is 45
OUTPUT506-2
                  result=ok
              else
                  result=fail
              fi
          else
              result=fail
          fi
        else
          result=fail
        fi
        if test $result = ok; then
          echo '      ' Serhei\'s interpreter test is ok  -- rm -rf $tempdir
          rm -rf $tempdir
        else
          echo '      ' Serhei\'s interpreter test failed -- look at directory $tempdir
        fi
fi

# Test 507.
if test $result = ok -a $start_test_number -le 507; then
	echo test 507: Check bug of deleting elements from table.
        cat >$test_file <<'TEST507'
var ts = ["MII", "MI;I", "MMI", "M;MI", "MFI", "MMF", "BBB", "MBB",
	  "MIB", "MMB", "MFB", "MIb", "MMb", "MFb"];
var seq = {}, ignore = {}, useq;

func add_transl (seq, s, t) {
  var i;

  if (s in seq) {
    for (i = 0; i < #seq {s}; i++)
      if (seq {s} [i] == t)
	return;
    seq {s} = seq {s} @ [t];
  } else
    seq {s} = [t];
}

func add_seq (str) {
  var start, i, j, s;
  start = 0;
  for (i = 0; i < #str; i++)
    if (str [i] == ';') {
      s = subv (str, start, i + 1 - start);
      start = i + 1;
      for (j = start; j < #str; j++)
        if (str [j] == 't')
          break;
      if (!(s in ignore))
	add_transl (seq, s, subv (str, start, j - start));
    }
  if (#str - start >= 3) {
    s = subv (str, start, -1);
    if (!(s in ignore))
      add_transl (seq, s, "");
  }
}

func build_start_seqs () {
  var i, j;

  for (i = 0; i < #ts; i++) {
    add_seq ("t" @ ts [i] @ ";");
    for (j = 0; j < #ts; j++) {
      add_seq ("t" @ ts [i] @ "t" @ ts [j] @ ";");
      add_seq ("t" @ ts [i] @ "t" @ ts [j]);
    }
  }
}

func subscr_divide (s) {
  var v = [nil, nil], k, m = 0, i = 0, f = 0, b = 0, nopb = 0;
  
  for (k = 0; k < #s; k++)
    if (s [k] == 'I') {
      if (i == 2)
        break;
      i++;
    } else if (s [k] == 'M') {
      if (m == 2)
        break;
      m++;
    } else if (s [k] == 'F') {
      if (f == 2)
        break;
      f++;
    } else if (s [k] == 'B' || s [k] == 'b') {
      if (nopb && (k != 0 && s [k - 1] == 't' || s [k] == 'b') || b == 3)
        break; // conflict on B0
      if (s [k] == 'b')
	nopb = 1;
      b++;
    }
  if (k < #s && s [k - 1] == 't')
    k--;
  v [0] = subv (s, 0, k);
  if (k < #s)
    v [1] = subv (s, k, -1);
  return v;
}

func build_all_seqs (seq) {
  var i, j, v, cont, p, s;

  for (;;) {
    cont = 0;
    v = vector (seq);
    for (i = 0; i < #v; i += 2) {
      s = v [i];
      p = subscr_divide (s);
      if (p [1] != nil) {
	ignore {s} = nil;
	del (seq, s);
	add_transl (seq, p[0], p [1][0] != 't' ? p[1] : "");
	if (p [1][0] != 't') {
	  add_transl (seq, p[1], "");
	  for (j = 0; j < #ts; j++) {
	    add_seq (p [1] @ "t" @ ts [j] @ ";");
	    add_seq (p [1] @ "t" @ ts [j]);
	  }
	}
	cont = 1;
      }
    }
    if (!cont)
      break;
  }
}

build_start_seqs ();
build_all_seqs (seq);
TEST507
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        else
                result=fail
        fi
fi

# Test 508.
if test $result = ok -a $start_test_number -le 508; then
	echo test 508: Check bug of deleting elements from table.
        cat >$test_file <<'TEST508'
class c (i) {
  class sc (ai) {}
}
var i = c (10);
putln (i.sc (20) == i.sc (20));
putln (i.sc (20) == i.sc (30));
putln (i.sc (20) == c(10).sc (20));
putln (i.sc (20) == c(30).sc (20));
TEST508
        echo '      ' $DINO $test_file ">$stdout" "2>$stderr"
        if $DINO $test_file >$stdout 2>$stderr; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT508' && $CMP $stdout $ftemp2; then
1
0
0
0
OUTPUT508
                  result=ok
                else
                  result=fail
                fi
        else
                result=fail
        fi
fi


# Test 509.
if test $result = ok -a $start_test_number -le 509; then
	echo test 509: Checking that return is in function/class/ext.
        cat >$test_file <<'TEST509'
return ret;
TEST509
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST509-1'; then
test.d:1:7: statement return is not in function, class, or extension
TEST509-1
                result=ok
        else
                result=fail
        fi
fi

# Test 510.
if test $result = ok -a $start_test_number -le 510; then
	echo test 510: Checking that return is in function/class/ext.
        cat >$test_file <<'TEST510'
var k = "aaa", t = {};
t {k} = 10;
k [1] = 'b';
TEST510
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST510-1'; then
test.d:3:3: run time error - attempt to modify immutable vector
TEST510-1
                result=ok
        else
                result=fail
        fi
fi

# Test 511.
if test $result = ok -a $start_test_number -le 511; then
	echo test 511: format output
        cat >$test_file <<'TEST511'
// default conversion
putf ("%d\n", 10);
putf ("%o\n", 10);
putf ("%x\n", 10);
putf ("%X\n", 10);
putf ("%e\n", 10.5);
putf ("%E\n", 10.5);
putf ("%f\n", 10.5);
putf ("%g\n", 10.5);
putf ("%G\n", 10.5);
putf ("%c\n", 'z');
putf ("%s\n", "Abracadabra");
// width
putf ("%15d\n", 10);
putf ("%15o\n", 10);
putf ("%15x\n", 10);
putf ("%15X\n", 10);
putf ("%15e\n", 10.5);
putf ("%15E\n", 10.5);
putf ("%15f\n", 10.5);
putf ("%15g\n", 10.5);
putf ("%15G\n", 10.5);
putf ("%15c\n", 'z');
putf ("%15s\n", "Abracadabra");
// flag -
putf ("%-15d\n", 10);
putf ("%-15o\n", 10);
putf ("%-15x\n", 10);
putf ("%-15X\n", 10);
putf ("%-15e\n", 10.5);
putf ("%-15E\n", 10.5);
putf ("%-15f\n", 10.5);
putf ("%-15g\n", 10.5);
putf ("%-15G\n", 10.5);
putf ("%-15c\n", 'z');
putf ("%-15s\n", "Abracadabra");
// flag #
putf ("%#o\n", 10);
putf ("%#x\n", 10);
putf ("%#X\n", 10);
putf ("%#e\n", 10.5);
putf ("%#E\n", 10.5);
putf ("%#f\n", 10.5);
putf ("%#g\n", 10.5);
putf ("%#G\n", 10.5);
// flag 0
putf ("%015d\n", 10);
putf ("%015o\n", 10);
putf ("%015x\n", 10);
putf ("%015X\n", 10);
putf ("%015e\n", 10.5);
putf ("%015E\n", 10.5);
putf ("%015f\n", 10.5);
putf ("%015g\n", 10.5);
putf ("%015G\n", 10.5);
// flag <blank>
putf ("% 15d\n", 10);
putf ("% 15e\n", 10.5);
putf ("% 15E\n", 10.5);
putf ("% 15f\n", 10.5);
putf ("% 15g\n", 10.5);
putf ("% 15G\n", 10.5);
// flag +
putf ("%+15d\n", 10);
putf ("%+15e\n", 10.5);
putf ("%+15E\n", 10.5);
putf ("%+15f\n", 10.5);
putf ("%+15g\n", 10.5);
putf ("%+15G\n", 10.5);
// flag + and <blank> -> ignore blank
putf ("%+ 15d\n", 10);
putf ("%+ 15e\n", 10.5);
putf ("%+ 15E\n", 10.5);
putf ("%+ 15f\n", 10.5);
putf ("%+ 15g\n", 10.5);
putf ("%+ 15G\n", 10.5);
// flag - and 0 -> ignore 0
putf ("%-015d\n", 10);
putf ("%-015o\n", 10);
putf ("%-015x\n", 10);
putf ("%-015X\n", 10);
putf ("%-015e\n", 10.5);
putf ("%-015E\n", 10.5);
putf ("%-015f\n", 10.5);
putf ("%-015g\n", 10.5);
putf ("%-015G\n", 10.5);
// parameter defined width
putf ("%*d\n", 15, 10);
putf ("%*o\n", 15, 10);
putf ("%*x\n", 15, 10);
putf ("%*X\n", 15, 10);
putf ("%*e\n", 15, 10.5);
putf ("%*E\n", 15, 10.5);
putf ("%*f\n", 15, 10.5);
putf ("%*g\n", 15, 10.5);
putf ("%*G\n", 15, 10.5);
putf ("%*c\n", 15, 'z');
// negative width -> absolute value and flag -
putf ("%*s\n", 15, "Abracadabra");
putf ("%*d\n", -15, 10);
putf ("%*o\n", -15, 10);
putf ("%*x\n", -15, 10);
putf ("%*X\n", -15, 10);
putf ("%*e\n", -15, 10.5);
putf ("%*E\n", -15, 10.5);
putf ("%*f\n", -15, 10.5);
putf ("%*g\n", -15, 10.5);
putf ("%*G\n", -15, 10.5);
putf ("%*c\n", -15, 'z');
putf ("%*s\n", -15, "Abracadabra");
// zero width
putf ("%*d\n", 0, 10);
putf ("%*o\n", 0, 10);
putf ("%*x\n", 0, 10);
putf ("%*X\n", 0, 10);
putf ("%*e\n", 0, 10.5);
putf ("%*E\n", 0, 10.5);
putf ("%*f\n", 0, 10.5);
putf ("%*g\n", 0, 10.5);
putf ("%*G\n", 0, 10.5);
putf ("%*c\n", 0, 'z');
putf ("%*s\n", 0, "Abracadabra");
// zero precision value
putf ("%.0d\n", 10);
putf ("%.0o\n", 10);
putf ("%.0x\n", 10);
putf ("%.0X\n", 10);
putf ("%.0e\n", 10.5);
putf ("%.0E\n", 10.5);
putf ("%.0f\n", 10.5);
putf ("%.0g\n", 10.5);
putf ("%.0G\n", 10.5);
putf ("%.0s\n", "Abracadabra");
// absent precision value -> zero value
putf ("%.d\n", 10);
putf ("%.o\n", 10);
putf ("%.x\n", 10);
putf ("%.X\n", 10);
putf ("%.e\n", 10.5);
putf ("%.E\n", 10.5);
putf ("%.f\n", 10.5);
putf ("%.g\n", 10.5);
putf ("%.G\n", 10.5);
putf ("%.s\n", "Abracadabra");
// precision with numeric conversion and flag 0 -> ignore flag 0
putf ("%05.0d\n", 10);
putf ("%05.0o\n", 10);
putf ("%05.0x\n", 10);
putf ("%05.0X\n", 10);
putf ("%05.d\n", 10);
putf ("%05.o\n", 10);
putf ("%05.x\n", 10);
putf ("%05.X\n", 10);
// precision value 10
putf ("%.10d\n", 10);
putf ("%.10o\n", 10);
putf ("%.10x\n", 10);
putf ("%.10X\n", 10);
putf ("%.10e\n", 10.5);
putf ("%.10E\n", 10.5);
putf ("%.10f\n", 10.5);
putf ("%.10g\n", 10.5);
putf ("%.10G\n", 10.5);
putf ("%.10s\n", "Abracadabra");
// precision value as parameter
putf ("%.*d\n", 10, 10);
putf ("%.*o\n", 10, 10);
putf ("%.*x\n", 10, 10);
putf ("%.*X\n", 10, 10);
putf ("%.*e\n", 10, 10.5);
putf ("%.*E\n", 10, 10.5);
putf ("%.*f\n", 10, 10.5);
putf ("%.*g\n", 10, 10.5);
putf ("%.*G\n", 10, 10.5);
putf ("%.*s\n", 10, "Abracadabra");
// negative precision value -> value zero
putf ("%.*d\n", -10, 10);
putf ("%.*o\n", -10, 10);
putf ("%.*x\n", -10, 10);
putf ("%.*X\n", -10, 10);
putf ("%.*e\n", -10, 10.5);
putf ("%.*E\n", -10, 10.5);
putf ("%.*f\n", -10, 10.5);
putf ("%.*g\n", -10, 10.5);
putf ("%.*G\n", -10, 10.5);
putf ("%.*s\n", -10, "Abracadabra");
// zero precision value for outputing zero
putf ("%.0d\n", 0);
putf ("%.0o\n", 0);
putf ("%.0x\n", 0);
putf ("%.0X\n", 0);
// %
putf ("%%\n");

// The same for fputf
// default conversion
fputf (stdout, "%d\n", 10);
fputf (stdout, "%o\n", 10);
fputf (stdout, "%x\n", 10);
fputf (stdout, "%X\n", 10);
fputf (stdout, "%e\n", 10.5);
fputf (stdout, "%E\n", 10.5);
fputf (stdout, "%f\n", 10.5);
fputf (stdout, "%g\n", 10.5);
fputf (stdout, "%G\n", 10.5);
fputf (stdout, "%c\n", 'z');
fputf (stdout, "%s\n", "Abracadabra");
// width
fputf (stdout, "%15d\n", 10);
fputf (stdout, "%15o\n", 10);
fputf (stdout, "%15x\n", 10);
fputf (stdout, "%15X\n", 10);
fputf (stdout, "%15e\n", 10.5);
fputf (stdout, "%15E\n", 10.5);
fputf (stdout, "%15f\n", 10.5);
fputf (stdout, "%15g\n", 10.5);
fputf (stdout, "%15G\n", 10.5);
fputf (stdout, "%15c\n", 'z');
fputf (stdout, "%15s\n", "Abracadabra");
// flag -
fputf (stdout, "%-15d\n", 10);
fputf (stdout, "%-15o\n", 10);
fputf (stdout, "%-15x\n", 10);
fputf (stdout, "%-15X\n", 10);
fputf (stdout, "%-15e\n", 10.5);
fputf (stdout, "%-15E\n", 10.5);
fputf (stdout, "%-15f\n", 10.5);
fputf (stdout, "%-15g\n", 10.5);
fputf (stdout, "%-15G\n", 10.5);
fputf (stdout, "%-15c\n", 'z');
fputf (stdout, "%-15s\n", "Abracadabra");
// flag #
fputf (stdout, "%#o\n", 10);
fputf (stdout, "%#x\n", 10);
fputf (stdout, "%#X\n", 10);
fputf (stdout, "%#e\n", 10.5);
fputf (stdout, "%#E\n", 10.5);
fputf (stdout, "%#f\n", 10.5);
fputf (stdout, "%#g\n", 10.5);
fputf (stdout, "%#G\n", 10.5);
// flag 0
fputf (stdout, "%015d\n", 10);
fputf (stdout, "%015o\n", 10);
fputf (stdout, "%015x\n", 10);
fputf (stdout, "%015X\n", 10);
fputf (stdout, "%015e\n", 10.5);
fputf (stdout, "%015E\n", 10.5);
fputf (stdout, "%015f\n", 10.5);
fputf (stdout, "%015g\n", 10.5);
fputf (stdout, "%015G\n", 10.5);
// flag <blank>
fputf (stdout, "% 15d\n", 10);
fputf (stdout, "% 15e\n", 10.5);
fputf (stdout, "% 15E\n", 10.5);
fputf (stdout, "% 15f\n", 10.5);
fputf (stdout, "% 15g\n", 10.5);
fputf (stdout, "% 15G\n", 10.5);
// flag +
fputf (stdout, "%+15d\n", 10);
fputf (stdout, "%+15e\n", 10.5);
fputf (stdout, "%+15E\n", 10.5);
fputf (stdout, "%+15f\n", 10.5);
fputf (stdout, "%+15g\n", 10.5);
fputf (stdout, "%+15G\n", 10.5);
// flag + and <blank> -> ignore blank
fputf (stdout, "%+ 15d\n", 10);
fputf (stdout, "%+ 15e\n", 10.5);
fputf (stdout, "%+ 15E\n", 10.5);
fputf (stdout, "%+ 15f\n", 10.5);
fputf (stdout, "%+ 15g\n", 10.5);
fputf (stdout, "%+ 15G\n", 10.5);
// flag - and 0 -> ignore 0
fputf (stdout, "%-015d\n", 10);
fputf (stdout, "%-015o\n", 10);
fputf (stdout, "%-015x\n", 10);
fputf (stdout, "%-015X\n", 10);
fputf (stdout, "%-015e\n", 10.5);
fputf (stdout, "%-015E\n", 10.5);
fputf (stdout, "%-015f\n", 10.5);
fputf (stdout, "%-015g\n", 10.5);
fputf (stdout, "%-015G\n", 10.5);
// parameter defined width
fputf (stdout, "%*d\n", 15, 10);
fputf (stdout, "%*o\n", 15, 10);
fputf (stdout, "%*x\n", 15, 10);
fputf (stdout, "%*X\n", 15, 10);
fputf (stdout, "%*e\n", 15, 10.5);
fputf (stdout, "%*E\n", 15, 10.5);
fputf (stdout, "%*f\n", 15, 10.5);
fputf (stdout, "%*g\n", 15, 10.5);
fputf (stdout, "%*G\n", 15, 10.5);
fputf (stdout, "%*c\n", 15, 'z');
// negative width -> absolute value and flag -
fputf (stdout, "%*s\n", 15, "Abracadabra");
fputf (stdout, "%*d\n", -15, 10);
fputf (stdout, "%*o\n", -15, 10);
fputf (stdout, "%*x\n", -15, 10);
fputf (stdout, "%*X\n", -15, 10);
fputf (stdout, "%*e\n", -15, 10.5);
fputf (stdout, "%*E\n", -15, 10.5);
fputf (stdout, "%*f\n", -15, 10.5);
fputf (stdout, "%*g\n", -15, 10.5);
fputf (stdout, "%*G\n", -15, 10.5);
fputf (stdout, "%*c\n", -15, 'z');
fputf (stdout, "%*s\n", -15, "Abracadabra");
// zero width
fputf (stdout, "%*d\n", 0, 10);
fputf (stdout, "%*o\n", 0, 10);
fputf (stdout, "%*x\n", 0, 10);
fputf (stdout, "%*X\n", 0, 10);
fputf (stdout, "%*e\n", 0, 10.5);
fputf (stdout, "%*E\n", 0, 10.5);
fputf (stdout, "%*f\n", 0, 10.5);
fputf (stdout, "%*g\n", 0, 10.5);
fputf (stdout, "%*G\n", 0, 10.5);
fputf (stdout, "%*c\n", 0, 'z');
fputf (stdout, "%*s\n", 0, "Abracadabra");
// zero precision value
fputf (stdout, "%.0d\n", 10);
fputf (stdout, "%.0o\n", 10);
fputf (stdout, "%.0x\n", 10);
fputf (stdout, "%.0X\n", 10);
fputf (stdout, "%.0e\n", 10.5);
fputf (stdout, "%.0E\n", 10.5);
fputf (stdout, "%.0f\n", 10.5);
fputf (stdout, "%.0g\n", 10.5);
fputf (stdout, "%.0G\n", 10.5);
fputf (stdout, "%.0s\n", "Abracadabra");
// absent precision value -> zero value
fputf (stdout, "%.d\n", 10);
fputf (stdout, "%.o\n", 10);
fputf (stdout, "%.x\n", 10);
fputf (stdout, "%.X\n", 10);
fputf (stdout, "%.e\n", 10.5);
fputf (stdout, "%.E\n", 10.5);
fputf (stdout, "%.f\n", 10.5);
fputf (stdout, "%.g\n", 10.5);
fputf (stdout, "%.G\n", 10.5);
fputf (stdout, "%.s\n", "Abracadabra");
// precision with numeric conversion and flag 0 -> ignore flag 0
fputf (stdout, "%05.0d\n", 10);
fputf (stdout, "%05.0o\n", 10);
fputf (stdout, "%05.0x\n", 10);
fputf (stdout, "%05.0X\n", 10);
fputf (stdout, "%05.d\n", 10);
fputf (stdout, "%05.o\n", 10);
fputf (stdout, "%05.x\n", 10);
fputf (stdout, "%05.X\n", 10);
// precision value 10
fputf (stdout, "%.10d\n", 10);
fputf (stdout, "%.10o\n", 10);
fputf (stdout, "%.10x\n", 10);
fputf (stdout, "%.10X\n", 10);
fputf (stdout, "%.10e\n", 10.5);
fputf (stdout, "%.10E\n", 10.5);
fputf (stdout, "%.10f\n", 10.5);
fputf (stdout, "%.10g\n", 10.5);
fputf (stdout, "%.10G\n", 10.5);
fputf (stdout, "%.10s\n", "Abracadabra");
// precision value as parameter
fputf (stdout, "%.*d\n", 10, 10);
fputf (stdout, "%.*o\n", 10, 10);
fputf (stdout, "%.*x\n", 10, 10);
fputf (stdout, "%.*X\n", 10, 10);
fputf (stdout, "%.*e\n", 10, 10.5);
fputf (stdout, "%.*E\n", 10, 10.5);
fputf (stdout, "%.*f\n", 10, 10.5);
fputf (stdout, "%.*g\n", 10, 10.5);
fputf (stdout, "%.*G\n", 10, 10.5);
fputf (stdout, "%.*s\n", 10, "Abracadabra");
// negative precision value -> value zero
fputf (stdout, "%.*d\n", -10, 10);
fputf (stdout, "%.*o\n", -10, 10);
fputf (stdout, "%.*x\n", -10, 10);
fputf (stdout, "%.*X\n", -10, 10);
fputf (stdout, "%.*e\n", -10, 10.5);
fputf (stdout, "%.*E\n", -10, 10.5);
fputf (stdout, "%.*f\n", -10, 10.5);
fputf (stdout, "%.*g\n", -10, 10.5);
fputf (stdout, "%.*G\n", -10, 10.5);
fputf (stdout, "%.*s\n", -10, "Abracadabra");
// zero precision value for outputing zero
fputf (stdout, "%.0d\n", 0);
fputf (stdout, "%.0o\n", 0);
fputf (stdout, "%.0x\n", 0);
fputf (stdout, "%.0X\n", 0);
// %
fputf (stdout, "%%\n");

// The same for sputf
// default conversion
put (sputf ("%d\n", 10));
put (sputf ("%o\n", 10));
put (sputf ("%x\n", 10));
put (sputf ("%X\n", 10));
put (sputf ("%e\n", 10.5));
put (sputf ("%E\n", 10.5));
put (sputf ("%f\n", 10.5));
put (sputf ("%g\n", 10.5));
put (sputf ("%G\n", 10.5));
put (sputf ("%c\n", 'z'));
put (sputf ("%s\n", "Abracadabra"));
// width
put (sputf ("%15d\n", 10));
put (sputf ("%15o\n", 10));
put (sputf ("%15x\n", 10));
put (sputf ("%15X\n", 10));
put (sputf ("%15e\n", 10.5));
put (sputf ("%15E\n", 10.5));
put (sputf ("%15f\n", 10.5));
put (sputf ("%15g\n", 10.5));
put (sputf ("%15G\n", 10.5));
put (sputf ("%15c\n", 'z'));
put (sputf ("%15s\n", "Abracadabra"));
// flag -
put (sputf ("%-15d\n", 10));
put (sputf ("%-15o\n", 10));
put (sputf ("%-15x\n", 10));
put (sputf ("%-15X\n", 10));
put (sputf ("%-15e\n", 10.5));
put (sputf ("%-15E\n", 10.5));
put (sputf ("%-15f\n", 10.5));
put (sputf ("%-15g\n", 10.5));
put (sputf ("%-15G\n", 10.5));
put (sputf ("%-15c\n", 'z'));
put (sputf ("%-15s\n", "Abracadabra"));
// flag #
put (sputf ("%#o\n", 10));
put (sputf ("%#x\n", 10));
put (sputf ("%#X\n", 10));
put (sputf ("%#e\n", 10.5));
put (sputf ("%#E\n", 10.5));
put (sputf ("%#f\n", 10.5));
put (sputf ("%#g\n", 10.5));
put (sputf ("%#G\n", 10.5));
// flag 0
put (sputf ("%015d\n", 10));
put (sputf ("%015o\n", 10));
put (sputf ("%015x\n", 10));
put (sputf ("%015X\n", 10));
put (sputf ("%015e\n", 10.5));
put (sputf ("%015E\n", 10.5));
put (sputf ("%015f\n", 10.5));
put (sputf ("%015g\n", 10.5));
put (sputf ("%015G\n", 10.5));
// flag <blank>
put (sputf ("% 15d\n", 10));
put (sputf ("% 15e\n", 10.5));
put (sputf ("% 15E\n", 10.5));
put (sputf ("% 15f\n", 10.5));
put (sputf ("% 15g\n", 10.5));
put (sputf ("% 15G\n", 10.5));
// flag +
put (sputf ("%+15d\n", 10));
put (sputf ("%+15e\n", 10.5));
put (sputf ("%+15E\n", 10.5));
put (sputf ("%+15f\n", 10.5));
put (sputf ("%+15g\n", 10.5));
put (sputf ("%+15G\n", 10.5));
// flag + and <blank> -> ignore blank
put (sputf ("%+ 15d\n", 10));
put (sputf ("%+ 15e\n", 10.5));
put (sputf ("%+ 15E\n", 10.5));
put (sputf ("%+ 15f\n", 10.5));
put (sputf ("%+ 15g\n", 10.5));
put (sputf ("%+ 15G\n", 10.5));
// flag - and 0 -> ignore 0
put (sputf ("%-015d\n", 10));
put (sputf ("%-015o\n", 10));
put (sputf ("%-015x\n", 10));
put (sputf ("%-015X\n", 10));
put (sputf ("%-015e\n", 10.5));
put (sputf ("%-015E\n", 10.5));
put (sputf ("%-015f\n", 10.5));
put (sputf ("%-015g\n", 10.5));
put (sputf ("%-015G\n", 10.5));
// parameter defined width
put (sputf ("%*d\n", 15, 10));
put (sputf ("%*o\n", 15, 10));
put (sputf ("%*x\n", 15, 10));
put (sputf ("%*X\n", 15, 10));
put (sputf ("%*e\n", 15, 10.5));
put (sputf ("%*E\n", 15, 10.5));
put (sputf ("%*f\n", 15, 10.5));
put (sputf ("%*g\n", 15, 10.5));
put (sputf ("%*G\n", 15, 10.5));
put (sputf ("%*c\n", 15, 'z'));
// negative width -> absolute value and flag -
put (sputf ("%*s\n", 15, "Abracadabra"));
put (sputf ("%*d\n", -15, 10));
put (sputf ("%*o\n", -15, 10));
put (sputf ("%*x\n", -15, 10));
put (sputf ("%*X\n", -15, 10));
put (sputf ("%*e\n", -15, 10.5));
put (sputf ("%*E\n", -15, 10.5));
put (sputf ("%*f\n", -15, 10.5));
put (sputf ("%*g\n", -15, 10.5));
put (sputf ("%*G\n", -15, 10.5));
put (sputf ("%*c\n", -15, 'z'));
put (sputf ("%*s\n", -15, "Abracadabra"));
// zero width
put (sputf ("%*d\n", 0, 10));
put (sputf ("%*o\n", 0, 10));
put (sputf ("%*x\n", 0, 10));
put (sputf ("%*X\n", 0, 10));
put (sputf ("%*e\n", 0, 10.5));
put (sputf ("%*E\n", 0, 10.5));
put (sputf ("%*f\n", 0, 10.5));
put (sputf ("%*g\n", 0, 10.5));
put (sputf ("%*G\n", 0, 10.5));
put (sputf ("%*c\n", 0, 'z'));
put (sputf ("%*s\n", 0, "Abracadabra"));
// zero precision value
put (sputf ("%.0d\n", 10));
put (sputf ("%.0o\n", 10));
put (sputf ("%.0x\n", 10));
put (sputf ("%.0X\n", 10));
put (sputf ("%.0e\n", 10.5));
put (sputf ("%.0E\n", 10.5));
put (sputf ("%.0f\n", 10.5));
put (sputf ("%.0g\n", 10.5));
put (sputf ("%.0G\n", 10.5));
put (sputf ("%.0s\n", "Abracadabra"));
// absent precision value -> zero value
put (sputf ("%.d\n", 10));
put (sputf ("%.o\n", 10));
put (sputf ("%.x\n", 10));
put (sputf ("%.X\n", 10));
put (sputf ("%.e\n", 10.5));
put (sputf ("%.E\n", 10.5));
put (sputf ("%.f\n", 10.5));
put (sputf ("%.g\n", 10.5));
put (sputf ("%.G\n", 10.5));
put (sputf ("%.s\n", "Abracadabra"));
// precision with numeric conversion and flag 0 -> ignore flag 0
put (sputf ("%05.0d\n", 10));
put (sputf ("%05.0o\n", 10));
put (sputf ("%05.0x\n", 10));
put (sputf ("%05.0X\n", 10));
put (sputf ("%05.d\n", 10));
put (sputf ("%05.o\n", 10));
put (sputf ("%05.x\n", 10));
put (sputf ("%05.X\n", 10));
// precision value 10
put (sputf ("%.10d\n", 10));
put (sputf ("%.10o\n", 10));
put (sputf ("%.10x\n", 10));
put (sputf ("%.10X\n", 10));
put (sputf ("%.10e\n", 10.5));
put (sputf ("%.10E\n", 10.5));
put (sputf ("%.10f\n", 10.5));
put (sputf ("%.10g\n", 10.5));
put (sputf ("%.10G\n", 10.5));
put (sputf ("%.10s\n", "Abracadabra"));
// precision value as parameter
put (sputf ("%.*d\n", 10, 10));
put (sputf ("%.*o\n", 10, 10));
put (sputf ("%.*x\n", 10, 10));
put (sputf ("%.*X\n", 10, 10));
put (sputf ("%.*e\n", 10, 10.5));
put (sputf ("%.*E\n", 10, 10.5));
put (sputf ("%.*f\n", 10, 10.5));
put (sputf ("%.*g\n", 10, 10.5));
put (sputf ("%.*G\n", 10, 10.5));
put (sputf ("%.*s\n", 10, "Abracadabra"));
// negative precision value -> value zero
put (sputf ("%.*d\n", -10, 10));
put (sputf ("%.*o\n", -10, 10));
put (sputf ("%.*x\n", -10, 10));
put (sputf ("%.*X\n", -10, 10));
put (sputf ("%.*e\n", -10, 10.5));
put (sputf ("%.*E\n", -10, 10.5));
put (sputf ("%.*f\n", -10, 10.5));
put (sputf ("%.*g\n", -10, 10.5));
put (sputf ("%.*G\n", -10, 10.5));
put (sputf ("%.*s\n", -10, "Abracadabra"));
// zero precision value for outputing zero
put (sputf ("%.0d\n", 0));
put (sputf ("%.0o\n", 0));
put (sputf ("%.0x\n", 0));
put (sputf ("%.0X\n", 0));
// %
put (sputf ("%%\n"));
// big precision
putf ("%.21474836s", "stop\n");
TEST511
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT511' && $CMP $stdout $ftemp2; then
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
012
0xa
0XA
1.050000e+01
1.050000E+01
10.500000
10.5000
10.5000
000000000000010
000000000000012
00000000000000a
00000000000000A
0001.050000e+01
0001.050000E+01
00000010.500000
0000000000010.5
0000000000010.5
             10
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

   10
   12
    a
    A
   10
   12
    a
    A
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01





%
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
012
0xa
0XA
1.050000e+01
1.050000E+01
10.500000
10.5000
10.5000
000000000000010
000000000000012
00000000000000a
00000000000000A
0001.050000e+01
0001.050000E+01
00000010.500000
0000000000010.5
0000000000010.5
             10
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

   10
   12
    a
    A
   10
   12
    a
    A
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01





%
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
012
0xa
0XA
1.050000e+01
1.050000E+01
10.500000
10.5000
10.5000
000000000000010
000000000000012
00000000000000a
00000000000000A
0001.050000e+01
0001.050000E+01
00000010.500000
0000000000010.5
0000000000010.5
             10
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

   10
   12
    a
    A
   10
   12
    a
    A
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01





%
stop
OUTPUT511
                        result=ok
                elif cat >$ftemp2 <<'OUTPUT511-1' && $CMP $stdout $ftemp2; then
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
012
0xa
0XA
1.050000e+01
1.050000E+01
10.500000
10.5000
10.5000
000000000000010
000000000000012
00000000000000a
00000000000000A
0001.050000e+01
0001.050000E+01
00000010.500000
0000000000010.5
0000000000010.5
             10
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

   10
   12
    a
    A
   10
   12
    a
    A
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01





%
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
012
0xa
0XA
1.050000e+01
1.050000E+01
10.500000
10.5000
10.5000
000000000000010
000000000000012
00000000000000a
00000000000000A
0001.050000e+01
0001.050000E+01
00000010.500000
0000000000010.5
0000000000010.5
             10
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

   10
   12
    a
    A
   10
   12
    a
    A
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01





%
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
012
0xa
0XA
1.050000e+01
1.050000E+01
10.500000
10.5000
10.5000
000000000000010
000000000000012
00000000000000a
00000000000000A
0001.050000e+01
0001.050000E+01
00000010.500000
0000000000010.5
0000000000010.5
             10
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
            +10
  +1.050000e+01
  +1.050000E+01
     +10.500000
          +10.5
          +10.5
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
             10
             12
              a
              A
   1.050000e+01
   1.050000E+01
      10.500000
           10.5
           10.5
              z
    Abracadabra
10             
12             
a              
A              
1.050000e+01   
1.050000E+01   
10.500000      
10.5           
10.5           
z              
Abracadabra    
10
12
a
A
1.050000e+01
1.050000E+01
10.500000
10.5
10.5
z
Abracadabra
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

10
12
a
A
1e+01
1E+01
10
1e+01
1E+01

   10
   12
    a
    A
   10
   12
    a
    A
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
0000000010
0000000012
000000000a
000000000A
1.0500000000e+01
1.0500000000E+01
10.5000000000
10.5
10.5
Abracadabr
10
12
a
A
1e+01
1E+01
10
1e+01
1E+01





%
stop
OUTPUT511-1
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 512.
if test $result = ok -a $start_test_number -le 512; then
	echo test 512: adjustment for %d
        cat >$test_file <<'TEST512'
sputf ("%#d", 10);
TEST512
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST512-1'; then
test.d:1:8: run time error - invalid format in `sputf'
TEST512-1
                result=ok
        else
                result=fail
        fi
fi

# Test 513.
if test $result = ok -a $start_test_number -le 513; then
	echo test 513: adjustment for %c
        cat >$test_file <<'TEST513'
sputf ("%#c", 10);
TEST513
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST513-1'; then
test.d:1:8: run time error - invalid format in `sputf'
TEST513-1
                result=ok
        else
                result=fail
        fi
fi

# Test 514.
if test $result = ok -a $start_test_number -le 514; then
	echo test 514: blank flag for %o
        cat >$test_file <<'TEST514'
sputf ("% o", 10);
TEST514
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST514-1'; then
test.d:1:8: run time error - invalid format in `sputf'
TEST514-1
                result=ok
        else
                result=fail
        fi
fi

# Test 515.
if test $result = ok -a $start_test_number -le 515; then
	echo test 515: adjustment for %s
        cat >$test_file <<'TEST515'
sputf ("%#s", "Abracadabra");
TEST515
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST515-1'; then
test.d:1:8: run time error - invalid format in `sputf'
TEST515-1
                result=ok
        else
                result=fail
        fi
fi

# Test 516.
if test $result = ok -a $start_test_number -le 516; then
	echo test 516: zero flag for %c
        cat >$test_file <<'TEST516'
sputf ("%015c", 'z');
TEST516
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST516-1'; then
test.d:1:8: run time error - invalid format in `sputf'
TEST516-1
                result=ok
        else
                result=fail
        fi
fi

# Test 517.
if test $result = ok -a $start_test_number -le 517; then
	echo test 517: zero flag for %s
        cat >$test_file <<'TEST517'
sputf ("%015s", "Abracadabra");
TEST517
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST517-1'; then
test.d:1:8: run time error - invalid format in `sputf'
TEST517-1
                result=ok
        else
                result=fail
        fi
fi

# Test 518.
if test $result = ok -a $start_test_number -le 518; then
	echo test 518: blank flag for %o
        cat >$test_file <<'TEST518'
sputf ("% 15o", 10);
TEST518
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST518-1'; then
test.d:1:8: run time error - invalid format in `sputf'
TEST518-1
                result=ok
        else
                result=fail
        fi
fi

# Test 519.
if test $result = ok -a $start_test_number -le 519; then
	echo test 519: blank flag for %x
        cat >$test_file <<'TEST519'
sputf ("% 15x", 10);
TEST519
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST519-1'; then
test.d:1:8: run time error - invalid format in `sputf'
TEST519-1
                result=ok
        else
                result=fail
        fi
fi

# Test 520.
if test $result = ok -a $start_test_number -le 520; then
	echo test 520: blank flag for %X
        cat >$test_file <<'TEST520'
sputf ("% 15X", 10);
TEST520
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST520-1'; then
test.d:1:8: run time error - invalid format in `sputf'
TEST520-1
                result=ok
        else
                result=fail
        fi
fi

# Test 521.
if test $result = ok -a $start_test_number -le 521; then
	echo test 521: blank flag for %c
        cat >$test_file <<'TEST521'
sputf ("% 15c", 10);
TEST521
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST521-1'; then
test.d:1:8: run time error - invalid format in `sputf'
TEST521-1
                result=ok
        else
                result=fail
        fi
fi

# Test 522.
if test $result = ok -a $start_test_number -le 522; then
	echo test 522: blank flag for %s
        cat >$test_file <<'TEST522'
sputf ("% 15s", "Abracadabra");
TEST522
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST522-1'; then
test.d:1:8: run time error - invalid format in `sputf'
TEST522-1
                result=ok
        else
                result=fail
        fi
fi

# Test 523.
if test $result = ok -a $start_test_number -le 523; then
	echo test 523: flag + for %o
        cat >$test_file <<'TEST523'
sputf ("%+15o", 10);
TEST523
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST523-1'; then
test.d:1:8: run time error - invalid format in `sputf'
TEST523-1
                result=ok
        else
                result=fail
        fi
fi

# Test 524.
if test $result = ok -a $start_test_number -le 524; then
	echo test 524: flag + for %x
        cat >$test_file <<'TEST524'
sputf ("%+15x", 10);
TEST524
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST524-1'; then
test.d:1:8: run time error - invalid format in `sputf'
TEST524-1
                result=ok
        else
                result=fail
        fi
fi

# Test 525.
if test $result = ok -a $start_test_number -le 525; then
	echo test 525: flag + for %X
        cat >$test_file <<'TEST525'
sputf ("%+15X", 10);
TEST525
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST525-1'; then
test.d:1:8: run time error - invalid format in `sputf'
TEST525-1
                result=ok
        else
                result=fail
        fi
fi

# Test 526.
if test $result = ok -a $start_test_number -le 526; then
	echo test 526: flag + for %c
        cat >$test_file <<'TEST526'
sputf ("%+15c", 10);
TEST526
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST526-1'; then
test.d:1:8: run time error - invalid format in `sputf'
TEST526-1
                result=ok
        else
                result=fail
        fi
fi

# Test 527.
if test $result = ok -a $start_test_number -le 527; then
	echo test 527: flag + for %s
        cat >$test_file <<'TEST527'
sputf ("%+15s", 10);
TEST527
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST527-1'; then
test.d:1:8: run time error - invalid format in `sputf'
TEST527-1
                result=ok
        else
                result=fail
        fi
fi

# Test 528.
if test $result = ok -a $start_test_number -le 528; then
	echo test 528: Few arguments for format
        cat >$test_file <<'TEST528'
sputf ("%d");
TEST528
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST528-1'; then
test.d:1:8: run time error - invalid number of parameters of `sputf'
TEST528-1
                result=ok
        else
                result=fail
        fi
fi

# Test 529.
if test $result = ok -a $start_test_number -le 529; then
	echo test 529: Few arguments for format
        cat >$test_file <<'TEST529'
sputf ("%*d", 10);
TEST529
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST529-1'; then
test.d:1:8: run time error - invalid number of parameters of `sputf'
TEST529-1
                result=ok
        else
                result=fail
        fi
fi

# Test 530.
if test $result = ok -a $start_test_number -le 530; then
	echo test 530: Too many parameters
        cat >$test_file <<'TEST530'
sputf ("%*d", 10, 10, 10);
TEST530
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST530-1'; then
test.d:1:8: run time error - invalid number of parameters of `sputf'
TEST530-1
                result=ok
        else
                result=fail
        fi
fi

# Test 531.
if test $result = ok -a $start_test_number -le 531; then
	echo test 531: Too many parameters
        cat >$test_file <<'TEST531'
sputf ("%d", 10, 10);
TEST531
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST531-1'; then
test.d:1:8: run time error - invalid number of parameters of `sputf'
TEST531-1
                result=ok
        else
                result=fail
        fi
fi

# Test 532.
if test $result = ok -a $start_test_number -le 532; then
	echo test 532: Parameter does not correspond to conversion
        cat >$test_file <<'TEST532'
sputf ("%d", "");
TEST532
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST532-1'; then
test.d:1:8: run time error - invalid parameter type of `sputf'
TEST532-1
                result=ok
        else
                result=fail
        fi
fi

# Test 533.
if test $result = ok -a $start_test_number -le 533; then
	echo test 533: Parameter does not correspond to conversion
        cat >$test_file <<'TEST533'
sputf ("%d", 'c');
TEST533
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST533-1'; then
test.d:1:8: run time error - invalid parameter type of `sputf'
TEST533-1
                result=ok
        else
                result=fail
        fi
fi

# Test 534.
if test $result = ok -a $start_test_number -le 534; then
	echo test 534: Parameter does not correspond to conversion
        cat >$test_file <<'TEST534'
sputf ("%d", 10.0);
TEST534
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST534-1'; then
test.d:1:8: run time error - invalid parameter type of `sputf'
TEST534-1
                result=ok
        else
                result=fail
        fi
fi

# Test 535.
if test $result = ok -a $start_test_number -le 535; then
	echo test 535: Parameter does not correspond to conversion
        cat >$test_file <<'TEST535'
sputf ("%c", 10);
TEST535
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST535-1'; then
test.d:1:8: run time error - invalid parameter type of `sputf'
TEST535-1
                result=ok
        else
                result=fail
        fi
fi

# Test 536.
if test $result = ok -a $start_test_number -le 536; then
	echo test 536: Parameter does not correspond to conversion
        cat >$test_file <<'TEST536'
sputf ("%c", "");
TEST536
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST536-1'; then
test.d:1:8: run time error - invalid parameter type of `sputf'
TEST536-1
                result=ok
        else
                result=fail
        fi
fi

# Test 537.
if test $result = ok -a $start_test_number -le 537; then
	echo test 537: Parameter does not correspond to conversion
        cat >$test_file <<'TEST537'
sputf ("%c", 10.0);
TEST537
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST537-1'; then
test.d:1:8: run time error - invalid parameter type of `sputf'
TEST537-1
                result=ok
        else
                result=fail
        fi
fi

# Test 538.
if test $result = ok -a $start_test_number -le 538; then
	echo test 538: Parameter does not correspond to conversion
        cat >$test_file <<'TEST538'
sputf ("%g", "");
TEST538
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST538-1'; then
test.d:1:8: run time error - invalid parameter type of `sputf'
TEST538-1
                result=ok
        else
                result=fail
        fi
fi

# Test 539.
if test $result = ok -a $start_test_number -le 539; then
	echo test 539: Parameter does not correspond to conversion
        cat >$test_file <<'TEST539'
sputf ("%g", 'c');
TEST539
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST539-1'; then
test.d:1:8: run time error - invalid parameter type of `sputf'
TEST539-1
                result=ok
        else
                result=fail
        fi
fi

# Test 540.
if test $result = ok -a $start_test_number -le 540; then
	echo test 540: Parameter does not correspond to conversion
        cat >$test_file <<'TEST540'
sputf ("%g", 10);
TEST540
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST540-1'; then
test.d:1:8: run time error - invalid parameter type of `sputf'
TEST540-1
                result=ok
        else
                result=fail
        fi
fi

# Test 541.
if test $result = ok -a $start_test_number -le 541; then
	echo test 541: Absent format
        cat >$test_file <<'TEST541'
sputf ();
TEST541
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST541-1'; then
test.d:1:8: run time error - invalid number of parameters of `sputf'
TEST541-1
                result=ok
        else
                result=fail
        fi
fi

# Test 542.
if test $result = ok -a $start_test_number -le 542; then
	echo test 542: Absent format
        cat >$test_file <<'TEST542'
fputf (stdout);
TEST542
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST542-1'; then
test.d:1:8: run time error - invalid number of parameters of `fputf'
TEST542-1
                result=ok
        else
                result=fail
        fi
fi

# Test 543.
if test $result = ok -a $start_test_number -le 543; then
	echo test 543: Invalid parameter
        cat >$test_file <<'TEST543'
sputf ([]);
TEST543
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST543-1'; then
test.d:1:8: run time error - invalid parameter type of `sputf'
TEST543-1
                result=ok
        else
                result=fail
        fi
fi

# Test 544.
if test $result = ok -a $start_test_number -le 544; then
	echo test 544: Invalid %%
        cat >$test_file <<'TEST544'
sputf ("%#%");
TEST544
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST544-1'; then
test.d:1:8: run time error - invalid format in `sputf'
TEST544-1
                result=ok
        else
                result=fail
        fi
fi

# Test 545.
if test $result = ok -a $start_test_number -le 545; then
	echo test 545: Invalid %%
        cat >$test_file <<'TEST545'
sputf ("%0%");
TEST545
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST545-1'; then
test.d:1:8: run time error - invalid format in `sputf'
TEST545-1
                result=ok
        else
                result=fail
        fi
fi

# Test 546.
if test $result = ok -a $start_test_number -le 546; then
	echo test 546: Invalid %%
        cat >$test_file <<'TEST546'
sputf ("%-%");
TEST546
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST546-1'; then
test.d:1:8: run time error - invalid format in `sputf'
TEST546-1
                result=ok
        else
                result=fail
        fi
fi

# Test 547.
if test $result = ok -a $start_test_number -le 547; then
	echo test 547: Invalid %%
        cat >$test_file <<'TEST547'
sputf ("% %");
TEST547
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST547-1'; then
test.d:1:8: run time error - invalid format in `sputf'
TEST547-1
                result=ok
        else
                result=fail
        fi
fi

# Test 548.
if test $result = ok -a $start_test_number -le 548; then
	echo test 548: Invalid %%
        cat >$test_file <<'TEST548'
sputf ("%+%");
TEST548
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST548-1'; then
test.d:1:8: run time error - invalid format in `sputf'
TEST548-1
                result=ok
        else
                result=fail
        fi
fi

# Test 549.
if test $result = ok -a $start_test_number -le 549; then
	echo test 549: Unknown conversion
        cat >$test_file <<'TEST549'
sputf ("%w", 10);
TEST549
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST549-1'; then
test.d:1:8: run time error - invalid format in `sputf'
TEST549-1
                result=ok
        else
                result=fail
        fi
fi

# Test 550.
if test $result = ok -a $start_test_number -le 550; then
	echo test 550: Too big width
        cat >$test_file <<'TEST550'
sputf ("%214748364s", "");
TEST550
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST550-1'; then
test.d:1:8: no memory
TEST550-1
                result=ok
        else
                result=fail
        fi
fi

# Test 551.
if test $result = ok -a $start_test_number -le 551; then
	echo test 551: Too big width
        cat >$test_file <<'TEST551'
sputf ("%2147483648s", "");
TEST551
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST551-1'; then
test.d:1:8: run time error - invalid format in `sputf'
TEST551-1
                result=ok
        else
                result=fail
        fi
fi

# Test 552.
if test $result = ok -a $start_test_number -le 552; then
	echo test 552: Too big precision
        cat >$test_file <<'TEST552'
sputf ("%.2147483648s", "");
TEST552
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST552-1'; then
test.d:1:8: run time error - invalid format in `sputf'
TEST552-1
                result=ok
        else
                result=fail
        fi
fi

# Test 553.
if test $result = ok -a $start_test_number -le 553; then
	echo test 553: Precision with %c
        cat >$test_file <<'TEST553'
sputf ("%.0c", 'z');
TEST553
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr; then
                result=ok
        elif $SCMP $stderr - <<'TEST553-1'; then
test.d:1:8: run time error - invalid format in `sputf'
TEST553-1
                result=ok
        else
                result=fail
        fi
fi

# Test 553.
if test $result = ok -a $start_test_number -le 553; then
	echo test 553: Ackermann from Language Shootout
        cat >$test_file <<'TEST553'
func Ack (m, n) {
  if (m == 0) return n + 1;
  if (n == 0) return Ack (m - 1, 1);
  return Ack (m - 1, Ack (m, n - 1));
}

var N = int (#argv < 1 ? 1 : argv [0]);
putln ("Ack(3,", N ,"): ", Ack (3, N));

TEST553
        echo '      ' $DINO $test_file 9 "2>$stderr"
        if $DINO $test_file 9 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT553' && $CMP $stdout $ftemp2; then
Ack(3,9): 4093
OUTPUT553
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 554.
if test $result = ok -a $start_test_number -le 554; then
	echo test 554: Binary Trees from Language Shootout
        cat >$test_file <<'TEST554'
class node (item, left, right) {}

func BottomUpTree (item, depth) {
  if (depth <= 0) return item;
  var i = item + item;

  depth--;
  return node (item, BottomUpTree (i - 1, depth), BottomUpTree (i, depth));
}

func ItemCheck (tree) {
  return (type (tree) != class ()
	  ? tree : tree.item + ItemCheck (tree.left) - ItemCheck (tree.right));
}

var N = int (#argv < 1 ? 0 : argv [0]);
var mindepth = 4, maxdepth = max (N, mindepth + 2);
var stretchdepth = maxdepth + 1, stretchtree = BottomUpTree (0, stretchdepth);

putf ("stretch tree of depth %d\t  check: %d\n", stretchdepth,
      ItemCheck (stretchtree));

var i, depth, longlivedtree = BottomUpTree (0, maxdepth);

for (depth = mindepth; depth <= maxdepth; depth += 2) {
  var iterations = 1 << (maxdepth - depth + mindepth), check = 0;

  for (i = 0; i < iterations; i++)
    check += (ItemCheck (BottomUpTree (1, depth))
	      + ItemCheck (BottomUpTree (-1, depth)));
  putf ("%d\t  trees of depth %d\t  check: %d\n", iterations*2, depth, check);
}

putf ("long lived tree of depth %d\t  check: %d\n",
      maxdepth, ItemCheck (longlivedtree));
TEST554
        echo '      ' $DINO $test_file 12 "2>$stderr"
        if $DINO $test_file 12 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT554' && $CMP $stdout $ftemp2; then
stretch tree of depth 13	  check: -1
8192	  trees of depth 4	  check: -8192
2048	  trees of depth 6	  check: -2048
512	  trees of depth 8	  check: -512
128	  trees of depth 10	  check: -128
32	  trees of depth 12	  check: -32
long lived tree of depth 12	  check: -1
OUTPUT554
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 555.
if test $result = ok -a $start_test_number -le 555; then
	echo test 555: Chameneos from Language Shootout
        cat >$test_file <<'TEST555'
var final blue = 0, final red = 1, final yellow = 2, final faded = 3;
var colors = [blue, red, yellow, blue], N = int (#argv < 1 ? 10 : argv [0]);
var first = nil, second = nil;

// Create a very social creature.
class creature (my_color, creatures_met = 0) {
  thread be () {
    for (;my_color != faded;) {
      var other;

      wait (second == nil); // Wait until meeting place clears.
      if (first != nil) { // Hey, I found a new friend!
	other = first; wait (1) {first = nil; second = my_color;}
      } else if (N > 0) { // Sniff, nobody here (yet).
	N--; first = my_color;
	wait (second != nil);
	other = second; wait (1) second = nil;
      } else other = faded; // meeting place is closed

      // change color
      if (other == faded) my_color = other;
      else {
	creatures_met++;
	if (my_color == other) ;
	else if (my_color == blue) my_color = (other == red ? yellow : red);
	else if (my_color == red) my_color = (other == blue ? yellow : blue);
	else if (my_color == yellow) my_color = (other == blue ? red : blue);
      }
    }
  }
}

var i, meetings = 0, creatures = [#colors : nil];

for (i = 0; i < #colors; i++) {
  creatures [i] = creature (colors [i]); creatures [i].be ();
}

for (i = 0; i < #colors; i++) {
  wait (creatures [i].my_color == faded);
  meetings += creatures [i].creatures_met;
}
putln (meetings);
TEST555
        echo '      ' $DINO $test_file 1000000 "2>$stderr"
        if $DINO $test_file 1000000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT555' && $CMP $stdout $ftemp2; then
2000000
OUTPUT555
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 556.
if test $result = ok -a $start_test_number -le 556; then
	echo test 556: Cheap Concurrency from Language Shootout
        cat >$test_file <<'TEST556'
var N = int (#argv < 1 ? 10 : argv [0]);
var cont_p = 1, i, t, first = nil, last = nil, count = 0;

class thread_node (next = nil, n = -1) {
  thread start () {
    for (; cont_p;) {
      wait (n >= 0 || ! cont_p);
      if (next != nil) {next.n = n + 1; n = -1;}
    }
  }
}


for (i = 0; i < 500; i++) {
  t = thread_node (); t.start ();
  if (last == nil) {last = t; first = last;}
  else {last.next = t; last = last.next;}
}

for (i = 0; i < N; i++) {
  first.n = count; wait (last.n >= 0); count = last.n + 1; last.n = -1;
}
wait (1) cont_p = 0; putln (count);
TEST556
        echo '      ' $DINO $test_file 3000 "2>$stderr"
        if $DINO $test_file 3000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT556' && $CMP $stdout $ftemp2; then
1500000
OUTPUT556
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 557.
if test $result = ok -a $start_test_number -le 557; then
	echo test 557: Cheap Concurrency from Language Shootout
        cat >$test_file <<'TEST557'
var N = int (#argv < 1 ? 10 : argv [0]);
var cont_p = 1, i, t, first = nil, last = nil, count = 0;

class thread_node (next = nil, n = -1) {
  thread start () {
    for (; cont_p;) {
      wait (n >= 0 || ! cont_p);
      if (next != nil) {next.n = n + 1; n = -1;}
    }
  }
}


for (i = 0; i < 500; i++) {
  t = thread_node (); t.start ();
  if (last == nil) {last = t; first = last;}
  else {last.next = t; last = last.next;}
}

for (i = 0; i < N; i++) {
  first.n = count; wait (last.n >= 0); count = last.n + 1; last.n = -1;
}
wait (1)cont_p = 0; putln (count);
TEST557
        echo '      ' $DINO $test_file 3000 "2>$stderr"
        if $DINO $test_file 3000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT557' && $CMP $stdout $ftemp2; then
1500000
OUTPUT557
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 558.
if test $result = ok -a $start_test_number -le 558; then
	echo test 558: Fasta from Language Shootout
        cat >$test_file <<'TEST558'
var IM = 139968, IA = 3877, IC = 29573, Last = 42;

func random (max) {
  Last = (Last * IA + IC) % IM;
  return (max * Last) / IM;
}

class freq (c, p) {}

// Weighted selection from alphabet

func makeCumulative (a) {
  var i, cp = 0, len = #a;

   for (i = 0; i < len; i++) {
     cp += a [i].p; a [i].p = cp;
   }
}

func selectRandom (a) {
  var i, len = #a, r = random (1.0);

  for (i = 0; i < len; i++)
    if (r < a[i].p) return a [i].c;
  return a [len - 1].c;
}

// Generate and write FASTA format

func makeRandomFasta (id, desc, a, n) {
  var i, m, length = 60;

  putln (">", id, " ", desc);
  for (;n > 0; n -= length) {
    m = (n < length ? n : length);
    for (i = 0; i < m; i++)
      put (selectRandom (a));
    putln ();
  }
}

func makeRepeatFasta (id, desc, s, n) {
  var i, m, todo = n, length = 60, k = 0, kn = #s;

  putln (">", id, " ", desc);
  for (; todo > 0;) {
    m = (todo < length ? todo : length);
    for (i = 0; i < m; i++) {
      if (k >= kn)
	k = 0;
      put (s [k]);
      k++;
    }
    putln ();
    todo -= length;
  }
}


// Main -- define alphabets, make 3 fragments

var alu =   "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG"
          @ "GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA"
          @ "CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT"
          @ "ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA"
          @ "GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG"
	  @ "AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC"
          @ "AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA";

var iub = [ freq ('a', 0.27), freq ('c', 0.12), freq ('g', 0.12),
	    freq ('t', 0.27), freq ('B', 0.02), freq ('D', 0.02),
	    freq ('H', 0.02), freq ('K', 0.02), freq ('M', 0.02),
	    freq ('N', 0.02), freq ('R', 0.02), freq ('S', 0.02),
	    freq ('V', 0.02), freq ('W', 0.02), freq ('Y', 0.02) ];
makeCumulative (iub);

var homosapiens = [ freq ('a', 0.3029549426680), freq ('c', 0.1979883004921),
		    freq ('g', 0.1975473066391), freq ('t', 0.3015094502008) ];
makeCumulative (homosapiens);

var N = int (#argv < 1 ? 1000 : argv [0]);
makeRepeatFasta ("ONE", "Homo sapiens alu", alu, N * 2);
makeRandomFasta ("TWO", "IUB ambiguity codes", iub, N * 3);
makeRandomFasta ("THREE", "Homo sapiens frequency", homosapiens, N * 5);
TEST558
        echo '      ' $DINO $test_file 1000 "2>$stderr"
        if $DINO $test_file 1000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT558' && $CMP $stdout $ftemp2; then
>ONE Homo sapiens alu
GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGA
TCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACT
AAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAG
GCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCG
CCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGT
GGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCA
GGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAA
TTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAG
AATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCA
GCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGT
AATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACC
AGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTG
GTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACC
CGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAG
AGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTT
TGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACA
TGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCT
GTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGG
TTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGT
CTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGG
CGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCG
TCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTA
CTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCG
AGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCG
GGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACC
TGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAA
TACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGA
GGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACT
GCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTC
ACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGT
TCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGC
CGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCG
CTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTG
GGCGACAGAGCGAGACTCCG
>TWO IUB ambiguity codes
cttBtatcatatgctaKggNcataaaSatgtaaaDcDRtBggDtctttataattcBgtcg
tactDtDagcctatttSVHtHttKtgtHMaSattgWaHKHttttagacatWatgtRgaaa
NtactMcSMtYtcMgRtacttctWBacgaaatatagScDtttgaagacacatagtVgYgt
cattHWtMMWcStgttaggKtSgaYaaccWStcgBttgcgaMttBYatcWtgacaYcaga
gtaBDtRacttttcWatMttDBcatWtatcttactaBgaYtcttgttttttttYaaScYa
HgtgttNtSatcMtcVaaaStccRcctDaataataStcYtRDSaMtDttgttSagtRRca
tttHatSttMtWgtcgtatSSagactYaaattcaMtWatttaSgYttaRgKaRtccactt
tattRggaMcDaWaWagttttgacatgttctacaaaRaatataataaMttcgDacgaSSt
acaStYRctVaNMtMgtaggcKatcttttattaaaaagVWaHKYagtttttatttaacct
tacgtVtcVaattVMBcttaMtttaStgacttagattWWacVtgWYagWVRctDattBYt
gtttaagaagattattgacVatMaacattVctgtBSgaVtgWWggaKHaatKWcBScSWa
accRVacacaaactaccScattRatatKVtactatatttHttaagtttSKtRtacaaagt
RDttcaaaaWgcacatWaDgtDKacgaacaattacaRNWaatHtttStgttattaaMtgt
tgDcgtMgcatBtgcttcgcgaDWgagctgcgaggggVtaaScNatttacttaatgacag
cccccacatYScaMgtaggtYaNgttctgaMaacNaMRaacaaacaKctacatagYWctg
ttWaaataaaataRattagHacacaagcgKatacBttRttaagtatttccgatctHSaat
actcNttMaagtattMtgRtgaMgcataatHcMtaBSaRattagttgatHtMttaaKagg
YtaaBataSaVatactWtataVWgKgttaaaacagtgcgRatatacatVtHRtVYataSa
KtWaStVcNKHKttactatccctcatgWHatWaRcttactaggatctataDtDHBttata
aaaHgtacVtagaYttYaKcctattcttcttaataNDaaggaaaDYgcggctaaWSctBa
aNtgctggMBaKctaMVKagBaactaWaDaMaccYVtNtaHtVWtKgRtcaaNtYaNacg
gtttNattgVtttctgtBaWgtaattcaagtcaVWtactNggattctttaYtaaagccgc
tcttagHVggaYtgtNcDaVagctctctKgacgtatagYcctRYHDtgBattDaaDgccK
tcHaaStttMcctagtattgcRgWBaVatHaaaataYtgtttagMDMRtaataaggatMt
ttctWgtNtgtgaaaaMaatatRtttMtDgHHtgtcattttcWattRSHcVagaagtacg
ggtaKVattKYagactNaatgtttgKMMgYNtcccgSKttctaStatatNVataYHgtNa
BKRgNacaactgatttcctttaNcgatttctctataScaHtataRagtcRVttacDSDtt
aRtSatacHgtSKacYagttMHtWataggatgactNtatSaNctataVtttRNKtgRacc
tttYtatgttactttttcctttaaacatacaHactMacacggtWataMtBVacRaSaatc
cgtaBVttccagccBcttaRKtgtgcctttttRtgtcagcRttKtaaacKtaaatctcac
aattgcaNtSBaaccgggttattaaBcKatDagttactcttcattVtttHaaggctKKga
tacatcBggScagtVcacattttgaHaDSgHatRMaHWggtatatRgccDttcgtatcga
aacaHtaagttaRatgaVacttagattVKtaaYttaaatcaNatccRttRRaMScNaaaD
gttVHWgtcHaaHgacVaWtgttScactaagSgttatcttagggDtaccagWattWtRtg
ttHWHacgattBtgVcaYatcggttgagKcWtKKcaVtgaYgWctgYggVctgtHgaNcV
taBtWaaYatcDRaaRtSctgaHaYRttagatMatgcatttNattaDttaattgttctaa
ccctcccctagaWBtttHtBccttagaVaatMcBHagaVcWcagBVttcBtaYMccagat
gaaaaHctctaacgttagNWRtcggattNatcRaNHttcagtKttttgWatWttcSaNgg
gaWtactKKMaacatKatacNattgctWtatctaVgagctatgtRaHtYcWcttagccaa
tYttWttaWSSttaHcaaaaagVacVgtaVaRMgattaVcDactttcHHggHRtgNcctt
tYatcatKgctcctctatVcaaaaKaaaagtatatctgMtWtaaaacaStttMtcgactt
taSatcgDataaactaaacaagtaaVctaggaSccaatMVtaaSKNVattttgHccatca
cBVctgcaVatVttRtactgtVcaattHgtaaattaaattttYtatattaaRSgYtgBag
aHSBDgtagcacRHtYcBgtcacttacactaYcgctWtattgSHtSatcataaatataHt
cgtYaaMNgBaatttaRgaMaatatttBtttaaaHHKaatctgatWatYaacttMctctt
ttVctagctDaaagtaVaKaKRtaacBgtatccaaccactHHaagaagaaggaNaaatBW
attccgStaMSaMatBttgcatgRSacgttVVtaaDMtcSgVatWcaSatcttttVatag
ttactttacgatcaccNtaDVgSRcgVcgtgaacgaNtaNatatagtHtMgtHcMtagaa
attBgtataRaaaacaYKgtRccYtatgaagtaataKgtaaMttgaaRVatgcagaKStc
tHNaaatctBBtcttaYaBWHgtVtgacagcaRcataWctcaBcYacYgatDgtDHccta
>THREE Homo sapiens frequency
aacacttcaccaggtatcgtgaaggctcaagattacccagagaacctttgcaatataaga
atatgtatgcagcattaccctaagtaattatattctttttctgactcaaagtgacaagcc
ctagtgtatattaaatcggtatatttgggaaattcctcaaactatcctaatcaggtagcc
atgaaagtgatcaaaaaagttcgtacttataccatacatgaattctggccaagtaaaaaa
tagattgcgcaaaattcgtaccttaagtctctcgccaagatattaggatcctattactca
tatcgtgtttttctttattgccgccatccccggagtatctcacccatccttctcttaaag
gcctaatattacctatgcaaataaacatatattgttgaaaattgagaacctgatcgtgat
tcttatgtgtaccatatgtatagtaatcacgcgactatatagtgctttagtatcgcccgt
gggtgagtgaatattctgggctagcgtgagatagtttcttgtcctaatatttttcagatc
gaatagcttctatttttgtgtttattgacatatgtcgaaactccttactcagtgaaagtc
atgaccagatccacgaacaatcttcggaatcagtctcgttttacggcggaatcttgagtc
taacttatatcccgtcgcttactttctaacaccccttatgtatttttaaaattacgttta
ttcgaacgtacttggcggaagcgttattttttgaagtaagttacattgggcagactcttg
acattttcgatacgactttctttcatccatcacaggactcgttcgtattgatatcagaag
ctcgtgatgattagttgtcttctttaccaatactttgaggcctattctgcgaaatttttg
ttgccctgcgaacttcacataccaaggaacacctcgcaacatgccttcatatccatcgtt
cattgtaattcttacacaatgaatcctaagtaattacatccctgcgtaaaagatggtagg
ggcactgaggatatattaccaagcatttagttatgagtaatcagcaatgtttcttgtatt
aagttctctaaaatagttacatcgtaatgttatctcgggttccgcgaataaacgagatag
attcattatatatggccctaagcaaaaacctcctcgtattctgttggtaattagaatcac
acaatacgggttgagatattaattatttgtagtacgaagagatataaaaagatgaacaat
tactcaagtcaagatgtatacgggatttataataaaaatcgggtagagatctgctttgca
attcagacgtgccactaaatcgtaatatgtcgcgttacatcagaaagggtaactattatt
aattaataaagggcttaatcactacatattagatcttatccgatagtcttatctattcgt
tgtatttttaagcggttctaattcagtcattatatcagtgctccgagttctttattattg
ttttaaggatgacaaaatgcctcttgttataacgctgggagaagcagactaagagtcgga
gcagttggtagaatgaggctgcaaaagacggtctcgacgaatggacagactttactaaac
caatgaaagacagaagtagagcaaagtctgaagtggtatcagcttaattatgacaaccct
taatacttccctttcgccgaatactggcgtggaaaggttttaaaagtcgaagtagttaga
ggcatctctcgctcataaataggtagactactcgcaatccaatgtgactatgtaatactg
ggaacatcagtccgcgatgcagcgtgtttatcaaccgtccccactcgcctggggagacat
gagaccacccccgtggggattattagtccgcagtaatcgactcttgacaatccttttcga
ttatgtcatagcaatttacgacagttcagcgaagtgactactcggcgaaatggtattact
aaagcattcgaacccacatgaatgtgattcttggcaatttctaatccactaaagcttttc
cgttgaatctggttgtagatatttatataagttcactaattaagatcacggtagtatatt
gatagtgatgtctttgcaagaggttggccgaggaatttacggattctctattgatacaat
ttgtctggcttataactcttaaggctgaaccaggcgtttttagacgacttgatcagctgt
tagaatggtttggactccctctttcatgtcagtaacatttcagccgttattgttacgata
tgcttgaacaatattgatctaccacacacccatagtatattttataggtcatgctgttac
ctacgagcatggtattccacttcccattcaatgagtattcaacatcactagcctcagaga
tgatgacccacctctaataacgtcacgttgcggccatgtgaaacctgaacttgagtagac
gatatcaagcgctttaaattgcatataacatttgagggtaaagctaagcggatgctttat
ataatcaatactcaataataagatttgattgcattttagagttatgacacgacatagttc
actaacgagttactattcccagatctagactgaagtactgatcgagacgatccttacgtc
gatgatcgttagttatcgacttaggtcgggtctctagcggtattggtacttaaccggaca
ctatactaataacccatgatcaaagcataacagaatacagacgataatttcgccaacata
tatgtacagaccccaagcatgagaagctcattgaaagctatcattgaagtcccgctcaca
atgtgtcttttccagacggtttaactggttcccgggagtcctggagtttcgacttacata
aatggaaacaatgtattttgctaatttatctatagcgtcatttggaccaatacagaatat
tatgttgcctagtaatccactataacccgcaagtgctgatagaaaatttttagacgattt
ataaatgccccaagtatccctcccgtgaatcctccgttatactaattagtattcgttcat
acgtataccgcgcatatatgaacatttggcgataaggcgcgtgaattgttacgtgacaga
gatagcagtttcttgtgatatggttaacagacgtacatgaagggaaactttatatctata
gtgatgcttccgtagaaataccgccactggtctgccaatgatgaagtatgtagctttagg
tttgtactatgaggctttcgtttgtttgcagagtataacagttgcgagtgaaaaaccgac
gaatttatactaatacgctttcactattggctacaaaatagggaagagtttcaatcatga
gagggagtatatggatgctttgtagctaaaggtagaacgtatgtatatgctgccgttcat
tcttgaaagatacataagcgataagttacgacaattataagcaacatccctaccttcgta
acgatttcactgttactgcgcttgaaatacactatggggctattggcggagagaagcaga
tcgcgccgagcatatacgagacctataatgttgatgatagagaaggcgtctgaattgata
catcgaagtacactttctttcgtagtatctctcgtcctctttctatctccggacacaaga
attaagttatatatatagagtcttaccaatcatgttgaatcctgattctcagagttcttt
ggcgggccttgtgatgactgagaaacaatgcaatattgctccaaatttcctaagcaaatt
ctcggttatgttatgttatcagcaaagcgttacgttatgttatttaaatctggaatgacg
gagcgaagttcttatgtcggtgtgggaataattcttttgaagacagcactccttaaataa
tatcgctccgtgtttgtatttatcgaatgggtctgtaaccttgcacaagcaaatcggtgg
tgtatatatcggataacaattaatacgatgttcatagtgacagtatactgatcgagtcct
ctaaagtcaattacctcacttaacaatctcattgatgttgtgtcattcccggtatcgccc
gtagtatgtgctctgattgaccgagtgtgaaccaaggaacatctactaatgcctttgtta
ggtaagatctctctgaattccttcgtgccaacttaaaacattatcaaaatttcttctact
tggattaactacttttacgagcatggcaaattcccctgtggaagacggttcattattatc
ggaaaccttatagaaattgcgtgttgactgaaattagatttttattgtaagagttgcatc
tttgcgattcctctggtctagcttccaatgaacagtcctcccttctattcgacatcgggt
ccttcgtacatgtctttgcgatgtaataattaggttcggagtgtggccttaatgggtgca
actaggaatacaacgcaaatttgctgacatgatagcaaatcggtatgccggcaccaaaac
gtgctccttgcttagcttgtgaatgagactcagtagttaaataaatccatatctgcaatc
gattccacaggtattgtccactatctttgaactactctaagagatacaagcttagctgag
accgaggtgtatatgactacgctgatatctgtaaggtaccaatgcaggcaaagtatgcga
gaagctaataccggctgtttccagctttataagattaaaatttggctgtcctggcggcct
cagaattgttctatcgtaatcagttggttcattaattagctaagtacgaggtacaactta
tctgtcccagaacagctccacaagtttttttacagccgaaacccctgtgtgaatcttaat
atccaagcgcgttatctgattagagtttacaactcagtattttatcagtacgttttgttt
ccaacattacccggtatgacaaaatgacgccacgtgtcgaataatggtctgaccaatgta
ggaagtgaaaagataaatat
OUTPUT558
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 559.
if test $result = ok -a $start_test_number -le 559; then
	echo test 559: Fannkuch from Language Shootout
        cat >$test_file <<'TEST559'
func fannkuch (n) {
   var perm, maxperm, perm1 = [n : 0], count = [n : 0];
   var i, k, t, flipscount, maxflipscount = 0, m = n - 1, r = n, check = 0;

   for (i = 0; i < n; i++) perm1 [i] = i;
   for (;;) {
      if (check < 30) {
         for (i = 0; i < n; i++) put (perm1 [i] + 1);
         putln (); check++;
      }

      for (; r != 1; r--) count [r - 1] = r;
      if (perm1 [0] != 0 && perm1 [m] != m) {
	perm = new perm1;
	for (flipscount = 0;; flipscount++) {
	  k = perm [0];
	  if (k == 0) break;
	  for (i = (k + 1) / 2 - 1; i >= 0 ; i--)  perm [i] <=> perm [k - i];
	}

	if (flipscount > maxflipscount) {
	  maxflipscount = flipscount; maxperm = new perm1;
	}
      }

      for (;;r++) {
         if (r == n) return maxflipscount;
         t = perm1 [0];
         for (i = 0; i < r; i++) perm1 [i] = perm1 [i + 1];
         perm1 [r] = t;
	 count [r]--;
         if (count [r] > 0) break;
      }
   }
}

var n = int (#argv < 1 ? 1 : argv [0]);
putln ("Pfannkuchen(", n, ") = ", fannkuch(n));
TEST559
        echo '      ' $DINO $test_file 9 "2>$stderr"
        if $DINO $test_file 9 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT559' && $CMP $stdout $ftemp2; then
123456789
213456789
231456789
321456789
312456789
132456789
234156789
324156789
342156789
432156789
423156789
243156789
341256789
431256789
413256789
143256789
134256789
314256789
412356789
142356789
124356789
214356789
241356789
421356789
234516789
324516789
342516789
432516789
423516789
243516789
Pfannkuchen(9) = 30
OUTPUT559
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 560.
if test $result = ok -a $start_test_number -le 560; then
	echo test 560: Harmonic from Language Shootout
        cat >$test_file <<'TEST560'
var d, partialSum = 0.0, n = int (#argv < 1 ? 10000000 : argv [0]);

for (d = 1; d <= n; d++) partialSum += 1.0 / d;
putf ("%0.9f\n", partialSum);
TEST560
        echo '      ' $DINO $test_file 10000000 "2>$stderr"
        if $DINO $test_file 10000000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT560' && $CMP $stdout $ftemp2; then
16.695311366
OUTPUT560
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 561.
if test $result = ok -a $start_test_number -le 561; then
	echo test 561: K-nucleotide from Language Shootout
        cat >$test_file <<'TEST561'
func kfrequency (seq, freq, k, frame) {
  var i, c, stop = #seq - k + 1;

  for (i = frame; i < stop; i += k) {
    c = subv (seq, i, k);
    if (c in freq) freq {c}++;
    else freq {c} = 1;
  }
}

func count (seq, frag) {
  var frame, k = #frag, freq = {};

  for (frame = 0; frame < k; frame++) kfrequency (seq, freq, k, frame);
  putln (frag in freq ? freq {frag} : 0, "\t", frag);
}

func frequency (seq, k) {
  var i, c, sum, frame, freq = {}, sfreq = [];
  func freq_cmp (el1, el2) {
    return freq {el2} - freq {el1};
  }

  for (frame = 0; frame < k; frame++) kfrequency (seq, freq, k, frame);
  for (c in freq) ins (sfreq, c, -1);
  sfreq = sort (sfreq, freq_cmp);
  sum = #seq - k + 1;
  for (i = 0; i < #sfreq; i++) {
    c = sfreq [i];
    putf ("%s %0.3f\n", c, (freq {c} * 100.) / sum);
  }
  putln ();
}

func readseq () {
  var c, line, lines = [];

  try {
    for (;;) {
      line = getln ();
      if (line [0] == '>' && subv (line, 1, 5) == "THREE") break;
    }
    for (;;) {
      line = getln ();
      c = line [0];
      if (c == '>')
	break;
      else if (c != ';')
	insv (lines, toupper (line), -1);
    }
  } catch (invcalls.eof) {}
  return lines;
}

var seq = readseq ();
frequency (seq, 1);
frequency (seq, 2);
count (seq, "GGT");
count (seq, "GGTA");
count (seq, "GGTATT");
count (seq, "GGTATTTTAATT");
count (seq, "GGTATTTTAATTTATAGT");
TEST561
        echo '      ' $DINO $test_file 1000 "2>$stderr"
        if $DINO $test_file 1000 <<'INPUT561' 2>$stderr >$stdout; then
>ONE Homo sapiens alu
GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGA
TCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACT
AAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAG
GCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCG
CCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGT
GGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCA
GGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAA
TTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAG
AATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCA
GCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGT
AATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACC
AGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTG
GTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACC
CGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAG
AGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTT
TGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACA
TGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCT
GTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGG
TTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGT
CTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGG
CGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCG
TCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTA
CTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCG
AGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCG
GGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACC
TGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAA
TACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGA
GGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACT
GCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTC
ACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGT
TCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGC
CGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCG
CTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTG
GGCGACAGAGCGAGACTCCG
>TWO IUB ambiguity codes
cttBtatcatatgctaKggNcataaaSatgtaaaDcDRtBggDtctttataattcBgtcg
tactDtDagcctatttSVHtHttKtgtHMaSattgWaHKHttttagacatWatgtRgaaa
NtactMcSMtYtcMgRtacttctWBacgaaatatagScDtttgaagacacatagtVgYgt
cattHWtMMWcStgttaggKtSgaYaaccWStcgBttgcgaMttBYatcWtgacaYcaga
gtaBDtRacttttcWatMttDBcatWtatcttactaBgaYtcttgttttttttYaaScYa
HgtgttNtSatcMtcVaaaStccRcctDaataataStcYtRDSaMtDttgttSagtRRca
tttHatSttMtWgtcgtatSSagactYaaattcaMtWatttaSgYttaRgKaRtccactt
tattRggaMcDaWaWagttttgacatgttctacaaaRaatataataaMttcgDacgaSSt
acaStYRctVaNMtMgtaggcKatcttttattaaaaagVWaHKYagtttttatttaacct
tacgtVtcVaattVMBcttaMtttaStgacttagattWWacVtgWYagWVRctDattBYt
gtttaagaagattattgacVatMaacattVctgtBSgaVtgWWggaKHaatKWcBScSWa
accRVacacaaactaccScattRatatKVtactatatttHttaagtttSKtRtacaaagt
RDttcaaaaWgcacatWaDgtDKacgaacaattacaRNWaatHtttStgttattaaMtgt
tgDcgtMgcatBtgcttcgcgaDWgagctgcgaggggVtaaScNatttacttaatgacag
cccccacatYScaMgtaggtYaNgttctgaMaacNaMRaacaaacaKctacatagYWctg
ttWaaataaaataRattagHacacaagcgKatacBttRttaagtatttccgatctHSaat
actcNttMaagtattMtgRtgaMgcataatHcMtaBSaRattagttgatHtMttaaKagg
YtaaBataSaVatactWtataVWgKgttaaaacagtgcgRatatacatVtHRtVYataSa
KtWaStVcNKHKttactatccctcatgWHatWaRcttactaggatctataDtDHBttata
aaaHgtacVtagaYttYaKcctattcttcttaataNDaaggaaaDYgcggctaaWSctBa
aNtgctggMBaKctaMVKagBaactaWaDaMaccYVtNtaHtVWtKgRtcaaNtYaNacg
gtttNattgVtttctgtBaWgtaattcaagtcaVWtactNggattctttaYtaaagccgc
tcttagHVggaYtgtNcDaVagctctctKgacgtatagYcctRYHDtgBattDaaDgccK
tcHaaStttMcctagtattgcRgWBaVatHaaaataYtgtttagMDMRtaataaggatMt
ttctWgtNtgtgaaaaMaatatRtttMtDgHHtgtcattttcWattRSHcVagaagtacg
ggtaKVattKYagactNaatgtttgKMMgYNtcccgSKttctaStatatNVataYHgtNa
BKRgNacaactgatttcctttaNcgatttctctataScaHtataRagtcRVttacDSDtt
aRtSatacHgtSKacYagttMHtWataggatgactNtatSaNctataVtttRNKtgRacc
tttYtatgttactttttcctttaaacatacaHactMacacggtWataMtBVacRaSaatc
cgtaBVttccagccBcttaRKtgtgcctttttRtgtcagcRttKtaaacKtaaatctcac
aattgcaNtSBaaccgggttattaaBcKatDagttactcttcattVtttHaaggctKKga
tacatcBggScagtVcacattttgaHaDSgHatRMaHWggtatatRgccDttcgtatcga
aacaHtaagttaRatgaVacttagattVKtaaYttaaatcaNatccRttRRaMScNaaaD
gttVHWgtcHaaHgacVaWtgttScactaagSgttatcttagggDtaccagWattWtRtg
ttHWHacgattBtgVcaYatcggttgagKcWtKKcaVtgaYgWctgYggVctgtHgaNcV
taBtWaaYatcDRaaRtSctgaHaYRttagatMatgcatttNattaDttaattgttctaa
ccctcccctagaWBtttHtBccttagaVaatMcBHagaVcWcagBVttcBtaYMccagat
gaaaaHctctaacgttagNWRtcggattNatcRaNHttcagtKttttgWatWttcSaNgg
gaWtactKKMaacatKatacNattgctWtatctaVgagctatgtRaHtYcWcttagccaa
tYttWttaWSSttaHcaaaaagVacVgtaVaRMgattaVcDactttcHHggHRtgNcctt
tYatcatKgctcctctatVcaaaaKaaaagtatatctgMtWtaaaacaStttMtcgactt
taSatcgDataaactaaacaagtaaVctaggaSccaatMVtaaSKNVattttgHccatca
cBVctgcaVatVttRtactgtVcaattHgtaaattaaattttYtatattaaRSgYtgBag
aHSBDgtagcacRHtYcBgtcacttacactaYcgctWtattgSHtSatcataaatataHt
cgtYaaMNgBaatttaRgaMaatatttBtttaaaHHKaatctgatWatYaacttMctctt
ttVctagctDaaagtaVaKaKRtaacBgtatccaaccactHHaagaagaaggaNaaatBW
attccgStaMSaMatBttgcatgRSacgttVVtaaDMtcSgVatWcaSatcttttVatag
ttactttacgatcaccNtaDVgSRcgVcgtgaacgaNtaNatatagtHtMgtHcMtagaa
attBgtataRaaaacaYKgtRccYtatgaagtaataKgtaaMttgaaRVatgcagaKStc
tHNaaatctBBtcttaYaBWHgtVtgacagcaRcataWctcaBcYacYgatDgtDHccta
>THREE Homo sapiens frequency
aacacttcaccaggtatcgtgaaggctcaagattacccagagaacctttgcaatataaga
atatgtatgcagcattaccctaagtaattatattctttttctgactcaaagtgacaagcc
ctagtgtatattaaatcggtatatttgggaaattcctcaaactatcctaatcaggtagcc
atgaaagtgatcaaaaaagttcgtacttataccatacatgaattctggccaagtaaaaaa
tagattgcgcaaaattcgtaccttaagtctctcgccaagatattaggatcctattactca
tatcgtgtttttctttattgccgccatccccggagtatctcacccatccttctcttaaag
gcctaatattacctatgcaaataaacatatattgttgaaaattgagaacctgatcgtgat
tcttatgtgtaccatatgtatagtaatcacgcgactatatagtgctttagtatcgcccgt
gggtgagtgaatattctgggctagcgtgagatagtttcttgtcctaatatttttcagatc
gaatagcttctatttttgtgtttattgacatatgtcgaaactccttactcagtgaaagtc
atgaccagatccacgaacaatcttcggaatcagtctcgttttacggcggaatcttgagtc
taacttatatcccgtcgcttactttctaacaccccttatgtatttttaaaattacgttta
ttcgaacgtacttggcggaagcgttattttttgaagtaagttacattgggcagactcttg
acattttcgatacgactttctttcatccatcacaggactcgttcgtattgatatcagaag
ctcgtgatgattagttgtcttctttaccaatactttgaggcctattctgcgaaatttttg
ttgccctgcgaacttcacataccaaggaacacctcgcaacatgccttcatatccatcgtt
cattgtaattcttacacaatgaatcctaagtaattacatccctgcgtaaaagatggtagg
ggcactgaggatatattaccaagcatttagttatgagtaatcagcaatgtttcttgtatt
aagttctctaaaatagttacatcgtaatgttatctcgggttccgcgaataaacgagatag
attcattatatatggccctaagcaaaaacctcctcgtattctgttggtaattagaatcac
acaatacgggttgagatattaattatttgtagtacgaagagatataaaaagatgaacaat
tactcaagtcaagatgtatacgggatttataataaaaatcgggtagagatctgctttgca
attcagacgtgccactaaatcgtaatatgtcgcgttacatcagaaagggtaactattatt
aattaataaagggcttaatcactacatattagatcttatccgatagtcttatctattcgt
tgtatttttaagcggttctaattcagtcattatatcagtgctccgagttctttattattg
ttttaaggatgacaaaatgcctcttgttataacgctgggagaagcagactaagagtcgga
gcagttggtagaatgaggctgcaaaagacggtctcgacgaatggacagactttactaaac
caatgaaagacagaagtagagcaaagtctgaagtggtatcagcttaattatgacaaccct
taatacttccctttcgccgaatactggcgtggaaaggttttaaaagtcgaagtagttaga
ggcatctctcgctcataaataggtagactactcgcaatccaatgtgactatgtaatactg
ggaacatcagtccgcgatgcagcgtgtttatcaaccgtccccactcgcctggggagacat
gagaccacccccgtggggattattagtccgcagtaatcgactcttgacaatccttttcga
ttatgtcatagcaatttacgacagttcagcgaagtgactactcggcgaaatggtattact
aaagcattcgaacccacatgaatgtgattcttggcaatttctaatccactaaagcttttc
cgttgaatctggttgtagatatttatataagttcactaattaagatcacggtagtatatt
gatagtgatgtctttgcaagaggttggccgaggaatttacggattctctattgatacaat
ttgtctggcttataactcttaaggctgaaccaggcgtttttagacgacttgatcagctgt
tagaatggtttggactccctctttcatgtcagtaacatttcagccgttattgttacgata
tgcttgaacaatattgatctaccacacacccatagtatattttataggtcatgctgttac
ctacgagcatggtattccacttcccattcaatgagtattcaacatcactagcctcagaga
tgatgacccacctctaataacgtcacgttgcggccatgtgaaacctgaacttgagtagac
gatatcaagcgctttaaattgcatataacatttgagggtaaagctaagcggatgctttat
ataatcaatactcaataataagatttgattgcattttagagttatgacacgacatagttc
actaacgagttactattcccagatctagactgaagtactgatcgagacgatccttacgtc
gatgatcgttagttatcgacttaggtcgggtctctagcggtattggtacttaaccggaca
ctatactaataacccatgatcaaagcataacagaatacagacgataatttcgccaacata
tatgtacagaccccaagcatgagaagctcattgaaagctatcattgaagtcccgctcaca
atgtgtcttttccagacggtttaactggttcccgggagtcctggagtttcgacttacata
aatggaaacaatgtattttgctaatttatctatagcgtcatttggaccaatacagaatat
tatgttgcctagtaatccactataacccgcaagtgctgatagaaaatttttagacgattt
ataaatgccccaagtatccctcccgtgaatcctccgttatactaattagtattcgttcat
acgtataccgcgcatatatgaacatttggcgataaggcgcgtgaattgttacgtgacaga
gatagcagtttcttgtgatatggttaacagacgtacatgaagggaaactttatatctata
gtgatgcttccgtagaaataccgccactggtctgccaatgatgaagtatgtagctttagg
tttgtactatgaggctttcgtttgtttgcagagtataacagttgcgagtgaaaaaccgac
gaatttatactaatacgctttcactattggctacaaaatagggaagagtttcaatcatga
gagggagtatatggatgctttgtagctaaaggtagaacgtatgtatatgctgccgttcat
tcttgaaagatacataagcgataagttacgacaattataagcaacatccctaccttcgta
acgatttcactgttactgcgcttgaaatacactatggggctattggcggagagaagcaga
tcgcgccgagcatatacgagacctataatgttgatgatagagaaggcgtctgaattgata
catcgaagtacactttctttcgtagtatctctcgtcctctttctatctccggacacaaga
attaagttatatatatagagtcttaccaatcatgttgaatcctgattctcagagttcttt
ggcgggccttgtgatgactgagaaacaatgcaatattgctccaaatttcctaagcaaatt
ctcggttatgttatgttatcagcaaagcgttacgttatgttatttaaatctggaatgacg
gagcgaagttcttatgtcggtgtgggaataattcttttgaagacagcactccttaaataa
tatcgctccgtgtttgtatttatcgaatgggtctgtaaccttgcacaagcaaatcggtgg
tgtatatatcggataacaattaatacgatgttcatagtgacagtatactgatcgagtcct
ctaaagtcaattacctcacttaacaatctcattgatgttgtgtcattcccggtatcgccc
gtagtatgtgctctgattgaccgagtgtgaaccaaggaacatctactaatgcctttgtta
ggtaagatctctctgaattccttcgtgccaacttaaaacattatcaaaatttcttctact
tggattaactacttttacgagcatggcaaattcccctgtggaagacggttcattattatc
ggaaaccttatagaaattgcgtgttgactgaaattagatttttattgtaagagttgcatc
tttgcgattcctctggtctagcttccaatgaacagtcctcccttctattcgacatcgggt
ccttcgtacatgtctttgcgatgtaataattaggttcggagtgtggccttaatgggtgca
actaggaatacaacgcaaatttgctgacatgatagcaaatcggtatgccggcaccaaaac
gtgctccttgcttagcttgtgaatgagactcagtagttaaataaatccatatctgcaatc
gattccacaggtattgtccactatctttgaactactctaagagatacaagcttagctgag
accgaggtgtatatgactacgctgatatctgtaaggtaccaatgcaggcaaagtatgcga
gaagctaataccggctgtttccagctttataagattaaaatttggctgtcctggcggcct
cagaattgttctatcgtaatcagttggttcattaattagctaagtacgaggtacaactta
tctgtcccagaacagctccacaagtttttttacagccgaaacccctgtgtgaatcttaat
atccaagcgcgttatctgattagagtttacaactcagtattttatcagtacgttttgttt
ccaacattacccggtatgacaaaatgacgccacgtgtcgaataatggtctgaccaatgta
ggaagtgaaaagataaatat
INPUT561
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT561' && $CMP $stdout $ftemp2; then
T 31.520
A 29.600
C 19.480
G 19.400

AT 9.922
TT 9.602
TA 9.402
AA 8.402
GA 6.321
TC 6.301
TG 6.201
GT 6.041
CT 5.961
AG 5.841
CA 5.461
AC 5.441
CC 4.041
CG 4.021
GC 3.701
GG 3.341

54	GGT
24	GGTA
4	GGTATT
0	GGTATTTTAATT
0	GGTATTTTAATTTATAGT
OUTPUT561
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 562.
if test $result = ok -a $start_test_number -le 562; then
	echo test 562: Fasta from Language Shootout
        cat >$test_file <<'TEST562'
var PI = 3.141592653589793;
var SOLAR_MASS = 4 * PI * PI;
var DAYS_PER_YEAR = 365.24;

class body (x, y, z, vx, vy, vz, mass) {}

var Jupiter = body (4.84143144246472090e+00,
		    -1.16032004402742839e+00,
	            -1.03622044471123109e-01,
		    1.66007664274403694e-03 * DAYS_PER_YEAR,
		    7.69901118419740425e-03 * DAYS_PER_YEAR,
		    -6.90460016972063023e-05 * DAYS_PER_YEAR,
		    9.54791938424326609e-04 * SOLAR_MASS);

var Saturn = body (8.34336671824457987e+00,
		   4.12479856412430479e+00,
		   -4.03523417114321381e-01,
		   -2.76742510726862411e-03 * DAYS_PER_YEAR,
		   4.99852801234917238e-03 * DAYS_PER_YEAR,
		   2.30417297573763929e-05 * DAYS_PER_YEAR,
		   2.85885980666130812e-04 * SOLAR_MASS);

var Uranus = body (1.28943695621391310e+01,
		   -1.51111514016986312e+01,
		   -2.23307578892655734e-01,
		   2.96460137564761618e-03 * DAYS_PER_YEAR,
		   2.37847173959480950e-03 * DAYS_PER_YEAR,
		   -2.96589568540237556e-05 * DAYS_PER_YEAR,
		   4.36624404335156298e-05 * SOLAR_MASS);

var Neptune = body (1.53796971148509165e+01,
		    -2.59193146099879641e+01,
		    1.79258772950371181e-01,
		    2.68067772490389322e-03 * DAYS_PER_YEAR,
		    1.62824170038242295e-03 * DAYS_PER_YEAR,
		    -9.51592254519715870e-05 * DAYS_PER_YEAR,
		    5.15138902046611451e-05 * SOLAR_MASS);

var Sun = body (0., 0., 0., 0., 0., 0., SOLAR_MASS);

func advance (bodies, dt) {
  var i, j;

  for (i = 0; i < #bodies; i++) {
    var bi = bodies [i];
    var bix = bi.x, biy = bi.y, biz = bi.z, bimass = bi.mass;
    var bivx = bi.vx, bivy = bi.vy, bivz = bi.vz;

    for (j = i + 1; j < #bodies; j++) {
      var bj = bodies [j];
      var dx = bix - bj.x, dy = biy - bj.y, dz = biz - bj.z;
      var distance = sqrt (dx * dx + dy * dy + dz * dz);
      var mag = dt / (distance * distance * distance);
      var bim = bimass * mag, bjm = bj.mass * mag;
      
      bivx -= dx * bjm; bivy -= dy * bjm; bivz -= dz * bjm;
      bj.vx += dx * bim; bj.vy += dy * bim; bj.vz += dz * bim;
    }
    bi.vx = bivx; bi.vy = bivy; bi.vz = bivz;
  }
  for (i = 0; i < #bodies; i++) {
    var bi = bodies[i];

    bi.x += dt * bi.vx; bi.y += dt * bi.vy; bi.z += dt * bi.vz;
  }
}

func energy (bodies) {
  var i, j, e = 0.;

  for (i = 0; i < #bodies; i++) {
    var bi = bodies [i];
    var vx = bi.vx, vy = bi.vy, vz = bi.vz, bim = bi.mass;

    e = e + (0.5 * bim * (vx * vx + vy * vy + vz * vz));
    for (j = i + 1; j < #bodies; j++) {
      var bj = bodies [j];
      var dx = bi.x - bj.x, dy = bi.y - bj.y, dz = bi.z - bj.z;
      var distance = sqrt (dx * dx + dy * dy + dz * dz);

      e = e - ((bim * bj.mass) / distance);
    }
  }
  return e;
}

func offsetMomentum (b) {
  var i, px = 0., py = 0., pz = 0.;

  for (i = 0; i < #b; i++) {
    var bi = b [i];
    var bim = bi.mass;

    px = px + (bi.vx * bim);
    py = py + (bi.vy * bim);
    pz = pz + (bi.vz * bim);
  }
  b [0].vx = -px / SOLAR_MASS;
  b [0].vy = -py / SOLAR_MASS;
  b [0].vz = -pz / SOLAR_MASS;
}

var i, N = int (#argv < 1 ? 1000 : argv [0]);
var bodies = [Sun, Jupiter, Saturn, Uranus, Neptune];

offsetMomentum (bodies);
putf ("%0.9f\n", energy (bodies));
for (i = 0; i < N; i++) {advance (bodies, 0.01);}
putf ("%0.9f\n", energy (bodies));
TEST562
        echo '      ' $DINO $test_file 100000 "2>$stderr"
        if $DINO $test_file 100000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT562' && $CMP $stdout $ftemp2; then
-0.169075164
-0.169079859
OUTPUT562
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 563.
if test $result = ok -a $start_test_number -le 563; then
	echo test 563: Nsieve from Language Shootout
        cat >$test_file <<'TEST563'
func nsieve (m) {
  var i, k, flags = [m + 1 : 1], count = 0;
  
  for (i = 2; i <= m; i++)
    if (flags [i]) {
      for (k = i + i; k <= m; k += i)
	flags [k] = 0;
      count++;
    }
  return count;
}

var i, m, n = max (2, int (#argv < 1 ? 1 : argv [0]));

for (i = 0; i <= 2; i++) {
  m = (1 << (n - i)) * 10000; putf ("Primes up to %8d %8d\n", m, nsieve (m));
}
TEST563
        echo '      ' $DINO $test_file 8 "2>$stderr"
        if $DINO $test_file 8 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT563' && $CMP $stdout $ftemp2; then
Primes up to  2560000   187134
Primes up to  1280000    98610
Primes up to   640000    52074
OUTPUT563
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 564.
if test $result = ok -a $start_test_number -le 564; then
	echo test 564: Nsieve Bits from Language Shootout
        cat >$test_file <<'TEST564'
var power = 5, precision = 1 << power, mask = precision - 1;

func nsieve (m) {
  var i, k, cm = (m + precision) / precision, flags = [cm : ~0], count = 0;
  
  for (i = 2; i <= m; i++)
    if (flags [i >> power] & (1 << (i & mask))) {
      for (k = i + i; k <= m; k += i)
	flags [k >> power] &= ~(1 << (k & mask));
      count++;
    }
  return count;
}


var i, m, N = max (2, int (#argv < 1 ? 1 : argv [0]));

for (i = 0; i <= 2; i++) {
  m = (1 << (N - i)) * 10000;
  putf ("Primes up to %8d %8d\n", m, nsieve (m));
}
TEST564
        echo '      ' $DINO $test_file 8 "2>$stderr"
        if $DINO $test_file 8 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT564' && $CMP $stdout $ftemp2; then
Primes up to  2560000   187134
Primes up to  1280000    98610
Primes up to   640000    52074
OUTPUT564
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 565.
if test $result = ok -a $start_test_number -le 565; then
	echo test 565: Pidigits from Language Shootout
        cat >$test_file <<'TEST565'
include "gmp";

var k = 0, z = [mpzs.mpz (1), mpzs.mpz (0), mpzs.mpz (0), mpzs.mpz (1)];

func next_digit () {
  var y;

  for (;;) {
    y = extract_digit (3);
    if (y == extract_digit (4)) {
      z = compose ([mpzs.mpz (10), mpzs.mpz (-10 * y),
		    mpzs.mpz (0), mpzs.mpz (1)], z);
      return y;
    }
    z = compose (z, next_lft ());
  }
}

func next_lft () {
  k++;
  return [mpzs.mpz (k), mpzs.mpz (4 * k + 2),
	  mpzs.mpz (0), mpzs.mpz (2 * k + 1)];
}

func extract_digit (x) {
  var xx = mpzs.mpz (x);

  return mpzs.get_i (mpzs.div (mpzs.add (mpzs.mul (z [0], xx), z [1]),
			       mpzs.add (mpzs.mul (z [2], xx), z [3])));
}

func compose (z, w) {
  return [mpzs.add (mpzs.mul (z [0], w [0]), mpzs.mul (z [1], w [2])),
	  mpzs.add (mpzs.mul (z [0], w [1]), mpzs.mul (z [1], w [3])),
	  mpzs.add (mpzs.mul (z [2], w [0]), mpzs.mul (z [3], w [2])),
	  mpzs.add (mpzs.mul (z [2], w [1]), mpzs.mul (z [3], w [3]))];
}

// main loop

var i, j, n = int (argv [0]);

for(i = 1; i <= n; i++) {
  put (next_digit());
  if (i % 10 == 0) putln ("\t:", i);
}

if (n % 10 != 0) {
  for (j = n % 10; j <= 10; j++) put (" ");
  putln ("\t:", n);
}
TEST565
        echo '      ' $DINO -L./gmp.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 1000 "2>$stderr"
        if $DINO -L./gmp.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 1000 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT565' && $CMP $stdout $ftemp2; then
3141592653	:10
5897932384	:20
6264338327	:30
9502884197	:40
1693993751	:50
0582097494	:60
4592307816	:70
4062862089	:80
9862803482	:90
5342117067	:100
9821480865	:110
1328230664	:120
7093844609	:130
5505822317	:140
2535940812	:150
8481117450	:160
2841027019	:170
3852110555	:180
9644622948	:190
9549303819	:200
6442881097	:210
5665933446	:220
1284756482	:230
3378678316	:240
5271201909	:250
1456485669	:260
2346034861	:270
0454326648	:280
2133936072	:290
6024914127	:300
3724587006	:310
6063155881	:320
7488152092	:330
0962829254	:340
0917153643	:350
6789259036	:360
0011330530	:370
5488204665	:380
2138414695	:390
1941511609	:400
4330572703	:410
6575959195	:420
3092186117	:430
3819326117	:440
9310511854	:450
8074462379	:460
9627495673	:470
5188575272	:480
4891227938	:490
1830119491	:500
2983367336	:510
2440656643	:520
0860213949	:530
4639522473	:540
7190702179	:550
8609437027	:560
7053921717	:570
6293176752	:580
3846748184	:590
6766940513	:600
2000568127	:610
1452635608	:620
2778577134	:630
2757789609	:640
1736371787	:650
2146844090	:660
1224953430	:670
1465495853	:680
7105079227	:690
9689258923	:700
5420199561	:710
1212902196	:720
0864034418	:730
1598136297	:740
7477130996	:750
0518707211	:760
3499999983	:770
7297804995	:780
1059731732	:790
8160963185	:800
9502445945	:810
5346908302	:820
6425223082	:830
5334468503	:840
5261931188	:850
1710100031	:860
3783875288	:870
6587533208	:880
3814206171	:890
7766914730	:900
3598253490	:910
4287554687	:920
3115956286	:930
3882353787	:940
5937519577	:950
8185778053	:960
2171226806	:970
6130019278	:980
7661119590	:990
9216420198	:1000
OUTPUT565
                        result=ok
                else
                        result=fail
                fi
       elif fgrep 'run time error - can not find external function' $stderr >/dev/null;then
		echo GMP package is absent -- skip
                result=ok
        else
                result=fail
        fi
fi

# Test 567.
if test $result = ok -a $start_test_number -le 566; then
	echo test 566: Random from Language Shootout
        cat >$test_file <<'TEST567'
var c, i, vec, seq = getf (), ilen = #seq;

seq = gsub (">[^\n]+\n|\n", seq, "");

var clen = #seq;
var variants = ["agggtaaa|tttaccct", "[cgt]gggtaaa|tttaccc[acg]",
		"a[act]ggtaaa|tttacc[agt]t", "ag[act]gtaaa|tttac[agt]ct",
		"agg[act]taaa|ttta[agt]cct", "aggg[acg]aaa|ttt[cgt]ccct",
		"agggt[cgt]aa|tt[acg]accct", "agggta[cgt]a|t[acg]taccct",
		"agggtaa[cgt]|[acg]ttaccct"];

for (i = 0; i < #variants; i++) {
  vec = gmatch (variants [i], seq);
  putln (variants [i], " ", vec == nil ? 0 : #vec / 2);
}

var subst = {
  "B" : "(c|g|t)", "D" : "(a|g|t)", "H" : "(a|c|t)", "K" : "(g|t)",
  "M" : "(a|c)", "N" : "(a|c|g|t)", "R" : "(a|g)", "S" : "(c|g)",
  "V" : "(a|c|g)", "W" : "(a|t)", "Y" : "(c|t)"
};

for (c in subst)
  seq = gsub (c, seq, subst {c});

putln ("\n", ilen, "\n", clen, "\n", #seq);
TEST567
        echo '      ' $DINO $test_file 1000 "2>$stderr"
        if $DINO $test_file 1000 <<'INPUT567' 2>$stderr >$stdout; then
>ONE Homo sapiens alu
GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGA
TCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACT
AAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAG
GCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCG
CCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGT
GGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCA
GGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAA
TTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAG
AATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCA
GCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGT
AATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACC
AGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTG
GTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACC
CGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAG
AGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTT
TGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACA
TGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCT
GTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGG
TTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGT
CTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGG
CGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCG
TCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTA
CTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCG
AGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCG
GGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACC
TGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAA
TACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGA
GGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACT
GCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTC
ACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGT
TCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGC
CGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCG
CTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTG
GGCGACAGAGCGAGACTCCG
>TWO IUB ambiguity codes
cttBtatcatatgctaKggNcataaaSatgtaaaDcDRtBggDtctttataattcBgtcg
tactDtDagcctatttSVHtHttKtgtHMaSattgWaHKHttttagacatWatgtRgaaa
NtactMcSMtYtcMgRtacttctWBacgaaatatagScDtttgaagacacatagtVgYgt
cattHWtMMWcStgttaggKtSgaYaaccWStcgBttgcgaMttBYatcWtgacaYcaga
gtaBDtRacttttcWatMttDBcatWtatcttactaBgaYtcttgttttttttYaaScYa
HgtgttNtSatcMtcVaaaStccRcctDaataataStcYtRDSaMtDttgttSagtRRca
tttHatSttMtWgtcgtatSSagactYaaattcaMtWatttaSgYttaRgKaRtccactt
tattRggaMcDaWaWagttttgacatgttctacaaaRaatataataaMttcgDacgaSSt
acaStYRctVaNMtMgtaggcKatcttttattaaaaagVWaHKYagtttttatttaacct
tacgtVtcVaattVMBcttaMtttaStgacttagattWWacVtgWYagWVRctDattBYt
gtttaagaagattattgacVatMaacattVctgtBSgaVtgWWggaKHaatKWcBScSWa
accRVacacaaactaccScattRatatKVtactatatttHttaagtttSKtRtacaaagt
RDttcaaaaWgcacatWaDgtDKacgaacaattacaRNWaatHtttStgttattaaMtgt
tgDcgtMgcatBtgcttcgcgaDWgagctgcgaggggVtaaScNatttacttaatgacag
cccccacatYScaMgtaggtYaNgttctgaMaacNaMRaacaaacaKctacatagYWctg
ttWaaataaaataRattagHacacaagcgKatacBttRttaagtatttccgatctHSaat
actcNttMaagtattMtgRtgaMgcataatHcMtaBSaRattagttgatHtMttaaKagg
YtaaBataSaVatactWtataVWgKgttaaaacagtgcgRatatacatVtHRtVYataSa
KtWaStVcNKHKttactatccctcatgWHatWaRcttactaggatctataDtDHBttata
aaaHgtacVtagaYttYaKcctattcttcttaataNDaaggaaaDYgcggctaaWSctBa
aNtgctggMBaKctaMVKagBaactaWaDaMaccYVtNtaHtVWtKgRtcaaNtYaNacg
gtttNattgVtttctgtBaWgtaattcaagtcaVWtactNggattctttaYtaaagccgc
tcttagHVggaYtgtNcDaVagctctctKgacgtatagYcctRYHDtgBattDaaDgccK
tcHaaStttMcctagtattgcRgWBaVatHaaaataYtgtttagMDMRtaataaggatMt
ttctWgtNtgtgaaaaMaatatRtttMtDgHHtgtcattttcWattRSHcVagaagtacg
ggtaKVattKYagactNaatgtttgKMMgYNtcccgSKttctaStatatNVataYHgtNa
BKRgNacaactgatttcctttaNcgatttctctataScaHtataRagtcRVttacDSDtt
aRtSatacHgtSKacYagttMHtWataggatgactNtatSaNctataVtttRNKtgRacc
tttYtatgttactttttcctttaaacatacaHactMacacggtWataMtBVacRaSaatc
cgtaBVttccagccBcttaRKtgtgcctttttRtgtcagcRttKtaaacKtaaatctcac
aattgcaNtSBaaccgggttattaaBcKatDagttactcttcattVtttHaaggctKKga
tacatcBggScagtVcacattttgaHaDSgHatRMaHWggtatatRgccDttcgtatcga
aacaHtaagttaRatgaVacttagattVKtaaYttaaatcaNatccRttRRaMScNaaaD
gttVHWgtcHaaHgacVaWtgttScactaagSgttatcttagggDtaccagWattWtRtg
ttHWHacgattBtgVcaYatcggttgagKcWtKKcaVtgaYgWctgYggVctgtHgaNcV
taBtWaaYatcDRaaRtSctgaHaYRttagatMatgcatttNattaDttaattgttctaa
ccctcccctagaWBtttHtBccttagaVaatMcBHagaVcWcagBVttcBtaYMccagat
gaaaaHctctaacgttagNWRtcggattNatcRaNHttcagtKttttgWatWttcSaNgg
gaWtactKKMaacatKatacNattgctWtatctaVgagctatgtRaHtYcWcttagccaa
tYttWttaWSSttaHcaaaaagVacVgtaVaRMgattaVcDactttcHHggHRtgNcctt
tYatcatKgctcctctatVcaaaaKaaaagtatatctgMtWtaaaacaStttMtcgactt
taSatcgDataaactaaacaagtaaVctaggaSccaatMVtaaSKNVattttgHccatca
cBVctgcaVatVttRtactgtVcaattHgtaaattaaattttYtatattaaRSgYtgBag
aHSBDgtagcacRHtYcBgtcacttacactaYcgctWtattgSHtSatcataaatataHt
cgtYaaMNgBaatttaRgaMaatatttBtttaaaHHKaatctgatWatYaacttMctctt
ttVctagctDaaagtaVaKaKRtaacBgtatccaaccactHHaagaagaaggaNaaatBW
attccgStaMSaMatBttgcatgRSacgttVVtaaDMtcSgVatWcaSatcttttVatag
ttactttacgatcaccNtaDVgSRcgVcgtgaacgaNtaNatatagtHtMgtHcMtagaa
attBgtataRaaaacaYKgtRccYtatgaagtaataKgtaaMttgaaRVatgcagaKStc
tHNaaatctBBtcttaYaBWHgtVtgacagcaRcataWctcaBcYacYgatDgtDHccta
>THREE Homo sapiens frequency
aacacttcaccaggtatcgtgaaggctcaagattacccagagaacctttgcaatataaga
atatgtatgcagcattaccctaagtaattatattctttttctgactcaaagtgacaagcc
ctagtgtatattaaatcggtatatttgggaaattcctcaaactatcctaatcaggtagcc
atgaaagtgatcaaaaaagttcgtacttataccatacatgaattctggccaagtaaaaaa
tagattgcgcaaaattcgtaccttaagtctctcgccaagatattaggatcctattactca
tatcgtgtttttctttattgccgccatccccggagtatctcacccatccttctcttaaag
gcctaatattacctatgcaaataaacatatattgttgaaaattgagaacctgatcgtgat
tcttatgtgtaccatatgtatagtaatcacgcgactatatagtgctttagtatcgcccgt
gggtgagtgaatattctgggctagcgtgagatagtttcttgtcctaatatttttcagatc
gaatagcttctatttttgtgtttattgacatatgtcgaaactccttactcagtgaaagtc
atgaccagatccacgaacaatcttcggaatcagtctcgttttacggcggaatcttgagtc
taacttatatcccgtcgcttactttctaacaccccttatgtatttttaaaattacgttta
ttcgaacgtacttggcggaagcgttattttttgaagtaagttacattgggcagactcttg
acattttcgatacgactttctttcatccatcacaggactcgttcgtattgatatcagaag
ctcgtgatgattagttgtcttctttaccaatactttgaggcctattctgcgaaatttttg
ttgccctgcgaacttcacataccaaggaacacctcgcaacatgccttcatatccatcgtt
cattgtaattcttacacaatgaatcctaagtaattacatccctgcgtaaaagatggtagg
ggcactgaggatatattaccaagcatttagttatgagtaatcagcaatgtttcttgtatt
aagttctctaaaatagttacatcgtaatgttatctcgggttccgcgaataaacgagatag
attcattatatatggccctaagcaaaaacctcctcgtattctgttggtaattagaatcac
acaatacgggttgagatattaattatttgtagtacgaagagatataaaaagatgaacaat
tactcaagtcaagatgtatacgggatttataataaaaatcgggtagagatctgctttgca
attcagacgtgccactaaatcgtaatatgtcgcgttacatcagaaagggtaactattatt
aattaataaagggcttaatcactacatattagatcttatccgatagtcttatctattcgt
tgtatttttaagcggttctaattcagtcattatatcagtgctccgagttctttattattg
ttttaaggatgacaaaatgcctcttgttataacgctgggagaagcagactaagagtcgga
gcagttggtagaatgaggctgcaaaagacggtctcgacgaatggacagactttactaaac
caatgaaagacagaagtagagcaaagtctgaagtggtatcagcttaattatgacaaccct
taatacttccctttcgccgaatactggcgtggaaaggttttaaaagtcgaagtagttaga
ggcatctctcgctcataaataggtagactactcgcaatccaatgtgactatgtaatactg
ggaacatcagtccgcgatgcagcgtgtttatcaaccgtccccactcgcctggggagacat
gagaccacccccgtggggattattagtccgcagtaatcgactcttgacaatccttttcga
ttatgtcatagcaatttacgacagttcagcgaagtgactactcggcgaaatggtattact
aaagcattcgaacccacatgaatgtgattcttggcaatttctaatccactaaagcttttc
cgttgaatctggttgtagatatttatataagttcactaattaagatcacggtagtatatt
gatagtgatgtctttgcaagaggttggccgaggaatttacggattctctattgatacaat
ttgtctggcttataactcttaaggctgaaccaggcgtttttagacgacttgatcagctgt
tagaatggtttggactccctctttcatgtcagtaacatttcagccgttattgttacgata
tgcttgaacaatattgatctaccacacacccatagtatattttataggtcatgctgttac
ctacgagcatggtattccacttcccattcaatgagtattcaacatcactagcctcagaga
tgatgacccacctctaataacgtcacgttgcggccatgtgaaacctgaacttgagtagac
gatatcaagcgctttaaattgcatataacatttgagggtaaagctaagcggatgctttat
ataatcaatactcaataataagatttgattgcattttagagttatgacacgacatagttc
actaacgagttactattcccagatctagactgaagtactgatcgagacgatccttacgtc
gatgatcgttagttatcgacttaggtcgggtctctagcggtattggtacttaaccggaca
ctatactaataacccatgatcaaagcataacagaatacagacgataatttcgccaacata
tatgtacagaccccaagcatgagaagctcattgaaagctatcattgaagtcccgctcaca
atgtgtcttttccagacggtttaactggttcccgggagtcctggagtttcgacttacata
aatggaaacaatgtattttgctaatttatctatagcgtcatttggaccaatacagaatat
tatgttgcctagtaatccactataacccgcaagtgctgatagaaaatttttagacgattt
ataaatgccccaagtatccctcccgtgaatcctccgttatactaattagtattcgttcat
acgtataccgcgcatatatgaacatttggcgataaggcgcgtgaattgttacgtgacaga
gatagcagtttcttgtgatatggttaacagacgtacatgaagggaaactttatatctata
gtgatgcttccgtagaaataccgccactggtctgccaatgatgaagtatgtagctttagg
tttgtactatgaggctttcgtttgtttgcagagtataacagttgcgagtgaaaaaccgac
gaatttatactaatacgctttcactattggctacaaaatagggaagagtttcaatcatga
gagggagtatatggatgctttgtagctaaaggtagaacgtatgtatatgctgccgttcat
tcttgaaagatacataagcgataagttacgacaattataagcaacatccctaccttcgta
acgatttcactgttactgcgcttgaaatacactatggggctattggcggagagaagcaga
tcgcgccgagcatatacgagacctataatgttgatgatagagaaggcgtctgaattgata
catcgaagtacactttctttcgtagtatctctcgtcctctttctatctccggacacaaga
attaagttatatatatagagtcttaccaatcatgttgaatcctgattctcagagttcttt
ggcgggccttgtgatgactgagaaacaatgcaatattgctccaaatttcctaagcaaatt
ctcggttatgttatgttatcagcaaagcgttacgttatgttatttaaatctggaatgacg
gagcgaagttcttatgtcggtgtgggaataattcttttgaagacagcactccttaaataa
tatcgctccgtgtttgtatttatcgaatgggtctgtaaccttgcacaagcaaatcggtgg
tgtatatatcggataacaattaatacgatgttcatagtgacagtatactgatcgagtcct
ctaaagtcaattacctcacttaacaatctcattgatgttgtgtcattcccggtatcgccc
gtagtatgtgctctgattgaccgagtgtgaaccaaggaacatctactaatgcctttgtta
ggtaagatctctctgaattccttcgtgccaacttaaaacattatcaaaatttcttctact
tggattaactacttttacgagcatggcaaattcccctgtggaagacggttcattattatc
ggaaaccttatagaaattgcgtgttgactgaaattagatttttattgtaagagttgcatc
tttgcgattcctctggtctagcttccaatgaacagtcctcccttctattcgacatcgggt
ccttcgtacatgtctttgcgatgtaataattaggttcggagtgtggccttaatgggtgca
actaggaatacaacgcaaatttgctgacatgatagcaaatcggtatgccggcaccaaaac
gtgctccttgcttagcttgtgaatgagactcagtagttaaataaatccatatctgcaatc
gattccacaggtattgtccactatctttgaactactctaagagatacaagcttagctgag
accgaggtgtatatgactacgctgatatctgtaaggtaccaatgcaggcaaagtatgcga
gaagctaataccggctgtttccagctttataagattaaaatttggctgtcctggcggcct
cagaattgttctatcgtaatcagttggttcattaattagctaagtacgaggtacaactta
tctgtcccagaacagctccacaagtttttttacagccgaaacccctgtgtgaatcttaat
atccaagcgcgttatctgattagagtttacaactcagtattttatcagtacgttttgttt
ccaacattacccggtatgacaaaatgacgccacgtgtcgaataatggtctgaccaatgta
ggaagtgaaaagataaatat
INPUT567
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT567' && $CMP $stdout $ftemp2; then
agggtaaa|tttaccct 1
[cgt]gggtaaa|tttaccc[acg] 0
a[act]ggtaaa|tttacc[agt]t 0
ag[act]gtaaa|tttac[agt]ct 0
agg[act]taaa|ttta[agt]cct 1
aggg[acg]aaa|ttt[cgt]ccct 0
agggt[cgt]aa|tt[acg]accct 0
agggta[cgt]a|t[acg]taccct 0
agggtaa[cgt]|[acg]ttaccct 2

10245
10000
13348
OUTPUT567
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 568.
if test $result = ok -a $start_test_number -le 568; then
	echo test 568: Reverse Complement from Language Shootout
        cat >$test_file <<'TEST568'
var map =   "ACBDGHKMNSRUTWVYacbdghkmnsrutwvy";
var subst = "TGVHCDMKNSYAAWBRTGVHCDMKNSYAAWBR";
var line, seq = [];

func output_seq (seq) {
  var i;

  for (i = 0; i < #seq; i += 60) putln (subv (seq, i, 60));
}

try {
  for (;;) {
    line = getln ();
    if (line [0] != '>') insv (seq, line, -1);
    else {
      output_seq (trans (rev (seq), map, subst));
      del (seq, 0, -1); putln (line);
    }
  }
} catch (invcalls.eof) {}

output_seq (trans (rev (seq), map, subst));
TEST568
        echo '      ' $DINO $test_file 1000 "2>$stderr"
        if $DINO $test_file 1000 <<'INPUT568' 2>$stderr >$stdout; then
>ONE Homo sapiens alu
GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGA
TCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACT
AAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAG
GCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCG
CCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGT
GGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCA
GGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAA
TTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAG
AATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCA
GCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGT
AATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACC
AGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTG
GTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACC
CGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAG
AGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTT
TGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACA
TGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCT
GTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGG
TTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGT
CTCAAAAAGGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGG
CGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCG
TCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTA
CTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCG
AGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCG
GGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACC
TGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAA
TACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGA
GGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACT
GCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAGGCCGGGCGCGGTGGCTC
ACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGT
TCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGC
CGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCG
CTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTG
GGCGACAGAGCGAGACTCCG
>TWO IUB ambiguity codes
cttBtatcatatgctaKggNcataaaSatgtaaaDcDRtBggDtctttataattcBgtcg
tactDtDagcctatttSVHtHttKtgtHMaSattgWaHKHttttagacatWatgtRgaaa
NtactMcSMtYtcMgRtacttctWBacgaaatatagScDtttgaagacacatagtVgYgt
cattHWtMMWcStgttaggKtSgaYaaccWStcgBttgcgaMttBYatcWtgacaYcaga
gtaBDtRacttttcWatMttDBcatWtatcttactaBgaYtcttgttttttttYaaScYa
HgtgttNtSatcMtcVaaaStccRcctDaataataStcYtRDSaMtDttgttSagtRRca
tttHatSttMtWgtcgtatSSagactYaaattcaMtWatttaSgYttaRgKaRtccactt
tattRggaMcDaWaWagttttgacatgttctacaaaRaatataataaMttcgDacgaSSt
acaStYRctVaNMtMgtaggcKatcttttattaaaaagVWaHKYagtttttatttaacct
tacgtVtcVaattVMBcttaMtttaStgacttagattWWacVtgWYagWVRctDattBYt
gtttaagaagattattgacVatMaacattVctgtBSgaVtgWWggaKHaatKWcBScSWa
accRVacacaaactaccScattRatatKVtactatatttHttaagtttSKtRtacaaagt
RDttcaaaaWgcacatWaDgtDKacgaacaattacaRNWaatHtttStgttattaaMtgt
tgDcgtMgcatBtgcttcgcgaDWgagctgcgaggggVtaaScNatttacttaatgacag
cccccacatYScaMgtaggtYaNgttctgaMaacNaMRaacaaacaKctacatagYWctg
ttWaaataaaataRattagHacacaagcgKatacBttRttaagtatttccgatctHSaat
actcNttMaagtattMtgRtgaMgcataatHcMtaBSaRattagttgatHtMttaaKagg
YtaaBataSaVatactWtataVWgKgttaaaacagtgcgRatatacatVtHRtVYataSa
KtWaStVcNKHKttactatccctcatgWHatWaRcttactaggatctataDtDHBttata
aaaHgtacVtagaYttYaKcctattcttcttaataNDaaggaaaDYgcggctaaWSctBa
aNtgctggMBaKctaMVKagBaactaWaDaMaccYVtNtaHtVWtKgRtcaaNtYaNacg
gtttNattgVtttctgtBaWgtaattcaagtcaVWtactNggattctttaYtaaagccgc
tcttagHVggaYtgtNcDaVagctctctKgacgtatagYcctRYHDtgBattDaaDgccK
tcHaaStttMcctagtattgcRgWBaVatHaaaataYtgtttagMDMRtaataaggatMt
ttctWgtNtgtgaaaaMaatatRtttMtDgHHtgtcattttcWattRSHcVagaagtacg
ggtaKVattKYagactNaatgtttgKMMgYNtcccgSKttctaStatatNVataYHgtNa
BKRgNacaactgatttcctttaNcgatttctctataScaHtataRagtcRVttacDSDtt
aRtSatacHgtSKacYagttMHtWataggatgactNtatSaNctataVtttRNKtgRacc
tttYtatgttactttttcctttaaacatacaHactMacacggtWataMtBVacRaSaatc
cgtaBVttccagccBcttaRKtgtgcctttttRtgtcagcRttKtaaacKtaaatctcac
aattgcaNtSBaaccgggttattaaBcKatDagttactcttcattVtttHaaggctKKga
tacatcBggScagtVcacattttgaHaDSgHatRMaHWggtatatRgccDttcgtatcga
aacaHtaagttaRatgaVacttagattVKtaaYttaaatcaNatccRttRRaMScNaaaD
gttVHWgtcHaaHgacVaWtgttScactaagSgttatcttagggDtaccagWattWtRtg
ttHWHacgattBtgVcaYatcggttgagKcWtKKcaVtgaYgWctgYggVctgtHgaNcV
taBtWaaYatcDRaaRtSctgaHaYRttagatMatgcatttNattaDttaattgttctaa
ccctcccctagaWBtttHtBccttagaVaatMcBHagaVcWcagBVttcBtaYMccagat
gaaaaHctctaacgttagNWRtcggattNatcRaNHttcagtKttttgWatWttcSaNgg
gaWtactKKMaacatKatacNattgctWtatctaVgagctatgtRaHtYcWcttagccaa
tYttWttaWSSttaHcaaaaagVacVgtaVaRMgattaVcDactttcHHggHRtgNcctt
tYatcatKgctcctctatVcaaaaKaaaagtatatctgMtWtaaaacaStttMtcgactt
taSatcgDataaactaaacaagtaaVctaggaSccaatMVtaaSKNVattttgHccatca
cBVctgcaVatVttRtactgtVcaattHgtaaattaaattttYtatattaaRSgYtgBag
aHSBDgtagcacRHtYcBgtcacttacactaYcgctWtattgSHtSatcataaatataHt
cgtYaaMNgBaatttaRgaMaatatttBtttaaaHHKaatctgatWatYaacttMctctt
ttVctagctDaaagtaVaKaKRtaacBgtatccaaccactHHaagaagaaggaNaaatBW
attccgStaMSaMatBttgcatgRSacgttVVtaaDMtcSgVatWcaSatcttttVatag
ttactttacgatcaccNtaDVgSRcgVcgtgaacgaNtaNatatagtHtMgtHcMtagaa
attBgtataRaaaacaYKgtRccYtatgaagtaataKgtaaMttgaaRVatgcagaKStc
tHNaaatctBBtcttaYaBWHgtVtgacagcaRcataWctcaBcYacYgatDgtDHccta
>THREE Homo sapiens frequency
aacacttcaccaggtatcgtgaaggctcaagattacccagagaacctttgcaatataaga
atatgtatgcagcattaccctaagtaattatattctttttctgactcaaagtgacaagcc
ctagtgtatattaaatcggtatatttgggaaattcctcaaactatcctaatcaggtagcc
atgaaagtgatcaaaaaagttcgtacttataccatacatgaattctggccaagtaaaaaa
tagattgcgcaaaattcgtaccttaagtctctcgccaagatattaggatcctattactca
tatcgtgtttttctttattgccgccatccccggagtatctcacccatccttctcttaaag
gcctaatattacctatgcaaataaacatatattgttgaaaattgagaacctgatcgtgat
tcttatgtgtaccatatgtatagtaatcacgcgactatatagtgctttagtatcgcccgt
gggtgagtgaatattctgggctagcgtgagatagtttcttgtcctaatatttttcagatc
gaatagcttctatttttgtgtttattgacatatgtcgaaactccttactcagtgaaagtc
atgaccagatccacgaacaatcttcggaatcagtctcgttttacggcggaatcttgagtc
taacttatatcccgtcgcttactttctaacaccccttatgtatttttaaaattacgttta
ttcgaacgtacttggcggaagcgttattttttgaagtaagttacattgggcagactcttg
acattttcgatacgactttctttcatccatcacaggactcgttcgtattgatatcagaag
ctcgtgatgattagttgtcttctttaccaatactttgaggcctattctgcgaaatttttg
ttgccctgcgaacttcacataccaaggaacacctcgcaacatgccttcatatccatcgtt
cattgtaattcttacacaatgaatcctaagtaattacatccctgcgtaaaagatggtagg
ggcactgaggatatattaccaagcatttagttatgagtaatcagcaatgtttcttgtatt
aagttctctaaaatagttacatcgtaatgttatctcgggttccgcgaataaacgagatag
attcattatatatggccctaagcaaaaacctcctcgtattctgttggtaattagaatcac
acaatacgggttgagatattaattatttgtagtacgaagagatataaaaagatgaacaat
tactcaagtcaagatgtatacgggatttataataaaaatcgggtagagatctgctttgca
attcagacgtgccactaaatcgtaatatgtcgcgttacatcagaaagggtaactattatt
aattaataaagggcttaatcactacatattagatcttatccgatagtcttatctattcgt
tgtatttttaagcggttctaattcagtcattatatcagtgctccgagttctttattattg
ttttaaggatgacaaaatgcctcttgttataacgctgggagaagcagactaagagtcgga
gcagttggtagaatgaggctgcaaaagacggtctcgacgaatggacagactttactaaac
caatgaaagacagaagtagagcaaagtctgaagtggtatcagcttaattatgacaaccct
taatacttccctttcgccgaatactggcgtggaaaggttttaaaagtcgaagtagttaga
ggcatctctcgctcataaataggtagactactcgcaatccaatgtgactatgtaatactg
ggaacatcagtccgcgatgcagcgtgtttatcaaccgtccccactcgcctggggagacat
gagaccacccccgtggggattattagtccgcagtaatcgactcttgacaatccttttcga
ttatgtcatagcaatttacgacagttcagcgaagtgactactcggcgaaatggtattact
aaagcattcgaacccacatgaatgtgattcttggcaatttctaatccactaaagcttttc
cgttgaatctggttgtagatatttatataagttcactaattaagatcacggtagtatatt
gatagtgatgtctttgcaagaggttggccgaggaatttacggattctctattgatacaat
ttgtctggcttataactcttaaggctgaaccaggcgtttttagacgacttgatcagctgt
tagaatggtttggactccctctttcatgtcagtaacatttcagccgttattgttacgata
tgcttgaacaatattgatctaccacacacccatagtatattttataggtcatgctgttac
ctacgagcatggtattccacttcccattcaatgagtattcaacatcactagcctcagaga
tgatgacccacctctaataacgtcacgttgcggccatgtgaaacctgaacttgagtagac
gatatcaagcgctttaaattgcatataacatttgagggtaaagctaagcggatgctttat
ataatcaatactcaataataagatttgattgcattttagagttatgacacgacatagttc
actaacgagttactattcccagatctagactgaagtactgatcgagacgatccttacgtc
gatgatcgttagttatcgacttaggtcgggtctctagcggtattggtacttaaccggaca
ctatactaataacccatgatcaaagcataacagaatacagacgataatttcgccaacata
tatgtacagaccccaagcatgagaagctcattgaaagctatcattgaagtcccgctcaca
atgtgtcttttccagacggtttaactggttcccgggagtcctggagtttcgacttacata
aatggaaacaatgtattttgctaatttatctatagcgtcatttggaccaatacagaatat
tatgttgcctagtaatccactataacccgcaagtgctgatagaaaatttttagacgattt
ataaatgccccaagtatccctcccgtgaatcctccgttatactaattagtattcgttcat
acgtataccgcgcatatatgaacatttggcgataaggcgcgtgaattgttacgtgacaga
gatagcagtttcttgtgatatggttaacagacgtacatgaagggaaactttatatctata
gtgatgcttccgtagaaataccgccactggtctgccaatgatgaagtatgtagctttagg
tttgtactatgaggctttcgtttgtttgcagagtataacagttgcgagtgaaaaaccgac
gaatttatactaatacgctttcactattggctacaaaatagggaagagtttcaatcatga
gagggagtatatggatgctttgtagctaaaggtagaacgtatgtatatgctgccgttcat
tcttgaaagatacataagcgataagttacgacaattataagcaacatccctaccttcgta
acgatttcactgttactgcgcttgaaatacactatggggctattggcggagagaagcaga
tcgcgccgagcatatacgagacctataatgttgatgatagagaaggcgtctgaattgata
catcgaagtacactttctttcgtagtatctctcgtcctctttctatctccggacacaaga
attaagttatatatatagagtcttaccaatcatgttgaatcctgattctcagagttcttt
ggcgggccttgtgatgactgagaaacaatgcaatattgctccaaatttcctaagcaaatt
ctcggttatgttatgttatcagcaaagcgttacgttatgttatttaaatctggaatgacg
gagcgaagttcttatgtcggtgtgggaataattcttttgaagacagcactccttaaataa
tatcgctccgtgtttgtatttatcgaatgggtctgtaaccttgcacaagcaaatcggtgg
tgtatatatcggataacaattaatacgatgttcatagtgacagtatactgatcgagtcct
ctaaagtcaattacctcacttaacaatctcattgatgttgtgtcattcccggtatcgccc
gtagtatgtgctctgattgaccgagtgtgaaccaaggaacatctactaatgcctttgtta
ggtaagatctctctgaattccttcgtgccaacttaaaacattatcaaaatttcttctact
tggattaactacttttacgagcatggcaaattcccctgtggaagacggttcattattatc
ggaaaccttatagaaattgcgtgttgactgaaattagatttttattgtaagagttgcatc
tttgcgattcctctggtctagcttccaatgaacagtcctcccttctattcgacatcgggt
ccttcgtacatgtctttgcgatgtaataattaggttcggagtgtggccttaatgggtgca
actaggaatacaacgcaaatttgctgacatgatagcaaatcggtatgccggcaccaaaac
gtgctccttgcttagcttgtgaatgagactcagtagttaaataaatccatatctgcaatc
gattccacaggtattgtccactatctttgaactactctaagagatacaagcttagctgag
accgaggtgtatatgactacgctgatatctgtaaggtaccaatgcaggcaaagtatgcga
gaagctaataccggctgtttccagctttataagattaaaatttggctgtcctggcggcct
cagaattgttctatcgtaatcagttggttcattaattagctaagtacgaggtacaactta
tctgtcccagaacagctccacaagtttttttacagccgaaacccctgtgtgaatcttaat
atccaagcgcgttatctgattagagtttacaactcagtattttatcagtacgttttgttt
ccaacattacccggtatgacaaaatgacgccacgtgtcgaataatggtctgaccaatgta
ggaagtgaaaagataaatat
INPUT568
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT568' && $CMP $stdout $ftemp2; then
>ONE Homo sapiens alu
CGGAGTCTCGCTCTGTCGCCCAGGCTGGAGTGCAGTGGCGCGATCTCGGCTCACTGCAAC
CTCCGCCTCCCGGGTTCAAGCGATTCTCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACA
GGCGCGCGCCACCACGCCCGGCTAATTTTTGTATTTTTAGTAGAGACGGGGTTTCACCAT
GTTGGCCAGGCTGGTCTCGAACTCCTGACCTCAGGTGATCCGCCCGCCTCGGCCTCCCAA
AGTGCTGGGATTACAGGCGTGAGCCACCGCGCCCGGCCTTTTTGAGACGGAGTCTCGCTC
TGTCGCCCAGGCTGGAGTGCAGTGGCGCGATCTCGGCTCACTGCAACCTCCGCCTCCCGG
GTTCAAGCGATTCTCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACAGGCGCGCGCCACC
ACGCCCGGCTAATTTTTGTATTTTTAGTAGAGACGGGGTTTCACCATGTTGGCCAGGCTG
GTCTCGAACTCCTGACCTCAGGTGATCCGCCCGCCTCGGCCTCCCAAAGTGCTGGGATTA
CAGGCGTGAGCCACCGCGCCCGGCCTTTTTGAGACGGAGTCTCGCTCTGTCGCCCAGGCT
GGAGTGCAGTGGCGCGATCTCGGCTCACTGCAACCTCCGCCTCCCGGGTTCAAGCGATTC
TCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACAGGCGCGCGCCACCACGCCCGGCTAAT
TTTTGTATTTTTAGTAGAGACGGGGTTTCACCATGTTGGCCAGGCTGGTCTCGAACTCCT
GACCTCAGGTGATCCGCCCGCCTCGGCCTCCCAAAGTGCTGGGATTACAGGCGTGAGCCA
CCGCGCCCGGCCTTTTTGAGACGGAGTCTCGCTCTGTCGCCCAGGCTGGAGTGCAGTGGC
GCGATCTCGGCTCACTGCAACCTCCGCCTCCCGGGTTCAAGCGATTCTCCTGCCTCAGCC
TCCCGAGTAGCTGGGATTACAGGCGCGCGCCACCACGCCCGGCTAATTTTTGTATTTTTA
GTAGAGACGGGGTTTCACCATGTTGGCCAGGCTGGTCTCGAACTCCTGACCTCAGGTGAT
CCGCCCGCCTCGGCCTCCCAAAGTGCTGGGATTACAGGCGTGAGCCACCGCGCCCGGCCT
TTTTGAGACGGAGTCTCGCTCTGTCGCCCAGGCTGGAGTGCAGTGGCGCGATCTCGGCTC
ACTGCAACCTCCGCCTCCCGGGTTCAAGCGATTCTCCTGCCTCAGCCTCCCGAGTAGCTG
GGATTACAGGCGCGCGCCACCACGCCCGGCTAATTTTTGTATTTTTAGTAGAGACGGGGT
TTCACCATGTTGGCCAGGCTGGTCTCGAACTCCTGACCTCAGGTGATCCGCCCGCCTCGG
CCTCCCAAAGTGCTGGGATTACAGGCGTGAGCCACCGCGCCCGGCCTTTTTGAGACGGAG
TCTCGCTCTGTCGCCCAGGCTGGAGTGCAGTGGCGCGATCTCGGCTCACTGCAACCTCCG
CCTCCCGGGTTCAAGCGATTCTCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACAGGCGC
GCGCCACCACGCCCGGCTAATTTTTGTATTTTTAGTAGAGACGGGGTTTCACCATGTTGG
CCAGGCTGGTCTCGAACTCCTGACCTCAGGTGATCCGCCCGCCTCGGCCTCCCAAAGTGC
TGGGATTACAGGCGTGAGCCACCGCGCCCGGCCTTTTTGAGACGGAGTCTCGCTCTGTCG
CCCAGGCTGGAGTGCAGTGGCGCGATCTCGGCTCACTGCAACCTCCGCCTCCCGGGTTCA
AGCGATTCTCCTGCCTCAGCCTCCCGAGTAGCTGGGATTACAGGCGCGCGCCACCACGCC
CGGCTAATTTTTGTATTTTTAGTAGAGACGGGGTTTCACCATGTTGGCCAGGCTGGTCTC
GAACTCCTGACCTCAGGTGATCCGCCCGCCTCGGCCTCCCAAAGTGCTGGGATTACAGGC
GTGAGCCACCGCGCCCGGCC
>TWO IUB ambiguity codes
TAGGDHACHATCRGTRGVTGAGWTATGYTGCTGTCABACDWVTRTAAGAVVAGATTTNDA
GASMTCTGCATBYTTCAAKTTACMTATTACTTCATARGGYACMRTGTTTTYTATACVAAT
TTCTAKGDACKADACTATATNTANTCGTTCACGBCGYSCBHTANGGTGATCGTAAAGTAA
CTATBAAAAGATSTGWATBCSGAKHTTABBAACGTSYCATGCAAVATKTSKTASCGGAAT
WVATTTNTCCTTCTTCTTDDAGTGGTTGGATACVGTTAYMTMTBTACTTTHAGCTAGBAA
AAGAGKAAGTTRATWATCAGATTMDDTTTAAAVAAATATTKTCYTAAATTVCNKTTRACG
ADTATATTTATGATSADSCAATAWAGCGRTAGTGTAAGTGACVGRADYGTGCTACHVSDT
CTVCARCSYTTAATATARAAAATTTAATTTACDAATTGBACAGTAYAABATBTGCAGBVG
TGATGGDCAAAATBNMSTTABKATTGGSTCCTAGBTTACTTGTTTAGTTTATHCGATSTA
AAGTCGAKAAASTGTTTTAWAKCAGATATACTTTTMTTTTGBATAGAGGAGCMATGATRA
AAGGNCAYDCCDDGAAAGTHGBTAATCKYTBTACBGTBCTTTTTGDTAASSWTAAWAARA
TTGGCTAAGWGRADTYACATAGCTCBTAGATAWAGCAATNGTATMATGTTKMMAGTAWTC
CCNTSGAAWATWCAAAAMACTGAADNTYGATNAATCCGAYWNCTAACGTTAGAGDTTTTC
ATCTGGKRTAVGAABVCTGWGBTCTDVGKATTBTCTAAGGVADAAAVWTCTAGGGGAGGG
TTAGAACAATTAAHTAATNAAATGCATKATCTAAYRTDTCAGSAYTTYHGATRTTWAVTA
BGNTCDACAGBCCRCAGWCRTCABTGMMAWGMCTCAACCGATRTGBCAVAATCGTDWDAA
CAYAWAATWCTGGTAHCCCTAAGATAACSCTTAGTGSAACAWTBGTCDTTDGACWDBAAC
HTTTNGSKTYYAAYGGATNTGATTTAARTTAMBAATCTAAGTBTCATYTAACTTADTGTT
TCGATACGAAHGGCYATATACCWDTKYATDCSHTDTCAAAATGTGBACTGSCCVGATGTA
TCMMAGCCTTDAAABAATGAAGAGTAACTHATMGVTTAATAACCCGGTTVSANTGCAATT
GTGAGATTTAMGTTTAMAAYGCTGACAYAAAAAGGCACAMYTAAGVGGCTGGAABVTACG
GATTSTYGTBVAKTATWACCGTGTKAGTDTGTATGTTTAAAGGAAAAAGTAACATARAAA
GGTYCAMNYAAABTATAGNTSATANAGTCATCCTATWADKAACTRGTMSACDGTATSAYT
AAHSHGTAABYGACTYTATADTGSTATAGAGAAATCGNTAAAGGAAATCAGTTGTNCYMV
TNACDRTATBNATATASTAGAAMSCGGGANRCKKMCAAACATTNAGTCTRMAATBMTACC
CGTACTTCTBGDSYAATWGAAAATGACADDCHAKAAAYATATTKTTTTCACANACWAGAA
AKATCCTTATTAYKHKCTAAACARTATTTTDATBTVWCYGCAATACTAGGKAAASTTDGA
MGGCHTTHAATVCAHDRYAGGRCTATACGTCMAGAGAGCTBTHGNACARTCCBDCTAAGA
GCGGCTTTARTAAAGAATCCNAGTAWBTGACTTGAATTACWTVACAGAAABCAATNAAAC
CGTNTRANTTGAYCMAWBADTANABRGGTKTHTWTAGTTVCTMBKTAGMTVKCCAGCANT
TVAGSWTTAGCCGCRHTTTCCTTHNTATTAAGAAGAATAGGMTRAARTCTABGTACDTTT
TATAAVDHAHTATAGATCCTAGTAAGYTWATDWCATGAGGGATAGTAAMDMNGBASTWAM
TSTATRBAYDABATGTATATYCGCACTGTTTTAACMCWBTATAWAGTATBTSTATVTTAR
CCTMTTAAKADATCAACTAATYTSVTAKGDATTATGCKTCAYCAKAATACTTKAANGAGT
ATTSDAGATCGGAAATACTTAAYAAVGTATMCGCTTGTGTDCTAATYTATTTTATTTWAA
CAGWRCTATGTAGMTGTTTGTTYKTNGTTKTCAGAACNTRACCTACKTGSRATGTGGGGG
CTGTCATTAAGTAAATNGSTTABCCCCTCGCAGCTCWHTCGCGAAGCAVATGCKACGHCA
ACAKTTAATAACASAAADATTWNYTGTAATTGTTCGTMHACHTWATGTGCWTTTTGAAHY
ACTTTGTAYAMSAAACTTAADAAATATAGTABMATATYAATGSGGTAGTTTGTGTBYGGT
TWSGSVGWMATTDMTCCWWCABTCSVACAGBAATGTTKATBGTCAATAATCTTCTTAAAC
ARVAATHAGYBWCTRWCABGTWWAATCTAAGTCASTAAAKTAAGVKBAATTBGABACGTA
AGGTTAAATAAAAACTRMDTWBCTTTTTAATAAAAGATMGCCTACKAKNTBAGYRASTGT
ASSTCGTHCGAAKTTATTATATTYTTTGTAGAACATGTCAAAACTWTWTHGKTCCYAATA
AAGTGGAYTMCYTAARCSTAAATWAKTGAATTTRAGTCTSSATACGACWAKAASATDAAA
TGYYACTSAACAAHAKTSHYARGASTATTATTHAGGYGGASTTTBGAKGATSANAACACD
TRGSTTRAAAAAAAACAAGARTCVTAGTAAGATAWATGVHAAKATWGAAAAGTYAHVTAC
TCTGRTGTCAWGATRVAAKTCGCAAVCGASWGGTTRTCSAMCCTAACASGWKKAWDAATG
ACRCBACTATGTGTCTTCAAAHGSCTATATTTCGTVWAGAAGTAYCKGARAKSGKAGTAN
TTTCYACATWATGTCTAAAADMDTWCAATSTKDACAMAADADBSAAATAGGCTHAHAGTA
CGACVGAATTATAAAGAHCCVAYHGHTTTACATSTTTATGNCCMTAGCATATGATAVAAG
>THREE Homo sapiens frequency
ATATTTATCTTTTCACTTCCTACATTGGTCAGACCATTATTCGACACGTGGCGTCATTTT
GTCATACCGGGTAATGTTGGAAACAAAACGTACTGATAAAATACTGAGTTGTAAACTCTA
ATCAGATAACGCGCTTGGATATTAAGATTCACACAGGGGTTTCGGCTGTAAAAAAACTTG
TGGAGCTGTTCTGGGACAGATAAGTTGTACCTCGTACTTAGCTAATTAATGAACCAACTG
ATTACGATAGAACAATTCTGAGGCCGCCAGGACAGCCAAATTTTAATCTTATAAAGCTGG
AAACAGCCGGTATTAGCTTCTCGCATACTTTGCCTGCATTGGTACCTTACAGATATCAGC
GTAGTCATATACACCTCGGTCTCAGCTAAGCTTGTATCTCTTAGAGTAGTTCAAAGATAG
TGGACAATACCTGTGGAATCGATTGCAGATATGGATTTATTTAACTACTGAGTCTCATTC
ACAAGCTAAGCAAGGAGCACGTTTTGGTGCCGGCATACCGATTTGCTATCATGTCAGCAA
ATTTGCGTTGTATTCCTAGTTGCACCCATTAAGGCCACACTCCGAACCTAATTATTACAT
CGCAAAGACATGTACGAAGGACCCGATGTCGAATAGAAGGGAGGACTGTTCATTGGAAGC
TAGACCAGAGGAATCGCAAAGATGCAACTCTTACAATAAAAATCTAATTTCAGTCAACAC
GCAATTTCTATAAGGTTTCCGATAATAATGAACCGTCTTCCACAGGGGAATTTGCCATGC
TCGTAAAAGTAGTTAATCCAAGTAGAAGAAATTTTGATAATGTTTTAAGTTGGCACGAAG
GAATTCAGAGAGATCTTACCTAACAAAGGCATTAGTAGATGTTCCTTGGTTCACACTCGG
TCAATCAGAGCACATACTACGGGCGATACCGGGAATGACACAACATCAATGAGATTGTTA
AGTGAGGTAATTGACTTTAGAGGACTCGATCAGTATACTGTCACTATGAACATCGTATTA
ATTGTTATCCGATATATACACCACCGATTTGCTTGTGCAAGGTTACAGACCCATTCGATA
AATACAAACACGGAGCGATATTATTTAAGGAGTGCTGTCTTCAAAAGAATTATTCCCACA
CCGACATAAGAACTTCGCTCCGTCATTCCAGATTTAAATAACATAACGTAACGCTTTGCT
GATAACATAACATAACCGAGAATTTGCTTAGGAAATTTGGAGCAATATTGCATTGTTTCT
CAGTCATCACAAGGCCCGCCAAAGAACTCTGAGAATCAGGATTCAACATGATTGGTAAGA
CTCTATATATATAACTTAATTCTTGTGTCCGGAGATAGAAAGAGGACGAGAGATACTACG
AAAGAAAGTGTACTTCGATGTATCAATTCAGACGCCTTCTCTATCATCAACATTATAGGT
CTCGTATATGCTCGGCGCGATCTGCTTCTCTCCGCCAATAGCCCCATAGTGTATTTCAAG
CGCAGTAACAGTGAAATCGTTACGAAGGTAGGGATGTTGCTTATAATTGTCGTAACTTAT
CGCTTATGTATCTTTCAAGAATGAACGGCAGCATATACATACGTTCTACCTTTAGCTACA
AAGCATCCATATACTCCCTCTCATGATTGAAACTCTTCCCTATTTTGTAGCCAATAGTGA
AAGCGTATTAGTATAAATTCGTCGGTTTTTCACTCGCAACTGTTATACTCTGCAAACAAA
CGAAAGCCTCATAGTACAAACCTAAAGCTACATACTTCATCATTGGCAGACCAGTGGCGG
TATTTCTACGGAAGCATCACTATAGATATAAAGTTTCCCTTCATGTACGTCTGTTAACCA
TATCACAAGAAACTGCTATCTCTGTCACGTAACAATTCACGCGCCTTATCGCCAAATGTT
CATATATGCGCGGTATACGTATGAACGAATACTAATTAGTATAACGGAGGATTCACGGGA
GGGATACTTGGGGCATTTATAAATCGTCTAAAAATTTTCTATCAGCACTTGCGGGTTATA
GTGGATTACTAGGCAACATAATATTCTGTATTGGTCCAAATGACGCTATAGATAAATTAG
CAAAATACATTGTTTCCATTTATGTAAGTCGAAACTCCAGGACTCCCGGGAACCAGTTAA
ACCGTCTGGAAAAGACACATTGTGAGCGGGACTTCAATGATAGCTTTCAATGAGCTTCTC
ATGCTTGGGGTCTGTACATATATGTTGGCGAAATTATCGTCTGTATTCTGTTATGCTTTG
ATCATGGGTTATTAGTATAGTGTCCGGTTAAGTACCAATACCGCTAGAGACCCGACCTAA
GTCGATAACTAACGATCATCGACGTAAGGATCGTCTCGATCAGTACTTCAGTCTAGATCT
GGGAATAGTAACTCGTTAGTGAACTATGTCGTGTCATAACTCTAAAATGCAATCAAATCT
TATTATTGAGTATTGATTATATAAAGCATCCGCTTAGCTTTACCCTCAAATGTTATATGC
AATTTAAAGCGCTTGATATCGTCTACTCAAGTTCAGGTTTCACATGGCCGCAACGTGACG
TTATTAGAGGTGGGTCATCATCTCTGAGGCTAGTGATGTTGAATACTCATTGAATGGGAA
GTGGAATACCATGCTCGTAGGTAACAGCATGACCTATAAAATATACTATGGGTGTGTGGT
AGATCAATATTGTTCAAGCATATCGTAACAATAACGGCTGAAATGTTACTGACATGAAAG
AGGGAGTCCAAACCATTCTAACAGCTGATCAAGTCGTCTAAAAACGCCTGGTTCAGCCTT
AAGAGTTATAAGCCAGACAAATTGTATCAATAGAGAATCCGTAAATTCCTCGGCCAACCT
CTTGCAAAGACATCACTATCAATATACTACCGTGATCTTAATTAGTGAACTTATATAAAT
ATCTACAACCAGATTCAACGGAAAAGCTTTAGTGGATTAGAAATTGCCAAGAATCACATT
CATGTGGGTTCGAATGCTTTAGTAATACCATTTCGCCGAGTAGTCACTTCGCTGAACTGT
CGTAAATTGCTATGACATAATCGAAAAGGATTGTCAAGAGTCGATTACTGCGGACTAATA
ATCCCCACGGGGGTGGTCTCATGTCTCCCCAGGCGAGTGGGGACGGTTGATAAACACGCT
GCATCGCGGACTGATGTTCCCAGTATTACATAGTCACATTGGATTGCGAGTAGTCTACCT
ATTTATGAGCGAGAGATGCCTCTAACTACTTCGACTTTTAAAACCTTTCCACGCCAGTAT
TCGGCGAAAGGGAAGTATTAAGGGTTGTCATAATTAAGCTGATACCACTTCAGACTTTGC
TCTACTTCTGTCTTTCATTGGTTTAGTAAAGTCTGTCCATTCGTCGAGACCGTCTTTTGC
AGCCTCATTCTACCAACTGCTCCGACTCTTAGTCTGCTTCTCCCAGCGTTATAACAAGAG
GCATTTTGTCATCCTTAAAACAATAATAAAGAACTCGGAGCACTGATATAATGACTGAAT
TAGAACCGCTTAAAAATACAACGAATAGATAAGACTATCGGATAAGATCTAATATGTAGT
GATTAAGCCCTTTATTAATTAATAATAGTTACCCTTTCTGATGTAACGCGACATATTACG
ATTTAGTGGCACGTCTGAATTGCAAAGCAGATCTCTACCCGATTTTTATTATAAATCCCG
TATACATCTTGACTTGAGTAATTGTTCATCTTTTTATATCTCTTCGTACTACAAATAATT
AATATCTCAACCCGTATTGTGTGATTCTAATTACCAACAGAATACGAGGAGGTTTTTGCT
TAGGGCCATATATAATGAATCTATCTCGTTTATTCGCGGAACCCGAGATAACATTACGAT
GTAACTATTTTAGAGAACTTAATACAAGAAACATTGCTGATTACTCATAACTAAATGCTT
GGTAATATATCCTCAGTGCCCCTACCATCTTTTACGCAGGGATGTAATTACTTAGGATTC
ATTGTGTAAGAATTACAATGAACGATGGATATGAAGGCATGTTGCGAGGTGTTCCTTGGT
ATGTGAAGTTCGCAGGGCAACAAAAATTTCGCAGAATAGGCCTCAAAGTATTGGTAAAGA
AGACAACTAATCATCACGAGCTTCTGATATCAATACGAACGAGTCCTGTGATGGATGAAA
GAAAGTCGTATCGAAAATGTCAAGAGTCTGCCCAATGTAACTTACTTCAAAAAATAACGC
TTCCGCCAAGTACGTTCGAATAAACGTAATTTTAAAAATACATAAGGGGTGTTAGAAAGT
AAGCGACGGGATATAAGTTAGACTCAAGATTCCGCCGTAAAACGAGACTGATTCCGAAGA
TTGTTCGTGGATCTGGTCATGACTTTCACTGAGTAAGGAGTTTCGACATATGTCAATAAA
CACAAAAATAGAAGCTATTCGATCTGAAAAATATTAGGACAAGAAACTATCTCACGCTAG
CCCAGAATATTCACTCACCCACGGGCGATACTAAAGCACTATATAGTCGCGTGATTACTA
TACATATGGTACACATAAGAATCACGATCAGGTTCTCAATTTTCAACAATATATGTTTAT
TTGCATAGGTAATATTAGGCCTTTAAGAGAAGGATGGGTGAGATACTCCGGGGATGGCGG
CAATAAAGAAAAACACGATATGAGTAATAGGATCCTAATATCTTGGCGAGAGACTTAAGG
TACGAATTTTGCGCAATCTATTTTTTACTTGGCCAGAATTCATGTATGGTATAAGTACGA
ACTTTTTTGATCACTTTCATGGCTACCTGATTAGGATAGTTTGAGGAATTTCCCAAATAT
ACCGATTTAATATACACTAGGGCTTGTCACTTTGAGTCAGAAAAAGAATATAATTACTTA
GGGTAATGCTGCATACATATTCTTATATTGCAAAGGTTCTCTGGGTAATCTTGAGCCTTC
ACGATACCTGGTGAAGTGTT
OUTPUT568
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 569.
if test $result = ok -a $start_test_number -le 569; then
	echo test 569: Spectral Norm from Language Shootout
        cat >$test_file <<'TEST569'
func A (i, j) { return 1.0 / ((i + j) * (i + j + 1) / 2 + i + 1); }

func Av (n, v) {
   var i, j, Av = [n : 0.0];

   for (i = 0; i < n; i++)
      for (j = 0; j < n; j++) Av [i] += A (i, j) * v [j];
   return Av;
}

func Atv (n, v) {
   var i, j, Atv = [n : 0.0];

   for (i = 0; i < n; i++)
     for (j = 0; j < n; j++) Atv [i] += A (j, i) * v [j];
   return Atv;
}

func AtAv (n, v) {return Atv (n, Av (n, v));}

var n = int (#argv < 1 ? 100 : argv [0]);
var i, u = [n : 1.0], v = [n : 0.0], vBv = 0.0, vv = 0.0;

for (i = 0; i < 10; i++) { v = AtAv (n, u); u = AtAv (n, v); }
for (i = 0; i < n; i++) { vBv += u [i] * v [i]; vv += v [i] * v [i]; }

putf ("%0.9f\n", sqrt (vBv / vv));
TEST569
        echo '      ' $DINO $test_file 200 "2>$stderr"
        if $DINO $test_file 200 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT569' && $CMP $stdout $ftemp2; then
1.274223601
OUTPUT569
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 570.
if test $result = ok -a $start_test_number -le 570; then
	echo test 570: Sum file Language Shootout
        cat >$test_file <<'TEST570'
var sum = 0;
try {
  for (;;) sum += int (getln ());
} catch (invcalls.eof) {}

putln (sum);
TEST570
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file  <<'INPUT570' 2>$stderr >$stdout; then
276
498
-981
770
-401
702
966
950
-853
-53
-293
604
288
892
-697
204
96
408
880
-7
-817
422
-261
-485
-77
826
184
864
-751
626
812
-369
-353
-371
488
-83
-659
24
524
-21
840
-757
-17
-973
-843
260
858
-389
-521
-99
482
-561
-213
630
766
932
112
-419
-877
762
266
-837
170
834
746
764
922
-89
576
-63
90
684
316
506
-959
708
70
252
-747
342
-593
-895
-937
-707
350
588
-201
-683
-113
-511
-867
322
202
472
150
-9
-643
28
336
86
-925
836
-473
-451
-971
-805
-619
84
-67
806
270
366
334
-555
-557
-331
-409
-553
-145
-71
528
490
492
828
628
-961
536
-859
-271
974
-671
-749
414
-257
778
56
598
-437
-899
-785
-987
32
-999
132
-821
-209
402
-543
194
-967
294
-943
-285
-483
-97
660
-481
-829
-309
-597
-855
80
-355
192
-823
436
916
282
-629
612
-329
-535
780
-47
706
110
756
-857
-933
-345
-523
718
-31
902
678
540
698
456
-399
126
412
-563
-321
-487
-641
-195
-199
-955
772
INPUT570
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT570' && $CMP $stdout $ftemp2; then
-4818
OUTPUT570
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 571.
if test $result = ok -a $start_test_number -le 571; then
	echo test 571: Takfp Language Shootout
        cat >$test_file <<'TEST571'
func Tak (x, y, z) {
  if (y >= x) return z;
  return Tak (Tak (x - 1.0, y, z), Tak (y - 1.0, z, x), Tak (z -1.0, x, y));
}

var n = int (#argv < 1 ? 1 : argv [0]);
putf ("%.1f\n", Tak (n * 3.0, n * 2.0, n * 1.0));
TEST571
        echo '      ' $DINO $test_file 9 "2>$stderr"
        if $DINO $test_file 9 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT571' && $CMP $stdout $ftemp2; then
18.0
OUTPUT571
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 572.
if test $result = ok -a $start_test_number -le 572; then
	echo test 572: Swap statement.
        cat >$test_file <<'TEST572'
var a = 1, b = 2;

putln (a, " ", b);
a<=>b;
putln (a, " ", b);

var ar = [1, 2, 3];
println (ar);
ar[0]<=>ar[2];
println (ar);

class s (i) {}
var c1 = s (0), c2 = s (3);
putln (c1.i, ' ', c2.i);
c1.i<=>c2.i;
putln (c1.i, ' ', c2.i);

var t = {"s" : 1, "t" : 2};
putln (t{"s"}, ' ', t{"t"});
t{"s"}<=>t{"t"};
putln (t{"s"}, ' ', t{"t"});
TEST572
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT572' && $CMP $stdout $ftemp2; then
1 2
2 1
[1, 2, 3]
[3, 2, 1]
0 3
3 0
1 2
2 1
OUTPUT572
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 573.
if test $result = ok -a $start_test_number -le 573; then
	echo test 573: Health from Language Shootout.
        cat >$test_file <<'TEST573'
class queue () {
  class node (item, next) {}
  var first = nil, last = nil;

  func Add (o) {
    var a = node (o, nil);

    if (first == nil) first = a; else last.next = a;
    last = a;
  }
  
  func Remove (o) {
    var c, p = nil;

    for (c = first; c != nil && c.item !== o; c = c.next) p = c;
    if (c == nil) return;
    if (p == nil) first = first.next; else p.next = c.next;
    if (last === c) last = p;
  }

  func Clear() { first = nil; last = nil; }
}

class Patient (remainingTime = 0, hospitalTime = 0, hospitalVisits = 0) {}

var final LEVELS = 5, final DISTRICTS = 4;

class HealthcareRegion (level, s) {
  var districts = [DISTRICTS : nil];
  var localHospital = Hospital (level == LEVELS, level, s);

  func TransferPatients () {
    var i, n;
    
    for (i = #districts - 1; i >= 0; i--)
      if (districts [i] != nil)
	for (n = districts [i].TransferPatients().first; n != nil; n = n.next)
	  localHospital.NewArrival(n.item);

    localHospital.TriageExaminationTreatment ();
    return localHospital.transfers;
  }

  func AccumulateTotals () {
    var i, t = Totals ();

    for (i = #districts - 1; i >= 0; i--)
      if (districts [i] != nil)
	t.PlusTotal (districts [i].AccumulateTotals ());
    
    localHospital.AccumulateTotals (t);
    return t;
  }

  func TreatmentQueue () { return localHospital.treatment; }
}

func CreateRegion (level, seed1, seed2) {
  var i, r = nil;
  
  if(level > 0) {
    r = HealthcareRegion (level, seed1 * seed2);
    for(i = #r.districts - 1; i >= 0; i--)
      r.districts [i] = CreateRegion (level - 1, seed1 * 4 + i + 1, seed2);
  }
  return r;
}

class Hospital (hasNoRegionalHospital, level, seed) {
  var availableStaff = 1 << (level - 1);
  var triage = queue (), examination = queue ();
  var treatment = queue (), transfers = queue ();
  var discharged = Totals ();

  func TriageExaminationTreatment () {
    DischargePatients ();
    TreatOrTransferPatients ();
    TriagePatients ();
    
    if (genRandom (1.0) > 0.7) NewArrival (Patient ());
  }
  
  func AccumulateTotals (t) {
    var n;
    
    for (n = triage.first; n != nil; n = n.next) t.PlusPatient (n.item);
    for (n = examination.first; n != nil; n = n.next) t.PlusPatient (n.item);
    for (n = treatment.first; n != nil; n = n.next) t.PlusPatient (n.item);
    t.PlusTotal (discharged);
  }
  
  func NewArrival (p) {
    p.hospitalVisits++;
    if (availableStaff == 0) triage.Add (p);
    else {
      availableStaff--;
      p.remainingTime = 3;
      p.hospitalTime += 3;
      examination.Add (p);
    }
  }
  
  func DischargePatients () {
    var n, p;
    
    for (n = treatment.first; n != nil; n = n.next) {
      p = n.item; p.remainingTime--;
      if (p.remainingTime == 0) {
	availableStaff++;
	treatment.Remove (p);
	discharged.PlusPatient (p);
      }
    }
  }

  func TreatOrTransferPatients () {
    var p, n;

    transfers.Clear ();
    for (n = examination.first; n != nil; n = n.next) {
      p = n.item; p.remainingTime--;
      if (p.remainingTime == 0) { // no transfer
	if (genRandom (1.0) > 0.1 || hasNoRegionalHospital) {
	  treatment.Add(p);
	  p.remainingTime = 10;
	  p.hospitalTime += 10;
	} else { // transfer
	  availableStaff++;
	  transfers.Add (p);
	}
	examination.Remove(p);
      }
    }
  }

  func TriagePatients () {
    var p, n;

    for (n = triage.first; n != nil; n = n.next) {
      p = n.item;
      if (availableStaff == 0) p.hospitalTime++;
      else {
	availableStaff--;
	p.remainingTime = 3;
	p.hospitalTime += 3;
	examination.Add (p);
	triage.Remove (p);
      }
    }
  }

  var final IM = 139968, final IA = 3877, final IC = 29573;

  func genRandom (max) {
    seed = (seed * IA + IC) % IM;
    return max * seed / IM ;
  }
}

class Totals () {
  var patients = 0, hospitalTime = 0, hospitalVisits = 0;

  func PlusTotal (t) {
    patients += t.patients;
    hospitalTime += t.hospitalTime;
    hospitalVisits += t.hospitalVisits;
  }

   func PlusPatient (p) {
     patients++;
     hospitalTime += p.hospitalTime;
     hospitalVisits += p.hospitalVisits;
   }
}

var N = int (#argv < 1 ? 100 : argv [0]);
var i, healthcareSystem = CreateRegion (LEVELS, 0, 42), t, n;

for (i = 0; i < N; i++)
  healthcareSystem.TransferPatients ();

t = healthcareSystem.AccumulateTotals ();

putln ("Patients: ", t.patients);
putln ("Time:     ", t.hospitalTime);
putln ("Visits:   ", t.hospitalVisits);

putln ("\nTreatment Queue - Remaining Treatment Time");
for (n = healthcareSystem.TreatmentQueue ().first; n != nil; n = n.next)
  putln (n.item.remainingTime, "\tanonymous patient");
TEST573
        echo '      ' $DINO $test_file 100 "2>$stderr"
        if $DINO $test_file 100 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT573' && $CMP $stdout $ftemp2; then
Patients: 10151
Time:     363815
Visits:   10526

Treatment Queue - Remaining Treatment Time
1	anonymous patient
3	anonymous patient
9	anonymous patient
10	anonymous patient
OUTPUT573
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 574.
if test $result = ok -a $start_test_number -le 574; then
	echo test 574: Sync-statement
        cat >$test_file <<'TEST574'
var f = 1;
thread t () {
  wait (1) {
    var i;

    f = 0;
    for (i = 0; i < 1000000; i++)
      if (i % 100000 == 0) putln (i);
  }
}

t ();
wait (! f);
putln ("it should be the last message");
TEST574
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT574' && $CMP $stdout $ftemp2; then
0
100000
200000
300000
400000
500000
600000
700000
800000
900000
it should be the last message
OUTPUT574
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 575.
if test $result = ok -a $start_test_number -le 575; then
	echo test 575: Wait in sync-statement
        cat >$test_file <<'TEST575'
var flag = 0;

thread f () {
  wait (1) {
    wait (flag);
    flag = 0;
  }
}

f ();
flag = 1;
wait (! flag);
putln ("it can not be printed");
TEST575
        echo '      ' "echo abcd|$DINO $test_file 2>$stderr"
        if echo abcd|$DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT575' && $CMP $stderr $ftemp2; then
test.d:5:8: wait in sync-statement
OUTPUT575
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 576.
if test $result = ok -a $start_test_number -le 576; then
	echo test 576: Catching wait in sync-statement
        cat >$test_file <<'TEST576'
var flag = 0;

thread f () {
  try {
    wait (1) wait (flag);
  } catch (errors.syncwait) {
    putln ("got the exception");
    flag = 0;
  }
}

f ();
flag = 1;
wait (! flag);
putln ("continue");
TEST576
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT576' && $CMP $stdout $ftemp2; then
got the exception
continue
OUTPUT576
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 577.
if test $result = ok -a $start_test_number -le 577; then
	echo test 577: Thread call in sync-statement
        cat >$test_file <<'TEST577'
var flag = 0;

thread f () {
}

wait (1) f ();
putln ("it can not be printed");
TEST577
        echo '      ' "$DINO $test_file 2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT577' && $CMP $stderr $ftemp2; then
test.d:6:12: thread call in sync-statement
OUTPUT577
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 578.
if test $result = ok -a $start_test_number -le 578; then
	echo test 578: Catching thread call in sync-statement
        cat >$test_file <<'TEST578'
var flag = 0;

thread f () {
}

try {
  wait (1) f ();
} catch (invcalls.syncthreadcall) {
  putln ("got the exception");
}

putln ("continue");
TEST578
        echo '      ' $DINO $test_file "2>$stderr"
        if $DINO $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT578' && $CMP $stdout $ftemp2; then
got the exception
continue
OUTPUT578
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 579.
if test $result = ok -a $start_test_number -le 579; then
	echo test 579: gmp package
        cat >$test_file <<'TEST579'
include "gmp";

var gmp1 = mpzs.mpz(5);
var gmp2 = mpzs.mpz(10);
var gmp3 = mpzs.mpz(0);

putln (mpzs.get_i (gmp1));
putln (mpzs.get_f (gmp2));
mpzs.set_str(gmp1, "10000000000000000000000000000000000000000000000");
mpzs.set_str(gmp2, "5000000000000000000000000000000000000000000000");
putln (mpzs.get_str (mpzs.add (gmp1, gmp2), 10));
putln (mpzs.get_str (mpzs.sub (gmp1, gmp2), 10));
putln (mpzs.get_str (mpzs.neg (gmp1), 10));
putln (mpzs.get_str (mpzs.abs (mpzs.neg (gmp1)), 10));
putln (mpzs.get_str (mpzs.mul (gmp1, gmp2), 10));
putln (mpzs.get_str (mpzs.div (gmp1, gmp2), 10));
putln (mpzs.get_str (mpzs.mod (gmp1, gmp2), 10));
putln (mpzs.get_str (mpzs.mod (gmp2, gmp1), 10));
putln (mpzs.get_str (mpzs.pow_ui (gmp2, 2), 10));
putln (mpzs.get_str (mpzs.root (gmp1, 2), 10));
putln (mpzs.cmp (gmp1, gmp2));
putln (mpzs.cmp (gmp2, gmp1));
putln (mpzs.get_str (gmp1, 8));
putln (mpzs.get_str (gmp2, 8));
putln (mpzs.get_str (mpzs.ior (gmp1, gmp2), 8));
putln (mpzs.get_str (mpzs.xor (gmp1, gmp2), 8));
putln (mpzs.get_str (mpzs.and (gmp1, gmp2), 8));
putln (mpzs.get_str (mpzs.com (gmp1), 10));
// putln (mpzs.get_str (mpzs.rand (gmp1, 1), 10));
// putln (mpzs.get_str (mpzs.rand (gmp1, 0), 10));
// putln (mpzs.get_str (mpzs.rand (gmp1, 0), 10));

mpzs.set_bit (gmp1, 10);
putln (mpzs.get_str (gmp1, 10));
putln (mpzs.tst_bit (gmp1, 10));
mpzs.clr_bit (gmp1, 10);
putln (mpzs.get_str (gmp1, 10));
TEST579
        if uname | fgrep CYGWIN; then
            echo '      ' $DINO -L./gmp.dll -I@srcdir@ $test_file "2>$stderr"
	    if $DINO -Lgmp.dll -I@srcdir@ $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT579' && $CMP $stdout $ftemp2; then
5
10
15000000000000000000000000000000000000000000000
5000000000000000000000000000000000000000000000
-10000000000000000000000000000000000000000000000
10000000000000000000000000000000000000000000000
50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
2
0
5000000000000000000000000000000000000000000000
25000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
100000000000000000000000
1
-1
0700324573052063614067325026200675322000000000000000
0340152275425031706033552413100336551000000000000000
0740376777477073716077777437300777773000000000000000
0440276706477052112054677435300543673000000000000000
0300100071000021604023100002000234100000000000000000
-10000000000000000000000000000000000000000000001
10000000000000000000000000000000000000000001024
1
10000000000000000000000000000000000000000000000
OUTPUT579
                        result=ok
                else
                        result=fail
                fi
	    else
                result=fail
	    fi
	else
            echo '      ' $DINO -L./gmp.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file "2>$stderr"
	    if $DINO -L./gmp.@EXTERN_LIB_SUFFIX@ -I@srcdir@ $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT579' && $CMP $stdout $ftemp2; then
5
10
15000000000000000000000000000000000000000000000
5000000000000000000000000000000000000000000000
-10000000000000000000000000000000000000000000000
10000000000000000000000000000000000000000000000
50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
2
0
5000000000000000000000000000000000000000000000
25000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
100000000000000000000000
1
-1
0700324573052063614067325026200675322000000000000000
0340152275425031706033552413100336551000000000000000
0740376777477073716077777437300777773000000000000000
0440276706477052112054677435300543673000000000000000
0300100071000021604023100002000234100000000000000000
-10000000000000000000000000000000000000000000001
10000000000000000000000000000000000000000001024
1
10000000000000000000000000000000000000000000000
OUTPUT579
                        result=ok
                else
                        result=fail
                fi
	    elif fgrep 'run time error - can not find external function' $stderr >/dev/null;then
		echo GMP package is absent -- skip
                result=ok
	    else
                result=fail
	    fi
        fi
fi

# Test 580.
if test $result = ok -a $start_test_number -le 580; then
	echo test 580: exit tracing
        cat >$test_file <<'TEST580'
func a () {
  exit (0);
}
func b () {
  a ();
}
func c (i) {
  if (i == 0) b (); else c (i - 1);
}
class d () {
  c (5);
}
d ();
TEST580
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stderr $ftemp2
                if cat >$ftemp2 <<'OUTPUT580' && $CMP $stderr $ftemp2; then
test.d:5:6:calling a
test.d:8:18:calling b
test.d:8:29:calling c
test.d:8:29:calling c
test.d:8:29:calling c
test.d:8:29:calling c
test.d:8:29:calling c
test.d:11:6:calling c
test.d:13:4:calling d
OUTPUT580
                        result=ok
                else
                        result=fail
                fi
	else
                result=fail
        fi
fi

# Test 581.
if test $result = ok -a $start_test_number -le 581; then
	echo test 581: exception tracing
        cat >$test_file <<'TEST581'
func a () {
  throw except ();
}
func b () {
  a ();
}
func c (i) {
  if (i == 0) b (); else c (i - 1);
}
class d () {
  c (5);
}
d ();
TEST581
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                result=fail
        else
                echo '      ' $CMP - $stderr
                if cat >$ftemp2 <<'OUTPUT581' && $CMP $stderr $ftemp2; then
test.d:2:7: run time error - exception except has not been processed
test.d:5:6:calling a
test.d:8:18:calling b
test.d:8:29:calling c
test.d:8:29:calling c
test.d:8:29:calling c
test.d:8:29:calling c
test.d:8:29:calling c
test.d:11:6:calling c
test.d:13:4:calling d
OUTPUT581
                        result=ok
                else
                        result=fail
                fi
        fi
fi

# Test 582.
if test $result = ok -a $start_test_number -le 582; then
	echo test 582: catched exception tracing
        cat >$test_file <<'TEST582'
func a () {
  var i = 0;
  i[10]=0;
}
func b () {
  a ();
}
func c (i) {
  if (i == 0) b (); else c (i - 1);
}
class d () {
  c (5);
}
var i;
for (i = 0; i < 10; i++) 
  try {
    d ();
  } catch (except().error) {
    putln ("got it: ", e.msg);
  }
TEST582
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT582' && $CMP $stdout $ftemp2; then
got it: run time error - index operation for non array
got it: run time error - index operation for non array
got it: run time error - index operation for non array
got it: run time error - index operation for non array
got it: run time error - index operation for non array
got it: run time error - index operation for non array
got it: run time error - index operation for non array
got it: run time error - index operation for non array
got it: run time error - index operation for non array
got it: run time error - index operation for non array
OUTPUT582
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Test 583.
if test $result = ok -a $start_test_number -le 583; then
	echo test 583: normal exit tracing
        cat >$test_file <<'TEST583'
var i;
for (i =0; i < 10; i++);
TEST583
        echo '      ' $DINO -t $test_file "2>$stderr"
        if $DINO -t $test_file 2>$stderr >$stdout; then
                echo '      ' $CMP $stdout $ftemp2
                if cat >$ftemp2 <<'OUTPUT583' && $CMP $stdout $ftemp2; then
OUTPUT583
                        result=ok
                else
                        result=fail
                fi
        else
                result=fail
        fi
fi

# Final message

if test $result = ok; then
        echo $script_file: it is all ok
        rm -f $test_file $test_file_1 $stderr a.out $stdout $ftemp $ftemp2
	rm -rf $tempdir
        exit 0
else
        echo '***' $script_file:test is failed
        echo '   '  see files $test_file, $stdout, $test_file_1, $stderr, $ftemp, $ftemp2, $tempdir
        exit 1
fi
