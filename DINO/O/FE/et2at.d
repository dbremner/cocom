// This code provides translation of abtract tree generated by Earley's
// parser to abstract trees needed for checking program semantics (context).

include "comm";
include "atree";
include "table";
include "error";

var where = nil, final in_expr = 0, final in_type = 1, final in_other = 2;

func nil2vec (vec) { return (vec == nil ? [] : vec); }
func tr (t, i, where_par) { return et2at_where (t.transl [i], where_par); }
func vtr (t, i, where_par) { return nil2vec (tr (t, i, where_par)); }

func nothing (t) { return nil;}

func tr_term (t) {
  var l = t.transl.lex, n = node (l.fname, l.lno, l.pos);

  if (inside (l, lexs.integer)) return n.expr ().number (l);
  else if (inside (l, lexs.floating)) return n.expr ().number (l);
  else if (inside (l, lexs.ch)) return n.expr ().chr (l);
  else if (inside (l, lexs.str)) return n.expr ().str (l);
  else if (!inside (l, lexs.ident))
    diags.error (l.fname, l.lno, l.pos,	"internal error: should be an ident");
  else if (where == in_expr) return n.expr ().des ().qualid (nil, l);
  else if (where == in_type) return n.tdef ().qualid (nil, l);
  else if (where == in_other) return l; // ident itself
  else diags.fatal (l.fname, l.lno, l.pos, "internal error: bad `where'");
}

class exported (ident) {} // used temporary for translation of exported ident.

func tr_exportid (t) { return exported (tr (t, 0, in_other)); }

func gen_pos_node (n) { return node (n.fname, n.lno, n.pos);}
func gen_node (t) { return gen_pos_node (t.transl [0].transl.lex);}
func gen_expr (t) { return gen_node (t).expr ();}

func gen_op2 (t) { return gen_expr (t).op2 (tr (t, 1), tr (t, 2)); }
func tr_eq (t) { return gen_op2 (t).eq (); }
func tr_ne (t) { return gen_op2 (t).ne (); }
func tr_lt (t) { return gen_op2 (t).lt (); }
func tr_le (t) { return gen_op2 (t).le (); }
func tr_gt (t) { return gen_op2 (t).gt (); }
func tr_ge (t) { return gen_op2 (t).ge (); }
func tr_in (t) { return gen_op2 (t).set_in (); }
func tr_is (t) {return gen_expr (t).op2 (tr (t, 1), tr (t, 2, in_type)).is ();}
func tr_plus (t) { return gen_op2 (t).plus (); }
func tr_minus (t) { return gen_op2 (t).minus (); }
func tr_or (t) { return gen_op2 (t).or (); }
func tr_and (t) { return gen_op2 (t).and (); }
func tr_mult (t) { return gen_op2 (t).mult (); }
func tr_rdiv (t) { return gen_op2 (t).rdiv (); }
func tr_div (t) { return gen_op2 (t).div (); }
func tr_mod (t) { return gen_op2 (t).mod (); }

func gen_op1 (t) { return gen_expr (t).op1 (tr (t, 1)); }
func tr_pos (t) { return gen_op1 (t).pos (); }
func tr_neg (t) { return gen_op1 (t).neg (); }
func tr_not (t) { return gen_op1 (t).not (); }

func tr_nil (t) { return gen_expr (t).null (); }
func tr_set (t) { return gen_expr (t).set (tr (t, 1)); }

func tr_range (t) {
  var min = tr (t, 0), max = tr (t, 1);

  return max == nil ? [min, min] : [min, max];
}

func gen_des (t) { return gen_node (t).expr().des ();}
func tr_ref (t) { return gen_des (t).ref (tr (t, 1)); }
func tr_index (t) {
  var i, res = tr (t, 1), indexes = tr (t, 2);

  for (i = 0; i < #indexes; i++)
    res = gen_des (t).elem (res, indexes [i]);
  return res;
}

func gen_typedef (t) { return gen_node (t).tdef ();}

func tr_dot (t) {
  var des = t.transl [1], ident = tr (t, 2, in_other), dcl = nil;

  if (des.name == "$term" && inside (des.transl.lex, lexs.ident))
    dcl = decltab.get (des.transl.lex, curr_scope);
  if (dcl == nil || !inside (dcl, decls.module))
    return gen_des (t).field (et2at_where (des), ident);
  else if (where == in_expr) return gen_des (t).qualid (des.transl.lex, ident);
  else if (where == in_type)
    return gen_typedef (t).qualid (des.transl.lex, ident);
  else diags.fatal (ident.fname, ident.lno, ident.pos,
		    "internal error: bad `where'");
}

func gen_stmt (t) { return gen_node (t).stmt ();}

func tr_des_and_par (t) {
  var des = tr (t, 1), par = t.transl [2], dcl = nil, left;

  if (par.name == "$term" && inside (par.transl.lex, lexs.ident))
    dcl = decltab.find (par.transl.lex, curr_scope);
  else if (par.name == "dot") { // module should be already read
    left = par.transl [1];
    if (left.name == "$term" && inside (left.transl.lex, lexs.ident)) {
      dcl = decltab.get (left.transl.lex, curr_scope);
      dcl = (dcl == nil || !inside (dcl, decls.module)
	     ? nil : decltab.get (par.transl [2].transl.lex, dcl));
    }
  }
  if (dcl != nil && inside (dcl, decls.tdecl))
    return gen_des (t).guard (des, et2at_where (par, in_type));
  else {
    par = et2at_where (par);
    if (type (par) != vector) par = [par];
    return (where == in_expr
	    ? gen_expr (t).fcall (des, par) : gen_stmt (t).pcall (des, par));
  }
}

func tr_assign (t) { return gen_stmt (t).assign (tr (t, 1), tr (t, 2)); }

func tr_call (t) {
  if (t.transl [0].name == "des_and_par") return tr_des_and_par (t.transl [0]);
  return gen_stmt (t).pcall (tr (t, 0), []);
}

class cond (expr, stmts) {}  // used temporary for translation of if
func tr_cond (t) { return cond (tr (t, 0), vtr (t, 1, in_other)); }

func tr_if (t) {
  var conds = tr (t, 1), else_stmts = vtr (t, 2, in_other);
  var i, v = [2 * #conds : nil];

  for (i = 0; i < #conds; i++) {
    v [2 * i] = conds[i].expr; v [2 * i + 1] = conds[i].stmts;
  }
  return gen_stmt (t).if_then (v, else_stmts);
}

func tr_cases (t) { return [tr (t, 0), vtr (t, 1, in_other)]; }

func tr_case (t) {
  return gen_stmt (t).case (tr (t, 1), tr (t, 2), vtr (t, 3, in_other));
}

func tr_exit (t) { return gen_stmt (t).exit (); }
func tr_ret (t) { return gen_stmt (t).ret (tr (t, 1)); }
func tr_loop (t) { return gen_stmt (t).loop (tr (t, 1, in_other)); }
func tr_while (t) {
  return gen_stmt (t).while (tr (t, 1), vtr (t, 2, in_other));
}
func tr_repeat (t) {
  return gen_stmt (t).repeat (tr (t, 1), vtr (t, 2, in_other));
}

func tr_with (t) {
  return gen_stmt (t).with (tr (t, 1), tr (t, 2, in_type),
			    vtr (t, 3, in_other));
}

func gen_decl (t, ident, scope) { return gen_node (t).decl (ident, scope);}

func tr_const (t) {
  var identdef = tr (t, 1, in_other), export = inside (identdef, exported);
  var ident = export ? identdef.ident : identdef, expr = tr (t, 2), c;

  c = gen_decl (t, ident, curr_scope).const (export, expr);
  if (c === decltab.insert (c, 0)) return c;
  diags.error (ident.fname, ident.lno, ident.pos,
		"repeated declaration of `", ident.repr, "'");
  return nil;
}

func tr_type (t) {
  var identdef = tr (t, 1, in_other), export = inside (identdef, exported);
  var ident = export ? identdef.ident : identdef;
  var typedef = tr (t, 2, in_type), d;
  
  d = gen_decl (t, ident, curr_scope).tdecl (export, typedef);
  if (d === decltab.insert (d, 0)) return d;
  diags.error (ident.fname, ident.lno, ident.pos,
	       "repeated declaration of `", ident.repr, "'");
  return nil;
}

func tr_var (t) {
  var identlist = tr (t, 0, in_other), typedef = tr (t, 1, in_type);
  var ident, export, i, v, seq = [];
    
  for (i = 0; i < #identlist; i++) {
    ident = identlist [i]; export = inside (ident, exported);
    ident = export ? ident.ident : ident;
    v = gen_pos_node (ident).decl (ident, curr_scope).vdecl (export, typedef);
    if (v === decltab.insert (v, 0)) ins (seq, v, -1);
    else diags.error (ident.fname, ident.lno, ident.pos,
		      "repeated declaration of `", ident.repr, "'");
  }
  return seq;
}

func tr_pointer (t) { return gen_typedef (t).ptr (tr (t, 1, in_type)); }

func tr_array (t) {
  var indexes = tr (t, 0), elt = tr (t, 1, in_type), i;
  
  for (i = #indexes - 1; i >= 0; i--)
    elt = (gen_pos_node (indexes [i]).tdef ().arr (indexes [i], elt));
  return elt;
}

func tr_oparray (t) { return gen_typedef (t).arr (nil, tr (t, 1, in_type)); }

func tr_fields (t) {
  var identlist = tr (t, 0, in_other), typedef = tr (t, 1, in_type);
  var ident, export, i, f, seq = [];
    
  for (i = 0; i < #identlist; i++) {
    ident = identlist [i]; export = inside (ident, exported);
    ident = export ? ident.ident : ident;
    f = gen_pos_node (ident).decl (ident, curr_scope).field (export, typedef);
    if (f === decltab.insert (f, 0)) ins (seq, f, -1);
    else diags.error (ident.fname, ident.lno, ident.pos,
		      "repeated declaration of `", ident.repr, "'");
  }
  return seq;
}

func tr_record (t) {
  var rec ;
  
  rec = gen_typedef (t).rec (tr (t, 1, in_type)); rec.scope = curr_scope;
  curr_scope = rec; rec.fields = tr (t, 2); curr_scope = rec.scope;
  return rec;
}

func tr_conc (t) { // translation of concatenation
  var f = tr (t, 0, where), s = tr (t, 1, where);
  
  if (f == nil) return (s == nil ? [] : type (s) == vector ? s : [s]);
  else if (s == nil) return (f == nil ? [] : type (f) == vector ? f : [f]);
  else if (type (f) == vector && type (s) == vector) return insv (f, s, -1);
  else if (type (f) == vector) return ins (f, s, -1);
  else if (type (s) == vector) return ins (s, f, 0);
  else return [f, s];
}

func tr_fps (t, var_p = 0) {
  var identlist = tr (t, 0, in_other);
  var typedef = tr (t, 1, in_type), ident, i, par, res = [];
    
  for (i = 0; i < #identlist; i++) {
    ident = identlist [i];
    par = gen_pos_node (ident).decl (ident, curr_scope).par (var_p, typedef);
    if (par === decltab.insert (par, 0)) ins (res, par, -1);
    else diags.error (ident.fname, ident.lno, ident.pos,
		      "repeated declaration of `", ident.repr, "'");
  }
  return res;
}

func tr_vfps (t) { return tr_fps (t); }

var proc_p = 0; // nonzero for checking formals for a procedure (not a type)

func tr_formals (t) {
  var l = t.transl [0], n, res;

  n = (l.name == "$nil" ? node ("", 0, 0) : gen_pos_node (l.transl.lex));
  res = n.tdef ().proc (nil, tr (t, 2, in_type));
  if (!proc_p) {res.scope = curr_scope; curr_scope = res;}
  res.pars = vtr (t, 1);
  if (!proc_p) curr_scope = res.scope;
  return res;
}

func tr_hint (t) { return 1; }

func tr_proc (t) {
  var ident = tr (t, 1, in_other), end_ident = tr (t, 5, in_other);
  var export = inside (ident, exported), p, tp, res, n;
  
  ident = export ? ident.ident : ident;
  if (ident == nil) { ident = end_ident; n = node ("", 0, 0); }
  else {
    n = gen_pos_node (ident);
    if (end_ident != nil && ident.repr != end_ident.repr)
      diags.error (end_ident.fname, end_ident.lno, end_ident.pos,
		   "ident after `END' is not the same as the procedure ident");
  }
  p = n.decl (ident, curr_scope).proc (export); curr_scope = p;
  p.hint = tr (t, 0) != nil; proc_p = 1; p.tdef = tr (t, 2); proc_p = 0;
  if (ident == nil) res = nil;
  else {
    tp = decltab.get (ident, p.scope); res = p;
    if (tp != nil && inside (tp, decls.proc) && tp.stmts == nil) {
      if (p.export != tp.export)
	diags.warn (ident.fname, ident.lno, ident.pos,
		    "forward declaration of `", ident.repr,
		    "' has a different export flag");
      p.forward = tp;
    } else if (tp != nil) {
      diags.error (ident.fname, ident.lno, ident.pos,
		   "repeated declaration of `", ident.repr, "'");
      res = nil;
    }
  }
  if (res != nil) decltab.insert (p, 1);
  p.decls = vtr (t, 3); p.stmts = vtr (t, 4, in_other); curr_scope = p.scope;
  return res;
}

func tr_forward (t) {
  var ident = tr (t, 1, in_other), export = inside (ident, exported), p, res;
  
  ident = export ? ident.ident : ident;
  p = gen_decl (t, ident, curr_scope).proc (export); curr_scope = p;
  res = p != decltab.insert (p, 0) ? nil : p;
  if (res == nil) diags.error (ident.fname, ident.lno, ident.pos,
			       "repeated declaration of `", ident.repr, "'");
  p.tr_type = tr (t, 2); curr_scope = p.scope;
  return p;
}

func find_module (id) {
  var d = decltab.get (id, modules_scope);

  if (d == nil && id.repr == system_id.repr) d = decltab.get (id, nil);
  return d;
}

func read_module_export (name) { // scan & parse & translate
  var at, st, fname, lexs, before = clock ();
  var scan = scanner (imported_module_file_name (name));
  
  lexs = scan.get_lexs ();
  at = o2parse (grammar_fname (), lexs, scan.term_map);
  trans_time -= clock () - before; st = et2at_where (at);
}

func tr_import (t) {
  var ident = tr (t, 0, in_other), external = tr (t, 1, in_other), imp,d ;

  ident = ident == nil ? external : ident;
  imp = gen_pos_node (ident).decl (ident, curr_scope).import (external);
  if (imp === decltab.insert (imp, 0)) {
    d = find_module (external != nil ? external : ident);
    if (d == nil) read_module_export (ident.repr);
    return imp;
  }
  diags.error (ident.fname, ident.lno, ident.pos,
	       "repeated declaration of `", ident.repr, "'");
  return nil;
}

func tr_module (t) {
  var ident = tr (t, 0, in_other), end_ident = tr (t, 4, in_other), m, n;
  
  if (ident == nil) { ident = end_ident; n = node ("", 0, 0); }
  else {
    n = gen_pos_node (ident);
    if (end_ident != nil && ident.repr != end_ident.repr)
      diags.error (end_ident.fname, end_ident.lno, end_ident.pos,
		   "ident after `END' is not the same as the module ident");
  }
  m = n.decl (ident, modules_scope).module (); curr_scope = m;
  if (m !== decltab.insert (m, 0) && ident != nil)
    diags.error (ident.fname, ident.lno, ident.pos,
		 "repeated declaration of `", ident.repr, "'");;
  m.imports = vtr (t, 1); m.decls = vtr (t, 2); m.stmts = vtr (t, 3, in_other);
  curr_scope = m.scope;
  return m;
}

var funcs = {"$error" : nothing, "$nil" : nothing, "$term" : tr_term,
	     "eq" : tr_eq, "ne" : tr_ne, "lt" : tr_lt, "le" : tr_le,
	     "gt" : tr_gt, "ge" : tr_ge, "in" : tr_in,  "is" : tr_is,
	     "plus" : tr_plus,  "minus" : tr_minus, "or" : tr_or,
	     "and" : tr_and, "mult" : tr_mult, "rdiv" : tr_rdiv,
	     "div" : tr_div, "mod" : tr_mod, "pos" : tr_pos,  "neg" : tr_neg,
	     "not" : tr_not, "nil" : tr_nil, "set" : tr_set,
	     "range" : tr_range, "ref" : tr_ref, "index" : tr_index,
	     "dot" : tr_dot, "des_and_par" : tr_des_and_par,
	     "assign" : tr_assign, "call" : tr_call,
	     "cond" : tr_cond, "if" : tr_if,
	     "cases" : tr_cases, "case" : tr_case, "exit" : tr_exit,
             "return" : tr_ret, "loop" : tr_loop, "while" : tr_while,
             "repeat" : tr_repeat, "with" : tr_with, "conc" : tr_conc,
	     "const" : tr_const, "type" : tr_type, "var" : tr_var,
	     "pointer" : tr_pointer, "array" : tr_array,
	     "oparray" : tr_oparray, "fields" : tr_fields,
             "record" : tr_record, "exportid" : tr_exportid,
             "fps" : tr_fps, "vfps" : tr_vfps, "formals" : tr_formals,
             "hint" : tr_hint, "proc" : tr_proc, "forward" : tr_forward,
	     "import" : tr_import, "module" : tr_module};

func et2at_where (t, where_par) {
  var saved = where, res;

  where = (where_par == nil ? in_expr : where_par);
  res = funcs {t.name} (t);
  where = saved;
  return res;
}

var trans_time = 0.0; // overal translation time

func et2at (t) {
  var res, start = clock ();

  res = et2at_where (t, in_other); trans_time += clock () - start;
  return res;
}
