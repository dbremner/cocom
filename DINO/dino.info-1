This is dino.info, produced by makeinfo version 4.3 from
/tmp/linuxdoc-dir-11849/sgmltmp.dino.info.2.

   \input texinfo


File: dino.info,  Node: Top,  Next: Introduction,  Up: (dir)

The Programming Language DINO
*****************************

     Vladimir Makarov, `vmakarov@users.sourceforge.net'.
     Dec 08, 2002
   Edited by Serhei Makarov.

   This document describes the programming language DINO.

     History
     ==========
       Apr 29, 2001.  Documentation of all objects corresponding to Earley's
                      parser was added.
     
       May 05, 2001.  Semantics of private declarations are changed slightly.
                      Earlier, they were accessible only by a separate
                      identifier.  Now they are accessible inside their
                      scope.  In other words, they can be accessible by `.'
                      or `->' inside the scope.
     
                      Added profile option -p.
     
                      Added IEEE standard floating point arithmetic.
     
                      Declaration block friends.
     
       Jun 22, 2001.  Function rcount is added.
     
       Jul 19, 2001.  Functions getf and fgetf have been added.
     
       Jun 23, 2001.  Function gmatch is added, rcount is removed.
     
       Jun 25, 2001.  Operators char, int, float are added.
     
       Sep 25, 2001.  Vector conversion with format.  New function rev.
                      Del, ins, and insv now return the vector.
     
       Oct 27, 2001.  New predefined variable version.  Additional
                      parameter for getf and fgetf.
     
       Oct 31, 2001.  Added special method destroy.
     
       Nov 22, 2001.  New functions sput, sputln, sprint, sprintln added.
     
       Dec 13, 2001.  New variables nil_anode and error_anode and new
                      function set_cost.
     
       Mar 15, 2002.  Function parse may return nil.
     
       Mar 18, 2002.  New function set_lookahead.
     
       Apr 30, 2002.  Calling destroy by finishing the program.
     
       Dec 8, 2002.   Equality of instance, classes and functions means
                      the same context.
       Dec 14, 2003.  Making table key is immutable in assignment.
     
       Jan 29, 2004.  New exception invfmt. New functions putf, fputf, sputf.

* Menu:

* Introduction::
* Syntax::
* Vocabulary and Representation::
* Declarations and Scope Rules::
* Expressions::
* Executive statements::
* Program::
* Predeclared identifiers::
* Appendix A- Syntax of Dino::
* Appendix B- Implementation::


File: dino.info,  Node: Introduction,  Next: Syntax,  Prev: Top,  Up: Top

Introduction
************

   DINO is a high level dynamic-typed scripting language.  DINO is
designed taking such design principles as simplicity, uniformity, and
expressiveness into account.  Dino is oriented on the same domain of
applications as the famous scripting languages Perl, TCL, and Python.
Most programmers know the C programming language.  Therefore Dino aims
to look like C where it is possible.  Dino is an object oriented
language with garbage collection.  Dino has possibilities of
parallelism description and exception handling.  Dino is an extensible
language with the possibility of dynamic loading of libraries written
on other languages.  The high level structures of Dino are
   * heterogenous extensible vectors

   * extensible associative tables with the ability to delete table
     elements

   * objects

   Originally, Dino was used in the russian graphics company ANIMATEK
(Animatek (http://www.animatek.com)) for description of the movement of
dinosaurs in a project.  It has been considerably redesigned and was
implemented with the aid of the COCOM tool set.

   This document is not intended for use as a programmer's tutorial.  It
is a concise description of the language DINO and can be used as a
programmer's reference.


File: dino.info,  Node: Syntax,  Next: Vocabulary and Representation,  Prev: Introduction,  Up: Top

Syntax
******

   An extended Backus-Naur Formalism (EBNF) is used to describe the
syntax of Dino.  Alternatives are separated by `|'.  Brackets `[' and
`]' denote optionality of the enclosed expression, and braces `{' and
`}' denote repetition (zero or more times).  Parentheses `(' and `)'
are used for grouping a EBNF construction containing alternatives
inside it as one construction.

   Terminal symbols denoting a class of terminals (e.g. identifier)
consist of only upper-case letters (e.g. IDENT).  The remaining
terminal symbols either start with a lower-case letter (e.g. keyword
else), or are denoted by ASCII character sequences in double quotes
(e.g. `"=="').  Non-terminal symbols start with an upper-case letter
and contain at least one lower-case letter (e.g. FormalParameters).


File: dino.info,  Node: Vocabulary and Representation,  Next: Declarations and Scope Rules,  Prev: Syntax,  Up: Top

Vocabulary and Representation
*****************************

   Wherever it is possible, we use also EBNF for description of lexical
symbols through ASCII set characters.  Otherwise, we will use natural
language sentences in `<' and `>'.  Lexical symbols are identifiers,
numbers, character constants, strings, operators, delimiters, and
comments.  White characters (blanks and line breaks) must not occur
within the symbols (except in comments, and blanks in strings).  White
characters are ignored unless they are essential to separate two
consecutive lexical symbols.  Upper- and lower-case letters are
considered to be distinct.
  1. An `identifier' is a sequence of letters and digits starting with
     a letter.  The underline is believed to be a valid letter in an
     identifier.
                    Ident = Letter {Letter | Digit}
          
                    Letter = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j"
                           | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t"
                           | "u" | "v" | "w" | "x" | "y" | "z"
                           | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
                           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
                           | "U" | "V" | "W" | "X" | "Y" | "Z"
                           | "_"
          
                    OctalDigit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7"
          
                    Digit = OctalDigit | "8" | "9"

     Examples:
                    line  line2  next_line  NextLine

  2. `Numbers' are (unsigned) decimal integer or floating point
     numbers.  Numbers start with a digit.  Floating point numbers are
     distinguished by the presence of decimal point `.' or an exponent
     in the number.
                    Number = Integer | FloatingPointNumber
          
                    Integer = Digit {Digit}
          
                    FloatingPointNumber = Digit {Digit} "." { Digit } [Exponent]
                                        | Digit {Digit} [Exponent]
          
                    Exponent = ("e" | "E") [ "+" | "-" ] Digit { Digit }

     Examples:
                    10
                    100.
                    1e2
                    100.0E+0

  3. A Dino `character constant' denotes an ASCII character.  The
     following sequences starting with the backslash have a special
     meaning inside a Dino character constant:
        * "\a'    -' ASCII character alert

        * "\b'    -' ASCII character backspace

        * "\f'    -' ASCII character form feed

        * "\n'    -' ASCII character new line

        * "\r'    -' ASCII character carriage return

        * "\t'    -' ASCII character horizontal tab

        * "\v'    -' ASCII character vertical tab

        * "\code' -' ASCII character with given octal code

        * "\char' -' ASCII character char for all remaining characters

     To denote a single quote mark use the sequence `\".  The double
     quote mark can be represented either by `\"' or simply by `"'.  To
     represent a backslash inside the character constant, use two
     consecutive ASCII backslashes.
                    Character = "'" Char "'"
          
                    Char = <any ASCII character except for the single quote ',
                            backslash \, or line break>
                         | SimpleEscapeSeq
                         | OctalEscapeSeq
          
                    SimpleEscapeSeq = <one of  \'  \"  \\  \a  \b  \f  \n  \r  \t  \v>
          
                    OctalEscapeSeq = "\" OctalDigit [ OctalDigit [ OctalDigit ] ]

     Examples:
                    'a'  '\''  '\\'  '\12'  '"'

  4. A `string' is sequence of ASCII characters enclosed in double
     quotes. There are the same sequences of ASCII characters with
     special meaning as in a character constant.  To denote a double
     quote mark use sequence `\"'.  The single quote mark can be
     represented either by `\" or simply by `".  To represent a
     backslash inside the character constant, use two consecutive ASCII
     backslashes.
                    String = '"' {Char} '"'

     Examples:
                    "This is Dino"  "Don't worry\n"

  5. The remaining essential symbols are called `operators' and
     `delimiters'.  Operators are used for forming expressions,
     delimiters are used for forming syntax constructions.  There is a
     special kind of operators and delimiters which look like
     identifiers containing only lower-case letters.  They are reserved
     identifiers (keywords).  Keywords can not be used in the place of
     an identifier.
                    OperatorOrDelimeter = "?" | ":" | "|" | "||" | "&" | "&&" | "^"
                                        | "==" | "!=" | "===" | "!==" | "<" | ">"
                                        | "<=" | ">=" | "<<" | ">>" | ">>>" | "@"
                                        | "+" | "-" | "/" | "*" | "%" | "!" | "+"
                                        | "-" | "~" | "#" | "(" | ")" | "[" | "]"
                                        | "{" | "}" | "->" | "." | "," | ";" | "="
                                        | "*=" | "/=" | "%=" | "+=" | "-="
                                        | "@=" | "<<=" | ">>=" | ">>>=" | "&="
                                        | "^=" | "|=" | "++" | "--" | "..."
                                        | Keyword
          
                    Keyword = "break" | "catch" | "char" | "class" | "continue"
                            | "else" | "ext" | "extern"
                            | "final" | "float" | "for" | "friend" | "func"
                            | "hide" | "hideblock" | "if" | "in" | "int"
                            | "new" | "nil" | "public" | "private" | "return"
                            | "table" | "thread" | "throw" | "try" | "type"
                            | "var" | "vector" | "wait"

  6. `Comments' are considered analogous to blanks on the syntax level
     of the program.  There are two types of comments.  The first type
     is an arbitrary character sequence starting with `/*' and
     finishing with `*/'.  The second type of comment starts with `//'
     and finishes with the first line break or with the end of file.
                    Comment = "/*" <arbitrary char. sequence not containing pair */> "*/"
                            | "//" <arbitrary char. sequence finishing on line break>


File: dino.info,  Node: Declarations and Scope Rules,  Next: Expressions,  Prev: Vocabulary and Representation,  Up: Top

Declarations and Scope Rules
****************************

   A Dino program is block structured.  Each block introduces a new
identifier scope.  A block consists of executive statements and
declarations and may contain nested blocks.  Each identifier used in a
program should be declared in a declaration in the program, unless it
is a predeclared identifier.
               Block = "{"  StmtList "}"
     
               StmtList = { Stmt }
     
               Stmt = ExecutiveStmt
                    | Declaration

   When declaring an identifier, you also specify certain permanent
properties of a declaration, such as whether it is a variable, a
function, or a class.  The identifier is then used to refer to the
associated declaration (more correctly with the declaration instance).
               Declaration = VarDeclarations
                           | AccessClause
                           | ExternDeclarations
                           | FuncClassExtDeclaration
                           | IncludeDeclaration

   The scope of a declaration is textually from the start (not from the
point of declaration!) to the end of the block to which the declaration
belongs and hence to which the declaration is local.  It excludes the
scopes of declarations with the same identifier which are in nested
blocks.  In a block, a maximum of one declaration of the same
identifier is possible.

   It is important to understand the notion of instantiation of the
declaration.  This notion reflects program execution, not the static
structure of program.  An instance exists in a `context'.  Actually, a
context is an execution environment consisting of the covering block
instances and/or class objects.  A new instance of the block is created
when execution of the block starts.  There may be more than one
instance of the same block, e.g. when the block is a function or class
body (in this case the block instance is a class object), or when the
block is executed on different threads (parallel execution branches) or
when there is a reference to a block instance after its execution.
When a new instance of the block starts, all the block declarations are
instantiated too.  For a variable declaration, it means a new instance
of variable is created in the given context.  For a function or class
declaration, it means that the function or class is bound to the given
context.

   Example: The following program illustrates a case when a reference to
a block instance exists after its execution.  The program outputs the
result 8.
               var i, f;
     
               for (i = 0; i < 10; i++)
                 if (i % 4 == 0)
                   {
                     var j = i;
                     func r () {return j;}
                     f = r;
                   }
               putln (f ());

   Declaration is always either private or public.  Private declaration
is accessible only inside the declaration scope or inside functions or
classes which are declared as `friend' in the declaration block.  A
public declaration instance is always accessible when association (see
below) of the identifier is successful.  By default, [instances of]
declarations in a class block are public.  In all other places, the
(instances of) declarations are private by default.  The following
constructions are used for declaring an identifier to be public,
private, or as friend:
               AccessClause = (public | private | friend) AccessList ";"
     
               AccessList = IDENT { "," IDENT }

   Examples:
               public param1, param2;
               private call_count;
               friend class2;

   Association of an identifier and the corresponding declaration
instance is performed by the following rules:
   * The corresponding declaration instance is searched for a separate
     identifier occurrence in the instance of the block in which the
     identifier occurs.  If the latter failed, the declaration is
     searched in the covering block instance of the current block
     instance, and so on.

   * Declaration instance for an identifier in the following
     construction
                 designator.identifier

     is searched in the block instance (e.g. in a class object) whose
     value is in the designator.  If the designator is a class object,
     its context is a class object, and the search failed, the search
     is continued in the covering class object etc.  The exception
     `accessop' occurs if the declaration is not found with such
     identifier, or the declaration is private and the construction is
     not in the declaration scope and not inside a friend of the
     declaration scope.

   * Declaration instance for an identifier whose name is an expression
     value in the following construction
                 *(expression)

     is searched in the same way as a separate identifier.  The
     exception `accessop' occurs if there is no such instance of a
     declaration with such an identifier in the covering block
     instances.

   * The declaration for an identifier in the following construction
                 (expression)->identifier

     is searched in an analogous way to the construction
     `designator.identifier' in the block instance which is the value
     of the variable whose name is given by the expression.  The
     variable is searched in the same way as in the construction
     `*(expression)'.  Exception `accessop' occurs if there is no such
     variable instance with the given name in covering block instances,
     there is no instance of the declaration with such identifier in
     the given context (the variable value), or the declaration is
     private and the construction is not in the declaration scope.

   The following identifiers are predeclared on the top level (in the
implicit block covering the whole program).  They are described in more
detail later in the report.
       anode          argv           atan2
       chdir          chgmod         chomod         chumod
       clock          close          cmpv           context
       cos            curr_thread
       del
       eltype         env            error_anode    errors
       except         excepts        exit           exp
       fatime         fctime         fget           fgetf
       fgetln         fgmode         fgn            file
       flush          fmtime         fomode         fprint
       fprintln       fput           fputln         fscan
       fscanln        fsize          ftype          fumode
       fun
       gc             get            getcwd         getegn
       geteun         getgn          getgroups      getf
       getln          getpid         getun          gmatch
       gsub
       ins            inside         insv           invaccesses
       invcalls       invexterns     invindexes     invkeys
       invops         invparsers     invregexps     isatty
       keys
       log            log10
       main_thread    match          max            min
       mkdir
       nil_anode
       open
       parser         pclose         popen          pow
       print          println        put            putln
       rand           readdir        remove         rename
       rev            rmdir
       scan           scanln         seek           signals
       sin            sort           split          split_regex
       sprint         sprintln       sput           sputln
       sqrt           srand          stderr         stdin
       stdout         strtime        sub            subv
       syserrors      system         systemcalls
       tell           time           time_format    token
       tolower        toupper
       version

   The following identifiers are predeclared in the class `except'
mentioned above.
       error

   The following identifiers are predeclared in the class `error'
mentioned above.
       deadlock
       invaccess      invcall        invenv         invindex
       invkey         invop
       signal

   The following identifiers are predeclared in the class `signal'
mentioned above.
       sigabrt        sigfpe         sigill         sigint
       sigsegv        sigterm

   The following identifiers are predeclared in the class `invop'
mentioned above.
       optype         opvalue

   The following identifiers are predeclared in the class `invindex'
mentioned above.
       indexop        indextype      indexvalue

   The following identifiers are predeclared in the class `invkey'
mentioned above.
       keyop          keyvalue

   The following identifiers are predeclared in the class `invcall'
mentioned above.
       callop
       eof
       internal       invenvar       invextern      invfmt
       invinput       invparser      invregexp      invresult
       parnumber      partype
       syserror       systemcall

   The following identifiers are predeclared in the class `syserror'
mentioned above.
       eaccess        eagain         ebadf          ebusy
       echild         edeadlk        edom           eexist
       efault         efbig          eintr          einval
       eio            eisdir         emfile         emlink
       enametoolong   enfile         enodev         enoent
       enoexec        enolck         enomem         enospc
       enosys         enotdir        enotempty      enotty
       enxio          eperm          epipe          erange
       erofs          espipe         esrch          exdev

   The following identifiers are predeclared in the class `systemcall'
mentioned above.
       noshell
       systemfail

   The following identifiers are predeclared in the class `invparser'
mentioned above.
       invgrammar     invtoken
       pmemory

   The following identifiers are predeclared in the class `invregexp'
mentioned above.
       badpat
       ebrack         ectype         eend           eescape
       eparen         erange         esize          espace
       esubreg

   The following identifiers are predeclared in the class `invextern'
mentioned above.
       libclose
       noextern       noexternsupp

   The following identifiers are predeclared in the class `invaccess'
mentioned above.
       accessop       accessvalue    arrowtype
       dereftype
       immutable

* Menu:

* Variable Declarations::
* External Declarations::
* Functions Classes Extensions::


File: dino.info,  Node: Variable Declarations,  Next: External Declarations,  Up: Declarations and Scope Rules

Variable Declarations
=====================

   Dino is an imperative language. In other words it has `variables'
which are named containers of values.  A variable can contain any
value.  This means that DINO is a dynamically-typed language.  The
declaration of a variable also may define the initial value of the
variable.  Assigning of the initial value to the variable instance is
made after execution of the previous statements of the block.  By
default the initial value of variables is the special value `nil'.  The
value of the variable can not be changed after its initialization if
its declaration contains the keyword `final'.
               VarDeclarations = var  VarParList ";"
     
               VarParList = VarPar { "," VarPar }
     
               VarPar = [final] IDENT [ "="  Expr]

   Examples:
               var i = 0, j, k;
               var final constant = 10, final nil_constant, l;


File: dino.info,  Node: External Declarations,  Next: Functions Classes Extensions,  Prev: Variable Declarations,  Up: Declarations and Scope Rules

External Declarations
=====================

   Dino permits to use functions written in other languages, e.g. C.
The functions should have special prototypes and must have to access to
the DINO standard procedural interface (SPI).  Dino can also have
access to variables of a special type declared in the source code in
another language.  The details of the implementation of such features
and the DINO SPI are not described here (some details are given in
appendix B).  As rule, the external functions and variables will be
implemented as dynamically loaded libraries.  This is the powerful
instrument of DINO extension.  The external functions and variables are
declared after keyword `extern'.  An external function identifier is
followed by `[]'.  All external declarations (e.g. in different blocks)
with the same identifier refer the the same external function or
variable.
               ExternDeclarations = extern  ExternItem { "," ExternItem } ";"
     
               ExternItem = IDENT
                          | IDENT  "(" ")"

   Examples:
               extern function (), variable;


File: dino.info,  Node: Functions Classes Extensions,  Prev: External Declarations,  Up: Declarations and Scope Rules

Functions Classes Extensions
============================

   A function/class declaration consists of a function/class header and
a function/class block (body).  The header specifies the function
identifier and `formal parameters'.  A function can return the result
with the aid of the statement `return'.  If the result value after the
keyword `return' is absent or the return statement is absent or is not
executed, the function returns `nil' by default.  A class call returns
an object of the class which can be considered as a block instance of
the class body.  The return-statement for classes must be without a
result.  `Thread-functions' are analogous to general functions.  The
difference is in that a new execution `thread' is created during the
thread-function call, the return-statement inside thread-function must
be without an expression, and the thread-function returns the
corresponding (execution) thread.  The execution thread finishes when
the corresponding thread block finishes.  Execution threads are
executed parallelly.  Originally only one thread (called the `main
thread') exists in a DINO program.

   The formal parameters are considered to be declared in a
function/class block and to be initialized by values of `actual
parameters' during a call of the function/class.  The function can be
called with any number of `actual parameters'.  If the number of actual
parameters is less than the formal parameters number, the remaining
formal parameters are initialized by the special value `nil'.
Otherwise if the number of actual parameters is more than the number of
formal parameters, the remaining actual parameter values are ignored.
In order to process all actual parameters, you should place `...' at
the end of the list of formal parameter declarations.  This means that
the formal parameter with the identifier `args' will be declared
implicitly.  The value of the parameter will be a vector whose elements
will be the remaining actual parameter values.  If the number of actual
parameters is less or equal to the number of formal parameters (not
taking the implicit parameter `args' into account), the value of `args'
will be the empty vector.  The formal parameter can be initialized by a
default value in a way analogous to variable initialization.  The
initialization is made only when the corresponding actual parameter
value is `nil'.

   If a class contains a function with the name `destroy', the function
will be called when the class object becomes garbage during the garbage
collection process or at the end of the program.  The function can also
be called explicitly if it is declared as public.  You should be
remember that although the function may have parameters and return a
value, the garbage collector (or finishing the program) ignores the
result value and does not pass actual parameters.  The single exception
when the function `destroy' is not called by finishing the program is
the case when memory can not be allocated more.  So the values of the
parameters will be `nil' if the function is called by the garbage
collector (or finishing the program).  You may prevent removing the
corresponding object in the function destroy by assigning the object to
a variable.  It means that the function can be called several times
(during several garbage collections) for the same object.  But you
should also avoid creation of objects during the call of function
`destroy' because it may result in increase of the heap.

   Instead of inheritance usually used in object-oriented languages,
Dino supports `extension'.  This feature permits to modify
function/class behaviour.  All code inside an extension body is
inserted at the end of body of the function/class declared with the
same identifier in the same block in the same order as the extensions
are placed in the block.  A function/class declared as `final' can not
be extended.
               FuncClassExtDeclaration = Header Block
     
               Header = [final] FuncThreadClass IDENT FormalParameters
                      | ext IDENT
     
               FuncThreadClass = func
                               | thread
                               | class
     
               FormalParameters = "("  [ VarParList ] ")"
                                | "("  VarParList "," "..."  ")"
                                | "(" "..."  ")"

   Examples:

   The following is a parameterless class header:
               class stack ()

   The following is a class header with an initialization:
               class stack (max_height = 100)

   The following is a function with a variable number of parameters:
               func print_args (...)
                 {
                   for (i = 0; i < #args; i++)
                     println (args[i]);
                 }

   The following example illustrates the usage of extensions:
                class point (x = 0, y = 0) {
                }
                ext point {
                  class circle (radius = 1) {
                    func square () {return 3.14 * radius * radius;}
                  }
                }
                ext point {
                  ext circle {
                    class ellipse (width) {
                      func square () {
                        ...
                      }
                    }
                }

   The following example is a class with the function `destroy':
               var objs_number = 0;
               class obj () {
                 private n, destroy;
                 var n = objs_number;
                 objs_number++;
                 func destroy () {objs_number--; objs_number--;}
               }

   The following example illustrates threads:
               class buffer (length = 3) {
                 var b = [length:nil], first = 0, free = 0, empty = 1;
                 private b, first, free, length;
                 func consume () {
                   var res;
     
                   wait !empty;
                   res = b [first];
                   first = (first + 1) % length;
                   empty = first == free;
                   return res;
                 }
                 func produce (val) {
                   wait empty || free != first;
                   b [free] = val;
                   free = (free + 1) % length;
                   empty = 0;
                 }
               }
     
               thread consumer (buffer) {
                   func produce (val) {
                     buffer.produce (val);
                     put ("produce: ");
                     println (val);
                   }
                   produce (10);
                   produce (10.5);
                   produce ("string");
                   produce ('c');
                   produce (nil);
               }
     
               thread producer (buffer) {
                 var val;
     
                 for (;;) {
                   val = buffer.consume ();
                   if (val == nil)
                     break;
                   put ("consume: ");
                   println (val);
                 }
               }
     
               var queue = buffer ();
               consumer (queue);
               producer (queue);


File: dino.info,  Node: Expressions,  Next: Executive statements,  Prev: Declarations and Scope Rules,  Up: Top

Expressions
***********

   Expressions are constructs denoting rules of computation of a value
from other values by the application of `operators'.  Expressions
consist of `operands' and operators.  Parentheses may be used to
express specific associations of operators and operands.  Dino is a
dynamic-typed language.  This means that a variable can store any Dino
value.

* Menu:

* Types and Values::
* Designators::
* Calls::
* Operators::


File: dino.info,  Node: Types and Values,  Next: Designators,  Up: Expressions

Types and Values
================

   All Dino values are `first class values', i.e. they can be assigned
to a variable, can be passed as a parameter of a function/class, and
can be returned by functions.  Operators require operands whose values
are of given type and return the value of the result type.  Most values
have a representation in Dino.  When a value representation is
encountered in an expression during the expression evaluation, the new
value is generated.

   There are values of `structured types', i.e. values which are built
from other values.  The value of a structured type may be `mutable' or
`immutable'.  A value or sub-value of a mutable value can be changed.
An immutable value can not be changed after its generation.  You can
make a mutable value immutable as a side effect by applying the
operator `final' (the table key is also made immutable as a side effect
of writing to the table).  In all cases, the operator returns the
operand value as the result.  If you try to change an immutable value,
exception `immutable' is generated.  You can make a new mutable value
as a side effect of applying operator `new'.  The operator returns a
new value equal to the operand value.
               Expr = final  Expr
                    | new  Expr

   Structured value types are also `shared value types'.  This notion
means that if two or more different variables (array elements or table
elements or keys) refer to the same value and the value is changed
through one variable, the value which is referred through the other
variables is changed too.  There is no difference between the notion
"the same value" and the notion "equal values" for non-shared type
values.  For the shared type operands, equality means that the operands
have the same structure (e.g. vectors with the same length) and the
corresponding element values are the same.

   Examples:
               new 5
               new ['a', 'b', 'c']
               new "abc"
               new {"key0" : 10, "key1" : 20}
               final 5
               final ['a', 'b', 'c']
               final "abc"
               final {"key0" : 10, "key1" : 20}

   Dino has the following types of values:
   * the special value `nil'.  This is the default value of all
     variables when a block starts.  The value is represented by the
     keyword `nil'.
                           Expr = nil

   * `character' which represents ASCII characters.  For the
     representation see `Character' in the section `Vocabulary and
     Representation'.
                           Expr = CHARACTER

   * `integer'.  For its representation see `Integer' in the section
     `Vocabulary and Representation'.  It is always stored as a 32-bit
     integer value.
                           Expr = INTEGER

   * `floating point number'.  For its representation see
     `FloatingPointNumber' in section `Vocabulary and Representation'.
     It is always stored as an IEEE double (64-bit) floating point
     value.
                           Expr = FLOATINGPOINTNUMBER

   * `vector'.  This is a structured shared type value.  A vector value
     is represented by a list of values (or expressions) in brackets
     with optional repetitions of the vector elements preceded by `:'.
     The repetition value is converted into an integer value by
     default.  If the repetition value after the conversion is not
     integer, exception `optype' is generated. If the repetition value
     is negative or zero, the element value will be absent in the
     vector.  Elements of vector are accessed by their indexes.
     Indexes always starts with 0.  Vectors in Dino are heterogenous,
     i.e. elements of a vector may be of different types.  A string
     represents an immutable vector all of whose elements are
     characters in the string.  Elements of mutable vectors can be
     added to or removed from the vector (see predefined functions
     `ins, insv, and del').
                           Expr = "["  ElistPartsList "]"
                                | STRING
                           ElistPartsList = [ Expr [":" Expr ] {"," Expr [":" Expr ] } ]

     Examples:
                         "aaab"
                         ['a', 'a', 'a', 'b']
                         [3 : 'a', 'b']
                         [3.0 : 'a', 'b']
                         ["3" : 'a', 'b']
                         ['a', 10, 10.0, "abcd", {}]
                         []

   * `table'.  This is a structured shared type value.  A table value
     is represented by a list of key values (expression values) in
     figure parentheses `{' and `}' with optional element values with a
     preceding `:'.  By default the element value is equal to `nil'.
     It is not allowed to have elements with equal keys in a table.  If
     it is not true in a table constructor, exception `keyvalue' is
     generated.  Elements of tables are accessed by their keys.
     Elements of mutable tables can be added to or removed from the
     table correspondingly by assigning values and with the aid of the
     function `del'.  The side effect of the table constructor
     execution is that the keys become immutable.
                           Expr = "{"  ElistPartsList "}"

     Examples:
                         {'a', 'b', 10:[10]}
                         {'a' : nil, 'b' : nil, 10 : [10]}
                         {[10, 'a', {10}] : 10, [10] : {20:20}}
                         {}

   * `function'.  Its value is represented by the function designator.
     It is important to remember that the function is bound to a
     context.

   * `thread-function'.  Its value is represented by the
     thread-function designator.  It is important to remember that the
     thread-function is bound to a context.

   * `class'.  Its value is represented by the class designator.  It is
     important to remember that the class is bound to a context.

   * `block instance'.  There is no Dino representation of such values.

   * `thread'.  There is no literal Dino representation of such values.
     A thread value is generated by calling a thread-function.

   * `object'[class instance].  This is a structured shared type value.
     There is no literal Dino representation of such values.  Objects
     are generated by calling classes.

   * `hide value'.  A hide value can not be generated by a Dino code.
     They are generated by external functions.

   * `hide block'.  This value is analogous to a hide value.  The
     differences are in that the size of a hide value is constrained by
     a C program pointer.  The size of q hideblock value has no such
     constraint.  Also a hideblock is of shared type.

   * `type'.  The values of such types are returned by th special
     operator `type (expression)'.
                           Expr = char
                                | int
                                | float
                                | hide
                                | hideblock
                                | vector
                                | table
                                | func
                                | thread
                                | class
                                | func "(" ")"
                                | thread "(" ")"
                                | class "(" ")"
                                | type

     There are the following type values:
        * type of `nil'.  There is no value representing type of `nil'.
          So use the construction `type (nil)' to get it.

        * type of characters.  The value is represented by the Dino
          keyword `char'.

        * type of integers.  The value is represented by the Dino
          keyword `int'.

        * type of floating point numbers.  The value is represented by
          the Dino keyword `float'.

        * type of vectors.  The value is represented by the Dino
          keyword `vector'.

        * type of tables.  The value is represented by the Dino keyword
          `table'.

        * type of functions.  The value is represented by the Dino
          keyword `func'.

        * type of thread-functions.  The value is represented by the
          Dino keyword `thread'.

        * type of classes.  The value is represented by the Dino
          keyword `class'.

        * type of block instances.  The value is represented by the
          Dino construction `func ()'.

        * type of threads.  The value is represented by the Dino
          construction `thread ()'.

        * type of objects.  The value is represented by the Dino
          construction `class ()'.

        * type of hide values.  The value is represented by the Dino
          keyword `hide'.

        * type of hideblocks.  The value is represented by the Dino
          keyword `hideblock'.

        * type of types.  The value is represented by the Dino keyword
          `type'.


File: dino.info,  Node: Designators,  Next: Calls,  Prev: Types and Values,  Up: Expressions

Designators
===========

   There is a special Dino construction called a `designator'.  A
designator refers for a vector or table element or for a declaration.
If the designator refers to a vector or table element or for a variable
declaration, it can stand in the left hand side of an assignment
statement.  If the designator stands in an expression, the
corresponding value is used (vector/table element value, variable
value, function, thread-function, or class).  When the designator
referring to table element stands up in the left hand side of an
assignment statement, its key becomes immutable.
               Expr = Designator

   A designator referring to a vector element has the following syntax:
               Designator = DesignatorOrCall "["  Expr "]"
     
               DesignatorOrCall = Designator
                                | Call

   The value of the construction before the brackets must be a vector.
Otherwise, the exception `indexop' is generated.  The value of
expression in the brackets (so called the `index') is converted to
integer.  If this is not possible, exception `indextype' is generated.
If the index is negative or greater than or equal to the vector length,
the exception `indexvalue' is generated.  The value of the designator
will be the vector element value with given index (the indexes starts
with zero).  Examples:
               vect [1]
               vect ["1"]
               vect [1.0]

   A designator referring to a table element has the following syntax:
               Designator = DesignatorOrCall "{"  Expr "}"

   The value of the construction before the figure brackets must be a
table.  Otherwise, the exception `keyop' is generated.  The value of
expression in the figure brackets is called the `key'.  The value of
the designator will be the table element value with the key which is
equal to given key.  If the element with the given key is absent in the
table, exception `keyvalue' is generated.  Examples:
               tab {'c'}
               tab {10}
               tab {"1"}
               tab {1.0}

   The remaining forms of designator refer to a declaration.  See
section `Declarations and Scope Rules' for a description on how they
work.
               Designator = DesignatorOrCall "."  IDENT
                          | "(" Expr ")" "->"  IDENT
                          |  "*" "(" Expr ")"
                          | IDENT

   Examples:
               value
               *("value")
               value.f
               ("value")->f


File: dino.info,  Node: Calls,  Next: Operators,  Prev: Designators,  Up: Expressions

Calls
=====

   One form of expression is the call of a function, thread-function, or
class.  The value of the designator before the actual parameters should
be a function, thread-function, or class.  Otherwise, the exception
`callop' is generated.  An instance of the block corresponding to the
body of the function, thread-function, or class is created.  The actual
parameter values are assigned to the corresponding formal parameters.
If the corresponding function, thread-function, or class has no default
formal parameter `args' (see section `Declarations'), the remaining
actual parameter values are ignored.  Otherwise, a vector whose
elements are the remaining parameter values is created and assigned to
the parameter `args'.  If there is no corresponding actual parameter
for a formal parameter, the default parameter value (see section
`Declarations') or the value `nil' is assigned to the formal parameter.
Then statements in the block are executed.  If it is the call of a
thread-function, a new execution thread is created, and the statements
of the block is executed in the new thread.  The value of call of the
thread-function is the corresponding thread.  It is returned before
starting the execution of statements in the new thread.

   Execution of the body is finished by reaching the block end or by
execution of a return-statement.  Finishing of the thread-function
results in finishing the corresponding thread.  The return-statement in
a thread-function or in class should be without an expression.  The
call of a class returns the created object.  A function call returns
the value of the expression in the executed return-statement.
Otherwise, the function call returns the value `nil'.
               Expr = Call
     
               Call = Designator ActualParameters
     
               ActualParameters = "("  [ Expr { "," Expr } ] ")"

   Examples:
               f ()
               f (10, 11, ni, [])
               obj.objf ()


File: dino.info,  Node: Operators,  Prev: Calls,  Up: Expressions

Operators
=========

   Expressions consist of operands and operators.  The order in which
operators are executed in an expression is defined by their `priority'
and `associativity' of operators.  That means that the expression `a
op1 b op2 c' when the operator `op2' has higher priority than `op1' is
analogous to `a op1 (b op2 c)'.  Dino operators have analogous
priorities to the ones in C language.  The following Dino operators are
placed in the order of their priority (the higher the line on which the
operator is placed, the higher its priority).
               !  #  ~  final  new
               *  /  %
               +  -
               @
               <<  >>  >>>
               <  >  <=  >=
               ==  !=  ===  !==
               &
               ^
               |
               in
               &&
               ||
               :
               ?

   All binary operators have left associativity in Dino.  That means
that the expression `a op1 b op2 c' when operators `op1' and `op2' have
the same priority is analogous to `[a op1 b] op2 c'.  Parentheses may
be used to express specific associations of operators and operands.
               Expr = "(" Expr ")"

   Most of the Dino operators require the operands to be of given types.
If an operand is not of given type, the conversion of it into the type
needed may be made.  If after the possible conversions the operands are
still not of necessary types, exception `optype' is generated (when
something about exceptions in this case is not mentioned).  The
following conversions may be made by default:
   * `Integer conversion'.  If the operand is a character, its code
     becomes integer.  If the operand is a floating point number, its
     fractional part is thrown away and integral part becomes integer.
     If the operand is a vector of characters, the corresponding string
     is believed to be the decimal representation of integer and is
     converted into the corresponding integer.  If the corresponding
     string is not a correct integer representation, the result is
     undefined.  If the corresponding string represents an integer
     whose representation requires more 32 bits, exception `erange' may
     be generated.  In all remaining cases the results of conversion
     coincide with the operand.

   * `Arithmetic conversion'.  Analogous to integer conversion except
     for that the conversion of float pointing number to integer is not
     made and if the string represents a floating point number (i.e.
     contains an exponent or fraction), the result will be the
     corresponding floating point number instead of integer.
     Additionally if the operand is in a non-short circuit binary
     operator (non-logical operators) and another operand is a floating
     point number after the conversion, the first operand is converted
     into a floating point number too.  Analogously if the result is an
     integer which can not be represented by a 32-bit integer or the
     result is a floating point number not represented by IEEE double
     format, the exception `erange' may be generated.

   * `String conversion'.  If the operand is a character, the result
     will be a new string (immutable vector of characters) with one
     element which is the character.  If the operand is an integer or a
     floating point number, the result will be a new string of
     characters which is a decimal string representation of the number.

* Menu:

* Logical operators::
* Bit operators::
* Comparison operators::
* Arithmetic operators::
* Miscellaneous operators::

