/* This file contains execution (run-time) objects description. */

/*
   Copyright (C) 1997-2014 Vladimir Makarov.

   Written by Vladimir Makarov <vmakarov@users.sourceforge.net>

   This file is part of interpreter of DINO.

   This is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This software is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GNU CC; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.

*/

/* Don't use -flat-structure for generation SPI from this description. */

%extend d_extern

%import {

#include "d_bc.h"
#include "d_runtab.h"

}

%export {

#define INCREMENT_PC() (cpc = BC_next (cpc))

/* The macro call returns optimal allocation size for vector elements.
   Remember vector can grow.  Remember also about string end char. */
#define OPTIMAL_ELS_SIZE(s) (((s) + 1) * 3 / 2)

extern int sync_flag;

extern pc_t cpc;
extern ER_node_t cstack;
extern ER_node_t uppest_stack;
extern ER_node_t tvars;
extern ER_node_t cvars;
extern ER_node_t ctop;
extern int tvar_num1, tvar_num2;

/* Return source position of byte code BC.  */
static position_t do_always_inline
get_pos (BC_node_t bc)
{
  d_assert (BC_IS_OF_TYPE (bc, BC_NM_bcode));
  return BC_pos (BC_info (bc));
}

/* Return source position of current executed byte code.  */
static position_t do_always_inline
get_cpos (void)
{
  return get_pos (cpc);
}

#define TOP_UP   DECR_CTOP (-1)
#define TOP_DOWN DECR_CTOP (1)

extern vlo_t heap_temp_refs;

#define CREATE_TEMP_REF() VLO_CREATE (heap_temp_refs, 256)
#define FINISH_TEMP_REF() VLO_DELETE (heap_temp_refs)
#define EMPTY_TEMP_REF() VLO_NULLIFY (heap_temp_refs)

#define PUSH_TEMP_REF(ref)\
 do\
   {\
     ER_node_t r = ref;\
     VLO_ADD_MEMORY (heap_temp_refs, &r, sizeof (r));\
   }\
 while (0)

#define POP_TEMP_REF(n) VLO_SHORTEN (heap_temp_refs, (n) * sizeof (ER_node_t))

#define GET_TEMP_REF(depth)\
  (((ER_node_t *) VLO_BEGIN (heap_temp_refs))\
   [VLO_LENGTH (heap_temp_refs) / sizeof (ER_node_t) - (depth) - 1])

#define TEMP_REFS_LENGTH() (VLO_LENGTH (heap_temp_refs) / sizeof (ER_node_t))

extern vlo_t temp_vlobj;
extern vlo_t temp_vlobj2;

/* Structure for storing info about called function/class.  */
struct trace_stack_elem
{
  BC_node_t block;
  pc_t pc; /* Pc of the call */
};

extern vlo_t trace_stack;

extern ER_node_t cprocess;
extern int_t context_number;
extern int_t process_number;
extern ER_node_t first_process_not_started;

#define GO_THROUGH_REDIR(ref)\
 while (ER_NODE_MODE (ref) == ER_NM_heap_redir) (ref) = ER_redir (ref)

/* Return true if it is non-external function.  */
static inline
int fun_p (ER_node_t val)
{
  BC_node_t code;

  if (ER_NODE_MODE (val) != ER_NM_code)
    return FALSE;
  code = ID_TO_CODE (ER_code_id (val));
  return BC_fun_p (code);
}

extern void initiate_int_tables (void);

extern unsigned int gc_number;
extern int free_gc_memory_percent;
extern size_t heap_size;
extern size_t free_heap_memory;
extern int heap_chunks_number;
extern int in_gc_p;
#ifndef NO_CONTAINER_CACHE
extern int current_cached_container_tick;
#endif
#ifndef NO_PROFILE
#if HAVE_SETITIMER
extern int_t gc_interrupts_number;
#else
extern ticker_t gc_ticker;
#endif
#endif

#if ! defined (NO_PROFILE) && HAVE_SETITIMER
extern int_t all_interrupts_number; 
extern void profile_interrupt (void);
#endif

extern int GC_executed_stmts_count;
extern int no_gc_p;

extern void *heap_allocate (size_t size, int stack_p);
extern void initiate_heap (void);
extern void final_call_destroy_functions (void);
extern void finish_heap (void);
extern void GC (void);
extern void heap_push (BC_node_t block_node_ptr, ER_node_t context,
		       int offset);
extern int heap_push_or_set_res (BC_node_t code, ER_node_t context,
				 val_t *call_start);
extern void heap_pop (void);
extern void create_uppest_stack (BC_node_t block_node);
extern void expand_uppest_stack (void);

extern unsigned int tab_collisions;
extern unsigned int tab_expansions;

extern void initiate_tables (void);

extern int executed_stmts_count;
extern int process_quantum;

extern ER_node_t create_process (pc_t start_process_pc, BC_node_t fun,
	                         ER_node_t fun_context);
extern void interrupt (pc_t first_resume_pc);
extern void block_cprocess (pc_t first_resume_pc, int wait_stmt_flag);
extern void delete_cprocess (void);
extern int delete_cprocess_during_exception (void);
extern void initiate_processes (pc_t start_pc);

extern void *external_address (BC_node_t decl);

extern void process_system_errors (const char *function_name);

extern void call_fun_class (BC_node_t fun, ER_node_t context, int_t pars_number);


#ifdef __GNUC__
extern void eval_error (BC_node_t error_decl, BC_node_t context_var,
			position_t position,
		        const char *format, ...) __attribute__ ((noreturn));
#else
extern void eval_error (BC_node_t error_decl, BC_node_t context_var,
			position_t position, const char *format, ...);
#endif

extern const char *er_type_name (int);

}

%%

/* Because objects can change their places (growing mutable objects or
   unpacking vector), we need the following nodes which are placed on
   place of first place of the object and refers for current place of
   the object (or another redirection).  The redirections do not
   survive GC.  Heap objects on which redirection refers for has the
   same (unique)number as original object. */
heap_redir :: heap_vect_tab
%other
  /* new_place, immutable, els_number are not used here. */
  redir : heap_vect_tab /* referenced object */
;

/* Don't add fields for nodes here as we have different structures in
   the interpriter and in the external functions.  */

%%

/* Return name of ER type T.  */
const char *
er_type_name (int t)
{
  return ER_node_name[t];
}


/*
Local Variables:
mode:c
End:
*/
