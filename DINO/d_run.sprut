/* This file contains execution (run-time) objects description. */

/*
   Copyright (C) 1997-2007 Vladimir Makarov.

   Written by Vladimir Makarov <vmakarov@users.sourceforge.net>

   This file is part of interpreter of DINO.

   This is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This software is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GNU CC; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.

*/

/* Don't use -flat-structure for generation SPI from this description. */

%extend d_extern

%type pc_t

%import {

#include "d_ir.h"

}

%export {

#define INCREMENT_PC() (cpc = IR_next_pc (IR_POINTER (cpc)))

/* The macro call returns optimal allocation size for vector elements.
   Remember vector can grow.  Remember also about string end char. */
#define OPTIMAL_ELS_SIZE(s) (((s) + 1) * 3 / 2)

extern int sync_flag;

extern pc_t cpc;
extern ER_node_t cstack;
extern ER_node_t uppest_stack;
extern ER_node_t ctop;

#define below_ctop (INDEXED_VAL (ctop, -1))

#ifdef NO_OPTIMIZE
#define ER_CTOP() ER_ctop (cstack)
#else
#define ER_CTOP() ctop
#endif

#ifdef NO_OPTIMIZE

#define SET_TOP\
   do {\
     ctop = (ER_node_t) ER_CTOP ();\
   } while (0)

#define TOP_UP\
   do {\
     DECR_CTOP (-1);\
     ctop = (ER_node_t) ER_CTOP ();\
   } while (0)

#define TOP_DOWN\
   do {\
     DECR_CTOP (1);\
     ctop = (ER_node_t) ER_CTOP ();\
   } while (0)


#else /* #ifdef NO_OPTIMIZE */

#define SET_TOP\
   do {\
   } while (0)

#define TOP_UP\
   do {\
     ctop = INDEXED_VAL (ctop, 1);\
   } while (0)

#define TOP_DOWN\
   do {\
     ctop = below_ctop;\
   } while (0)

#endif /* #ifdef NO_OPTIMIZE */

extern ER_node_t temp_ref;
extern vlo_t heap_temp_refs;

#define CREATE_TEMP_REF() VLO_CREATE (heap_temp_refs, 256)
#define FINISH_TEMP_REF() VLO_DELETE (heap_temp_refs)
#define EMPTY_TEMP_REF() VLO_NULLIFY (heap_temp_refs)

#define PUSH_TEMP_REF(ref)\
 do\
   {\
     ER_node_t r = ref;\
     VLO_ADD_MEMORY (heap_temp_refs, &r, sizeof (r));\
   }\
 while (0)

#define POP_TEMP_REF(n) VLO_SHORTEN (heap_temp_refs, (n) * sizeof (ER_node_t))

#define GET_TEMP_REF(depth)\
  (((ER_node_t *) VLO_BEGIN (heap_temp_refs))\
   [VLO_LENGTH (heap_temp_refs) / sizeof (ER_node_t) - (depth) - 1])

#define TEMP_REFS_LENGTH() (VLO_LENGTH (heap_temp_refs) / sizeof (ER_node_t))

extern vlo_t temp_vlobj;
extern vlo_t temp_vlobj2;

/* Structure for storing info about called function/class.  */
struct trace_stack_elem
{
  IR_node_t func_class;
  pc_t pc; /* Pc of the call */
};

extern vlo_t trace_stack;

extern ER_node_t cprocess;
extern int_t context_number;
extern int_t process_number;
extern ER_node_t first_process_not_started;

#define GO_THROUGH_REDIR(ref)\
 while (ER_NODE_MODE (ref) == ER_NM_heap_redir) (ref) = ER_redir (ref)

extern size_t type_size_table [];
extern size_t val_displ_table [];

extern void initiate_int_tables (void);

extern int no_gc_flag;
extern unsigned int gc_number;
extern int free_gc_memory_percent;
extern size_t heap_size;
extern size_t free_heap_memory;
extern int heap_chunks_number;
extern int in_gc_p;
#ifndef NO_CONTAINER_CACHE
extern int current_cached_container_tick;
#endif
#ifndef NO_PROFILE
#if HAVE_SETITIMER
extern integer_t gc_interrupts_number;
#else
extern ticker_t gc_ticker;
#endif
#endif

#if ! defined (NO_PROFILE) && HAVE_SETITIMER
extern integer_t all_interrupts_number; 
extern void profile_interrupt (void);
#endif

extern void *heap_allocate (size_t size, int stack_p);
extern void initiate_heap (void);
extern void final_call_destroy_functions (void);
extern void finish_heap (void);
extern void gc (void);
extern void heap_push (IR_node_t block_node_ptr, ER_node_t context,
		       int offset);
extern void heap_pop (void);

extern unsigned int tab_collisions;
extern unsigned int tab_expansions;

extern void initiate_tables (void);

extern int executed_stmts_count;
extern int process_quantum;

/* Macro for possible switch the process.  Remeber cpc must be correct
   for resuming the current process lately. */
#define QUANTUM_SWITCH_PROCESS\
  do {\
    if (++executed_stmts_count >= 0)\
      block_cprocess (cpc, FALSE);\
  } while (0)\

extern ER_node_t create_process (pc_t start_process_pc, IR_node_t func,
	                         ER_node_t func_context);
extern void block_cprocess (pc_t first_resume_pc, int wait_stmt_flag);
extern void delete_cprocess (void);
extern int delete_cprocess_during_exception (void);
extern void initiate_processes (pc_t start_pc);

extern void *external_address (IR_node_t decl);

extern void process_system_errors (const char *function_name);

extern void call_func_class (int_t pars_number);


#ifdef __GNUC__
extern void eval_error (IR_node_t error_decl, IR_node_t context_var,
			position_t position,
		        const char *format, ...) __attribute__ ((noreturn));
#else
extern void eval_error (IR_node_t error_decl, IR_node_t context_var,
			position_t position, const char *format, ...);
#endif
}

%%

/* Because objects can change their places (growing mutable objects or
   unpacking vector), we need the following nodes which are placed on
   place of first place of the object and refers for current place of
   the object (or another redirection).  The redirections do not
   survive GC.  Heap objects on which redirection refers for has the
   same (unique)number as original object. */
heap_redir :: heap_vect_tab
%other
  /* new_place, immutable, els_number are not used here. */
  redir : heap_vect_tab /* referenced object */
;

heap_stack
%other
  call_pc : pc_t
;

heap_process
%other
  /* Program counter which will be first after the resuming the process. */
  saved_pc : pc_t
;
