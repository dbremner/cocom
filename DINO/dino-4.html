<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>The Programming Language DINO: Declarations and Scope Rules</TITLE>
 <LINK HREF="dino-5.html" REL=next>
 <LINK HREF="dino-3.html" REL=previous>
 <LINK HREF="dino.html#toc4" REL=contents>
</HEAD>
<BODY>
<A HREF="dino-5.html">Next</A>
<A HREF="dino-3.html">Previous</A>
<A HREF="dino.html#toc4">Contents</A>
<HR>
<H2><A NAME="s4">4. Declarations and Scope Rules</A></H2>

<P>Dino program has block structure.  Each block introduces a new
identifier scope.  Block consists of executive statements and
declarations and may contains nested blocks.  Each identifier used in a
program should be declared in a declaration of the program, unless it
is a predeclared identifier.
<BLOCKQUOTE><CODE>
<PRE>
          Block = "{"  StmtList "}"

          StmtList = { Stmt }
        
          Stmt = ExecutiveStmt
               | Declaration
</PRE>
</CODE></BLOCKQUOTE>

Declaring identifier, you also specify certain permanent properties of
an declaration, such as whether it is a variable, a function, or a
class.  The identifier is then used to refer to the associated
declaration (more correctly with the declaration instance).
<BLOCKQUOTE><CODE>
<PRE>
          Declaration = VarDeclarations
                      | AccessClause
                      | ExternDeclarations
                      | FuncClassExtDeclaration
                      | IncludeDeclaration
</PRE>
</CODE></BLOCKQUOTE>

The scope of an declaration is textually from the start (not from the
point of declaration!) to the end of the block to which the declaration
belongs and hence to which the declaration is local.  It excludes the
scopes of declarations with the same identifier which are in nested
blocks.  In a block, maximum one declaration of the same identifier is
possible.
<P>It is important to understand notion of instantiation of the
declaration.  This notion reflects program execution not static
structure of program.  An instance exists in <EM>context</EM>.
Actually, context is execution environment consisting of covering
block instances or/and class objects.  A new instance of the block is
created when the block execution starts.  There may be more one
instance of the same block, e.g. when the block is a function or class
body (block instance in this case is a class object), or when the
block is executed on different threads (parallel execution branches)
or when there is a reference to block instance after its execution.
When new instance of the block starts, all the block declarations are
instantiated too.  For a variable declaration, it means new instance
of variable is created in given context.  For a function or class
declaration, it means that the function or class is bound to given
context.
<P>Examples: 
The following program illustrates case when a reference to
block instance exists after its execution.  The program outputs
result 8. 
<BLOCKQUOTE><CODE>
<PRE>
          var i, f;
        
          for (i = 0; i &lt; 10; i++)
            if (i % 4 == 0)
              {
                var j = i;
                func r () {return j;}
                f = r;
              }
          putln (f ());
</PRE>
</CODE></BLOCKQUOTE>
<P>Declaration is either private or public.  Private declaration is
accessible only inside the declaration scope or inside function or
class which are declared as friend in the declaration block.  Public
declaration instance is accessible always when association (see below)
of the identifier is successful.  By default, (instances of)
declarations in class block are public.  In all other places, the
(instances of) declarations are private by default.  The following
constructions are used for declaring identifier public, private, or as
friend:
<BLOCKQUOTE><CODE>
<PRE>
          AccessClause = (public | private | friend) AccessList ";"

          AccessList = IDENT { "," IDENT }
</PRE>
</CODE></BLOCKQUOTE>

Examples:
<BLOCKQUOTE><CODE>
<PRE>
          public param1, param2;
          private call_count;
          friend class2;
</PRE>
</CODE></BLOCKQUOTE>

Association of identifier and the declaration instance are performed
by the following rules:
<UL>
<LI>The corresponding declaration instance are searched for
separate identifier occurrence in the instance of the block in
which the identifier occurs.  If the previous failed, the
declaration is searched in covering block instance of the
current block instance.  And so on.</LI>
<LI>Declaration instance for identifier in the following
construction
<BLOCKQUOTE><CODE>
<PRE>
        designator.identifier
</PRE>
</CODE></BLOCKQUOTE>

is searched in block instance (e.g. in a class object) whose
value is in the designator.  If the designator is a class
object, its context is a class object, and the search failed,
the search is continued in the covering class object etc.
Exception <CODE>accessop</CODE> occurs if the declaration is not
found with such identifier, or the declaration is private and
the construction is not in the declaration scope and not
inside friend of the declaration scope.</LI>
<LI>Declaration instance for identifier whose name is
expression value in the following construction
<BLOCKQUOTE><CODE>
<PRE>
        *(expression)
</PRE>
</CODE></BLOCKQUOTE>

is searched in the same way as a separate identifier.
Exception <CODE>accessop</CODE> occurs if there is no instance of
declaration with such identifier in covering block instances.</LI>
<LI>Declaration for identifier in the following construction
<BLOCKQUOTE><CODE>
<PRE>
        (expression)->identifier
</PRE>
</CODE></BLOCKQUOTE>

is searched in analogous way as in construction
<CODE>designator.identifier</CODE> in block instance which is
value of the variable whose name is given by the expression.
The variable is searched in the same way as in construction
<CODE>*(expression)</CODE>.  Exception <CODE>accessop</CODE> occurs if
there is no variable instance with given name in covering
block instances, there is no instance of the declaration with
such identifier in given context (the variable value), or the
declaration is private and the construction is not in the
declaration scope.</LI>
</UL>

The following identifiers are predeclared on the top level (in implicit
block covering all program).  They are described in more detail in the
report later.
<BLOCKQUOTE><CODE>
<PRE>
  anode          argv           atan2
  chdir          chgmod         chomod         chumod
  clock          close          cmpv           context
  cos            curr_thread
  del
  eltype         env            errors         except
  excepts        exit           exp
  fatime         fctime         fget           fgetln
  fgmode         fgn            file           flush
  fmtime         fomode         fprint         fprintln
  fput           fputln         fscan          fscanln
  fsize          ftype          fumode         fun
  gc             get            getcwd         getegn
  geteun         getgn          getgroups      getln
  getpid         getun          gsub
  ins            inside         insv           invaccesses
  invcalls       invexterns     invindexes     invkeys
  invops         invparsers     invregexps     isatty
  keys
  log            log10
  main_thread    match          max            min
  mkdir
  open
  pclose         popen          pow            print
  println        put            putln
  rand           readdir        remove         rename
  rmdir
  scan           scanln         seek           signals
  sin            sort           split          split_regex
  sqrt           srand          stderr         stdin
  stdout         strtime        sub            subv
  syserrors      system         systemcalls
  tell           time           time_format    token
  tolower        toupper
</PRE>
</CODE></BLOCKQUOTE>

The following identifiers are predeclared in class <EM>except</EM> mentioned above.
<BLOCKQUOTE><CODE>
<PRE>
  error
</PRE>
</CODE></BLOCKQUOTE>

The following identifiers are predeclared in class <EM>error</EM> mentioned above.
<BLOCKQUOTE><CODE>
<PRE>
  deadlock
  invaccess      invcall        invenv         invindex
  invkey         invop
  signal
</PRE>
</CODE></BLOCKQUOTE>

The following identifiers are predeclared in class <EM>signal</EM> mentioned above.
<BLOCKQUOTE><CODE>
<PRE>
  sigabrt        sigfpe         sigill         sigint
  sigsegv        sigterm
</PRE>
</CODE></BLOCKQUOTE>

The following identifiers are predeclared in class <EM>invop</EM> mentioned above.
<BLOCKQUOTE><CODE>
<PRE>
  optype         opvalue
</PRE>
</CODE></BLOCKQUOTE>

The following identifiers are predeclared in class <EM>invindex</EM> mentioned above.
<BLOCKQUOTE><CODE>
<PRE>
  indexop        indextype      indexvalue
</PRE>
</CODE></BLOCKQUOTE>

The following identifiers are predeclared in class <EM>invkey</EM> mentioned above.
<BLOCKQUOTE><CODE>
<PRE>
  keyop          keyvalue
</PRE>
</CODE></BLOCKQUOTE>

The following identifiers are predeclared in class <EM>invcall</EM> mentioned above.
<BLOCKQUOTE><CODE>
<PRE>
  callop
  eof
  internal       invenvar       invextern      invinput
  invparser      invregexp      invresult
  parnumber      partype
  syserror       systemcall
</PRE>
</CODE></BLOCKQUOTE>

The following identifiers are predeclared in class <EM>syserror</EM> mentioned above.
<BLOCKQUOTE><CODE>
<PRE>
  eaccess        eagain         ebadf          ebusy
  echild         edeadlk        edom           eexist
  efault         efbig          eintr          einval
  eio            eisdir         emfile         emlink
  enametoolong   enfile         enodev         enoent
  enoexec        enolck         enomem         enospc
  enosys         enotdir        enotempty      enotty
  enxio          eperm          epipe          erange
  erofs          espipe         esrch          exdev
</PRE>
</CODE></BLOCKQUOTE>

The following identifiers are predeclared in class <EM>systemcall</EM> mentioned above.
<BLOCKQUOTE><CODE>
<PRE>
  noshell
  systemfail
</PRE>
</CODE></BLOCKQUOTE>

The following identifiers are predeclared in class <EM>invparser</EM> mentioned above.
<BLOCKQUOTE><CODE>
<PRE>
  invgrammar     invtoken
  pmemory
</PRE>
</CODE></BLOCKQUOTE>

The following identifiers are predeclared in class <EM>invregexp</EM> mentioned above.
<BLOCKQUOTE><CODE>
<PRE>
  badpat
  ebrack         ectype         eend           eescape
  eparen         erange         esize          espace
  esubreg
</PRE>
</CODE></BLOCKQUOTE>

The following identifiers are predeclared in class <EM>invextern</EM> mentioned above.
<BLOCKQUOTE><CODE>
<PRE>
  libclose
  noextern       noexternsupp
</PRE>
</CODE></BLOCKQUOTE>

The following identifiers are predeclared in class <EM>invaccess</EM> mentioned above.
<BLOCKQUOTE><CODE>
<PRE>
  accessop       accessvalue    arrowtype
  dereftype  
  immutable
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss4.1">4.1 Variable Declarations</A>
</H2>

<P>Dino is imperative language. In other words it has <EM>variables</EM>
which are named containers of values.  Variable can contain any value.
This means that DINO is a dynamic-type language.  Declaration of
variable also may define initial value of the variable.  Assigning of
the initial value to the variable instance is made after execution of
the previous statements of the block.  By default initial value of
variables is special value <B>nil</B>.  The value of variable can
not be changed after its initialization if its declaration contains
keyword <B>final</B>.
<BLOCKQUOTE><CODE>
<PRE>
          VarDeclarations = var  VarParList ";"

          VarParList = VarPar { "," VarPar }
        
          VarPar = [final] IDENT [ "="  Expr]
</PRE>
</CODE></BLOCKQUOTE>

Examples:
<BLOCKQUOTE><CODE>
<PRE>
          var i = 0, j, k;
          var final constant = 10, final nil_constant, l;
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss4.2">4.2 External Declarations</A>
</H2>

<P>Dino permits to use functions written on other languages, e.g. C.  The
functions should have special prototypes and can have to access to
DINO standard procedural interface (SPI).  Dino can also have access
to variables of special type declared in source code on other
language.  The details of such features implementation and DINO SPI
are not described here (some details are given in appendix B).  As
rule, the external functions and variables will be implemented as
dynamically loaded libraries.  This is powerful instrument of DINO
extension.  The external functions, variables are declared after
keyword <B>extern</B>.  The external function identifier is followed
by <CODE>()</CODE>.  All external declarations (e.g. in different blocks)
with the same identifier refer for the same external function or
variable.
<BLOCKQUOTE><CODE>
<PRE>
          ExternDeclarations = extern  ExternItem { "," ExternItem } ";"

          ExternItem = IDENT 
                     | IDENT  "(" ")"
</PRE>
</CODE></BLOCKQUOTE>

Examples:
<BLOCKQUOTE><CODE>
<PRE>
          extern function (), variable;
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss4.3">4.3 Functions, Classes, Extensions</A>
</H2>

<P>Function/class declaration consists of a function/class header and a
function/class block (body).  The header specifies the function
identifier and <EM>formal parameters</EM>.  Function can return the
result with the aid of statement <EM>return</EM>.  If the result value
after keyword return is absent or return statement is absent or is not
executed, the function returns <B>nil</B> by default.  Class call
returns an object of the class which can be considered as a block
instance of the class body.  Return-statement for classes must be
without result.  <EM>Thread-functions</EM> are analogous to general
functions.  The difference is in that a new execution <EM>thread</EM>
is created during the thread-function call, return-statement inside
thread-function must be without an expression, and thread-function
returns the corresponding (execution) thread.  The execution thread
finishes when the corresponding thread block finishes.  Execution
threads are executed parallelly.  Originally only one thread (so
called <EM>main thread</EM>) exists in DINO program.
<P>The formal parameters are considered to be declared in function/class
block and to be initialized by values of <EM>actual parameters</EM>
during call of the function/class.  The function can be called with
any numbers of <EM>actual parameters</EM>.  If the number of actual
parameters are less than the formal parameters number, the remaining
formal parameters are initialized by special value <B>nil</B>.
Otherwise if the number of actual parameters are more than the formal
parameters number, the remaining actual parameter values are ignored.
In order to process all actual parameters, you should place
<CODE>...</CODE> at the end of list of formal parameter declarations.
That means that formal parameter with identifier <CODE>args</CODE> will be
declared implicitly.  The value of the parameter will be vector whose
elements will be the remaining actual parameter values.  If the number
of actual parameters are less or equal to the number of formal
parameters (not taking implicit parameter <CODE>args</CODE> into account),
the value of <CODE>args</CODE> will be empty vector.  The formal parameter
can be initialized by default value in way analogous to variable
initialization.  The initialization is made only when the
corresponding actual parameter value is <B>nil</B>.
<P>Instead of inheritance usually used in object oriented languages, Dino
supports <EM>extension</EM>.  This feature permits to modify
function/class behaviour.  All inside extension bodies is inserted at
the end of body of function/class declared with the same identifier in
the same block in the same order as the extensions are placed in the
block.  Function/class declared as <EM>final</EM> can not be extended.
<BLOCKQUOTE><CODE>
<PRE>
          FuncClassExtDeclaration = Header Block

          Header = [final] FuncThreadClass IDENT FormalParameters
                 | ext IDENT

          FuncThreadClass = func 
                          | thread 
                          | class 
        
          FormalParameters = "("  [ VarParList ] ")"
                           | "("  VarParList "," "..."  ")"
                           | "(" "..."  ")"
</PRE>
</CODE></BLOCKQUOTE>

Examples:
<P>The following header is a parameterless class header.
<BLOCKQUOTE><CODE>
<PRE>
          class stack ()
</PRE>
</CODE></BLOCKQUOTE>

The following header is a class header with initialization
<BLOCKQUOTE><CODE>
<PRE>
          class stack (max_height = 100)
</PRE>
</CODE></BLOCKQUOTE>

The following function is a function with variable number parameters
<BLOCKQUOTE><CODE>
<PRE>
          func print_args (...)
            {
              for (i = 0; i &lt; #args; i++)
                println (args[i]);
            }
</PRE>
</CODE></BLOCKQUOTE>

The following illustrates usage of extensions
<BLOCKQUOTE><CODE>
<PRE>
           class point (x = 0, y = 0) {
           }
           ext point {
             class circle (radius = 1) {
               func square () {return 3.14 * radius * radius;}
             }
           }
           ext point {
             ext circle {
               class ellipse (width) {
                 func square () {
                   ...
                 }
               }
           }
</PRE>
</CODE></BLOCKQUOTE>

The following example illustrates threads.
<BLOCKQUOTE><CODE>
<PRE>
          class buffer (length = 3) {
            var b = [length:nil], first = 0, free = 0, empty = 1;
            private b, first, free, length;
            func consume () {
              var res;
          
              wait !empty;
              res = b [first];
              first = (first + 1) % length;
              empty = first == free;
              return res;
            }
            func produce (val) {
              wait empty || free != first;
              b [free] = val;
              free = (free + 1) % length;
              empty = 0;
            }
          }
          
          thread consumer (buffer) {
              func produce (val) {
                buffer.produce (val);
                put ("produce: ");
                println (val);
              }
              produce (10);
              produce (10.5);
              produce ("string");
              produce ('c');
              produce (nil);
          }
          
          thread producer (buffer) {
            var val;
          
            for (;;) {
              val = buffer.consume ();
              if (val == nil)
                break;
              put ("consume: ");
              println (val);
            }
          }
          
          var queue = buffer ();
          consumer (queue);
          producer (queue);
</PRE>
</CODE></BLOCKQUOTE>
<P>
<HR>
<A HREF="dino-5.html">Next</A>
<A HREF="dino-3.html">Previous</A>
<A HREF="dino.html#toc4">Contents</A>
</BODY>
</HTML>
