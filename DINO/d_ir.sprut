/*
   Copyright (C) 1997-2013 Vladimir Makarov.

   Written by Vladimir Makarov <vmakarov@users.sourceforge.net>

   This file is part of interpreter of DINO.

   This is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This software is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GNU CC; see the file COPYING.  If not, write to the Free
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.

*/

/* Value of node pointer to erroneous (syntactically or semantically)
   constructions is NULL.  But this value may be also used for representation
   of correct program.

   After semantic analysis idents are changed by corresponding
   decl occurrence. */

%import {

#include "d_common.h"

/* Structures representing binary_operation_node and unary_operation_node
   have member of its mode.  EVT is abbreviation of expr value type.
   The order of enumeration constants is important. */

enum expr_value_type
{
  /* To correctly initiate nodes' member value_type of this enumeration
     constant is to be equal to the following value. */
  EVT_UNKNOWN = 0,
  EVT_CHAR = 1,
  EVT_INT = 2,
  EVT_FLOAT = 4,
  EVT_VECTOR = 8,
  EVT_TABLE = 16,
  EVT_FUNC = 32,
  EVT_CLASS = 64,
  EVT_TYPE = 128,
  EVT_SLICE = 256
};

/* This is mask for number. */
#define EVT_NUMBER_MASK (EVT_CHAR | EVT_INT | EVT_FLOAT)
/* This is mask for int or vector. */
#define EVT_INT_VECTOR_MASK (EVT_INT | EVT_VECTOR)
/* This is mask for number or vector. */
#define EVT_NUMBER_VECTOR_MASK (EVT_CHAR | EVT_INT | EVT_FLOAT | EVT_VECTOR)
/* This is mask for number, vector, or table. */
#define EVT_NUMBER_VECTOR_TABLE_MASK\
   (EVT_CHAR | EVT_INT | EVT_FLOAT | EVT_VECTOR  | EVT_TABLE)
/* This is mask for number or string. */
#define EVT_NUMBER_STRING_MASK EVT_NUMBER_VECTOR_MASK
/* This is mask for vector or slice. */
#define EVT_VECTOR_SLICE_MASK (EVT_VECTOR | EVT_SLICE)
/* This is mask for table or slice. */
#define EVT_TABLE_SLICE_MASK (EVT_TABLE | EVT_SLICE)
/* This is mask for number, vector, or slice. */
#define EVT_NUMBER_VECTOR_SLICE_MASK (EVT_NUMBER_VECTOR_MASK | EVT_SLICE)
/* This is mask for number, vector, table, or slice. */
#define EVT_NUMBER_VECTOR_TABLE_SLICE_MASK \
  (EVT_NUMBER_VECTOR_TABLE_MASK | EVT_SLICE)

typedef enum expr_value_type expr_value_type_t;

typedef int type_mask_t;

typedef int integer_t;

typedef const char *string_t;

typedef struct BC_node *BC_hidden_node_t;

enum access_val
{
  PRIVATE_ACCESS,
  PUBLIC_ACCESS,
  DEFAULT_ACCESS
};

typedef enum access_val access_val_t;

}

%export {

/* These macros for storage management of DINO internal representation: */

/* Start work with the storage manager -- see DINO documentation. */

#define IR_START_ALLOC()    OS_CREATE (irp, 0)

/* Finish work with the storage manager -- see DINO documentation. */

#define IR_STOP_ALLOC()     OS_DELETE (irp)

/* Allocate storage for internal representation of given size
   -- see DINO documentation. */

#define IR_ALLOC(ptr, size, ptr_type)\
  do {\
    OS_TOP_EXPAND (irp, size); ptr = (ptr_type) OS_TOP_BEGIN (irp);\
    OS_TOP_FINISH (irp);\
  } while (0);

/* Free storage of internal representation of given size -- see DINO
   documentation. */

#define IR_FREE(ptr, size)


/* These macros are analogous to ones of package `object-stack'
   worked with storage of DINO internal representation: */

/* Start new internal representation object -- see also package
   `object-stack'. */

#define IR_TOP_FINISH()  OS_TOP_FINISH (irp)

/* Nullify current internal representation object -- see also package
   `object-stack'. */

#define IR_TOP_NULLIFY()  OS_TOP_NULLIFY (irp)

/* Shorten current internal representation object on given number bytes -- see
   also package `object-stack'. */

#define IR_TOP_SHORTEN(length) OS_TOP_SHORTEN (irp, length)

/* Return start address of current internal representation object -- see also
   package `object-stack'. */

#define IR_TOP_BEGIN()  OS_TOP_BEGIN (irp)

/* Return length of current internal representation object in bytes -- see
   also package `object-stack'. */

#define IR_TOP_LENGTH()  OS_TOP_LENGTH (irp)

/* Expand current internal representation object -- see also package
   `object-stack'. */

#define IR_TOP_EXPAND(length)  OS_TOP_EXPAND (irp, length)

/* Add byte to the end of current internal representation object -- see also
   package `object-stack'. */

#define IR_TOP_ADD_BYTE(b)  OS_TOP_ADD_BYTE (irp, b)

/* Add string to the end of current internal representation object -- see also
   package `object-stack'. */

#define IR_TOP_ADD_STRING(str)  OS_TOP_ADD_STRING (irp, str)

/* Add memory of given length to the end of current internal representation
   object -- see also package `object-stack'. */

#define IR_TOP_ADD_MEMORY(mem, length)  OS_TOP_ADD_MEMORY (irp, mem, length)

extern os_t irp;


extern void initiate_table (void);
extern void delete_table (void);
extern IR_node_t *find_table_entry (IR_node_t ref, int reserve);
extern void include_to_table (IR_node_t ref);
extern IR_node_t find_unique_ident (char *string);
extern IR_node_t create_node (IR_node_mode_t mode);
extern IR_node_t create_node_with_pos (IR_node_mode_t mode, position_t pos);
extern IR_node_t create_unique_node_with_string (IR_node_mode_t m,
                                                 const char *str,
                                                 char **string_in_pool_ptr);
extern IR_node_t create_unique_ident_node (const char *str);
extern void initiate_icode (void);

extern IR_node_t find_decl_in_given_scope (IR_node_t ident, IR_node_t scope);
extern IR_node_t find_decl (IR_node_t ident, IR_node_t scope);
extern void set_environment_declarations (IR_node_t environment_scope);

extern IR_node_t get_ident_node (char *name, position_t pos);
extern IR_node_t get_int_node (int_t number_value, position_t pos);
extern IR_node_t get_float_node (floating_t number_value, position_t pos);

/* Variable name for the rest parameter values (...). */
#define ARGS_NAME "args"

/* This is name of varibale which will contains catdhed exception in
   corresponding catch block. */

#define CATCH_EXCEPTION_NAME "e"

extern IR_node_t temp_unique_ident;
extern IR_node_t temp_unique_int;
extern IR_node_t temp_unique_float;
extern IR_node_t temp_unique_char;
extern IR_node_t temp_unique_string;
extern IR_node_t temp_ident;
extern IR_node_t temp_decl;
extern IR_node_t destroy_unique_ident;

/* This is trick (usage that IR_NODE_MODE is macro)!!!  Therefore the
   following macro must apply to node with the same structure as node
   with mode m. */

#define IR_SET_MODE(v, m) (IR_NODE_MODE (v) = (m))

/* The macro call value is pointer to unique ident node of
   corresponding ident node V.  V may be NULL. */

#define IR_GET_UNIQUE_IDENT(v)\
  ((v) == NULL ? v : IR_unique_ident (v))

/* The following macro value is standard environment which is parsed
   before the program. The last character must be a space for correct
   parsing.  The last character of the string *should* be \n.  That is
   important for correct work OF REPL. */
#define ENVIRONMENT \
  "class except () { \n"\
  "  class error (msg = nil){\n"\
  "    class signal (msg = nil) {\n"\
  "      class sigint (msg = nil) {}\n"\
  "      class sigill (msg = nil) {}\n"\
  "      class sigabrt (msg = nil) {}\n"\
  "      class sigfpe (msg = nil) {}\n"\
  "      class sigterm (msg = nil) {}\n"\
  "      class sigsegv (msg = nil) {}\n"\
  "    }\n"\
  "    class invenv (msg = nil) {}\n"\
  "    class invop (msg = nil) {\n"\
  "      class optype (msg = nil) {}\n"\
  "      class opvalue (msg = nil) {}\n"\
  "    }\n"\
  "    class invindex (msg = nil) {\n"\
  "      class indextype (msg = nil) {}\n"\
  "      class indexvalue (msg = nil) {}\n"\
  "      class indexop (msg = nil) {}\n"\
  "    }\n"\
  "    class invslice (msg = nil) {\n"\
  "      class slicetype (msg = nil) {}\n"\
  "      class sliceform (msg = nil) {}\n"\
  "    }\n"\
  "    class invector (msg = nil) {\n"\
  "      class veclen (msg = nil) {}\n"\
  "      class vecform (msg = nil) {}\n"\
  "      class matrixform (msg = nil) {}\n"\
  "    }\n"\
  "    class invkey (msg = nil) {\n"\
  "      class keyvalue (msg = nil) {}\n"\
  "      class keyop (msg = nil) {}\n"\
  "    }\n"\
  "    class invcall (msg = nil) {\n"\
  "      class callop (msg = nil) {}\n"\
  "      class partype (msg = nil) {}\n"\
  "      class invresult (msg = nil) {}\n"\
  "      class invinput (msg = nil) {}\n"\
  "      class invfmt (msg = nil) {}\n"\
  "      class eof (msg = nil) {}\n"\
  "      class parnumber (msg = nil) {}\n"\
  "      class syncthreadcall (msg = nil) {}\n"\
  "      class syserror (msg = nil) {\n"\
  "        class eaccess (msg = nil) {}\n"\
  "        class eagain (msg = nil) {}\n"\
  "        class ebadf (msg = nil) {}\n"\
  "        class ebusy (msg = nil) {}\n"\
  "        class echild (msg = nil) {}\n"\
  "        class edeadlk (msg = nil) {}\n"\
  "        class edom (msg = nil) {}\n"\
  "        class eexist (msg = nil) {}\n"\
  "        class efault (msg = nil) {}\n"\
  "        class efbig (msg = nil) {}\n"\
  "        class eintr (msg = nil) {}\n"\
  "        class einval (msg = nil) {}\n"\
  "        class eio (msg = nil) {}\n"\
  "        class eisdir (msg = nil) {}\n"\
  "        class emfile (msg = nil) {}\n"\
  "        class emlink (msg = nil) {}\n"\
  "        class enametoolong (msg = nil) {}\n"\
  "        class enfile (msg = nil) {}\n"\
  "        class enodev (msg = nil) {}\n"\
  "        class enoent (msg = nil) {}\n"\
  "        class enoexec (msg = nil) {}\n"\
  "        class enolck (msg = nil) {}\n"\
  "        class enomem (msg = nil) {}\n"\
  "        class enospc (msg = nil) {}\n"\
  "        class enosys (msg = nil) {}\n"\
  "        class enotdir (msg = nil) {}\n"\
  "        class enotempty (msg = nil) {}\n"\
  "        class enotty (msg = nil) {}\n"\
  "        class enxio (msg = nil) {}\n"\
  "        class eperm (msg = nil) {}\n"\
  "        class epipe (msg = nil) {}\n"\
  "        class erange (msg = nil) {}\n"\
  "        class erofs (msg = nil) {}\n"\
  "        class espipe (msg = nil) {}\n"\
  "        class esrch (msg = nil) {}\n"\
  "        class exdev (msg = nil) {}\n"\
  "      }\n"\
  "      class systemcall (msg = nil) {\n"\
  "        class noshell (msg = nil) {}\n"\
  "        class systemfail (msg = nil) {}\n"\
  "      }\n"\
  "      class invregexp (msg = nil) {\n"\
  "        class ebrack (msg = nil) {}\n"\
  "        class erange (msg = nil) {}\n"\
  "        class ectype (msg = nil) {}\n"\
  "        class eparen (msg = nil) {}\n"\
  "        class esubreg (msg = nil) {}\n"\
  "        class eend (msg = nil) {}\n"\
  "        class eescape (msg = nil) {}\n"\
  "        class badpat (msg = nil) {}\n"\
  "        class esize (msg = nil) {}\n"\
  "        class espace (msg = nil) {}\n"\
  "      }\n"\
  "      class invparser (msg = nil) {\n"\
  "        class invgrammar (msg = nil) {}\n"\
  "        class invtoken (msg = nil) {}\n"\
  "        class pmemory (msg = nil) {}\n"\
  "      }\n"\
  "      class invextern (msg = nil) {\n"\
  "        class noextern (msg = nil) {}\n"\
  "        class libclose (msg = nil) {}\n"\
  "        class noexternsupp (msg = nil) {}\n"\
  "      }\n"\
  "      class invenvar (msg = nil) {}\n"\
  "      class internal (msg = nil) {}\n"\
  "    }\n"\
  "    class invaccess (msg = nil) {\n"\
  "      class accessop (msg = nil) {}\n"\
  "      class accessvalue (msg = nil) {}\n"\
  "      class immutable (msg = nil) {}\n"\
  "    }\n"\
  "    class deadlock (msg = nil) {}\n"\
  "    class syncwait (msg = nil) {}\n"\
  "  }\n"\
  "}\n"\
  "val excepts = except ();\n"\
  "val errors = excepts.error ();\n"\
  "val signals = errors.signal ();\n"\
  "val invops = errors.invop ();\n"\
  "val invindexes = errors.invindex ();\n"\
  "val invslices = errors.invslice ();\n"\
  "val invectors = errors.invector ();\n"\
  "val invkeys = errors.invkey ();\n"\
  "val invcalls = errors.invcall ();\n"\
  "val syserrors = invcalls.syserror ();\n"\
  "val systemcalls = invcalls.systemcall ();\n"\
  "val invregexps = invcalls.invregexp ();\n"\
  "val invparsers = invcalls.invparser ();\n"\
  "val invexterns = invcalls.invextern ();\n"\
  "val invaccesses = errors.invaccess ();\n"\
  "var argv, env; val version, main_thread, curr_thread;\n"\
  "class anode (name, transl) {}\n"\
  "class token (code) {}\n"\
  "val nil_anode = anode (\"$nil\", nil);\n"\
  "val error_anode = anode (\"$error\", nil);\n"\
  "final class parser ()\n"\
  "{\n"\
  "  var ambiguous_p;\n"\
  "  var -grammar;\n"\
  "\n"\
  "  func -int_earley_parse_grammar(){} func -int_earley_set_debug_level(){}\n"\
  "  func -int_earley_set_one_parse_flag (){}\n"\
  "  func -int_earley_set_lookahead_level (){}\n"\
  "  func -int_earley_set_cost_flag (){}\n"\
  "  func -int_earley_set_error_recovery_flag () {}\n"\
  "  func -int_earley_set_recovery_match (){} func -int_earley_parse (){}\n"\
  "  func -int_earley_create_grammar (){}\n"\
  "\n"\
  "  func set_grammar (descr, strict_p) {\n"\
  "    int_earley_parse_grammar (grammar, strict_p, descr);\n"\
  "  }\n"\
  "  func set_debug (level) {\n"\
  "    return int_earley_set_debug_level (grammar, level);\n"\
  "  }\n"\
  "  func set_one_parse (flag) {\n"\
  "    return int_earley_set_one_parse_flag (grammar, flag);\n"\
  "  }\n"\
  "  func set_lookahead (flag) {\n"\
  "    return int_earley_set_lookahead_level (grammar, flag);\n"\
  "  }\n"\
  "  func set_cost (flag) {\n"\
  "    return int_earley_set_cost_flag (grammar, flag);\n"\
  "  }\n"\
  "  func set_recovery (flag) {\n"\
  "    return int_earley_set_error_recovery_flag (grammar, flag);\n"\
  "  }\n"\
  "  func set_recovery_match (n_toks) {\n"\
  "    return int_earley_set_recovery_match (grammar, n_toks);\n"\
  "  }\n"\
  "  func parse (tokens, error_func) {\n"\
  "    var __i; // Trick to guarantee temp. vars to call error_func\n"\
  "    __i = 1 ^ 2 & (3 ^ 4 & (5 ^ 6 & (7 ^ 8 & (9 ^ 10 & (11 ^ 12 & 13)))));\n"\
  "    return int_earley_parse (grammar, tokens, error_func);\n"\
  "  }\n"\
  "\n"\
  "  grammar = int_earley_create_grammar ();\n"\
  "}\n"\
  "// Do not place any code inside file (it is only for internal purposes)\n"\
  "final class file (){\n"\
  "  var -file_ptr;\n"\
  "  throw invcalls.callop\n"\
  "    (\"File can be created only by functions open or popen\");}\n"\
  "val stdin;\n"\
  "val stdout;\n"\
  "val stderr;\n"\
  "func max (){} func min (){}\n"\
  "func tolower (){} func toupper (){} func transliterate (){}\n"\
  "func eltype (){}\n"\
  "func keys (){}\n"\
  "func context (){} func inside (){}\n"\
  "func subv(){} func cmpv(){} func del(){} func ins(){}  func insv(){}\n"\
  "func rev(){} func sort(){}\n"\
  "func sqrt (){} func exp (){} func log (){} func log10(){} func pow(){} \n"\
  "func sin(){} func cos(){} func atan2(){} \n"\
  "func match(){} func gmatch(){} func sub(){} func gsub(){}\n"\
  "func split(){} var split_regex = \"[ \t]+\";\n"\
  "func srand(){} func rand(){} \n"\
  "func __process_errno__() {} \n"\
  "func readdir(){} func ftype () {}\n"\
  "func fun(){} func fgn () {} func fsize(){}\n"\
  "func fatime() {} func fmtime(){} func fctime () {}\n"\
  "func fumode() {} func fgmode(){} func fomode () {}\n"\
  "func time(){}\n"\
  "func strtime() {} var time_format = \"%a %b %d %H:%M:%S %Z %Y\";\n"\
  "func clock(){}\n"\
  "func gc() {} \n"\
  "func rename() {} func remove(){}\n"\
  "func mkdir() {} func rmdir(){}\n"\
  "func getcwd() {} func chdir(){}\n"\
  "func chumod() {} func chgmod() {} func chomod() {} func isatty(){}\n"\
  "func open() {} func close(){} func flush(){}\n"\
  "func popen() {} func pclose(){}\n"\
  "func tell() {} func seek() {}\n"\
  "func put(){} func putln(){}\n"\
  "func fput(){} func fputln(){} func sput(){} func sputln(){}\n"\
  "func putf (){} func fputf (){} func sputf (){}\n"\
  "func print(){} func println(){}\n"\
  "func fprint(){} func fprintln(){} func sprint(){} func sprintln(){}\n"\
  "func get(){} func getln(){} func getf(){}\n"\
  "func fget(){} func fgetln(){} func fgetf(){}\n"\
  "func scan(){} func scanln(){} func fscan(){} func fscanln(){}\n"\
  "func getpid(){} func getun(){} func geteun(){}\n"\
  "func getgn(){} func getegn(){} func getgroups(){}\n"\
  "func system(){}\n"\
  "func exit(){}\n"\
  "func fold(){} func filter(){} func map(){}\n"\
  "func transpose(){}\n"\
  "func __init__() {} __init__();\n"
}

%local {
#include "d_common.h"

/* All internal representation storage is implemented by object stack.  See
   package `object-stack'. */

os_t irp;

IR_node_t temp_unique_ident;
IR_node_t temp_unique_int;
IR_node_t temp_unique_float;
IR_node_t temp_unique_char;
IR_node_t temp_unique_string;
IR_node_t temp_ident;
IR_node_t temp_decl;
IR_node_t destroy_unique_ident;

}

%type char_t int_t floating_t string_t integer_t bool_t position_t type_mask_t
      ticker_t BC_hidden_node_t access_val_t

%%

%abstract
ir_node :: %root
;

%abstract
generic_pos :: ir_node
%other
        /* The following field is set in context analyzer.  It is
	   important place it here to have the same field displacement
	   for all nodes.  It is important for interpreter speed.  */
        pos : position_t
;


/************* The following part are set in syntax analyzer **************/

/* Only char_node can refer to this node. */
unique_char :: ir_node
%other
        char_value : char_t
;

/* Only number_node can refer to this node. */
unique_int :: ir_node
%other
        int_value : int_t
;

unique_float :: ir_node
%other
        float_value : floating_t
;

unique_string :: ir_node
%other
        string_value : string_t
;

/* Only ident can refer to this node. */
unique_ident :: ir_node
%other
        ident_string : string_t
;

%abstract
expr :: generic_pos
;

%abstract
designator :: expr
;

/* After semantic analysis reference from any code node to the
   following node is changed on reference to node representing the
   corresponding object occurrence (e.g. var occurrence). */
ident :: designator
%other
        unique_ident : unique_ident /* always defined */
;

nil ::  expr;

char :: expr
%other
        unique_char : unique_char /* always defined */
;

int :: expr
%other
        unique_int : unique_int /* always defined */
;

float :: expr
%other
        unique_float : unique_float /* always defined */
;

string :: expr
%other
        unique_string : unique_string /* always defined */
;

%abstract
operation :: expr
;

/* The following structures are representing all binary and unary
   operation nodes. */
%abstract
binary_operation :: operation
%other
        left_operand, right_operand : expr
;

%abstract
unary_operation :: operation
%other
        operand : expr
;

%abstract
component_designator :: designator
%other
        designator : expr
        component : expr
;

in, or, xor, and, eq, ne, identity, unidentity, lt, gt, le, ge,
   lshift, rshift, ashift, concat, plus, minus,
   mult, div, mod :: binary_operation
;

%abstract
logical_binary_operation :: unary_operation
%other
        cont_operand : expr
;

logical_or, logical_and :: logical_binary_operation
;

/* conditional expression */
cond :: expr
%other
   cond_expr : expr
   true_expr : expr
   false_expr : expr
;

const, new, not, unary_plus, unary_minus, bitwise_not, length,
  fold_plus, fold_mult, fold_and, fold_xor, fold_or,
  typeof, charof, intof, floatof, vectorof, tableof,
  funcof, threadof, classof :: unary_operation
;

format_vectorof :: binary_operation
;

%abstract
index_designator :: component_designator
;

%abstract
vec_index_designator :: index_designator
;

index :: vec_index_designator
;

%abstract
key_index_designator :: index_designator
;

key_index :: key_index_designator
;

%abstract
period_designator :: component_designator
;

period :: period_designator
;

/* component for slice is the slice start.  */
slice :: index_designator
%other
        bound : expr
        step : expr
;

this :: expr
;

%abstract
type :: expr
;

/* The following nodes represent different types.  Type of nil is used
   only in the evaluator.  Actually there is no nodes `nil_type'. */
nil_type, hide_type, hideblock_type, char_type, int_type, float_type,
   vector_type, table_type,
   func_type, thread_type, class_type, stack_type, instance_type, process_type,
   type_type :: type
;

/* The following structure represents vector, table construction
   nodes. */
%abstract
vector_table :: expr
%other
        elist : elist_element
;

vector, table ::  vector_table
;

/* The following structure is representing expr list element
   nodes. */
elist_element :: generic_pos
%other
        /* Always null for actual parameters. */
        repetition_key : expr
        expr : expr
        /* Pointer to next expr list element (elist). */
        next_elist : elist_element
;

class_func_thread_call :: expr
%other
        /* Reference to expr that defines the called func. */
        func_expr : expr
        /* The following member refers to expr list representing
           actual parameter node. */
        actuals : elist_element
;

/* Identifier in a friend clause. */
friend_ident :: ir_node
%other
	ident_in_clause : ident
	next_friend_ident : friend_ident
;

%abstract
stmt :: generic_pos
%other
        next_stmt : stmt
;

%abstract
assign_stmt :: stmt
%other
        assignment_var : designator
        assignment_expr : expr
;

/* var_assign is an assign inside var-clause.  par_assign (or assign for
   parameter) if the parameter value is nil.  See also node
   par_assign_test. */
assign, mult_assign, div_assign, mod_assign,
plus_assign, minus_assign, concat_assign, lshift_assign,
rshift_assign, ashift_assign, and_assign, xor_assign, or_assign,
var_assign, par_assign :: assign_stmt
;

proc_call :: stmt
%other
        /* See commentaries for func call node. */
        proc_expr : expr
        proc_actuals : elist_element
;

if_stmt :: stmt
%other
        if_expr : expr
        /* Reference to stmts after keyword then. */
        if_part : stmt
        /* Reference to stmts after keyword else. */
        else_part : stmt
;

/* This node serves as test loop expr in interpreter. */
for_stmt :: stmt
%other
        /* Reference to the stmt which is first in the for-construction.*/
        for_initial_stmt : stmt
        for_guard_expr : expr
        /* Reference to the stmt which is last in the for-construction. */
        for_iterate_stmt : stmt
        /* Reference to stmts in given for-stmt. */
        for_stmts : stmt
;

foreach_stmt :: stmt
%other
        /* Reference to designator left to `in'.*/
        foreach_designator : designator
        /* Reference to table right to `in'.*/
        foreach_table : expr
        /* Reference to stmts in given for-stmt. */
        foreach_stmts : stmt
;

%abstract
for_break_contintue :: stmt
;

break_stmt, continue_stmt :: for_break_contintue
;

return_without_result :: stmt
;

return_with_result :: stmt
%other
        /* Reference to expr after keyword return. */
        returned_expr : expr
;

throw :: stmt
%other
        /* Reference to expr (instance value) after keyword THROW. */
        throw_expr : expr
;

wait_stmt :: stmt
%other
        /* Reference to expr after keyword wait. */
        wait_guard_expr : expr
	/* Wait stmt.  */
        wait_stmt : stmt
;

/* The following structure is representing block nodes. */
block :: stmt
%other
        /* This member is defined for all blocks. */
        block_scope : block
        /* Reference to stmts in given block. */
        block_stmts : stmt
        /* Reference to corresponding func or class (NULL for
           separate block) or extension (only before the evaluation). */
        func_class_ext : func_class_ext
        /* Lists of identifiers in friend clauses. */
        friend_list : friend_ident
        /* The list of exceptions for TRY block, NULL for simple
           block. */
        exceptions : exception
;

exception :: generic_pos
%other
          exception_class_expr : expr
          /* The following field is not NULL only for the first
             identifier in the exception list. */
          catch_block : block
          next_exception : exception
;

%abstract
decl :: stmt
%other
        scope : block
        ident : ident
	access : access_val_t
	/* Flag of that this (external) var is constant (can not be
	   changed). */
	const_flag : bool_t
;

%abstract
external_decl :: decl
;

/* The following node represents formal parameter of funcs and classes
   too. */
var :: decl
%other
	/* Flag of that this var is created from a formal parameter
	   with default value. */
        par_assign_flag : bool_t {$ = FALSE;}
;

/* The following node represents external variable declaration. */
external_var :: external_decl
;

/* The following node represents formal parameter of funcs and classes
   too. */
pub :: decl
;

/* The following node represents external function declaration. */
external_func :: external_decl
;

%abstract
func_class_ext :: decl
;

%abstract
func_or_class :: func_class_ext
        /* The next stmt is always corresponding block node if it is
	   not forward declaration. */
%other
        /* Number of parameters of the func.  The formal
           parameters are the start vars in the func block.  The
           number takes into account variable for `...' too. */
        parameters_number : integer_t
        /* Number of minimal actual parameters for the func.  It is
	   actually number of first formal parameters without default
	   value. */
        min_actual_parameters_number : integer_t
	/* Flag of that args must be defined.  In order words ... is
           used. */
	args_flag : bool_t
	/* Flag of that this is final (can not be extended). */
	final_flag : bool_t
        /* TRUE if it is a just forward declaration. */
        forward_decl_flag : bool_t
;

/* The first nodes in corresponding block is func parameter
   represented by var nodes.  Its scope is this block. */
func :: func_or_class
%other
	/* Thrue if this true. */
	thread_flag : bool_t
;

/* See commentaries for func node. */
class :: func_or_class
;

/* Extensions are absent during evaluation and the most of context
   analysis. */
ext :: func_class_ext
;

/************* The following part is set in context analyzer **************/

ident
%other
        decl : decl
;

unique_ident
%other
        /* If the following member is negative than the ident is
           not used for access to any block decl.  Otherwise
           the member value is number of the ident in all
           idents used for access to any block decl.  This
           member must be initiated by negative value for the node
           creation time. */
        block_decl_ident_number : integer_t {$ = -1;}
        /* If the following member is TRUE than the ident is
           decalared in some block. */
        it_is_declared_in_block : bool_t
;

expr
%other
	/* Possible types of value of given operation. */
        value_type : type_mask_t
;

vector_table
%other
        /* Number of elements in the list elist. */
        parts_number : integer_t
;

class_func_thread_call
%other
        /* Number of elements in the list actuals. */
        class_func_thread_call_parameters_number : integer_t
;

slice
%other
        /* Dimension of the slice.  In other words, how many triples
	   (start, bound, step) is in the final slice.  */
        dim : int_t {$ = 1;}
;

proc_call
%other
        /* Number of elements in the list proc_actuals. */
        proc_call_pars_number : integer_t
;

block
%other
        /* Number of all blocks which contain given block. */
        block_level : integer_t
        /* Number of vars immediately placed in given block. */
        vars_number : integer_t {$ = 0;}
        /* Number of temporary vars needed for expr
           evaluation in given block. */
        temporary_vars_number : integer_t {$ = 0;}
        /* See the following comment.  The field value is NULL if the
	   corresponding block is not try-block. */
        catch_list_pc : generic_pos
        /* The following flag is TRUE if the block contains a
	   declaration. */
        decls_flag : bool_t {$ = FALSE;}
        /* The following flag is TRUE if an instance of the block may
           be used after block execution finish.  It is possibly if
           there is a function or class value is assigned to variable,
           passed as parameter, returned as function result or became
           as vector/table element.  This flag is used to solve can we
           try to pop block instance after its execution and as
           consequence to decrease number of GC.  We could be more
           accurate in several ways:
             o Check only function/class inside the block.
             o Check that vector whose element is the function class
               is assigned to, passed as parameter, returned as
               function result or became as vector/table element. */
        extended_life_context_flag : bool_t {$ = FALSE;}
        /* The following is the list of friends of the block. */
        friends : friend {$ = NULL;}
        bc_block : BC_hidden_node_t {$ = NULL;} /* Byte code block */
;

/* The following is a node of the list of friends of block (it means
   that the friend (all blocks inside it) can have access to the block
   private declarations). */
friend :: ir_node
%other
        friend_decl : decl
        next_friend : friend
;

decl
%other
        /* The following field is the first friend ident if the decl
           ident is in an friend clause. */
	friend_ident : friend_ident
        bc_decl : BC_hidden_node_t {$ = NULL;} /* Byte code decl */
;

func_or_class
%other
	/* Order number of the function or class.  */
	no : int_t {$ = -1;}
;

class
%other
        /* True if there is no statements in class block.  */
        simple_class_flag : bool_t {$ = FALSE;}
;

external_func
%other
	/* Order number of the external function.  */
	no : int_t {$ = -1;}
;

var
%other
        /* Number (0, ...) of the var (only immediatly placed) in
           block vars.  The numeration of vars in func starts with 0. */
        var_number_in_block : integer_t
;

/************* The following part is set in evaluator **************/

func_or_class
%other
        /* Number of function/class calls. */
        calls_number : integer_t {$ = 0;}
	/* Time of function (class body) execution.  Defined if the
	   previous field is not zero. */
        exec_time : ticker_t
        interrupts_number : integer_t
;

external_decl
%other
        /* Address of loaded external. */
        address : string_t {$ = NULL;}
;
  
block
%other
        /* The following field is cached address of container for the
           current block.  The cached value is not
           defined if cached_container_tick is not equal to the
           current value. */
	cached_container_address : string_t
	cached_container_tick : integer_t {$ = -1;}
        /* The following field is set up on enter of the block.  */
        block_saved_sync_flag : bool_t
;

%%

#define IR_PTR(p) ((IR_node_t) p)

/* Funcs for work with code node hash table.  The table contains pointers
   to code nodes representing unique idents, values (cardinal, integer
   and etc.), decls (i.e. nodes having members ident and scope). */

/* The node hash table. */

static hash_table_t node_hash_table;

/* Func for evaluation of hash value of code node represented by EL_PTR. */

static unsigned
hash_func (hash_table_entry_t el_ptr)
{
  IR_node_t node_ref;
  IR_node_mode_t mode;
  const char *chp;
  char ch;
  int_t int_number;
  floating_t float_number;
  size_t i, size, hash_value;

  node_ref = IR_PTR (el_ptr);
  mode = IR_NODE_MODE (node_ref);
  if (mode == IR_NM_var || mode == IR_NM_external_var
      || mode == IR_NM_external_func || mode == IR_NM_func
      || mode == IR_NM_class || mode == IR_NM_ext)
    hash_value
      = ((unsigned) (long) IR_scope (node_ref)
	 + (unsigned) (long) IR_GET_UNIQUE_IDENT (IR_ident (node_ref)));
  else
    {
      if (mode == IR_NM_unique_char)
	{
	  size = sizeof (char_t);
          ch = IR_char_value (node_ref);
	  chp = &ch;
	}
      else if (mode == IR_NM_unique_int)
	{
	  size = sizeof (int_t);
          int_number = IR_int_value (node_ref);
	  chp = (char *) &int_number;
	}
      else if (mode == IR_NM_unique_float)
	{
	  size = sizeof (floating_t);
          float_number = IR_float_value (node_ref);
	  chp = (char *) &float_number;
	}
      else if (mode == IR_NM_unique_string)
	{
	  chp = IR_string_value (node_ref);
	  size = strlen (chp);
	}
      else if (mode == IR_NM_unique_ident)
	{
	  chp = IR_ident_string (node_ref);
	  size = strlen (chp);
	}
      else
	d_unreachable ();
      for (hash_value = 0, i = 0; i < size; i++, chp++)
	hash_value += (*chp) << (i & 0xf);
    }
  return hash_value;
}

/* Func used for comparison of hash table elements represented by EL1_PTR,
   EL2_PTR.  Return TRUE if the elements represent equal nodes. */

static int
compare_func (hash_table_entry_t el1_ptr, hash_table_entry_t el2_ptr)
{
  IR_node_t node_ref1, node_ref2;
  IR_node_mode_t mode1, mode2;
  int elements_are_equal;

  node_ref1 = IR_PTR (el1_ptr);
  node_ref2 = IR_PTR (el2_ptr);
  mode1 = IR_NODE_MODE (node_ref1);
  mode2 = IR_NODE_MODE (node_ref2);
  if ((mode1 == IR_NM_var || mode1 == IR_NM_external_var
       || mode1 == IR_NM_external_func || mode1 == IR_NM_func
       || mode1 == IR_NM_class || mode1 == IR_NM_ext)
      && (mode2 == IR_NM_var || mode2 == IR_NM_external_var
	  || mode2 == IR_NM_external_func || mode2 == IR_NM_func
	  || mode2 == IR_NM_class || mode2 == IR_NM_ext))
    elements_are_equal
      = (IR_scope (node_ref1) == IR_scope (node_ref2)
	 && (IR_GET_UNIQUE_IDENT (IR_ident (node_ref1))
	     == IR_GET_UNIQUE_IDENT (IR_ident (node_ref2))));
  else
    {
      elements_are_equal = mode1 == mode2;
      if (elements_are_equal)
	{
	  if (mode1 == IR_NM_unique_ident)
	    elements_are_equal
	      = (strcmp (IR_ident_string (node_ref1),
			 IR_ident_string (node_ref2))
		 == 0);
	  else if (mode1 == IR_NM_unique_char)
	    elements_are_equal = (IR_char_value (node_ref1)
				  == IR_char_value (node_ref2));
	  else if (mode1 == IR_NM_unique_int)
	    elements_are_equal
	      = (IR_int_value (node_ref1) == IR_int_value (node_ref2));
	  else if (mode1 == IR_NM_unique_float)
	    elements_are_equal
	      = (IR_float_value (node_ref1) == IR_float_value (node_ref2));
	  else if (mode1 == IR_NM_unique_string)
	    elements_are_equal
	      = strcmp (IR_string_value (node_ref1),
                        IR_string_value (node_ref2)) == 0;
	  else
	    d_unreachable ();
	}
    }
  return elements_are_equal;
}

void
initiate_table (void)
{
  node_hash_table = create_hash_table (1000, hash_func, compare_func);
}

/* Delete the code node hash table. */

void
delete_table (void)
{
  delete_hash_table (node_hash_table);
}

/* Find pointer to the code node hash table entry which contains pointer to
   node with the same keys as in node starting with REF or else the empty entry
   (its value is NULL).  If RESERVE is TRUE than the empty entry is reseved
   and must be filled by node with the same keys as in node starting with
   REF. */

IR_node_t *
find_table_entry (IR_node_t ref, int reserve)
{
  return
    (IR_node_t *) find_hash_table_entry (node_hash_table,
					  (hash_table_entry_t) ref, reserve);
}

/* Include node starting with REF to the code node hash table.  If node with
   the same keys is already in the table than delete it and include the node
   starting with REF to the table. */

void
include_to_table (IR_node_t ref)
{
  IR_node_t *table_entry_pointer;

  table_entry_pointer = find_table_entry (ref, TRUE);
  *table_entry_pointer = ref;
}

/* Return pointer to unique ident node with the hash table key STRING. */

IR_node_t
find_unique_ident (char *string)
{
  IR_node_t result;

  IR_set_ident_string (temp_unique_ident, string);
  result = (*find_table_entry (temp_unique_ident, FALSE));
  return result;
}

/* Allocate memory for node with given mode and initiate its mode. */

IR_node_t
create_node (IR_node_mode_t mode)
{
  return IR_create_node (mode);
}

/* Allocate memory for node with given mode and initiate its common
   members MODE and POS. */

IR_node_t
create_node_with_pos (IR_node_mode_t mode, position_t pos)
{
  IR_node_t ref;

  ref = IR_create_node (mode);
  IR_set_pos (ref, pos);
  return ref;
}

/* Allocate memory for node with given mode and string attribute and
   initiate its common member mode.  Return pointer to the string
   attribute STR through parameter string_in_pool_ptr.  Nodes with string
   attribute are unique string, unique ident. */

IR_node_t
create_unique_node_with_string (IR_node_mode_t m,
				const char *str, char **string_in_pool_ptr)
{
  IR_node_t ref;

  ref = IR_create_node (m);
  IR_TOP_EXPAND (strlen (str) + 1);
  *string_in_pool_ptr = IR_TOP_BEGIN ();
  IR_TOP_FINISH ();
  strcpy (*string_in_pool_ptr, str);
  return ref;
}

/* Create unique ident with name STR (allocate memory, copy attribute
   in pool, initiate members and include to the hash table if the unique
   ident does not exist).  Only this func must be used for creation
   of unique ident because only this func initiates correctly some
   members. */

IR_node_t
create_unique_ident_node (const char *str)
{
  IR_node_t ref;
  char *string_in_pool;

  IR_set_ident_string (temp_unique_ident, (char *) str);
  ref = *find_table_entry (temp_unique_ident, FALSE);
  if (ref == NULL)
    {
      ref = create_unique_node_with_string (IR_NM_unique_ident, str,
                                            &string_in_pool);
      IR_set_ident_string (ref, string_in_pool);
      /* The following means that the ident is not used for access to 
         any class decl. */
      IR_set_block_decl_ident_number (ref, -1);
      include_to_table (ref);
    }
  return ref;
}

/* This func should be invoked only one before any work with intermediate
   code but after initiation of table.  The func creates standard
   environment. */

void
initiate_icode (void)
{
  IR_start ();
  temp_unique_ident = IR_create_node (IR_NM_unique_ident);
  temp_unique_int = IR_create_node (IR_NM_unique_int);
  temp_unique_float = IR_create_node (IR_NM_unique_float);
  temp_unique_char = IR_create_node (IR_NM_unique_char);
  temp_unique_string = IR_create_node (IR_NM_unique_string);
  temp_ident = IR_create_node (IR_NM_ident);
  temp_decl = IR_create_node (IR_NM_var);
  destroy_unique_ident = create_unique_ident_node ("destroy");
}



/* This page contains func for searching for idents according to
   language visibility rules. */

/* The func returns pointer to decl with key (IDENT, SCOPE)
   or NULL if such decl does not exist.  IDENT is to be not NULL.
   SCOPE may be NULL. */

IR_node_t
find_decl_in_given_scope (IR_node_t ident, IR_node_t scope)
{
  IR_set_ident (temp_decl, ident);
  IR_set_scope (temp_decl, scope);
  return *find_table_entry (temp_decl, FALSE);
}

/* The func returns pointer to decl visible according language
   rule from SCOPE and designated by IDENT, or returns NULL if such
   decl does not exist.  IDENT is to be not NULL.
   SCOPE may be NULL. */

IR_node_t
find_decl (IR_node_t ident, IR_node_t scope)
{
  IR_node_t decl;

  d_assert (scope != NULL);
  for (;;)
    {
      decl = find_decl_in_given_scope (ident, scope);
      if (decl != NULL || scope == NULL)
	break;
      scope = IR_block_scope (scope);
    }
  return decl;
}



/* Return new identifier node with given NAME and POS. */

IR_node_t
get_ident_node (char *name, position_t pos)
{
  IR_node_t result;

  result = create_node_with_pos (IR_NM_ident, pos);
  IR_set_unique_ident (result, create_unique_ident_node (name));
  return result;
}

/* Return new int node with given NUMBER_VALUE and POS. */

IR_node_t
get_int_node (int_t number_value, position_t pos)
{
  IR_node_t result;
  IR_node_t unique_number_value_node;

  IR_set_int_value (temp_unique_int, number_value);
  unique_number_value_node = *find_table_entry (temp_unique_int, FALSE);
  if (unique_number_value_node == NULL)
    {
      unique_number_value_node = create_node (IR_NM_unique_int);
      IR_set_int_value (unique_number_value_node, number_value);
      include_to_table (unique_number_value_node);
    }
  result = create_node_with_pos (IR_NM_int, pos);
  IR_set_unique_int (result, unique_number_value_node);
  return result;
}


/* Return new number node with given NUMBER_VALUE and POS. */

IR_node_t
get_float_node (floating_t number_value, position_t pos)
{
  IR_node_t result;
  IR_node_t unique_number_value_node;

  IR_set_float_value (temp_unique_float, number_value);
  unique_number_value_node = *find_table_entry (temp_unique_float, FALSE);
  if (unique_number_value_node == NULL)
    {
      unique_number_value_node = create_node (IR_NM_unique_float);
      IR_set_float_value (unique_number_value_node, number_value);
      include_to_table (unique_number_value_node);
    }
  result = create_node_with_pos (IR_NM_float, pos);
  IR_set_unique_float (result, unique_number_value_node);
  return result;
}

/*
Local Variables:
mode:c
End:
*/
