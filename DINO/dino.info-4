This is dino.info, produced by makeinfo version 4.3 from
/tmp/linuxdoc-dir-8068/sgmltmp.dino.info.2.

   \input texinfo


File: dino.info,  Node: File output functions,  Next: File input functions,  Prev: Functions for work with files-,  Up: File functions

File output functions
.....................

   The following functions are used to output something into opened
files.  All the functions always return the value `nil'.  The functions
may generate an exception declared in the class `syserror' (e.g. `eio',
`enospc' and so on) besides the standard `partype', and `parnumber'.
   * `put (...)'.  All parameters should be strings after implicit
     string conversion.  The function outputs all strings into the
     standard output stream.

   * `putln (...)'.  The function is analogous to the function `put'
     except for the fact that it additionally outputs a new line
     character after output of all the strings.

   * `fput (fileinstance, ...)'.  The function is analogous to the
     function `put' except for the fact that it outputs the string into
     an opened file associated with a class `file' instance which is
     the first parameter value.

   * `fputln (fileinstance, ...)'.  The function is analogous to
     function `fput' except for the fact that it additionally outputs a
     new line character after output of all the strings.

   * `putf (format, ...)'.  The first parameter should be strings after
     implicit string conversion.  The function outputs the rest of
     parameters according to the format.  The number of the rest
     parameters should be exactly equal to the conversions (including
     parameterized widths and precisions) in the format.  Otherwise,
     exception `parnumber' will be generated.  The types of the
     parameter should correspond to the corresponding conversion
     specifier (or to be integer for parameterized widths and
     precisions).  If it is not true, exception `partype' will be
     generated.  The format is subset of one of standard C function
     `printf' and has the following syntax:
                    format : <any character except %>
                           | '%' flags [width] [precision]
                                 conversion_specifier
                    flags :
                          | flag
          
                    flag : '#' | '0' | '-' | ' ' | '+'
          
                    width : '*' | <decimal number starting with non-zero>
          
                    precision : '.' ['*' | <decimal number>]
          
                    conversion_specifier : 'd' | 'o' | 'x' | 'X'
                                         | 'e' | 'E' | 'f' | 'F'
                                         | 'g' | 'G' | 'a' | 'A'
                                         | 'c' | 's' | '%'

     If the format syntax is wrong, exception `invfmt' is generated.

     Flag '#' means that the value should be converted into an
     alternative form.  It can be present only for conversion
     specifiers 'o', 'x', 'X', 'e', 'E', 'f', 'F', 'g', 'G', 'a', and
     'A'.  If the flag is used for conversion specifier 'o', the output
     will be prefixed by '0'.  For 'x' and 'X' the output will be
     prefixed by '0x' and '0X' correspondingly. For conversions 'a',
     'A', 'e', 'E', 'f', 'F', 'g', and 'G' the output will always
     contain a decimal point.  For conversions 'g' and 'G' it also
     means that trailing zeros are not removed from the output as they
     would be without the flag.  The following code using flag '#' in
     format
                   putf ("->%#o %#x %#a %#.0e %#.0f %#g\n",
                         8, 10, 1., 2., 3., 4.);

     will output
                   ->010 0xa 0x1.p+0 2.e+00 3. 4.00000

     Flag '0' means that the output value will be zero padded on the
     left. If both flags '0' and '-' appear, the flag '0' is ignored.
     It is also ignored for conversions 'd', 'o', 'x', and 'X' if a
     precision is given.  The flag is prohibited for conversions 'c'
     and 's'.  The following code using flag '0' in format
                   putf ("->%04d %04x %012.2a %09.2e %05.2f %05.2g\n",
                         8, 10, 1., 2., 3., 4.);

     will output
                   ->0008 000a 0x0001.00p+0 02.00e+00 03.00 00004

     Flag '-' means that the output will be left adjusted on the field
     boundary.  (The default is right justification). Flag '-'
     overrides flag '0' if the both are given.  The following code
     using flag '-' in format
                   putf ("->%-04d %-04x %-012.2a %-09.2e %-05.2f %-05.2g\n",
                         8, 10, 1., 2., 3., 4.);

     will output
                   ->8    a    0x1.00p+0    2.00e+00  3.00  4

     Flag ' ' means that the output of a signed number will start with
     a blank for positives number.  The flag can be used only for
     conversions 'd', 'a', 'A', 'e', 'E', 'f', 'F', 'g', and 'G'.  If
     both flags ' ' and '+' appear, the flag ' ' is ignored.  The
     following code using flag ' ' in format
                   putf ("->% d % .2a % .2e % .2f % .2g\n",
                         8, 1., 2., 3., 4.);

     will output
                   -> 8  0x1.00p+0  2.00e+00  3.00  4

     Flag '+' means that the output of a signed number will start with
     a plus for positives number.  The flag can be used only for
     conversions 'd', 'a', 'A', 'e', 'E', 'f', 'F', 'g', and 'G'.  Flag
     '+' overrides flag ' ' if both are given.  The following code
     using flag '+' in format
                   putf ("->%+d %+.2a %+.2e %+.2f %+.2g\n",
                         8, 1., 2., 3., 4.);

     will output
                   ->+8 +0x1.00p+0 +2.00e+00 +3.00 +4

     The width defines a minimum width of the output value.  If the
     output is smaller, it is padded with spaces (or zeros - see flag
     '0') on the left (if flag '-' is used) or right.  The output is
     never truncated.  The width should be no more than maximal integer
     value, otherwise exception `invfmt' is generated.  The width can
     be given as a parameter of integer type if '*' is used.  If the
     value of width given by the parameter is negative, flag '-' is
     believed to be given and the width is believed to be equal to
     zero.  The following code using width in format
                   putf ("->%5d %05d %-5d %*d %*d<-\n", 8, 9, 10, 5, 8, -5, 10);

     will output
                   ->    8 00009 10        8 10   <-

     The precision is prohibited for conversions 'c'.  If the number
     after the period is absent, its value will be zero.  The precision
     can be given as a parameter of integer type if '*' is used after
     the period.  If the value of precision given by the parameter is
     negative, its value is believed to be zero too.  For conversions
     'd', 'o', 'x', and 'X' the precision means minimum number of
     output digits.  For conversions 'a', 'A', 'e', 'E', 'f', and 'F'
     it means the number of digits to appear after the decimal point.
     For 'g' and 'G' it means the maximum number of significant digits.
     For 's' it means the maximum number of characters to be output
     from a string.  The following code using precision in format
                   putf ("->%.d %.0d %.5d %.0f %.0e %.2g<-\n",
                         8, 8, 9, 1.6, 2.3, 3.53);
                   putf ("->%.2s %.0d %.*d %.*d<-\n", "long", 0, 5, 8, -5, 8);

     will output
                   ->8 8 00009 2 2e+00 3.5<-
                   ->lo  00008 8<-

     Conversion 'd' should be used to output integer.  The default
     precision is 1.  When 0 is output with an explicit precision 0,
     the output is empty.

     Conversions 'o', 'x', and 'X' should be used to output an integer
     value as unsigned in octal and hexadecimal form.  The lower case
     letters `abcdef' are used for 'x' and the upper case letters
     `ABCDEF' are used for 'X'.  The precision gives the minimum number
     of digits that must appear. If the output value requires fewer
     digits, it is padded on the left with zeros.  The default
     precision is 1.  When 0 is output with an explicit precision 0,
     the output is empty.

     Conversions 'f' and 'F' should be used to output floating point
     values.  The output value has a form `[-]ddd.ddd' where the number
     of digits after the decimal point is given by the precision
     specification.  The default precision value is 6.  If the
     precision is explicitly zero, no decimal-point character appears.

     Conversions 'e' and 'E' should be used to output floating point
     values with an exponent in form `[-]d.ddd[e|E][+|-]dd'.  There is
     always one digit before the decimal-point.  The number of digits
     after the decimal point is defined by the precision.  The default
     precision value is 6.  If the precision is zero, no decimal-point
     appears.  Conversion 'E' uses the letter `E' (rather than `e') to
     introduce the exponent.  The exponent always contains at least two
     digits.  If the exponent value is zero, the exponent is output as
     `00'.

     Conversions 'g' and 'G' should be used to output floating point
     values in style 'f' or 'e' (or 'F' or 'E' for conversion 'G').
     The precision defines the number of significant digits.  The
     default value of the precision is 6.  If the precision is zero, it
     is treated as 1.  Conversion 'e' is used if the exponent from the
     conversion is less than -4 or not less than the precision.
     Trailing zeros are removed from the fractional part of the output.
     If all fractional part is zero, the decimal point is removed too.

     Conversion 'a' and 'A' should be used to output floating point
     values in hexadecimal form `[-]0[x|X]h.hhhh[p|P][+|-}d'.  For
     conversion 'a' the prefix `0x', the exponent separator `p', and
     the letters `abcdef' are used.  For 'A' the corresponding upper
     case letters are used.  There is always one hexadecimal digit
     before the decimal point, and the number of digits after it is
     equal to the precision.  The default precision suffices for an
     exact representation of the value if an exact representation in
     base 2 exists and otherwise is sufficiently large to distinguish
     all floating point values.  The digit before the decimal point is
     always nonzero for normalized numbers.

     Conversion 'c' should be used to output a character value.

     Conversion 's' should be used to output strings.

     Conversion '%' should be used to output `%'.

     The following code using different conversions in format
                   putf ("->%% %c %s %d %o %x %X<-\n",
                         'c', "string", 7, 8, 20, 20);
                   putf ("->%a %A %f %F<-\n", 1.25, 1.2, 1.5, 1.5);
                   putf ("->%e %E %g %G %g %G<-\n",
                         2.8, 2.8, 3.7, 3.7, 455555555.555, 5.9e-5);

     will output
                   ->% c string 7 10 14 14<-
                   ->0x1.4p+0 0X1.3333333333333P+0 1.500000 1.500000<-
                   ->2.800000e+00 2.800000E+00 3.7 3.7 4.55556e+08 5.9E-05<-

   * `fput (fileinstance, format, ...)'.  The function is analogous to
     the function `putf' except for the fact that it outputs the string
     into an opened file associated with a class `file' instance which
     is the first parameter value.

   * `print (...)'.  The function outputs all parameter values into
     standard output stream.  The function never makes implicit
     conversions of the parameter values.  The parameter values are
     output as they could be represented in Dino itself (e.g. character
     `'c" is output as `'c", vector `['a', 'b', 'c']' is output as
     `"abc"', vector `[10, 20]' as `[10, 20]' and so on).  As you know
     some values (functions, classes, block instances, class instances,
     threads) are not represented fully in DINO.  Such values are
     represented schematically.  For example, the output `func f
     {}.g(unique_number)' would mean function `f' in the call of
     function (or class) `g' with the given unique number and function
     g is in the instance of the implicit block covering the whole
     program.  For the function `g', output would look simply like `func
     g' because there is only one instance of the implicit block
     covering the whole program.  Output for an instance of the class
     `c' in the function `f' looks like `instance
     {}.f(unique_number).c(unique_number)'.  Output for a block
     instance of the function `f' looks like `stack
     {}.f(unique_number)'.  Output for a thread whose thread-function
     `t' is declared in the function `f' would look like `thread
     unique_number {}.f(unique_number).t(unique_number)'.

   * `println (...)'.  The function is analogous to the function
     `print' except for the fact that it additionally outputs new line
     character after output of all parameters.

   * `fprint (fileinstance, ...)'.  The function is analogous to the
     function `print' except for the fact that it outputs the
     parameters into an opened file associated with a class `file'
     instance which is the value of first parameter.

   * `fprintln (fileinstance, ...)'.  The function is analogous to
     function `fprint' except for the fact that it additionally outputs
     a new line character after the output of all the parameters.


File: dino.info,  Node: File input functions,  Prev: File output functions,  Up: File functions

File input functions
....................

   The following functions are used to input something from opened
files.  All the functions always return the value `nil'.  The functions
may generate an exception declared in the class `syserror' (e.g. `eio',
`enospc' and so on) or `eof' besides the standard `partype', and
`parnumber'.
   * `get ()'.  The function reads one character from standard input
     stream and returns it.  The function generates the exception `eof'
     if the function tries to read the end of file.

   * `getln ()'.  The function reads one line from standard input
     stream and returns it as a new string.  The end of line is the
     newline character or end of file.  The returned string does not
     contain the newline character.  The function generates the
     exception `eof' only when the file position indicator before the
     function call stands exactly on the end of file.

   * `getf ([ln_flag])'.  The function reads the whole standard input
     stream and returns it as a new string.  The function generates the
     exception `eof' only when the file position indicator before the
     function call stands exactly on the end of file.  The function has
     an optional parameter which should be integer after implicit
     integer conversion.  If the parameter value is nonzero, the
     function returns a vector of strings.  Otherwise it behaves as
     usually.  Each string is a line in the input stream.  The strings
     do not contain the newline character.

   * `fget (fileinstance)'.  The function is analogous to function
     `get' except for the fact that it reads from an opened file
     associated with the class `file' instance which is the parameter's
     value.

   * `fgetln (fileinstance)'.  The function is analogous to the
     function `getln' except for the fact that it reads from an opened
     file associated with a class `file' instance which is the
     parameter value.

   * `fgetf (fileinstance [, ln_flag])'.  The function is analogous to
     the function `getf' except for the fact that it reads from an
     opened file associated with a class `file' instance which is the
     parameter's value.

   * `scan ()'.  The functions reads a character, integer, floating
     point number, string, vector, or table and returns it as the
     result.  The input values should be represented in the file as the
     ones in the Dino language (except for the fact that there should
     be no identifiers in the input values and there should be no
     operators in the values, although the signs `+' and `-' are
     possible in an integer or floating point represenation).  The
     table or vector should contains only values of types mentioned
     above.  The values in the file can be separated by white
     characters.  If there is an error (e.g. unbalanced brackets in a
     vector value) in the read value representation the function
     generates the exception `invinput'.  The functions generates the
     exception `eof' if only white characters are still unread in the
     file.

   * `scanln ()'.  The function is analogous to the function `scan'
     except for the fact that it skips all characters until the end of
     line or the end of file after reading the value.  Skipping is made
     even if the exception `invinput' is generated.

   * `fscan (fileinstance)'.  The function is analogous to the function
     `scan' except for the fact that it reads from an opened file
     associated with a class `file' instance which is the parameter's
     value.

   * `fscanln (fileinstance)'.  The function is analogous to the
     function `scanln' except for that it reads from an opened file
     associated with a class `file' instance which is the parameter
     value.


File: dino.info,  Node: Time functions,  Next: Functions for access to process information,  Prev: File functions,  Up: Predeclared functions

Time functions
--------------

   The following functions can be used to get information about real
time.
   * `time ()'.  The function returns the time in seconds since the
     fixed time (usually since January 1, 1970).

   * `strtime ([format [, time]])'.  The function returns a string
     representing the `time' (integer representing time in seconds
     since the fixed time) according to the `format' (string).  If the
     format is not given, the value of variable `time_format' is used.
     In this case if the value of `time_format' is corrupted (it is not
     a string), the function generates exception `invenvar'.  If the
     time is not given, the current time is used.  The format is the
     same as in C library function `strftime'.  Here is an extraction
     from the OS function documentation.  The following format
     specifiers can be used in the format:
        * `%a' - the abbreviated weekday name according to the current
          locale.

        * `%A' - the full weekday name according to the current locale.

        * `%%b' - the abbreviated month name according to the current
          locale.

        * `%%B' - the full month name according to the current locale.

        * `%%c' - the preferred date and time representation for the
          current locale.

        * `%%d' - the day of the month as a decimal number (range 01 to
          31).

        * `%%H' - the hour as a decimal number using a 24-hour clock
          (range 00 to 23).

        * `%%I' - the hour as a decimal number using a 12-hour clock
          (range 01 to 12).

        * `%%j' - the day of the year as a decimal number (range 001 to
          366).

        * `%%m' - the month as a decimal number (range 01 to 12).

        * `%%M' - the minute as a decimal number.

        * `%%p' - either `am' or `pm' according to the given time
          value, or the corresponding strings for the current locale.

        * `%%S' - the second as a decimal number.

        * `%%U' - the week number of the current year as a decimal
          number, starting with the first Sunday as the first day of
          the first week.

        * `%%W' - the week number of the current year as a decimal
          number, starting with the first Monday as the first day of
          the first week.

        * `%%w' - the day of the week as a decimal, Sunday being 0.

        * `%%x' - the preferred date representation for the current
          locale without the time.

        * `%%X' - the preferred time representation for the current
          locale without the date.

        * `%%y' - the year as a decimal number without a century (range
          00 to 99).

        * `%%Y' - the year as a decimal number including the century.

        * `%%Z' - the time zone or the name or an abbreviation.

        * `%%%' - a literal `%' character.


File: dino.info,  Node: Functions for access to process information,  Next: Miscellaneous functions,  Prev: Time functions,  Up: Predeclared functions

Functions for access to process information
-------------------------------------------

   There are Dino predeclared functions which are used to get
information about the current OS process (the Dino interpreter which
executes the program).  Each OS process has unique identifier and
usually OS processes are called by a concrete user and group and are
executed on behalf of the concrete user and group (so called effective
identifiers).  The following functions return such information.  On
some OSes the function may return string "Unknown" as a name if there
are notions of user and group identifiers.
   * `getpid ()'.  The function returns an integer value which is the
     process ID of the current OS process.

   * `getun ()'.  The function returns a new string which is the user
     name for the current OS process.

   * `geteun ()'.  The function returns a new string which is the
     effective user name for the current OS process.

   * `getgn ()'.  The function returns a new string which is the group
     name for the current OS process.

   * `getegn ()'.  The function returns a new string which is the
     effective group name for the current OS process.

   * `getgroups ()'.  The function returns a new vector of strings
     (possibly the empty vector) representing supplementary group names
     for the current OS process.


File: dino.info,  Node: Miscellaneous functions,  Prev: Functions for access to process information,  Up: Predeclared functions

Miscellaneous functions
-----------------------

   There are the following miscellaneous functions:
   * `max (v1, v2, ...)'.  The function searches for and returns the
     maximal value in all of its parameters.  The parameters should be
     of integer or floating point type after implicit arithmetic
     conversion.  So the function can return an integer or floating
     point number depending on the type of the maximal value after the
     conversion.

   * `min (v1, v2, ...)'.  The function is analogous to the previous
     function, but searches for and returns the minimal value.

   * `tolower (str)'.  The function expects that the parameter `str'
     (after implicit string conversion) is a string.  The function
     returns new string `str' in which upper case letters are changed
     to the corresponding lower case letters.

   * `toupper (str)'.  The function expects that the parameter `str'
     (after implicit string conversion) is a string.  The function
     returns the new string `str' in which lower case letters are
     changed to the corresponding upper case letters.

   * `trans (str, what, subst)'.  The function transliterates charactes
     in a string.  The function expects that the parameters `str'
     (after implicit string conversion), `what', and `subst' are
     strings.  The function returns the new string `str' in which its
     characters which are present in `what' are changed to the
     corresponding characters in <\tt>subst<\tt>.  The last two strings
     should have the same length.  The second string may contain more
     than one occurence of a character.  In this case the last
     correspondence is taken.

   * `eltype (vect)'.  The function expects that the parameter value is
     a vector.  The function returns `nil' if the vector is
     heterogenous, otherwise the function returns the type of the
     vector elements (type of `nil' if the vector is empty).

   * `keys (tab)'.  The function expects that the parameter value is a
     table.  The function returns a new mutable vector containing all
     the keys in the table.  The order of keys in the vector is
     undefined.

   * `context (par)'. The function returns the context (see section
     `Declarations and Scope Rules') represented by a block instance or
     an object for the given parameter value which should be a
     function, a class, a thread, a block instance, or an object.

   * `inside (par1, par2[, flag])'.  The goal for function usage is to
     check that something is declared inside something other.  If the
     third parameter value after implicit integer conversion is given
     and nonzero, it is checked with taking contexts into account.  The
     second parameter value should be a function or a class.  The first
     parameter value should be a function, a class, an object, or a
     block instance.  In the first three cases, they define
     corresponding a function, class, or block.  If the function,
     class, or block defined by the first parameter is declared inside
     the function or class given by the second parameter, the function
     `inside' returns 1.  The function `inside' also returns 1 if the
     function or class defined by the first parameter is the same as
     the function or class given by the second parameter.  Otherwise
     the function `inside' returns 0.  The following example
     illustrates the difference between checking with taking contexts
     into account and without it.
                    class c () {
                      class subc () {
                      }
                    }
                    inside (c ().subc (), c ().subc);
                    inside (c ().subc (), c ().subc, 1);

     The first call of `inside' returns 1, while the second one returns
     0.

   * `subv (vect, index[, length])'.  The function is used to extract a
     slice of vector elements.  The first parameter value should be a
     vector after implicit string conversion.  The second and third
     parameter values should be integers after implicit integer
     conversion. The function extracts only an element or the part of
     the slice existing in the vector (so you can use any values of the
     index and the length).  If index is negative, it is considered to
     be equal to zero.  If the length is negative, the slice will
     finish on the vector end.  The function returns a new vector which
     is the slice.  The result vector is immutable only when the
     original vector is immutable.

   * `del (vect, index[, length]) or del (tab, key)'.  The first form
     of the function is used to remove the vector element or a slice of
     vector elements from the mutable vector `vect'.  The second and
     the third parameter values should be integers after implicit
     integer conversion. The function removes only an element or the
     part of the slice existing in the vector (so you can use any
     values of the index and the length).  If index is negative, it is
     considered to be equal to zero.  If the length is negative, the
     slice will finish on the vector end.  The second form of the
     function is used to remove the element (if it exists) with the
     given key from the mutable table.  The function generates the
     exception `immutable' if we are trying to remove from an immutable
     vector or table.  The function returns the modified vector.

   * `ins (vect, el[, index])'.  The function inserts the element given
     by the second parameter into the vector given by the first
     parameter on the place given by the third parameter.  If the third
     parameter is not given it is believed to be zero.  The third
     parameter should be an integer after implicit integer conversion.
     If the third parameter is negative or equal to or greater than the
     vector length, the element is inserted at the end of the vector.
     The function generates the exception `immutable' if we are trying
     to insert into an immutable vector.  The function returns the
     modified vector.

   * `insv (vect, vect[, index])'.  The function is analogous to the
     function `ins' but it is used for insertion of all vector elements
     into the vector given as the first parameter.  So the second
     parameter value should be a vector.  The function returns the
     modified vector.

   * `rev (vect)'.  The function returns reversion of the given vector.

   * `cmpv (vect, vect)'.  The function makes implicit string
     conversion of the parameter values.  After that, the parameter
     values should be vectors whose first corresponding equal elements
     should have the same type (character, integer, or floating point
     type).  The first corresponding unequal elements should have the
     same type too (the remaining elements can have different type).
     As usual, if this is not true, exception `partype' is generated.
     The function returns 1 if the first unequal element value of the
     first vector is greater than the corresponding element in the
     second vector, -1 if less, and 0 if the all corresponding vector
     elements are equal.  If the first vector is a prefix of the second
     vector, the function returns -1.  If the second vector is a prefix
     of the first vector, the function returns 1, so it is in fact
     generalized lexicographical order.

   * `sort (vect[, compare_function])'.  The function returns a new
     sorted vector.  The original vector given as the first parameter
     value should be a homogeneous vector whose elements are of
     character, integer, or floating point type.  If the second
     parameter is not given, standard arithmetic order (see comparison
     operators) is used.  To use special ordering, use the second
     parameter which should be a function which compares two elements
     of the vector and returns a negative integer if the first
     parameter value (element) is less than the second one, a positive
     integer if the first parameter value is greater than the second
     one, and zero if they are equal.

   * `exit (code)'.  The function finishes the work of the interpreter
     with the given code which should be an integer value after
     implicit integer conversion.

   * `gc ()'.  The function forces garbage collection and heap
     compaction.  Usually the Dino interpreter itself invokes garbage
     collection when there is no more free memory.

   * `system (command)'.  The function executes the command given by a
     string (the parameter value) in the OS command interpreter.
     Besides standard exceptions `parnumber' and `partype' the function
     may generate exceptions `noshell' and `systemfail'.

   * `srand ([seed])'.  The function sets the parameter value (after
     implicit integer conversion) as the seed for a new sequence of
     pseudo-random integers to be returned by `rand'.  These sequences
     are repeatable by calling `srand' with the same seed value.  If
     the parameter is not given, the seed will be the result of calling
     function `time'.

   * `rand ()'.  The function returns a pseudo-random integer value.
     If the function `srand' was not called before, 1 will be used as
     the seed value.

   * `sput (...), sputln (...), sputf (format, ...)' The functions are
     analogous to functions put, putln, print, and println but they
     return the result string instead of output of the formed string
     into the standard output stream.

   * `sprint (...), sprintln (...)'.  The functions are analogous to
     functions print and println but they return the result string
     instead of output of the formed string into the standard output
     stream.


File: dino.info,  Node: Appendix A- Syntax of Dino,  Next: Appendix B- Implementation,  Prev: Predeclared identifiers,  Up: Top

Appendix A- Syntax of Dino
**************************

     Expr = Expr "?"  Expr ":" Expr
          | Expr "||"  Expr
          | Expr "&&"  Expr
          | Expr in  Expr
          | Expr "|"  Expr
          | Expr "^"  Expr
          | Expr "&"  Expr
          | Expr "=="  Expr
          | Expr "!="  Expr
          | Expr "==="  Expr
          | Expr "!=="  Expr
          | Expr "<"  Expr
          | Expr ">"  Expr
          | Expr "<="  Expr
          | Expr ">="  Expr
          | Expr "<<"  Expr
          | Expr ">>"  Expr
          | Expr ">>>"  Expr
          | Expr "@"  Expr
          | Expr "+"  Expr
          | Expr "-"  Expr
          | Expr "*"  Expr
          | Expr "/"  Expr
          | Expr "%"  Expr
          | "!"  Expr
          | "+"  Expr
          | "-"  Expr
          | "~"  Expr
          | "#"  Expr
          | final  Expr
          | new  Expr
          | Designator
          | INTEGER
          | FLOATINGPOINTNUMBER
          | CHARACTER
          | nil
          | "(" Expr ")"
          | Call
          | "["  ElistPartsList "]"
          | "{"  ElistPartsList "}"
          | STRING
          | char
          | int
          | float
          | hide
          | hideblock
          | vector
          | table
          | func
          | thread
          | class
          | func "(" ")"
          | char "(" Expr ")"
          | int "(" Expr ")"
          | float "(" Expr ")"
          | vector "(" Expr ["," Expr] ")"
          | table "(" Expr ")"
          | thread "(" ")"
          | class "(" ")"
          | type
          | type "(" Expr ")"
          | func "(" Expr ")"
          | thread "(" Expr ")"
          | class "(" Expr ")"
     
     Designator = DesignatorOrCall "["  Expr "]"
                | DesignatorOrCall "{"  Expr "}"
                | DesignatorOrCall ActualParameters
                | DesignatorOrCall "."  IDENT
                | IDENT
     
     ElistPartsList = [ Expr [ ":" Expr ] {"," Expr [ ":" Expr ] } ]
     
     DesignatorOrCall = Designator
                      | Call
     
     Call = Designator ActualParameters
     
     ActualParameters = "("  [ Expr { "," Expr } ] ")"
     
     VarParList = VarPar { "," VarPar }
     
     VarPar = [final] IDENT [ "="  Expr]
     
     Stmt = ExecutiveStmt
          | Declaration
     
     Assign = "="
            | "*="
            | "/="
            | "%="
            | "+="
            | "-="
            | "@="
            | "<<="
            | ">>="
            | ">>>="
            | "&="
            | "^="
            | "|="
     
     ExecutiveStmt = ";"
                   | Designator Assign  Expr ";"
                   | Designator ("++" | "--")  ";"
                   | ("++" | "--")  Designator ";"
                   | Designator ActualParameters  ";"
                   | if  "(" Expr ")" Stmt [ else Stmt ]
                   | for  "("  Stmt ForGuardExpr ";"  Stmt ")" Stmt
                   | for  "("  Designator in Expr ")" Stmt
                   | break ";"
                   | continue ";"
                   | return  [ Expr ] ";"
                   | throw  Expr ";"
                   | wait  "(" Expr ")" Stmt
                   | BlockStmt
                   | TryBlockStmt
     
     ForGuardExpr = [Expr]
     
     BlockStmt = Block
     
     TryBlockStmt = try Block { Catch }
     
     Catch = catch  "(" ExceptClassList ")" Block
     
     ExceptClassList = Expr { "," Expr }
     
     Declaration = VarDeclarations
                 | AccessClause
                 | ExternDeclarations
                 | FuncClassExtDeclaration
                 | IncludeDeclaration
     
     VarDeclarations = var  VarParList ";"
     
     ExternDeclarations = extern  ExternItem { "," ExternItem } ";"
     
     FuncClassExtDeclaration = Header Block
     
     AccessClause = (public | private | friend) AccessList ";"
     
     AccessList = IDENT { "," IDENT }
     
     IncludeDeclaration = include ["+"] STRING ";"
     
     ExternItem = IDENT
                | IDENT  "(" ")"
     
     Header = [final] FuncThreadClass IDENT FormalParameters
            | ext IDENT
     
     FuncThreadClass = func
                     | thread
                     | class
     
     FormalParameters = "("  [ VarParList ] ")"
                      | "("  VarParList "," "..."  ")"
                      | "(" "..."  ")"
     
     Block = "{"  StmtList "}"
     
     StmtList = { Stmt }
     
     Program = StmtList


File: dino.info,  Node: Appendix B- Implementation,  Prev: Appendix A- Syntax of Dino,  Up: Top

Appendix B- Implementation
**************************

     DINO(1)                          User Manuals                          DINO(1)
     
     
     
     NAME
            dino - the interpreter of the programming language DINO
     
     SYNOPSIS
            dino  [  -s  -h  size -Idirname -Lpath -p] (-c program | program-file )
            dino-program-arguments
     
     DESCRIPTION
            dino interprets a program in the DINO programming language.   The  pro-
            gram file (and include files) must have the suffix .d
     
            The  description  of  DINO language is in the report of the Programming
            Language DINO.
     
     OPTIONS
            The options which the DINO interpreter recognizes are:
     
            -c program
                   Execute the Dino program given on the command line as the  argu-
                   ment.
     
            -h number
                   Determine  the  size  of the heap chunks used by the DINO inter-
                   preter.  The size can be given in bytes (e.g. 32000),  in  kilo-
                   bytes  (e.g.  64k), or in megabytes (e.g. 1m).  The default size
                   is 1 Megabyte.  Initially,  the  Dino  interpreter  creates  one
                   chunk.   It  allocates one additional chunk (as rule of the same
                   size) whenever there is no additional memory after garbage  col-
                   lection.
     
            -s     Output some statistics of interpreter work into stderr.  Statis-
                   tics contain the maximal heap size, number of heap  chunks,  and
                   number  of  collisions  in  hash  tables  which are used for the
                   implementation of DINO tables.
     
            -Idirname
                   Define the  directory  in  which  Dino  include  files  will  be
                   searched  for.  The order of searching in directories given with
                   this option is the same as the one on the command line.
     
            -Ldirname
                   Define where to serach for external libraries (if shared or  dll
                   libraries  are  implemented  on  the  system.   This is true for
                   Linux, Solaris, Irix, OSF, and Windows) in which the Dino exter-
                   nal  variables and functions will be searched for.  The order of
                   searching in libraries given with this option is the same as one
                   on the command line.
     
            -p     Output  profile  information  into  stderr.  Profile information
                   contains the number of calls and execution times of  all  called
                   functions and classes.
     
     FILES
            file.d
                   a DINO program file
            libdino.so
                   a DINO shared library on some Unix systems.
            mpi.d
                   the DINO file implementing multiple precision arithmetic.
            mpi.so
                   the  DINO  shared library used for implementing MPI on some Unix
                   systems.
            mpi.dll
                   the DINO dll library used for implementing MPI on  Windows  sys-
                   tems.
            ieee.d
                   the  DINO  file implementing IEEE standard floating point arith-
                   metic.
            ieee.so
                   the DINO shared library used for implementing IEEE on some  Unix
                   systems.
            ieee.dll
                   the  DINO dll library used for implementing IEEE on Windows sys-
                   tems.
            ipcerr.d
                   the DINO file definining  exceptions  of  ipc/network  software.
                   This file is used by socket.d.
            ipcerr.so
                   the  DINO  shared  library  used for implementing IPCERR on some
                   Unix systems.
            ipcerr.dll
                   the DINO dll library used for  implementing  IPCERR  on  Windows
                   systems.
            socket.d
                   the DINO file implementing work with sockets.
            socket.so
                   the  DINO  shared  library  used for implementing SOCKET on some
                   Unix systems.
            socket.dll
                   the DINO dll library used for  implementing  SOCKET  on  Windows
                   systems.
            There are no temporary files used by DINO.
     
     ENVIRONMENT
            There  are the following environment variables which affect DINO behav-
            ior:
     
            DINO_HOME
                   If not null, it defines the places of the dino shared  libraries
                   (such a library may be only on some Unix systems including Linux
                   and  Solaris),  include  files,  and  dino   standard   external
                   libraries.   The  places  are defined as the subdirectory lib in
                   directory given by the environment variable value.   You  should
                   define  the variable value on Windows if you installed the files
                   in a directory other than C:\dino\lib
     
            DINO_PATH
                   If not null, it defines the places of dino  include-files.   The
                   value  of the variable has more priority than DINO_HOME but less
                   priority than values given through -I options.
     
            DINO_LIB
                   If not null, it defines places of dino shared library,  if  any.
                   The   value  of  variable  has  more  priority  than  DINO_HOME.
                   DINO_EXTERN_LIBS.
     
            DINO_EXTERN_LIBS
                   If not null,  it  defines  paths  of  additional  Dino  external
                   libraries.   The  libraries should be separated by ":" (on Unix)
                   or ";" (on Windows).  The value has less  priority  than  values
                   given in -L options.
     
     DIAGNOSTICS
            DINO diagnostics are self-explanatory.
     
     AUTHOR
            Vladimir N. Makarov, vmakarov@users.sourceforge.net
     
     BUGS
            Please report bugs to cocom-bugs@lists.sourceforge.net.
     
     
     
     DINO                              5 May 2001                           DINO(1)


