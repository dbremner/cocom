<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.66">
 <TITLE>OKA (pipeline hazards description translator): Generated code</TITLE>
 <LINK HREF="oka-4.html" REL=next>
 <LINK HREF="oka-2.html" REL=previous>
 <LINK HREF="oka.html#toc3" REL=contents>
</HEAD>
<BODY>
<A HREF="oka-4.html">Next</A>
<A HREF="oka-2.html">Previous</A>
<A HREF="oka.html#toc3">Contents</A>
<HR>
<H2><A NAME="s3">3.</A> <A HREF="oka.html#toc3">Generated code</A></H2>

<P>A specification as described in the previous section is translated by
OKA (pipeline hazards description translator) into interface and
implementation files having the same names as one of specification
file and correspondingly suffixes `.h' and `.c' (C code) or `.cpp'
(C++ code).</P>

<H2><A NAME="ss3.1">3.1</A> <A HREF="oka.html#toc3.1">C++ code</A>
</H2>

<P>Interface file of PHD consists of the following definitions:
<DL>
<DT><B>Class `OKA_chip'.</B><DD>
<P>Object of the class describes current state of processor.  The
class has the following public members:
<OL>
<LI>Function 
<BLOCKQUOTE><CODE>
<PRE>
             `int OKA_transition (int OKA_instruction)'
</PRE>
</CODE></BLOCKQUOTE>

The function has one parameter: instruction code.  If
corresponding instruction can be started by the processor in
its current state, the function returns 1 and the object
(processor) changes own state which reflects starting the
execution of given instruction.  In the opposite case, when
the instruction can not be started, the function returns 0
and the object (processor) does not change own state.
</LI>
<LI>Function
<BLOCKQUOTE><CODE>
<PRE>
             `int OKA_is_dead_lock (void)'
</PRE>
</CODE></BLOCKQUOTE>

The function returns 1 (TRUE) when transition from the
corresponding processor state is not possible on any
instruction.  The single way to change object (processor)
state is to advance time (on one cycle) with the aid of
special pseudo-instruction code `OKA__ADVANCE_CYCLE'.  For
example, dead lock state for dual-issue processor can be
state reflecting starting two instructions on a cycle.
</LI>
<LI>Function
<BLOCKQUOTE><CODE>
<PRE>
             `void OKA_reset (void)'
</PRE>
</CODE></BLOCKQUOTE>

The function sets up the object (processor) in initial
state.  No any processor unit is busy in the state.
</LI>
<LI>Constructor
<BLOCKQUOTE><CODE>
<PRE>
             `OKA_chip (void)'
</PRE>
</CODE></BLOCKQUOTE>

The constructor simply calls function `OKA_reset'.</LI>
</OL>
</P>
<DT><B>Macros or enumeration (see option `-enum')</B><DD>
<P>which declare instruction codes.  Macros or enumeration
constants have the same name as one in PHD and prefix `OKA_'
(see also option `-p').  OKA always generates additional code
`OKA__ADVANCE_CYCLE'.  If such pseudo-instruction starts, the
processor make transition into the state reflecting advancing
time on one cycle.  It is guaranteed that there is always
transition from any processor state on given
pseudo-instruction.  Macros or enumeration are generated in
interface file only if option `-export' is present on OKA
command line.  By default, the macros or the enumeration are
generated in the implementation file.  Usually, the last case
means that the scheduler code is placed PHD in additional C/C++
code.</P>
</DL>
</P>

<H2><A NAME="ss3.2">3.2</A> <A HREF="oka.html#toc3.2">C code</A>
</H2>

<P>Interface file of PHD consists of the following definitions of
generated type and functions:
<OL>
<LI>Structure `OKA_chip' which describes state of the processor.
    </LI>
<LI>Type definition `OKA_chip' which is simply structure `OKA_chip'.
    </LI>
<LI>Function 
<BLOCKQUOTE><CODE>
<PRE>
          `int OKA_transition (OKA_chip *OKA_chip,
                               int OKA_instruction)'
</PRE>
</CODE></BLOCKQUOTE>

The function has two parameter: pointer to structure
describing the processor state and instruction code.  If
corresponding instruction can be started by the processor in
its current state, the function returns 1 and the structure is
changed in order to reflects starting the execution of given
instruction.  In the opposite case, when the instruction can
not be started, the function returns 0 and the structure is
not changed.
    </LI>
<LI>Function
<BLOCKQUOTE><CODE>
<PRE>
          `int OKA_is_dead_lock (OKA_chip *OKA_chip)'
</PRE>
</CODE></BLOCKQUOTE>

The function returns 1 (TRUE) when transition from the
processor state given by the structure is not possible on any
instruction.  The single way to change processor state is to
advance time (on one cycle) with the aid of special
pseudo-instruction code `OKA__ADVANCE_CYCLE'.  For example,
dead lock state for dual-issue processor can be state
reflecting starting two instructions on a cycle.
    </LI>
<LI>Function
<BLOCKQUOTE><CODE>
<PRE>
          `void OKA_reset (OKA_chip *OKA_chip)'
</PRE>
</CODE></BLOCKQUOTE>

The function sets up the structure (processor) in initial
state.  No any processor unit is busy in the state.
</LI>
<LI>Macros or enumeration (see option `-enum') which declare
instruction codes.  Macros or enumeration constants have the
same name as one in PHD and prefix `OKA_' (see also option `-p').
OKA always generates additional code `OKA__ADVANCE_CYCLE'.  If
such pseudo-instruction starts, the processor make transition
into the state reflecting advancing time on one cycle.  It is
guaranteed that there is always transition from any processor
state on given pseudo-instruction.  Macros or enumeration are
generated in interface file only if option `-export' is present
on OKA command line.  By default, the macros or the enumeration
are generated in the implementation file.  Usually, the last
case means that the scheduler code is placed PHD in additional
C/C++ code.</LI>
</OL>
</P>

<HR>
<A HREF="oka-4.html">Next</A>
<A HREF="oka-2.html">Previous</A>
<A HREF="oka.html#toc3">Contents</A>
</BODY>
</HTML>
